diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
index 1b894c327..6a1767e2a 100644
--- a/arch/riscv/Kconfig
+++ b/arch/riscv/Kconfig
@@ -26,15 +26,28 @@ config RISCV
 	select ARCH_HAS_SET_DIRECT_MAP
 	select ARCH_HAS_SET_MEMORY
 	select ARCH_HAS_STRICT_KERNEL_RWX if MMU
+	select ARCH_HAS_STRICT_MODULE_RWX if MMU
+	select ARCH_HAS_DMA_PREP_COHERENT
+	select ARCH_HAS_SYNC_DMA_FOR_CPU
+	select ARCH_HAS_SYNC_DMA_FOR_DEVICE
+	select ARCH_HAS_DMA_WRITE_COMBINE
+	select ARCH_HAS_DMA_MMAP_PGPROT
+	select ARCH_KEEP_MEMBLOCK
 	select ARCH_OPTIONAL_KERNEL_RWX if ARCH_HAS_STRICT_KERNEL_RWX
 	select ARCH_OPTIONAL_KERNEL_RWX_DEFAULT
+	select ARCH_USE_QUEUED_SPINLOCKS
+	select ARCH_USE_QUEUED_RWLOCKS
 	select ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT if MMU
 	select ARCH_WANT_FRAME_POINTERS
 	select ARCH_WANT_HUGE_PMD_SHARE if 64BIT
 	select CLONE_BACKWARDS
 	select CLINT_TIMER if !MMU
 	select COMMON_CLK
+	select CPU_PM if (SUSPEND || CPU_IDLE)
+	select COMPAT_BINFMT_ELF if BINFMT_ELF && COMPAT
 	select EDAC_SUPPORT
+	select DMA_DIRECT_REMAP
+	select GENERIC_ALLOCATOR
 	select GENERIC_ARCH_TOPOLOGY if SMP
 	select GENERIC_ATOMIC64 if !64BIT
 	select GENERIC_CLOCKEVENTS
@@ -58,6 +71,7 @@ config RISCV
 	select HAVE_ARCH_KGDB
 	select HAVE_ARCH_KGDB_QXFER_PKT
 	select HAVE_ARCH_MMAP_RND_BITS if MMU
+	select HAVE_ARCH_MMAP_RND_COMPAT_BITS if COMPAT
 	select HAVE_ARCH_SECCOMP_FILTER
 	select HAVE_ARCH_TRACEHOOK
 	select HAVE_ASM_MODVERSIONS
@@ -67,11 +81,17 @@ config RISCV
 	select HAVE_EBPF_JIT if MMU
 	select HAVE_FUTEX_CMPXCHG if FUTEX
 	select HAVE_GCC_PLUGINS
+	select HAVE_FUNCTION_ERROR_INJECTION
+	select HAVE_EFFICIENT_UNALIGNED_ACCESS
 	select HAVE_GENERIC_VDSO if MMU && 64BIT
+	select HAVE_KPROBES
+	select HAVE_KPROBES_ON_FTRACE
+	select HAVE_KRETPROBES
 	select HAVE_PCI
 	select HAVE_PERF_EVENTS
 	select HAVE_PERF_REGS
 	select HAVE_PERF_USER_STACK_DUMP
+	select HAVE_REGS_AND_STACK_ACCESS_API
 	select HAVE_STACKPROTECTOR
 	select HAVE_SYSCALL_TRACEPOINTS
 	select IRQ_DOMAIN
@@ -93,12 +113,18 @@ config ARCH_MMAP_RND_BITS_MIN
 	default 18 if 64BIT
 	default 8
 
+config ARCH_MMAP_RND_COMPAT_BITS_MIN
+	default 8
+
 # max bits determined by the following formula:
 #  VA_BITS - PAGE_SHIFT - 3
 config ARCH_MMAP_RND_BITS_MAX
 	default 24 if 64BIT # SV39 based
 	default 17
 
+config ARCH_MMAP_RND_COMPAT_BITS_MAX
+	default 17
+
 # set if we run in machine mode, cleared if we run in supervisor mode
 config RISCV_M_MODE
 	bool
@@ -144,6 +170,20 @@ config KASAN_SHADOW_OFFSET
 	default 0xdfffffc800000000 if 64BIT
 	default 0xffffffff if 32BIT
 
+config FORCE_MAX_ZONEORDER
+        int "Maximum zone order"
+        default 13
+	help
+	  The kernel memory allocator divides physically contiguous memory
+	  blocks into "zones", where each zone is a power of two number of
+	  pages.  This option selects the largest power of two that the kernel
+	  keeps in the memory allocator.  If you need to allocate very large
+	  blocks of physically contiguous memory, then you may need to
+	  increase this value.
+
+	  This config option is actually maximum order plus one. For example,
+	  a value of 13 means that the largest free memory block is 2^12 pages.
+
 config ARCH_FLATMEM_ENABLE
 	def_bool y
 
@@ -162,6 +202,9 @@ config ARCH_WANT_GENERAL_HUGETLB
 config ARCH_SUPPORTS_DEBUG_PAGEALLOC
 	def_bool y
 
+config ARCH_SUPPORTS_UPROBES
+	def_bool y
+
 config SYS_SUPPORTS_HUGETLBFS
 	depends on MMU
 	def_bool y
@@ -229,7 +272,7 @@ config ARCH_RV64I
 	select HAVE_FTRACE_MCOUNT_RECORD
 	select HAVE_FUNCTION_GRAPH_TRACER
 	select HAVE_FUNCTION_TRACER
-	select SWIOTLB if MMU
+	select SWIOTLB if RISCV_SWIOTLB
 
 endchoice
 
@@ -318,12 +361,22 @@ config RISCV_ISA_C
 
 	   If you don't know what to do here, say Y.
 
+config NO_SFENCE_VMA
+	bool "Replace sfence.vma with CSR_SMCIR operation"
+	depends on !SMP
+	default y
+
+config RISCV_SWIOTLB
+	bool "Enable SWIOTLB"
+	depends on MMU
+	default y
+
 menu "supported PMU type"
 	depends on PERF_EVENTS
 
 config RISCV_BASE_PMU
 	bool "Base Performance Monitoring Unit"
-	def_bool y
+	def_bool n
 	help
 	  A base PMU that serves as a reference implementation and has limited
 	  feature of perf.  It can run on any RISC-V machines so serves as the
@@ -340,6 +393,47 @@ config FPU
 
 	  If you don't know what to do here, say Y.
 
+config VECTOR
+	bool "VECTOR support"
+	default n
+
+choice VECTOR_VERSION
+	prompt "Vector Version"
+	depends on VECTOR
+	default VECTOR_1_0
+
+config VECTOR_1_0
+	bool "VECTOR 1.0 support"
+	help
+	  Say N here if you want to disable all vector 1.0 related procedure
+	  in the kernel.
+
+	  If you don't know what to do here, say Y.
+
+config VECTOR_0_7
+	bool "VECTOR 0.7 support"
+	help
+	  Say N here if you want to disable all vector 0.7 related procedure
+	  in the kernel.
+
+	  If you don't know what to do here, say Y.
+
+endchoice
+
+config VLEN_256
+	bool "VECTOR VLEN 256"
+	depends on VECTOR
+	default n
+
+config VECTOR_EMU
+	bool "VECTOR e64 emulate for c906 v1"
+	depends on VECTOR
+	default n
+
+config THEAD_ISA
+	bool "T-HEAD extension ISA in AFLAGS with -march=_xtheadc"
+	default n
+
 endmenu
 
 menu "Kernel features"
@@ -353,6 +447,48 @@ config RISCV_SBI_V01
 	help
 	  This config allows kernel to use SBI v0.1 APIs. This will be
 	  deprecated in future once legacy M-mode software are no longer in use.
+
+config KEXEC
+	bool "Kexec system call"
+	select KEXEC_CORE
+	select HOTPLUG_CPU if SMP
+	depends on MMU
+	default y
+	help
+	  kexec is a system call that implements the ability to shutdown your
+	  current kernel, and to start another kernel. It is like a reboot
+	  but it is independent of the system firmware. And like a reboot
+	  you can start any kernel with it, not just Linux.
+
+	  The name comes from the similarity to the exec system call.
+
+config CRASH_DUMP
+	bool "Build kdump crash kernel"
+	default y
+	help
+	  Generate crash dump after being started by kexec. This should
+	  be normally only set in special crash dump kernels which are
+	  loaded in the main kernel with kexec-tools into a specially
+	  reserved region and then later executed after a crash by
+	  kdump/kexec.
+
+	  For more details see Documentation/admin-guide/kdump/kdump.rst
+
+config COMPAT
+	bool "Kernel support for 32-bit U-mode"
+	depends on 64BIT && MMU
+	help
+	  This option enables support for a 32-bit U-mode running under a 64-bit
+	  kernel at S-mode. riscv32-specific components such as system calls,
+	  the user helper functions (vdso), signal rt_frame functions and the
+	  ptrace interface are handled appropriately by the kernel.
+
+	  If you want to execute 32-bit userspace applications, say Y.
+
+config SYSVIPC_COMPAT
+	def_bool y
+	depends on COMPAT && SYSVIPC
+
 endmenu
 
 menu "Boot options"
@@ -431,8 +567,14 @@ config BUILTIN_DTB
 
 menu "Power management options"
 
+source "drivers/cpuidle/Kconfig"
+source "drivers/cpufreq/Kconfig"
 source "kernel/power/Kconfig"
 
+config ARCH_SUSPEND_POSSIBLE
+	def_bool y
+
 endmenu
 
+source "arch/riscv/kvm/Kconfig"
 source "drivers/firmware/Kconfig"
diff --git a/arch/riscv/Kconfig.socs b/arch/riscv/Kconfig.socs
index 8a55f6156..7718166b0 100644
--- a/arch/riscv/Kconfig.socs
+++ b/arch/riscv/Kconfig.socs
@@ -48,4 +48,16 @@ config SOC_KENDRYTE_K210_DTB_BUILTIN
 	  This option should be selected if no bootloader is being used.
 	  If unsure, say Y.
 
+config SOC_THEAD
+	bool "T-HEAD SoCs"
+	select SIFIVE_PLIC
+	help
+	  This enables support for T-HEAD SoC platform hardware.
+
+config SOC_THEAD_LIGHT_EMU
+	bool "T-HEAD Light SoC emulation"
+	depends on SOC_THEAD
+	help
+	  This enables support for T-HEAD Light SoC platform on FPGA emulation.
+
 endmenu
diff --git a/arch/riscv/Makefile b/arch/riscv/Makefile
index 226c36607..ffadba85b 100644
--- a/arch/riscv/Makefile
+++ b/arch/riscv/Makefile
@@ -12,6 +12,8 @@ OBJCOPYFLAGS    := -O binary
 LDFLAGS_vmlinux :=
 ifeq ($(CONFIG_DYNAMIC_FTRACE),y)
 	LDFLAGS_vmlinux := --no-relax
+	KBUILD_CPPFLAGS += -DCC_USING_PATCHABLE_FUNCTION_ENTRY
+	CC_FLAGS_FTRACE := -fpatchable-function-entry=8
 endif
 
 ifeq ($(CONFIG_CMODEL_MEDLOW),y)
@@ -46,12 +48,25 @@ endif
 endif
 
 # ISA string setting
-riscv-march-$(CONFIG_ARCH_RV32I)	:= rv32ima
-riscv-march-$(CONFIG_ARCH_RV64I)	:= rv64ima
-riscv-march-$(CONFIG_FPU)		:= $(riscv-march-y)fd
-riscv-march-$(CONFIG_RISCV_ISA_C)	:= $(riscv-march-y)c
-KBUILD_CFLAGS += -march=$(subst fd,,$(riscv-march-y))
-KBUILD_AFLAGS += -march=$(riscv-march-y)
+# Newer binutils versions default to ISA spec version 20191213 which moves some
+# instructions from the I extension to the Zicsr and Zifencei extensions.
+toolchain-need-zicsr-zifencei := $(call cc-option-yn, -march=$(riscv-march-y)_zicsr_zifencei)
+riscv-march-$(toolchain-need-zicsr-zifencei) := $(riscv-march-y)_zicsr_zifencei
+
+riscv-march-cflags-$(CONFIG_ARCH_RV32I)		:= rv32ima
+riscv-march-cflags-$(CONFIG_ARCH_RV64I)		:= rv64ima
+riscv-march-cflags-$(CONFIG_RISCV_ISA_C)	:= $(riscv-march-cflags-y)c
+
+riscv-march-aflags-$(CONFIG_ARCH_RV32I)		:= rv32ima
+riscv-march-aflags-$(CONFIG_ARCH_RV64I)		:= rv64ima
+riscv-march-aflags-$(CONFIG_FPU)		:= $(riscv-march-aflags-y)fd
+riscv-march-aflags-$(CONFIG_RISCV_ISA_C)	:= $(riscv-march-aflags-y)c
+riscv-march-aflags-$(CONFIG_VECTOR_1_0)		:= $(riscv-march-aflags-y)v
+riscv-march-aflags-$(CONFIG_VECTOR_0_7)		:= $(riscv-march-aflags-y)v0p7
+riscv-march-aflags-$(CONFIG_THEAD_ISA)		:= $(riscv-march-aflags-y)_xtheadc
+
+KBUILD_CFLAGS += -march=$(riscv-march-cflags-y) -Wa,-march=$(riscv-march-aflags-y)
+KBUILD_AFLAGS += -march=$(riscv-march-aflags-y)
 
 KBUILD_CFLAGS += -mno-save-restore
 KBUILD_CFLAGS += -DCONFIG_PAGE_OFFSET=$(CONFIG_PAGE_OFFSET)
@@ -85,12 +100,26 @@ head-y := arch/riscv/kernel/head.o
 
 core-y += arch/riscv/
 
+core-$(CONFIG_KVM) += arch/riscv/kvm/
+
 libs-y += arch/riscv/lib/
 libs-$(CONFIG_EFI_STUB) += $(objtree)/drivers/firmware/efi/libstub/lib.a
 
 PHONY += vdso_install
 vdso_install:
 	$(Q)$(MAKE) $(build)=arch/riscv/kernel/vdso $@
+	$(if $(CONFIG_COMPAT),$(Q)$(MAKE) \
+		$(build)=arch/riscv/kernel/compat_vdso $@)
+
+ifeq ($(KBUILD_EXTMOD),)
+ifeq ($(CONFIG_MMU),y)
+prepare: vdso_prepare
+vdso_prepare: prepare0
+	$(Q)$(MAKE) $(build)=arch/riscv/kernel/vdso include/generated/vdso-offsets.h
+	$(if $(CONFIG_COMPAT),$(Q)$(MAKE) \
+		$(build)=arch/riscv/kernel/compat_vdso include/generated/compat_vdso-offsets.h)
+endif
+endif
 
 ifeq ($(CONFIG_RISCV_M_MODE)$(CONFIG_SOC_KENDRYTE),yy)
 KBUILD_IMAGE := $(boot)/loader.bin
diff --git a/arch/riscv/boot/dts/Makefile b/arch/riscv/boot/dts/Makefile
index ca1f8cbd7..ec44e69ab 100644
--- a/arch/riscv/boot/dts/Makefile
+++ b/arch/riscv/boot/dts/Makefile
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 subdir-y += sifive
 subdir-y += kendryte
+subdir-y += thead
 
 obj-$(CONFIG_BUILTIN_DTB) := $(addsuffix /, $(subdir-y))
diff --git a/arch/riscv/boot/dts/thead/Makefile b/arch/riscv/boot/dts/thead/Makefile
new file mode 100755
index 000000000..e4fdf6f92
--- /dev/null
+++ b/arch/riscv/boot/dts/thead/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+
+dtb-$(CONFIG_SOC_THEAD) += light-lpi4a.dtb
\ No newline at end of file
diff --git a/arch/riscv/boot/dts/thead/light-lpi4a-ref.dts b/arch/riscv/boot/dts/thead/light-lpi4a-ref.dts
new file mode 100755
index 000000000..cfa1929e5
--- /dev/null
+++ b/arch/riscv/boot/dts/thead/light-lpi4a-ref.dts
@@ -0,0 +1,1621 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+/dts-v1/;
+
+#include "light.dtsi"
+#include <dt-bindings/input/linux-event-codes.h>
+#include <dt-bindings/gpio/gpio.h>
+#include "light-vi-devices.dtsi"
+/ {
+	chosen {
+		bootargs = "console=ttyS0,115200 crashkernel=256M-:128M earlycon clk_ignore_unused sram=0xffe0000000,0x180000";
+		stdout-path = "serial0:115200n8";
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		status = "disabled";
+		led0 {
+			label = "SYS_STATUS";
+			gpios = <&gpio1_porta 15 0>;	/* GPIO_ACTIVE_HIGH: 0 */
+			default-state = "off";
+		};
+	};
+
+	display-subsystem {
+		status = "okay";
+	};
+
+	lcd0_backlight: pwm-backlight@0 {
+		compatible = "pwm-backlight";
+		pwms = <&pwm 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+	};
+	pwm-fan {
+		compatible = "pwm-fan";
+		cooling-min-state = <0>;
+		cooling-max-state = <3>;
+		#cooling-cells = <2>;
+		pwms = <&pwm 1 5000000>;
+		cooling-levels = <1 128 192 255>;
+	};
+	light_iopmp: iopmp {
+		compatible = "thead,light-iopmp";
+
+		/* config#1: multiple valid regions */
+		iopmp_emmc: IOPMP_EMMC {
+			regions = <0x000000 0x100000>,
+				  <0x100000 0x200000>;
+			attr = <0xFFFFFFFF>;
+			dummy_slave= <0x800000>;
+		};
+
+		/* config#2: iopmp bypass */
+		iopmp_sdio0: IOPMP_SDIO0 {
+			bypass_en;
+		};
+
+		/* config#3: iopmp default region set */
+		iopmp_sdio1: IOPMP_SDIO1 {
+			attr = <0xFFFFFFFF>;
+			is_default_region;
+		};
+
+		iopmp_usb0: IOPMP_USB0 {
+			attr = <0xFFFFFFFF>;
+			is_default_region;
+		};
+
+		iopmp_ao: IOPMP_AO {
+			is_default_region;
+		};
+
+		iopmp_aud: IOPMP_AUD {
+			is_default_region;
+		};
+
+		iopmp_chip_dbg: IOPMP_CHIP_DBG {
+			is_default_region;
+		};
+
+		iopmp_eip120i: IOPMP_EIP120I {
+			is_default_region;
+		};
+
+		iopmp_eip120ii: IOPMP_EIP120II {
+			is_default_region;
+		};
+
+		iopmp_eip120iii: IOPMP_EIP120III {
+			is_default_region;
+		};
+
+		iopmp_isp0: IOPMP_ISP0 {
+			is_default_region;
+		};
+
+		iopmp_isp1: IOPMP_ISP1 {
+			is_default_region;
+		};
+
+		iopmp_dw200: IOPMP_DW200 {
+			is_default_region;
+		};
+
+		iopmp_vipre: IOPMP_VIPRE {
+			is_default_region;
+		};
+
+		iopmp_venc: IOPMP_VENC {
+			is_default_region;
+		};
+
+		iopmp_vdec: IOPMP_VDEC {
+			is_default_region;
+		};
+
+		iopmp_g2d: IOPMP_G2D {
+			is_default_region;
+		};
+
+		iopmp_fce: IOPMP_FCE {
+			is_default_region;
+		};
+
+		iopmp_npu: IOPMP_NPU {
+			is_default_region;
+		};
+
+		iopmp0_dpu: IOPMP0_DPU {
+			bypass_en;
+		};
+
+		iopmp1_dpu: IOPMP1_DPU {
+			bypass_en;
+		};
+
+		iopmp_gpu: IOPMP_GPU {
+			is_default_region;
+		};
+
+		iopmp_gmac1: IOPMP_GMAC1 {
+			is_default_region;
+		};
+
+		iopmp_gmac2: IOPMP_GMAC2 {
+			is_default_region;
+		};
+
+		iopmp_dmac: IOPMP_DMAC {
+			is_default_region;
+		};
+
+		iopmp_tee_dmac: IOPMP_TEE_DMAC {
+			is_default_region;
+		};
+
+		iopmp_dsp0: IOPMP_DSP0 {
+			is_default_region;
+		};
+
+		iopmp_dsp1: IOPMP_DSP1 {
+			is_default_region;
+		};
+	};
+
+	mbox_910t_client1: mbox_910t_client1 {
+		compatible = "thead,light-mbox-client";
+		mbox-names = "902";
+		mboxes = <&mbox_910t 1 0>;
+		status = "disabled";
+	};
+/* not use
+	mbox_910t_client2: mbox_910t_client2 {
+		compatible = "thead,light-mbox-client";
+		mbox-names = "906";
+		mboxes = <&mbox_910t 2 0>;
+		audio-mbox-regmap = <&audio_mbox>;
+		status = "okay";
+	};
+*/
+
+	lightsound: lightsound@1 {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "Light-Sound-Card";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		status = "disabled";
+	};
+
+/*  no use
+	light_rpmsg: light_rpmsg {
+		compatible = "light,rpmsg-bus", "simple-bus";
+		memory-region = <&rpmsgmem>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		rpmsg: rpmsg{
+			vdev-nums = <1>;
+            reg = <0x0 0x1E000000 0 0x10000>;
+			compatible = "light,light-rpmsg";
+			status = "okay";
+		};
+	};
+*/
+
+	dummy_codec: dummy_codec {
+		#sound-dai-cells = <1>;
+		compatible = "linux,bt-sco";
+		status = "okay";
+	};
+
+	reg_vref_1v8: regulator-adc-verf {
+			compatible = "regulator-fixed";
+			regulator-name = "vref-1v8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+	status = "okay";
+	};
+
+        reg_tp_pwr_en: regulator-pwr-en {
+                compatible = "regulator-fixed";
+                regulator-name = "regulator-pwr-en";
+                regulator-min-microvolt = <2800000>;
+                regulator-max-microvolt = <2800000>;
+                gpio = <&pcal6408ahk_d 4 1>;
+                enable-active-high;
+                regulator-always-on;
+        };
+
+	reg_usb_hub_vdd1v2: regulator-hub-vdd12-en {
+		compatible = "regulator-fixed";
+		regulator-name = "regulator-hub-vdd12-en";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+		gpio = <&pcal6408ahk_d 2 1>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	reg_usb_hub_vcc5v: regulator-hub-vcc5v-en {
+		compatible = "regulator-fixed";
+		regulator-name = "regulator-hub-vcc5v-en";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&pcal6408ahk_d 3 1>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	wcn_wifi: wireless-wlan {
+		compatible = "wlan-platdata";
+		clock-names = "clk_wifi";
+		ref-clock-frequency = <24000000>;
+		keep_wifi_power_on;
+		pinctrl-names = "default";
+		wifi_chip_type = "rtl8723ds";
+		WIFI,poweren_gpio = <&pcal6408ahk_c 5 0>;
+		status = "okay";
+	};
+
+	wcn_bt: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		pinctrl-names = "default", "rts_gpio";
+		BT,power_gpio    = <&pcal6408ahk_c 6 0>;
+		status = "okay";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&pinctrl_volume>;
+		pinctrl-names = "default";
+		key-volumedown {
+			label = "Volume Down Key";
+			linux,code = <KEY_VOLUMEDOWN>;
+			debounce-interval = <1>;
+			gpios = <&gpio1_porta 19 0x1>;
+		};
+		key-volumeup {
+			label = "Volume Up Key";
+			linux,code = <KEY_VOLUMEUP>;
+			debounce-interval = <1>;
+			gpios = <&gpio2_porta 25 0x1>;
+		};
+	};
+
+	aon: aon {
+		compatible = "thead,light-aon";
+		mbox-names = "aon";
+		mboxes = <&mbox_910t 1 0>;
+		status = "okay";
+
+		pd: light-aon-pd {
+			compatible = "thead,light-aon-pd";
+			#power-domain-cells = <1>;
+		};
+
+		soc_aud_3v3_en_reg: soc_aud_3v3_en {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_aud_3v3_en";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			enable-active-high;
+			regulator-always-on;
+		};
+
+		soc_aud_1v8_en_reg: soc_aud_1v8_en {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_aud_1v8_en";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			enable-active-high;
+			regulator-always-on;
+		};
+
+		soc_vdd_3v3_en_reg: soc_vdd_3v3_en {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_vdd_3v3_en";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio0_porta 30 1>;
+			enable-active-high;
+			regulator-always-on;
+		};
+
+		soc_vdd33_lcd0_en_reg: soc_lcd0_vdd33_en {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_lcd0_vdd33_en";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&pcal6408ahk_d 5 1>;
+			enable-active-high;
+		};
+
+		soc_vdd18_lcd0_en_reg: soc_lcd0_vdd18_en {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_lcd0_vdd18_en";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			gpio = <&pcal6408ahk_d 6 1>;
+			enable-active-high;
+		};
+
+		soc_vdd5v_se_en_reg: soc_vdd5v_se_en {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_vdd5v_se_en";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio2_porta 14 1>;
+			enable-active-high;
+			regulator-always-on;
+		};
+
+		soc_wcn33_en_reg: soc_wcn33_en {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_wcn33_en";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio2_porta 29 1>;
+			enable-active-high;
+			regulator-always-on;
+		};
+
+		soc_vbus_en_reg: soc_vbus_en {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_vbus_en";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio1_porta 22 1>;
+			enable-active-high;
+			regulator-always-on;
+		};
+
+
+		soc_avdd28_rgb_reg: soc_avdd28_rgb {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_avdd28_rgb";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <2800000>;
+			gpio = <&pcal6408ahk_b 1 1>;
+			regulator-always-on;
+			enable-active-high;
+		};
+
+		soc_dovdd18_rgb_reg: soc_dovdd18_rgb {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_dovdd18_rgb";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <2800000>;
+			gpio = <&pcal6408ahk_b 2 1>;
+			regulator-always-on;
+			enable-active-high;
+		};
+
+		soc_dvdd12_rgb_reg: soc_dvdd12_rgb {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_dvdd12_rgb";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <2800000>;
+			gpio = <&pcal6408ahk_b 0 1>;
+			regulator-always-on;
+			enable-active-high;
+		};
+
+		soc_avdd25_ir_reg: soc_avdd25_ir {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_avdd25_ir";
+			regulator-min-microvolt = <2500000>;
+			regulator-max-microvolt = <2500000>;
+			gpio = <&pcal6408ahk_b 5 1>;
+			enable-active-high;
+		};
+
+		soc_dovdd18_ir_reg: soc_dovdd18_ir {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_dovdd18_ir";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			gpio = <&pcal6408ahk_b 3 1>;
+			enable-active-high;
+		};
+
+		soc_dvdd12_ir_reg: soc_dvdd12_ir {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_dvdd12_ir";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			gpio = <&pcal6408ahk_b 4 1>;
+			enable-active-high;
+		};
+
+		soc_cam2_avdd25_ir_reg: soc_cam2_avdd25_ir {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_cam2_avdd25_ir";
+			regulator-min-microvolt = <2500000>;
+			regulator-max-microvolt = <2500000>;
+			gpio = <&pcal6408ahk_b 7 1>;
+			enable-active-high;
+		};
+
+		soc_cam2_dovdd18_ir_reg: soc_cam2_dovdd18_ir {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_cam2_dovdd18_ir";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			gpio = <&pcal6408ahk_b 6 1>;
+			enable-active-high;
+		};
+
+		soc_cam2_dvdd12_ir_reg: soc_cam2_dvdd12_ir {
+			compatible = "regulator-fixed";
+			regulator-name = "soc_cam2_dvdd12_ir";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			gpio = <&pcal6408ahk_c 0 1>;
+			enable-active-high;
+		};
+
+		aon_reg_dialog: light-dialog-reg {
+			compatible = "thead,light-dialog-pmic-ant";
+			status = "okay";
+
+			dvdd_cpu_reg: appcpu_dvdd {
+				regulator-name = "appcpu_dvdd";
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1570000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			dvddm_cpu_reg: appcpu_dvddm {
+				regulator-name = "appcpu_dvddm";
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1570000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_dvdd18_aon_reg: soc_dvdd18_aon {
+				regulator-name = "soc_dvdd18_aon";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_avdd33_usb3_reg: soc_avdd33_usb3 {
+				regulator-name = "soc_avdd33_usb3";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_dvdd08_aon_reg: soc_dvdd08_aon {
+				regulator-name = "soc_dvdd08_aon";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_dvdd08_ddr_reg: soc_dvdd08_ddr {
+				regulator-name = "soc_dvdd08_ddr";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_vdd_ddr_1v8_reg: soc_vdd_ddr_1v8 {
+				regulator-name = "soc_vdd_ddr_1v8";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_vdd_ddr_1v1_reg: soc_vdd_ddr_1v1 {
+				regulator-name = "soc_vdd_ddr_1v1";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_vdd_ddr_0v6_reg: soc_vdd_ddr_0v6 {
+				regulator-name = "soc_vdd_ddr_0v6";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_dvdd18_ap_reg: soc_dvdd18_ap {
+				regulator-name = "soc_dvdd18_ap";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_avdd08_mipi_hdmi_reg: soc_avdd08_mipi_hdmi {
+				regulator-name = "soc_avdd08_mipi_hdmi";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_avdd18_mipi_hdmi_reg: soc_avdd18_mipi_hdmi {
+				regulator-name = "soc_avdd18_mipi_hdmi";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_vdd33_emmc_reg: soc_vdd33_emmc {
+				regulator-name = "soc_vdd33_emmc";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_vdd18_emmc_reg: soc_vdd18_emmc {
+				regulator-name = "soc_vdd18_emmc";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			soc_dovdd18_scan_reg: soc_dovdd18_scan {
+				regulator-name = "soc_dovdd18_scan";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <3600000>;
+			};
+
+			soc_dvdd12_scan_reg: soc_dvdd12_scan {
+				regulator-name = "soc_dvdd12_scan";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <3600000>;
+			};
+
+			soc_avdd28_scan_en_reg: soc_avdd28_scan_en {
+				regulator-name = "soc_avdd28_scan_en";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <3600000>;
+			};
+
+		};
+
+		c910_cpufreq {
+			compatible = "thead,light-mpw-cpufreq";
+			status = "okay";
+		};
+
+		test: light-aon-test {
+			compatible = "thead,light-aon-test";
+		};
+	};
+
+};
+
+&resmem {
+	#address-cells = <2>;
+	#size-cells = <2>;
+	ranges;
+
+	tee_mem: memory@1c000000 {
+		reg = <0x0 0x1c000000 0 0x2000000>;
+		no-map;
+	};
+
+	dsp0_mem: memory@20000000 {             /**0x2000_0000~0x2040_0000 4M**/
+		reg = <0x0 0x20000000 0x0 0x00280000   /* DSP FW code&data section 2.5M*/ 
+               0x0 0x20280000 0x0 0x00001000   /* DSP communication area 4K*/ 
+               0x0 0x20281000 0x0 0x00007000  /* Panic/log page 28K */
+               0x0 0x20288000 0x0 0x00178000>;  /* DSP shared memory 1.5M-32K*/
+		no-map;
+	};
+    dsp1_mem: memory@20400000 {             /**0x2040_0000~0x2080_0000 4M**/
+        reg = <0x0 0x20400000 0x0 0x00280000  /* DSP FW code&data section */ 
+               0x0 0x20680000 0x0 0x00001000 /* DSP communication area */
+               0x0 0x20681000 0x0 0x00007000    /* Panic/log page*/ 
+               0x0 0x20688000 0x0 0x00178000>;  /* DSP shared memory */
+        no-map;
+    };
+	vi_mem: framebuffer@10000000 {
+		reg = <0x0 0x10000000 0x0 0x02C00000	/* vi_mem_pool_region[0]  44 MB (default) */
+		       0x0 0x12C00000 0x0 0x01D00000	/* vi_mem_pool_region[1]  29 MB */
+		       0x0 0x14900000 0x0 0x01E00000>;	/* vi_mem_pool_region[2]  30 MB */
+		no-map;
+	};
+	facelib_mem: memory@17000000 {
+		reg = <0x0 0x17000000 0 0x02000000>;
+		no-map;
+	};
+    /* not use 
+    audio_mem: memory@32000000 {
+		reg = <0x0 0x32000000 0x0 0x6400000>;
+		no-map;
+    };
+	rpmsgmem: memory@1E000000 {
+		reg = <0x0 0x1E000000 0x0 0x10000>;
+		no-map;
+	};
+    */
+
+};
+
+&adc {
+	vref-supply = <&reg_vref_1v8>;
+    #io-channel-cells = <1>;
+	status = "okay";
+};
+
+&audio_i2c0 {
+	clock-frequency = <100000>;
+	status = "okay";
+
+	es8156_audio_codec: es8156@8 {
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8156";
+		reg = <0x08>;
+		sound-name-prefix = "ES8156";
+		AVDD-supply = <&soc_aud_3v3_en_reg>;
+		DVDD-supply = <&soc_aud_1v8_en_reg>;
+		PVDD-supply = <&soc_aud_1v8_en_reg>;
+	};
+
+	es7210_audio_codec: es7210@40 {
+		#sound-dai-cells = <0>;
+		compatible = "MicArray_0";
+		reg = <0x40>;
+		sound-name-prefix = "ES7210";
+		MVDD-supply = <&soc_aud_3v3_en_reg>;
+		AVDD-supply = <&soc_aud_3v3_en_reg>;
+		DVDD-supply = <&soc_aud_1v8_en_reg>;
+		PVDD-supply = <&soc_aud_1v8_en_reg>;
+	};
+
+	audio_aw87519_pa: amp@58 {
+		compatible = "awinic,aw87519_pa";
+		reg = <0x58>;
+		sound-name-prefix = "AW87519";
+		status = "disabled";
+	};
+
+	audio_aw87519_pa1@5b {
+		compatible = "awinic,aw87519_pa";
+		reg = <0x5b>;
+		status = "disabled";
+	};
+
+};
+
+&audio_i2c1 {
+	clock-frequency = <100000>;
+	status = "okay";
+
+	es8156_audio_codec_1: es8156@8 {
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8156";
+		reg = <0x08>;
+		status = "disabled";
+	};
+
+	es7210_audio_codec_1: es7210@40 {
+		#sound-dai-cells = <0>;
+		compatible = "MicArray_0";
+		reg = <0x40>;
+		status = "disabled";
+	};
+
+	audio_aw87519_pa2@58 {
+		compatible = "awinic,aw87519_pa";
+		reg = <0x58>;
+		status = "disabled";
+	};
+
+	audio_aw87519_pa3@5b {
+		compatible = "awinic,aw87519_pa";
+		reg = <0x5b>;
+		status = "disabled";
+	};
+};
+
+&spi0 {
+	num-cs = <1>;
+	cs-gpios = <&gpio2_porta 15 0>; // GPIO_ACTIVE_HIGH: 0
+	rx-sample-delay-ns = <10>;
+	status = "okay";
+
+	spi_norflash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "winbond,w25q64jwm", "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <50000000>;
+		w25q,fast-read;
+	};
+
+	spidev@1 {
+		compatible = "spidev";
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		reg = <0x1>;
+		spi-max-frequency = <50000000>;
+	};
+};
+
+&uart0 {
+	clock-frequency = <100000000>;
+};
+
+&qspi0 {
+	num-cs = <1>;
+	cs-gpios = <&gpio2_porta 3 0>;
+	rx-sample-dly = <4>;
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-nand";
+		spi-max-frequency = <100000000>;
+		spi-tx-bus-width = <4>;
+		spi-rx-bus-width = <4>;
+		reg = <0>;
+
+		partition@0 {
+			label = "ubi1";
+			reg = <0x00000000 0x08000000>;
+		};
+	};
+};
+
+&qspi1 {
+	compatible = "snps,dw-apb-ssi";
+	num-cs = <1>;
+	cs-gpios = <&gpio0_porta 1 0>;
+	status = "okay";
+
+	spidev@0 {
+		compatible = "spidev";
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		reg = <0x0>;
+		spi-max-frequency = <50000000>;
+	};
+
+};
+
+&gmac0 {
+	phy-mode = "rgmii-id";
+	rx-clk-delay = <0x00>; /* for RGMII */
+	tx-clk-delay = <0x00>; /* for RGMII */
+	phy-handle = <&phy_88E1111_0>;
+	status = "okay";
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+
+		phy_88E1111_0: ethernet-phy@0 {
+			reg = <0x1>;
+		};
+
+		phy_88E1111_1: ethernet-phy@1 {
+			reg = <0x2>;
+		};
+	};
+};
+
+&gmac1 {
+	phy-mode = "rgmii-id";
+	rx-clk-delay = <0x00>; /* for RGMII */
+	tx-clk-delay = <0x00>; /* for RGMII */
+	phy-handle = <&phy_88E1111_1>;
+	status = "okay";
+};
+
+&emmc {
+	max-frequency = <198000000>;
+	non-removable;
+	mmc-hs400-1_8v;
+	io_fixed_1v8;
+	is_emmc;
+	no-sdio;
+	no-sd;
+	pull_up;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&sdhci0 {
+	max-frequency = <198000000>;
+	bus-width = <4>;
+	pull_up;
+	wprtn_ignore;
+	status = "okay";
+};
+
+&sdhci1 {
+	max-frequency = <100000000>;
+	bus-width = <4>;
+	pull_up;
+	no-sd;
+	no-mmc;
+	non-removable;
+	io_fixed_1v8;
+	post-power-on-delay-ms = <50>;
+	wprtn_ignore;
+	cap-sd-highspeed;
+	keep-power-in-suspend;
+	wakeup-source;
+	status = "okay";
+};
+
+&padctrl0_apsys { /* right-pinctrl */
+	light-evb-padctrl0 {
+			/*
+			 * Pin Configuration Node:
+			 * Format: <pin_id mux_node config>
+			 */
+			pinctrl_uart0: uart0grp {
+				thead,pins = <
+					FM_UART0_TXD	0x0	0x72
+					FM_UART0_RXD	0x0	0x72
+				>;
+			};
+
+			pinctrl_spi0: spi0grp {
+				thead,pins = <
+					FM_SPI_CSN	0x3	0x20a
+					FM_SPI_SCLK	0x0	0x20a
+					FM_SPI_MISO	0x0	0x23a
+					FM_SPI_MOSI	0x0	0x23a
+				>;
+			};
+
+			pinctrl_qspi0: qspi0grp {
+				thead,pins = <
+					FM_QSPI0_SCLK    0x0    0x20f
+					FM_QSPI0_CSN0    0x3    0x20f
+					FM_QSPI0_CSN1    0x0    0x20f
+					FM_QSPI0_D0_MOSI 0x0    0x23f
+					FM_QSPI0_D1_MISO 0x0    0x23f
+					FM_QSPI0_D2_WP   0x0    0x23f
+					FM_QSPI0_D3_HOLD 0x0    0x23f
+				>;
+			};
+
+			pinctrl_audio_i2s0: i2s0grp {
+				thead,pins = <
+					FM_QSPI0_SCLK    0x2    0x208
+					FM_QSPI0_CSN0    0x2    0x238
+					FM_QSPI0_CSN1    0x2    0x208
+					FM_QSPI0_D0_MOSI 0x2    0x238
+					FM_QSPI0_D1_MISO 0x2    0x238
+					FM_QSPI0_D2_WP   0x2    0x238
+					FM_QSPI0_D3_HOLD 0x2    0x238
+				>;
+			};
+
+			pinctrl_pwm: pwmgrp {
+				thead,pins = <
+					FM_GPIO3_2	0x1	0x208	/* pwm0 */
+					FM_GPIO3_3	0x1	0x208	/* pwm1 */
+				>;
+			};
+		};
+};
+
+&padctrl1_apsys { /* left-pinctrl */
+	light-evb-padctrl1 {
+			/*
+			 * Pin Configuration Node:
+			 * Format: <pin_id mux_node config>
+			 */
+			pinctrl_uart3: uart3grp {
+				thead,pins = <
+					FM_UART3_TXD	0x0	0x72
+					FM_UART3_RXD	0x0	0x72
+				>;
+			};
+
+			pinctrl_uart4: uart4grp {
+				thead,pins = <
+					FM_UART4_TXD	0x0	0x72
+					FM_UART4_RXD	0x0	0x72
+					FM_UART4_CTSN	0x0	0x72
+					FM_UART4_RTSN	0x0	0x72
+				>;
+			};
+
+			pinctrl_qspi1: qspi1grp {
+				thead,pins = <
+					FM_QSPI1_SCLK    0x0    0x20a
+					FM_QSPI1_CSN0    0x3    0x20a
+					FM_QSPI1_D0_MOSI 0x0    0x23a
+					FM_QSPI1_D1_MISO 0x0    0x23a
+				>;
+			};
+
+
+			pinctrl_iso7816: iso7816grp {
+				thead,pins = <
+					FM_QSPI1_SCLK		0x1	0x208
+					FM_QSPI1_D0_MOSI	0x1	0x238
+					FM_QSPI1_D1_MISO	0x1	0x238
+					FM_QSPI1_D2_WP		0x1	0x238
+					FM_QSPI1_D3_HOLD	0x1	0x238
+				>;
+			};
+
+			pinctrl_volume: volume_grp {
+				thead,pins = <
+					FM_CLK_OUT_2  0x3     0x208
+				>;
+			};
+		};
+};
+
+&padctrl_aosys {
+	light-aon-padctrl {
+			/*
+			 * Pin Configuration Node:
+			 * Format: <pin_id mux_node config>
+			 */
+
+			pinctrl_audiopa1: audiopa1_grp {
+				thead,pins = <
+					FM_AUDIO_PA1	0x3	0x72
+				>;
+			};
+
+			pinctrl_audiopa2: audiopa2_grp {
+				thead,pins = <
+					FM_AUDIO_PA2	0x0	0x72
+				>;
+			};
+
+	};
+};
+
+&i2c0 {
+    clock-frequency = <400000>;
+	status = "okay";
+
+	pcal6408ahk_b: gpio@20 {
+		compatible = "nxp,pca9557";
+		reg = <0x18>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+};
+
+&i2c1 {
+    clock-frequency = <400000>;
+	status = "okay";
+
+	pcal6408ahk_c: gpio@20 {
+		compatible = "nxp,pca9557";
+		reg = <0x18>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+};
+
+&i2c2 {
+    clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c3 {
+    clock-frequency = <400000>;
+	status = "okay";
+
+	pcal6408ahk_d: gpio@20 {
+		compatible = "nxp,pca9557";
+		reg = <0x18>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+	
+	touch@14 {
+		#gpio-cells = <2>;
+		compatible = "goodix,gt9271";
+		reg = <0x14>;
+		interrupt-parent = <&ao_gpio_porta>;
+		interrupts = <3 0>; 
+		irq-gpios = <&ao_gpio_porta 3 0>; 
+		reset-gpios = <&pcal6408ahk_d 0 0>; 
+		AVDD28-supply = <&reg_tp_pwr_en>;
+		touchscreen-size-x = <800>;
+		touchscreen-size-y = <1280>;
+		tp-size = <9271>;
+		status = "okay";
+	};
+};
+
+&i2c4 {
+    clock-frequency = <400000>;
+	status = "okay";
+};
+
+&isp0 {
+	status = "okay";
+};
+
+&isp1 {
+	status = "okay";
+};
+
+&isp_ry0 {
+	status = "okay";
+};
+
+&dewarp {
+	status = "okay";
+};
+
+&dec400_isp0 {
+	status = "okay";
+};
+
+&dec400_isp1 {
+	status = "okay";
+};
+
+&dec400_isp2 {
+	status = "okay";
+};
+
+&bm_visys {
+	status = "okay";
+};
+
+&bm_csi0 {
+	status = "okay";
+};
+
+&bm_csi1 {
+	status = "okay";
+};
+
+&bm_csi2 {
+	status = "okay";
+};
+
+&vi_pre {
+	//vi_pre_irq_en = <1>;
+	status = "okay";
+};
+
+&xtensa_dsp {
+	status = "okay";
+};
+
+&xtensa_dsp0 {
+	status = "okay";
+    memory-region = <&dsp0_mem>;
+};
+
+&xtensa_dsp1 {
+	status = "okay";
+    memory-region = <&dsp1_mem>;
+};
+
+&vvcam_sensor0 {
+	sensor_name = "OV12870";
+	sensor_regulators = "soc_dovdd18_rgb", "soc_dvdd12_rgb", "soc_avdd28_rgb";
+	sensor_regulator_timing_us = <70 50 20>;
+	sensor_pdn = <&gpio1_porta 28 0>; //powerdown pin / shutdown pin 
+    sensor_rst 	= <&pcal6408ahk_c 1 0>;
+	sensor_pdn_delay_us = <4000>; //powerdown pin / shutdown pin actived till I2C ready
+	DOVDD18_RGB-supply = <&soc_dovdd18_rgb_reg>;
+	DVDD12_RGB-supply = <&soc_dvdd12_rgb_reg>;
+	AVDD28_RGB-supply = <&soc_avdd28_rgb_reg>;
+    i2c_reg_width = /bits/ 8 <2>;
+    i2c_data_width = /bits/ 8 <1>;
+    i2c_addr = /bits/ 8 <0x10>;
+	i2c_bus = /bits/ 8 <0>;
+	status = "okay";
+};
+
+&vvcam_sensor1 {//cam1 csia
+    sensor_name = "SC132GS";
+    sensor_regulators = "soc_dovdd18_ir", "soc_dvdd12_ir", "soc_avdd25_ir";
+    sensor_regulator_timing_us = <70 1000 2000>;
+    i2c_addr = /bits/ 8 <0x30>;
+    sensor_pdn = <&gpio1_porta 30 0>; //powerdown pin / shutdown pin 
+    sensor_rst 	= <&pcal6408ahk_c 2 0>;
+	sensor_pdn_delay_us = <2000>; //powerdown pin / shutdown pin actived till I2C ready
+    DOVDD18_IR-supply = <&soc_dovdd18_ir_reg>;
+    DVDD12_IR-supply = <&soc_dvdd12_ir_reg>;
+    AVDD25_IR-supply = <&soc_avdd25_ir_reg>;
+    i2c_reg_width = /bits/ 8 <2>;
+    i2c_data_width = /bits/ 8 <1>;
+    i2c_bus = /bits/ 8 <1>;
+    status = "okay";
+};
+
+&vvcam_sensor2 {//cam2 csib
+    sensor_name = "SC132GS";
+    sensor_regulators = "soc_cam2_dovdd18_ir", "soc_cam2_dvdd12_ir", "soc_cam2_avdd25_ir";
+    sensor_regulator_timing_us = <70 1000 2000>;
+    i2c_addr = /bits/ 8 <0x30>;
+    sensor_pdn = <&gpio2_porta 13 0>; //powerdown pin / shutdown pin 
+    sensor_rst 	= <&pcal6408ahk_c 3 0>;
+	sensor_pdn_delay_us = <2000>; //powerdown pin / shutdown pin actived till I2C ready
+    DOVDD18_IR-supply = <&soc_cam2_dovdd18_ir_reg>;
+    DVDD12_IR-supply = <&soc_cam2_dvdd12_ir_reg>;
+    AVDD25_IR-supply = <&soc_cam2_avdd25_ir_reg>;
+    i2c_reg_width = /bits/ 8 <2>;
+    i2c_data_width = /bits/ 8 <1>;
+    i2c_bus = /bits/ 8 <2>;
+    status = "okay";
+};
+
+&vvcam_sensor3 {//cam3 csi0 modified
+	sensor_name = "OV5693";
+	sensor_regulators = "soc_dovdd18_rgb", "soc_dvdd12_rgb", "soc_avdd28_rgb";
+	sensor_regulator_voltage_uV = <1800000 1200000 2800000>;
+	sensor_regulator_timing_us = <70 50 20>;
+	sensor_pdn = <&gpio1_porta 28 0>; //powerdown pin / shutdown pin 
+	sensor_rst 	= <&pcal6408ahk_c 1 0>;
+	sensor_pdn_delay_us = <4000>; //powerdown pin / shutdown pin actived till I2C ready
+	DOVDD18_RGB-supply = <&soc_dovdd18_rgb_reg>;
+	DVDD12_RGB-supply = <&soc_dvdd12_rgb_reg>;
+	AVDD28_RGB-supply = <&soc_avdd28_rgb_reg>;
+	i2c_reg_width = /bits/ 8 <2>;
+	i2c_data_width = /bits/ 8 <1>;
+	i2c_addr = /bits/ 8 <0x36>;
+	i2c_bus = /bits/ 8 <0>;
+	status = "okay";
+};
+&video2 {
+    vi_mem_pool_region = <0>;	// vi_mem: framebuffer, region[0]
+	status = "okay";
+	channel0 {
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <3>;
+			csi_idx = <0>;
+			mode_idx = <1>;
+			path_type = "SENSOR_2592x1944_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_MP";
+            output {
+				max_width = <2600>;
+				max_height = <2000>;
+				bit_per_pixel = <12>;
+				frame_count = <3>;
+			};
+		};
+	};
+};
+
+
+&video3{
+    vi_mem_pool_region = <0>;	// vi_mem: framebuffer, region[0]
+	status = "okay";
+    channel0 {
+		sensor0 {
+            subdev_name = "vivcam";
+			idx = <0>;
+			csi_idx = <0>;
+			mode_idx = <0>;
+			path_type = "SENSOR_VGA_RAW12_LINER";
+
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <3>;
+			csi_idx = <0>;
+			mode_idx = <1>;
+			path_type = "SENSOR_2592x1944_LINER";
+		};
+        dma {
+            subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_MP";
+			output {
+				max_width = <1920>;
+				max_height = <1088>;
+				bit_per_pixel = <12>;
+				frame_count = <3>;
+			};
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE0";
+			dw_dst_depth = <2>;
+		};
+	};
+	channel1 {
+        sensor0 {
+            subdev_name = "vivcam";
+			idx = <0>;
+			csi_idx = <0>;
+			mode_idx = <0>;
+			path_type = "SENSOR_VGA_RAW12_LINER";
+
+		};
+        dma {
+            subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_MP";
+			output {
+				max_width = <1920>;
+				max_height = <1088>;
+				bit_per_pixel = <12>;
+				frame_count = <3>;
+			};
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE1";
+			dw_dst_depth = <2>;
+		};
+	};
+	channel2 {
+        sensor0 {
+            subdev_name = "vivcam";
+			idx = <0>;
+			csi_idx = <0>;
+			mode_idx = <0>;
+			path_type = "SENSOR_VGA_RAW12_LINER";
+
+		};
+        dma {
+            subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_MP";
+			output {
+				max_width = <1920>;
+				max_height = <1088>;
+				bit_per_pixel = <12>;
+				frame_count = <3>;
+			};
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE2";
+			dw_dst_depth = <2>;
+		};
+	};
+};
+
+&video9{
+	status = "okay";
+	channel0 {
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <1>; //vivcam1 sc132gs
+			csi_idx = <2>; //<2>=CSI2X2_A
+			mode_idx = <0>;
+			path_type = "SENSOR_1080X1280_30FPS_RAW10_LINER";
+		};
+		dsp{
+			output {
+				max_width = <1080>;
+				max_height = <1280>;
+				bit_per_pixel = <16>;
+				frame_count = <3>;
+			};
+		};
+	};
+};
+
+
+&video10{ // TUNINGTOOL
+	status = "okay";
+	channel0 {
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0>; //<0>=vivcam0 : ov12870 
+			csi_idx = <0>; //<0>=CSI2
+			mode_idx = <1>;
+			path_type = "SENSOR_1080P_RAW10_LINER"; //SENSOR_VGA_RAW10_LINER//
+			skip_init = <1>;
+		};
+        dma {
+			path_type = "VIPRE_CSI0_ISP0";
+		};
+	};
+};
+
+&video15{
+    status = "okay";
+    channel0 {
+        status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0>;
+			csi_idx = <0>;
+			mode_idx = <0>;
+			path_type = "SENSOR_VGA_RAW12_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <3>;
+			csi_idx = <0>;
+			mode_idx = <1>;
+			path_type = "SENSOR_2592x1944_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_DDR";
+		};
+    };
+};
+
+&trng {
+	status = "disabled";
+};
+
+&eip_28 {
+	status = "okay";
+};
+
+&vdec {
+	status = "okay";
+};
+
+&venc {
+	status = "okay";
+};
+
+&isp_venc_shake {
+	status = "okay";
+};
+
+&vidmem {
+	status = "okay";
+    memory-region = <&vi_mem>;
+};
+
+&gpu {
+	status = "okay";
+};
+
+&npu {
+	vha_clk_rate = <1000000000>;
+	status = "okay";
+};
+
+&fce {
+	memory-region = <&facelib_mem>;
+	status = "okay";
+};
+
+&dpu_enc0 {
+	status = "okay";
+
+	ports {
+		/* output */
+		port@1 {
+			reg = <1>;
+
+			enc0_out: endpoint {
+				remote-endpoint = <&dsi0_in>;
+			};
+		};
+	};
+};
+
+&dpu_enc1 {
+        ports {
+                /delete-node/ port@0;
+        };
+};
+
+&dpu {
+        status = "okay";
+};
+
+&dsi0 {
+        status = "okay";
+};
+
+&dhost_0 {
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+
+			dsi0_in: endpoint {
+				remote-endpoint = <&enc0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+
+			dsi0_out: endpoint {
+				remote-endpoint = <&panel0_in>;
+			};
+		};
+	};
+
+	panel0@0 {
+		compatible = "chongzhou,cz101b4001", "jadard,jd9365da-h3";
+		reg = <0>;
+		backlight = <&lcd0_backlight>;
+		reset-gpio = <&pcal6408ahk_d 7 0>; /* active low */
+		hsvcc-supply = <&soc_vdd18_lcd0_en_reg>;
+		vspn3v3-supply = <&soc_vdd33_lcd0_en_reg>;
+
+		port {
+			panel0_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&disp1_out {
+	remote-endpoint = <&hdmi_tx_in>;
+};
+
+&hdmi_tx {
+	status = "okay";
+
+	port@0 {
+		/* input */
+		hdmi_tx_in: endpoint {
+			remote-endpoint = <&disp1_out>;
+		};
+	};
+};
+
+&lightsound {
+        status = "okay";
+        simple-audio-card,dai-link@0 {          /* I2S - AUDIO SYS CODEC 8156*/
+                reg = <0>;
+                format = "i2s";
+                cpu {
+                        sound-dai = <&i2s1 0>;
+                };
+                codec {
+                        sound-dai = <&es8156_audio_codec>;
+                };
+        };
+        simple-audio-card,dai-link@1 {          /* I2S - AUDIO SYS CODEC 7210*/
+                reg = <1>;
+                format = "i2s";
+                cpu {
+                        sound-dai = <&i2s1 0>;
+                };
+                codec {
+                        sound-dai = <&es7210_audio_codec>;
+                };
+        };
+        simple-audio-card,dai-link@2 {          /* I2S - HDMI */
+                reg = <2>;
+                format = "i2s";
+                cpu {
+                        sound-dai = <&light_i2s 1>;
+                };
+                codec {
+                        sound-dai = <&dummy_codec 2>;
+                };
+        };
+};
+
+&light_i2s {
+        status = "okay";
+};
+
+&i2s0 {
+        status = "okay";
+};
+
+&i2s1 {
+        status = "okay";
+        dmas = <&dmac2 11>, <&dmac2 10>;
+};
+
+&i2s2 {
+        status = "okay";
+};
+
+&i2s3 {
+        status = "okay";
+};
+
+&cpus {
+	c910_0: cpu@0 {
+		operating-points = <
+			/* kHz    uV */
+			300000	650000
+			800000	700000
+			1500000	800000
+			1848000 1000000
+		>;
+		light,dvddm-operating-points = <
+			/* kHz   uV */
+			300000	800000
+			800000	800000
+			1500000	800000
+			1848000 1000000
+		>;
+	};
+	c910_1: cpu@1 {
+		operating-points = <
+			/* kHz    uV */
+			300000	650000
+			800000	700000
+			1500000	800000
+			1848000 1000000
+		>;
+		light,dvddm-operating-points = <
+			/* kHz   uV */
+			300000	800000
+			800000	800000
+			1500000	800000
+			1848000 1000000
+		>;
+	};
+	c910_2: cpu@2 {
+
+		operating-points = <
+			/* kHz    uV */
+			300000	650000
+			800000	700000
+			1500000	800000
+			1848000 1000000
+		>;
+		light,dvddm-operating-points = <
+			/* kHz   uV */
+			300000	800000
+			800000	800000
+			1500000	800000
+			1848000 1000000
+		>;
+	};
+	c910_3: cpu@3 {
+
+		operating-points = <
+			/* kHz    uV */
+			300000	650000
+			800000	700000
+			1500000	800000
+			1848000 1000000
+		>;
+		light,dvddm-operating-points = <
+			/* kHz   uV */
+			300000	800000
+			800000	800000
+			1500000	800000
+			1848000 1000000
+		>;
+	};
+};
+&usb{
+	dr_mode = "otg";//peripheral host otg
+	usb-role-switch;
+	//role-switch-default-mode = "host";
+};
\ No newline at end of file
diff --git a/arch/riscv/boot/dts/thead/light-lpi4a.dts b/arch/riscv/boot/dts/thead/light-lpi4a.dts
new file mode 100755
index 000000000..cae29d3f0
--- /dev/null
+++ b/arch/riscv/boot/dts/thead/light-lpi4a.dts
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include "light-lpi4a-ref.dts"
+
+/ {
+	model = "T-HEAD Light Lichee Pi 4A configuration for 8GB DDR board";
+	compatible = "thead,light-val", "thead,light-lpi4a", "thead,light";
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x00000000 0x2 0x00000000>;
+	};
+};
+
+&cmamem {
+	alloc-ranges = <0x1 0xe4000000 0 0x14000000>; // [0x1E400_0000 ~ 0x1F800_0000]
+};
+
+&usb_1 {
+	hubswitch-gpio = <&ao_gpio_porta 4 0>;
+	vbus-supply = <&soc_vbus_en_reg>;
+	hub1v2-supply = <&reg_usb_hub_vdd1v2>;
+	hub5v-supply = <&reg_usb_hub_vcc5v>;
+};
diff --git a/arch/riscv/boot/dts/thead/light-vi-devices.dtsi b/arch/riscv/boot/dts/thead/light-vi-devices.dtsi
new file mode 100755
index 000000000..4bd13a419
--- /dev/null
+++ b/arch/riscv/boot/dts/thead/light-vi-devices.dtsi
@@ -0,0 +1,948 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021-2022 Alibaba Group Holding Limited.
+ */
+
+&video0{
+	status = "okay";
+	channel0 {
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI1_ISP0";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <0>;
+			path_type = "ISP_MI_PATH_MP";
+		};
+	};
+	channel1 {
+		channel_id = <1>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI1_ISP0";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <0>;
+			path_type = "ISP_MI_PATH_SP";
+		};
+	};
+	channel2 {
+		channel_id = <2>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI1_ISP0";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <0>;
+			path_type = "ISP_MI_PATH_SP2_BP";
+		};
+	};
+};
+
+&video1{
+	status = "okay";
+	channel0 { // VSE0
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI1_ISP0";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <0>;
+			path_type = "ISP_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE0";
+		};
+	};
+	channel1 { // VSE1
+		channel_id = <1>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI1_ISP0";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <0>;
+			path_type = "ISP_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE1";
+		};
+	};
+	channel2 { // VSE2
+		channel_id = <2>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI1_ISP0";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <0>;
+			path_type = "ISP_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE2";
+		};
+	};
+};
+
+&video2 {
+	status = "okay";
+	channel0 {
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor2 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_MP";
+		};
+	};
+	channel1 {
+		channel_id = <1>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_SP";
+		};
+	};
+	channel2 {
+		channel_id = <2>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_SP2_BP";
+		};
+	};
+};
+
+&video3 {
+	status = "okay";
+		channel0 {
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE0";
+		};
+	};
+	channel1 {
+		channel_id = <1>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE1";
+		};
+	};
+	channel2 {
+		channel_id = <2>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE2";
+		};
+	};
+};
+
+&video4 {
+	status = "okay";
+	channel0 {
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_PP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <0>;
+			path_type = "DSP_PATH_ISP_RY";
+		};
+		ry {
+			subdev_name = "ry";
+			idx = <0>;
+			path_type = "ISP_RY_MI_PATH_MP";
+		};
+	};
+	channel1 {
+		channel_id = <1>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_PP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <0>;
+			path_type = "DSP_PATH_ISP_RY";
+		};
+		ry {
+			subdev_name = "ry";
+			idx = <0>;
+			path_type = "ISP_RY_MI_PATH_SP";
+		};
+	};
+	channel2 {
+		channel_id = <2>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_PP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <0>;
+			path_type = "DSP_PATH_ISP_RY";
+		};
+		ry {
+			subdev_name = "ry";
+			idx = <0>;
+			path_type = "ISP_RY_MI_PATH_SP2_BP";
+		};
+	};
+};
+
+&video5 {
+	status = "okay";
+	channel0 {
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_PP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <0>;
+			path_type = "DSP_PATH_ISP_RY";
+		};
+		ry {
+			subdev_name = "ry";
+			idx = <0>;
+			path_type = "ISP_RY_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE0";
+		};
+	};
+	channel1 {
+		channel_id = <1>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_PP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <0>;
+			path_type = "DSP_PATH_ISP_RY";
+		};
+		ry {
+			subdev_name = "ry";
+			idx = <0>;
+			path_type = "ISP_RY_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE1";
+		};
+	};
+	channel2 {
+		channel_id = <2>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP1";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <1>;
+			path_type = "ISP_MI_PATH_PP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <0>;
+			path_type = "DSP_PATH_ISP_RY";
+		};
+		ry {
+			subdev_name = "ry";
+			idx = <0>;
+			path_type = "ISP_RY_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE2";
+		};
+	};
+};
+
+
+&video6 {
+	status = "okay";
+	channel0 {
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI2_DSP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <1>;
+			path_type = "DSP_PATH_VIPRE_ODD";
+		};
+	};
+	channel1 {
+		channel_id = <1>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI2_DSP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <1>;
+			path_type = "DSP_PATH_VIPRE_EVEN";
+		};
+	};
+};
+
+
+&video7{
+	status = "okay";
+	channel0 {
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI1_ISP0";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <0>;
+			path_type = "ISP_MI_PATH_PP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <1>;
+			path_type = "DSP_PATH_ISP_RY";
+		};
+		ry {
+			subdev_name = "ry";
+			idx = <0>;
+			path_type = "ISP_RY_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE0";
+		};
+
+	};
+	channel1 {
+		channel_id = <1>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI1_ISP0";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <0>;
+			path_type = "ISP_MI_PATH_PP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <1>;
+			path_type = "DSP_PATH_ISP_RY";
+		};
+		ry {
+			subdev_name = "ry";
+			idx = <0>;
+			path_type = "ISP_RY_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE1";
+		};
+	};
+	channel2 {
+		channel_id = <2>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI1_ISP0";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <0>;
+			path_type = "ISP_MI_PATH_PP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <1>;
+			path_type = "DSP_PATH_ISP_RY";
+		};
+		ry {
+			subdev_name = "ry";
+			idx = <0>;
+			path_type = "ISP_RY_MI_PATH_MP";
+		};
+		dw {
+			subdev_name = "dw";
+			idx = <0>;
+			path_type = "DW_DWE_VSE2";
+		};
+	};
+};
+
+
+&video8{
+	status = "okay";
+	channel0 {
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI1_DSP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <0>;
+			path_type = "DSP_PATH_VIPRE_DDR";
+		};
+	};
+};
+
+
+&video9 { //IR debug
+	status = "okay";
+	channel0 {
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI2_DSP";
+		};
+		dsp {
+			subdev_name = "dsp";
+			idx = <1>;
+			path_type = "DSP_PATH_VIPRE_DDR";
+		};
+	};
+};
+
+
+&video10{ // TUNING TOOL
+	status = "okay";
+	channel0 { // CSI2X2_B
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+			skip_init = <1>;
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+			skip_init = <1>;
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI1_ISP0";
+		};
+	};
+};
+
+
+&video11{
+	status = "okay";
+	channel0 {
+		channel_id = <0>;
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI2_ISP0";
+		};
+		isp {
+			subdev_name = "isp";
+			idx = <0>;
+			path_type = "ISP_MI_PATH_MP";
+		};
+	};
+};
+
+
+&video12{ // TUNING TOOL
+	status = "okay";
+	channel0 { // CSI2
+		status = "okay";
+		sensor0 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+			skip_init = <1>;
+		};
+		sensor1 {
+			subdev_name = "vivcam";
+			idx = <0xff>; // invalid
+			csi_idx = <0xff>;
+			path_type = "SENSOR_VGA_RAW10_LINER";
+			skip_init = <1>;
+		};
+		dma {
+			subdev_name = "vipre";
+			idx = <0>;
+			path_type = "VIPRE_CSI0_ISP0";
+		};
+	};
+};
+
+
diff --git a/arch/riscv/boot/dts/thead/light.dtsi b/arch/riscv/boot/dts/thead/light.dtsi
new file mode 100755
index 000000000..37043ad6f
--- /dev/null
+++ b/arch/riscv/boot/dts/thead/light.dtsi
@@ -0,0 +1,2386 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/pinctrl/light-fm-left-pinctrl.h>
+#include <dt-bindings/pinctrl/light-fm-right-pinctrl.h>
+#include <dt-bindings/pinctrl/light-fm-aon-pinctrl.h>
+#include <dt-bindings/clock/light-fm-ap-clock.h>
+#include <dt-bindings/clock/light-vpsys.h>
+#include <dt-bindings/clock/light-vosys.h>
+#include <dt-bindings/clock/light-visys.h>
+#include <dt-bindings/clock/light-dspsys.h>
+#include <dt-bindings/firmware/thead/rsrc.h>
+#include <dt-bindings/soc/thead,light-iopmp.h>
+#include <dt-bindings/thermal/thermal.h>
+#include <dt-bindings/reset/light-reset.h>
+
+/ {
+	compatible = "thead,light";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+		gpio0 = &gpio0;
+		gpio1 = &gpio1;
+		gpio2 = &gpio2;
+		gpio3 = &gpio3;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		audio_i2c0 = &audio_i2c0;
+		audio_i2c1 = &audio_i2c1;
+		mmc0 = &emmc;
+		mmc1 = &sdhci0;
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+		serial4 = &uart4;
+		serial5 = &uart5;
+		spi0 = &spi0;
+		spi1 = &qspi0;
+		spi2 = &qspi1;
+
+		flash_led0 = &vvcam_flash_led0;
+		vivcam0 = &vvcam_sensor0;
+		vivcam1 = &vvcam_sensor1;
+		vivcam2 = &vvcam_sensor2;
+		vivcam3 = &vvcam_sensor3;
+		vivcam4 = &vvcam_sensor4;
+		vivcam5 = &vvcam_sensor5;
+        vivcam6 = &vvcam_sensor6;
+        vivcam7 = &vvcam_sensor7;
+
+        viv_video0 =  &video0;
+        viv_video1 =  &video1;
+		viv_video2 =  &video2;
+		viv_video3 =  &video3;
+		viv_video4 =  &video4;
+		viv_video5 =  &video5;
+		viv_video6 =  &video6;
+        viv_video7 =  &video7;
+        viv_video8 =  &video8;
+		viv_video9 =  &video9;
+		viv_video10 = &video10;
+		viv_video11 = &video11;
+		viv_video12 = &video12;
+        viv_video13 = &video13;
+		viv_video14 = &video14;
+		viv_video15 = &video15;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x200000 0x0 0xffe00000>;
+	};
+
+	resmem: reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* global autoconfigured region for contiguous allocations */
+		cmamem: linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0 0x14000000>; // 320MB by default
+			alloc-ranges = <0 0x64000000 0 0x14000000>; // [0x6400_0000 ~ 0x7800_0000]
+			linux,cma-default;
+		};
+	};
+
+    aon_iram: aon-iram@ffffef8000 {
+            compatible = "syscon";
+            reg = <0xff 0xffef8000 0x0 0x10000>;
+    };
+
+	thermal-zones {
+		cpu-thermal-zone {
+			polling-delay-passive = <250>;
+			polling-delay = <2000>;
+			thermal-sensors = <&pvt 0>;
+			trips {
+				cpu_config0: trip0 {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				cpu_config1: trip1 {
+					temperature = <110000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				cpu_cdev {
+					trip = <&cpu_config0>;
+					cooling-device =
+						<&c910_0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&c910_1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&c910_2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&c910_3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+				};
+			};
+		};
+	};
+
+	cpus: cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		timebase-frequency = <3000000>;
+		c910_0: cpu@0 {
+			device_type = "cpu";
+			reg = <0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcvsu";
+			mmu-type = "riscv,sv39";
+			cpu-freq = "1.848Ghz";
+			cpu-icache = "64KB";
+			cpu-dcache = "64KB";
+			cpu-l2cache = "1MB";
+			cpu-tlb = "1024 4-ways";
+			cpu-cacheline = "64Bytes";
+			cpu-vector = "0.7.1";
+			#cooling-cells = <2>;
+
+			operating-points = <
+				/* kHz    uV */
+				300000	600000
+				800000	700000
+				1500000	800000
+				1848000	1000000
+			>;
+			light,dvddm-operating-points = <
+				/* kHz   uV */
+				300000	750000
+				800000	800000
+				1500000	800000
+				1848000	1000000
+			>;
+			clock-latency = <61036>;
+			clocks = <&clk C910_CCLK>,
+				 <&clk C910_CCLK_I0>,
+				 <&clk CPU_PLL1_FOUTPOSTDIV>,
+				 <&clk CPU_PLL0_FOUTPOSTDIV>;
+			clock-names = "c910_cclk", "c910_cclk_i0",
+				      "cpu_pll1_foutpostdiv", "cpu_pll0_foutpostdiv";
+			dvdd-supply = <&dvdd_cpu_reg>;
+			dvddm-supply = <&dvddm_cpu_reg>;
+
+			cpu0_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+		c910_1: cpu@1 {
+			device_type = "cpu";
+			reg = <1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcvsu";
+			mmu-type = "riscv,sv39";
+			cpu-freq = "1.848Ghz";
+			cpu-icache = "64KB";
+			cpu-dcache = "64KB";
+			cpu-l2cache = "1MB";
+			cpu-tlb = "1024 4-ways";
+			cpu-cacheline = "64Bytes";
+			cpu-vector = "0.7.1";
+			#cooling-cells = <2>;
+
+			operating-points = <
+				/* kHz    uV */
+				300000	600000
+				800000	700000
+				1500000	800000
+				1848000	1000000
+			>;
+			light,dvddm-operating-points = <
+				/* kHz   uV */
+				300000	750000
+				800000	800000
+				1500000	800000
+				1848000	1000000
+			>;
+			clock-latency = <61036>;
+			clocks = <&clk C910_CCLK>,
+				 <&clk C910_CCLK_I0>,
+				 <&clk CPU_PLL1_FOUTPOSTDIV>,
+				 <&clk CPU_PLL0_FOUTPOSTDIV>;
+			clock-names = "c910_cclk", "c910_cclk_i0",
+				      "cpu_pll1_foutpostdiv", "cpu_pll0_foutpostdiv";
+			dvdd-supply = <&dvdd_cpu_reg>;
+			dvddm-supply = <&dvddm_cpu_reg>;
+
+			cpu1_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+		c910_2: cpu@2 {
+			device_type = "cpu";
+			reg = <2>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcvsu";
+			mmu-type = "riscv,sv39";
+			cpu-freq = "1.848Ghz";
+			cpu-icache = "64KB";
+			cpu-dcache = "64KB";
+			cpu-l2cache = "1MB";
+			cpu-tlb = "1024 4-ways";
+			cpu-cacheline = "64Bytes";
+			cpu-vector = "0.7.1";
+			#cooling-cells = <2>;
+
+			operating-points = <
+				/* kHz    uV */
+				300000	600000
+				800000	700000
+				1500000	800000
+				1848000	1000000
+			>;
+			light,dvddm-operating-points = <
+				/* kHz   uV */
+				300000	750000
+				800000	800000
+				1500000	800000
+				1848000	1000000
+			>;
+			clock-latency = <61036>;
+			clocks = <&clk C910_CCLK>,
+				 <&clk C910_CCLK_I0>,
+				 <&clk CPU_PLL1_FOUTPOSTDIV>,
+				 <&clk CPU_PLL0_FOUTPOSTDIV>;
+			clock-names = "c910_cclk", "c910_cclk_i0",
+				      "cpu_pll1_foutpostdiv", "cpu_pll0_foutpostdiv";
+			dvdd-supply = <&dvdd_cpu_reg>;
+			dvddm-supply = <&dvddm_cpu_reg>;
+
+			cpu2_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+		c910_3: cpu@3 {
+			device_type = "cpu";
+			reg = <3>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcvsu";
+			mmu-type = "riscv,sv39";
+			cpu-freq = "1.848Ghz";
+			cpu-icache = "64KB";
+			cpu-dcache = "64KB";
+			cpu-l2cache = "1MB";
+			cpu-tlb = "1024 4-ways";
+			cpu-cacheline = "64Bytes";
+			cpu-vector = "0.7.1";
+			#cooling-cells = <2>;
+
+			operating-points = <
+				/* kHz    uV */
+				300000	600000
+				800000	700000
+				1500000	800000
+				1848000	1000000
+			>;
+			light,dvddm-operating-points = <
+				/* kHz   uV */
+				300000	750000
+				800000	800000
+				1500000	800000
+				1848000	1000000
+			>;
+			clock-latency = <61036>;
+			clocks = <&clk C910_CCLK>,
+				 <&clk C910_CCLK_I0>,
+				 <&clk CPU_PLL1_FOUTPOSTDIV>,
+				 <&clk CPU_PLL0_FOUTPOSTDIV>;
+			clock-names = "c910_cclk", "c910_cclk_i0",
+				      "cpu_pll1_foutpostdiv", "cpu_pll0_foutpostdiv";
+			dvdd-supply = <&dvdd_cpu_reg>;
+			dvddm-supply = <&dvddm_cpu_reg>;
+
+			cpu3_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+	};
+
+	display-subsystem {
+		compatible = "verisilicon,display-subsystem";
+		ports = <&dpu_disp0>, <&dpu_disp1>;
+		status = "disabled";
+	};
+
+	dpu-encoders {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		dpu_enc0: dpu-encoder@0 {
+			/* default encoder is DSI */
+			compatible = "verisilicon,dsi-encoder";
+			reg = <0>;
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				/* input */
+				port@0 {
+					reg = <0>;
+
+					enc0_in: endpoint {
+						remote-endpoint = <&disp0_out>;
+					};
+				};
+			};
+		};
+
+		dpu_enc1: dpu-encoder@1 {
+			/* default encoder is DSI */
+			compatible = "verisilicon,dsi-encoder";
+			reg = <1>;
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				/* input */
+				port@0 {
+					reg = <0>;
+
+					enc1_in: endpoint {
+						remote-endpoint = <&disp1_out>;
+					};
+				};
+			};
+		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		reset: reset-sample {
+			compatible = "thead,reset-sample";
+			plic-delegate = <0xff 0xd81ffffc>;
+			entry-reg = <0xff 0xff019050>;
+			entry-cnt = <4>;
+			control-reg = <0xff 0xff015004>;
+			control-val = <0x1c>;
+			csr-copy = <0x7f3 0x7c0 0x7c1 0x7c2 0x7c3 0x7c5 0x7cc 0x7ce>;
+		};
+
+		clint0: clint@ffdc000000 {
+			compatible = "riscv,clint0";
+			interrupts-extended = <
+				&cpu0_intc  3 &cpu0_intc  7
+				&cpu1_intc  3 &cpu1_intc  7
+				&cpu2_intc  3 &cpu2_intc  7
+				&cpu3_intc  3 &cpu3_intc  7
+			>;
+			reg = <0xff 0xdc000000 0x0 0x04000000>;
+			clint,has-no-64bit-mmio;
+		};
+
+		intc: interrupt-controller@ffd8000000 {
+			#interrupt-cells = <1>;
+			compatible = "riscv,plic0";
+			interrupt-controller;
+			interrupts-extended = <
+				&cpu0_intc 0xffffffff &cpu0_intc 9
+				&cpu1_intc 0xffffffff &cpu1_intc 9
+				&cpu2_intc 0xffffffff &cpu2_intc 9
+				&cpu3_intc 0xffffffff &cpu3_intc 9
+			>;
+			reg = <0xff 0xd8000000 0x0 0x04000000>;
+			reg-names = "control";
+			riscv,max-priority = <7>;
+			riscv,ndev = <240>;
+		};
+
+		clocks {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			dummy_clock_apb: apb-clock@0 {
+				compatible = "fixed-clock";
+				reg = <0>;	/* Not address, just for index */
+				clock-frequency = <62500000>;
+				clock-output-names = "dummy_clock_apb";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_ref: ref-clock@1 {
+				compatible = "fixed-clock";
+				reg = <1>;	/* Not address, just for index */
+				clock-frequency = <50000000>;
+				clock-output-names = "dummy_clock_ref";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_suspend: suspend-clock@2 {
+				compatible = "fixed-clock";
+				reg = <2>;	/* Not address, just for index */
+				clock-frequency = <50000000>;
+				clock-output-names = "dummy_clock_suspend";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_rtc: rtc-clock@3 {
+				compatible = "fixed-clock";
+				reg = <3>;	/* Not address, just for index */
+				clock-frequency = <32768>;
+				clock-output-names = "dummy_clock_rtc";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_ahb: ahb-clock@4 {
+				compatible = "fixed-clock";
+				reg = <4>;	/* Not address, just for index */
+				clock-frequency = <50000000>;
+				clock-output-names = "dummy_clock_ahb";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_gpu: gpu-clock@6 {
+				compatible = "fixed-clock";
+				reg = <6>;  /* Not address, just for index */
+				clock-frequency = <18000000>;
+				clock-output-names = "dummy_clock_gpu";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_dphy_ref: dphy-ref-clock@7 {
+				compatible = "fixed-clock";
+				reg = <7>;      /* Not address, just for index */
+				clock-frequency = <24000000>;
+				clock-output-names = "dummy_clock_dphy_ref";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_dphy_cfg: dphy-cfg-clock@8 {
+				compatible = "fixed-clock";
+				reg = <8>;      /* Not address, just for index */
+				clock-frequency = <24000000>;
+				clock-output-names = "dummy_clock_dphy_cfg";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_dpu_pixel0: dpu-pixel-clock@9 {
+				compatible = "fixed-clock";
+				reg = <9>;
+				clock-frequency = <72000000>;
+				clock-output-names = "dummy_clock_dpu_pixel0";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_dpu_pixel1: dpu-pixel-clock@10 {
+				compatible = "fixed-clock";
+				reg = <10>;
+				clock-frequency = <74250000>;
+				clock-output-names = "dummy_clock_dpu_pixel1";
+				#clock-cells = <0>;
+			};
+
+			osc_32k: clock-osc-32k@11 {
+				compatible = "fixed-clock";
+				reg = <11>;
+				#clock-cells = <0>;
+				clock-frequency = <32768>;
+				clock-output-names = "osc_32k";
+			};
+
+			osc_24m: clock-osc-24m@12 {
+				compatible = "fixed-clock";
+				reg = <12>;
+				#clock-cells = <0>;
+				clock-frequency = <24000000>;
+				clock-output-names = "osc_24m";
+			};
+
+			rc_24m: clock-rc-24m@13 {
+				compatible = "fixed-clock";
+				reg = <13>;
+				#clock-cells = <0>;
+				clock-frequency = <24000000>;
+				clock-output-names = "rc_24m";
+			};
+
+			dummy_clock_eip: eip-clock@14 {
+				compatible = "fixed-clock";
+				reg = <14>;	/* Not address, just for index */
+				clock-frequency = <400000000>;
+				clock-output-names = "dummy_clock_eip";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_spi: spi-clock@15 {
+				compatible = "fixed-clock";
+				reg = <15>;	/* Not address, just for index */
+				clock-frequency = <396000000>;
+				clock-output-names = "dummy_clock_spi";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_qspi: spi-clock@16 {
+				compatible = "fixed-clock";
+				reg = <15>;	/* Not address, just for index */
+				clock-frequency = <792000000>;
+				clock-output-names = "dummy_clock_qspi";
+				#clock-cells = <0>;
+			};
+
+			dummy_gmac_ahb: gmac-ahb-clock@16 {
+				compatible = "fixed-clock";
+				reg = <16>;
+				clock-frequency = <250000000>;
+				clock-output-names = "dummy_gmac_ahb";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_gmac: gmac-clock@17 {
+				compatible = "fixed-clock";
+				reg = <17>;
+				clock-frequency = <500000000>;
+				clock-output-names = "dummy_clock_gmac";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_sdhci: sdhci-clock@18 {
+				compatible = "fixed-clock";
+				reg = <18>;	/* Not address, just for index */
+				clock-frequency = <198000000>;
+				clock-output-names = "dummy_clock_sdhci";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_aonsys_clk: aonsys-clk-clock@19 {
+				compatible = "fixed-clock";
+				reg = <19>;	/* Not address, just for index */
+				clock-frequency = <73728000>;
+				clock-output-names = "dummy_clock_aonsys_clk";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_uart_sclk: uart-sclk-clock@20 {
+				compatible = "fixed-clock";
+				reg = <20>;	/* Not address, just for index */
+				clock-frequency = <100000000>;
+				clock-output-names = "dummy_clock_uart_sclk";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_visys: visys-dummy-clock@21 {
+				compatible = "fixed-clock";
+				reg = <21>;
+				clock-frequency = <24000000>;
+				#clock-cells = <0>;
+			};
+		};
+
+		iso7816: iso7816-card@fff7f30000 {
+			compatible = "thead,light-iso7816-card";
+			reg = <0xff 0xf7f30000 0x0 0x4000>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_iso7816>;
+			interrupts = <69>;
+			interrupt-parent = <&intc>;
+			status = "disabled";
+		};
+
+		teesys_syscon: teesys-reg@ffff200000 {
+			compatible = "syscon";
+			reg = <0xff 0xff200000 0x0 0x10000>;
+		};
+
+		visys_reg: visys-reg@ffe4040000 {
+			compatible = "thead,light-visys-reg", "syscon";
+			reg = <0xff 0xe4040000 0x0 0x1000>;
+			status = "disabled";
+		};
+
+		dspsys_reg: dspsys-reg@ffef040000 {
+			compatible = "thead,light-dspsys-reg", "syscon";
+			reg = <0xff 0xef040000 0x0 0x1000>;
+			status = "okay";
+		};
+
+		audio_ioctrl: audio_ioctrl@ffcb01d000 {
+			compatible = "thead,light-audio-ioctrl-reg", "syscon";
+			reg = <0xff 0xcb01d000 0x0 0x1000>;
+			status = "okay";
+		};
+
+		audio_cpr: audio_cpr@ffcb000000 {
+			compatible = "thead,light-audio-cpr-reg", "syscon";
+			reg = <0xff 0xcb000000 0x0 0x1000>;
+			status = "okay";
+		};
+
+		nvmem_controller: efuse@ffff210000 {
+			compatible = "thead,light-fm-efuse", "syscon";
+			reg = <0xff 0xff210000 0x0 0x10000>;
+			thead,teesys = <&teesys_syscon>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			gmac0_mac_address: mac-address@176 {
+				reg = <0xb0 6>;
+			};
+
+			gmac1_mac_address: mac-address@184 {
+				reg = <0xb8 6>;
+			};
+		};
+
+		misc_sysreg: misc_sysreg@ffec02c000 {
+			compatible = "thead,light-misc-sysreg", "syscon";
+			reg = <0xff 0xec02c000 0x0 0x1000>;
+			status = "okay";
+		};
+
+		usb3_drd: usb3_drd@ffec03f000 {
+			compatible = "thead,light-usb3-drd", "syscon";
+			reg = <0xff 0xec03f000 0x0 0x1000>;
+			status = "okay";
+		};
+
+		gpio0: gpio@ffec005000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0xff 0xec005000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			gpio0_porta: gpio0-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&intc>;
+				interrupts = <56>;
+			};
+		};
+
+		gpio1: gpio@ffec006000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0xff 0xec006000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			gpio1_porta: gpio1-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&intc>;
+				interrupts = <57>;
+			};
+		};
+
+		gpio2: gpio@ffe7f34000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0xff 0xe7f34000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			gpio2_porta: gpio2-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&intc>;
+				interrupts = <58>;
+			};
+		};
+
+		gpio3: gpio@ffe7f38000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0xff 0xe7f38000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			gpio3_porta: gpio3-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&intc>;
+				interrupts = <59>;
+			};
+		};
+
+		ao_gpio: gpio@fffff41000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0xff 0xfff41000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			ao_gpio_porta: ao_gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&intc>;
+				interrupts = <76>;
+			};
+		};
+
+		ao_gpio4: gpio@fffff52000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0xff 0xfff52000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			ao_gpio4_porta: ao_gpio4-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&intc>;
+				interrupts = <55>;
+			};
+		};
+
+		padctrl1_apsys: pinctrl1-apsys@ffe7f3c000 {
+			compatible = "thead,light-fm-left-pinctrl";
+			reg = <0xff 0xe7f3c000 0x0 0x1000>;
+			status = "okay";
+		};
+
+		padctrl0_apsys: padctrl0-apsys@ffec007000 {
+			compatible = "thead,light-fm-right-pinctrl";
+			reg = <0xff 0xec007000 0x0 0x1000>;
+			status = "okay";
+		};
+
+		pwm: pwm@ffec01c000 {
+			compatible = "thead,pwm-light";
+			reg = <0xff 0xec01c000 0x0 0x4000>;
+			#pwm-cells = <2>;
+			clocks = <&clk CLKGEN_PWM_PCLK>,
+			         <&clk CLKGEN_PWM_CCLK>;
+			clock-names = "pclk", "cclk";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_pwm>;
+		};
+
+		timer0: timer@ffefc32000 {
+			compatible = "snps,dw-apb-timer";
+			reg = <0xff 0xefc32000 0x0 0x14>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "timer";
+			clock-frequency = <62500000>;
+			interrupts = <16>;
+			interrupt-parent = <&intc>;
+			status = "okay";
+		};
+
+		timer1: timer@ffefc32014 {
+			compatible = "snps,dw-apb-timer";
+			reg = <0xff 0xefc32014 0x0 0x14>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "timer";
+			clock-frequency = <62500000>;
+			interrupts = <17>;
+			interrupt-parent = <&intc>;
+			status = "okay";
+		};
+
+		timer2: timer@ffefc32028 {
+			compatible = "snps,dw-apb-timer";
+			reg = <0xff 0xefc32028 0x0 0x14>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "timer";
+			clock-frequency = <62500000>;
+			interrupts = <18>;
+			interrupt-parent = <&intc>;
+			status = "disabled";
+		};
+
+		timer3: timer@ffefc3203c {
+			compatible = "snps,dw-apb-timer";
+			reg = <0xff 0xefc3203c 0x0 0x14>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "timer";
+			clock-frequency = <62500000>;
+			interrupts = <19>;
+			interrupt-parent = <&intc>;
+			status = "disabled";
+		};
+
+		padctrl_aosys: padctrl-aosys@fffff4a000 {
+			compatible = "thead,light-fm-aon-pinctrl";
+			reg = <0xff 0xfff4a000 0x0 0x2000>;
+			status = "okay";
+		};
+
+/*
+                padctrl_audiosys: padctrl-audiosys@ffcb01d000 {
+			compatible = "thead,light-fm-audio-pinctrl";
+			reg = <0xff 0xcb01d000 0x0 0x1000>;
+			status = "disabled";
+		};
+*/
+		timer4: timer@ffffc33000 {
+			compatible = "snps,dw-apb-timer";
+			reg = <0xff 0xffc33000 0x0 0x14>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "timer";
+			clock-frequency = <62500000>;
+			interrupts = <20>;
+			interrupt-parent = <&intc>;
+			status = "disabled";
+		};
+
+		timer5: timer@ffffc33014 {
+			compatible = "snps,dw-apb-timer";
+			reg = <0xff 0xffc33014 0x0 0x14>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "timer";
+			clock-frequency = <62500000>;
+			interrupts = <21>;
+			interrupt-parent = <&intc>;
+			status = "disabled";
+		};
+
+		timer6: timer@ffffc33028 {
+			compatible = "snps,dw-apb-timer";
+			reg = <0xff 0xffc33028 0x0 0x14>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "timer";
+			clock-frequency = <62500000>;
+			interrupts = <22>;
+			interrupt-parent = <&intc>;
+			status = "disabled";
+		};
+
+		timer7: timer@ffffc3303c {
+			compatible = "snps,dw-apb-timer";
+			reg = <0xff 0xffc3303c 0x0 0x14>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "timer";
+			clock-frequency = <62500000>;
+			interrupts = <23>;
+			interrupt-parent = <&intc>;
+			status = "disabled";
+		};
+
+		uart0: serial@ffe7014000 { /* Normal serial, for C910 log */
+			compatible = "snps,dw-apb-uart";
+			reg = <0xff 0xe7014000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <36>;
+			clocks = <&clk CLKGEN_UART0_SCLK>;
+			clock-names = "baudclk";
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			hw-flow-control = "unsupport";
+			status = "okay";
+		};
+
+		uart1: serial@ffe7f00000 { /* Normal serial, for C902 log */
+			compatible = "snps,dw-apb-uart";
+			reg = <0xff 0xe7f00000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <37>;
+			clocks = <&clk CLKGEN_UART1_SCLK>;
+			clock-names = "baudclk";
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			hw-flow-control = "unsupport";
+			status = "okay";
+		};
+
+		uart2: serial@ffec010000 { /* IRDA supported serial, not in 85P bit */
+			compatible = "snps,dw-apb-uart";
+			reg = <0xff 0xec010000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <38>;
+			clocks = <&clk CLKGEN_UART2_SCLK>;
+			clock-names = "baudclk";
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			hw-flow-control = "unsupport";
+			status = "disabled";
+		};
+
+		uart3: serial@ffe7f04000 { /* IRDA supported serial, not in 85P bit */
+			compatible = "snps,dw-apb-uart";
+			reg = <0xff 0xe7f04000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <39>;
+			clocks = <&clk CLKGEN_UART3_SCLK>;
+			clock-names = "baudclk";
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			hw-flow-control = "unsupport";
+			status = "okay";
+		};
+
+		uart4: serial@fff7f08000 { /* High Speed with Flow Ctrol serial */
+			compatible = "snps,dw-apb-uart";
+			reg = <0xff 0xf7f08000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <40>;
+			clocks = <&clk CLKGEN_UART4_SCLK>;
+			clock-names = "baudclk";
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			hw-flow-control = "support";
+			status = "okay";
+		};
+
+		uart5: serial@fff7f0c000 { /* Normal serial, for external SE, not in 85P bit */
+			compatible = "snps,dw-apb-uart";
+			reg = <0xff 0xf7f0c000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <41>;
+			clocks = <&clk CLKGEN_UART5_SCLK>;
+			clock-names = "baudclk";
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			hw-flow-control = "unsupport";
+			status = "disabled";
+		};
+
+		adc: adc@0xfffff51000 {
+			compatible = "thead,light-adc";
+			reg = <0xff 0xfff51000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <61>;
+			clocks = <&dummy_clock_aonsys_clk>;
+			clock-names = "adc";
+			/* ADC pin is proprietary,no need to config pinctrl */
+			status = "disabled";
+		};
+
+		spi0: spi@ffe700c000 {
+			compatible = "snps,dw-apb-ssi";
+			reg = <0xff 0xe700c000 0x0 0x1000>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_spi0>;
+			interrupt-parent = <&intc>;
+			interrupts = <54>;
+			clocks = <&dummy_clock_spi>;
+			num-cs = <2>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		qspi0: spi@ffea000000 {
+			compatible = "snps,dw-apb-ssi-quad";
+			reg = <0xff 0xea000000 0x0 0x1000>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_qspi0>;
+			interrupt-parent = <&intc>;
+			interrupts = <52>;
+			clocks = <&dummy_clock_qspi>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		qspi1: spi@fff8000000 {
+			compatible = "snps,dw-apb-ssi-quad";
+			reg = <0xff 0xf8000000 0x0 0x1000>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_qspi1>;
+			interrupt-parent = <&intc>;
+			interrupts = <53>;
+			clocks = <&dummy_clock_spi>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		g2d: gc620@ffecc80000 {
+			compatible = "thead,c910-gc620";
+			reg = <0xff 0xecc80000 0x0 0x40000>;
+			interrupt-parent = <&intc>;
+			interrupts = <101>;
+			interrupt-names = "irq_2d";
+			clocks = <&vpsys_clk_gate LIGHT_VPSYS_G2D_PCLK>,
+				 <&vpsys_clk_gate LIGHT_VPSYS_G2D_ACLK>,
+				 <&vpsys_clk_gate LIGHT_VPSYS_G2D_CCLK>;
+			clock-names = "pclk", "aclk", "cclk";
+			status = "okay";
+		};
+
+		dsi0: dw-mipi-dsi0@ffef500000 {
+			compatible = "thead,light-mipi-dsi", "simple-bus", "syscon";
+			reg = <0xff 0xef500000 0x0 0x10000>;
+			status = "disabled";
+
+			dphy_0: dsi0-dphy {
+				compatible = "thead,light-mipi-dphy";
+				regmap = <&dsi0>;
+				vosys-regmap = <&vosys_reg>;
+				clocks = <&vosys_clk_gate LIGHT_CLKGEN_MIPIDSI0_REFCLK>,
+					 <&vosys_clk_gate LIGHT_CLKGEN_MIPIDSI0_CFG_CLK>,
+					 <&vosys_clk_gate LIGHT_CLKGEN_MIPIDSI0_PCLK>,
+					 <&clk OSC_24M>,
+					 <&clk OSC_24M>;
+				clock-names = "refclk", "cfgclk", "pclk", "prefclk", "pcfgclk";
+				#phy-cells = <0>;
+			};
+
+			dhost_0: dsi0-host {
+				compatible = "verisilicon,dw-mipi-dsi";
+				regmap = <&dsi0>;
+				interrupt-parent = <&intc>;
+				interrupts = <129>;
+				clocks = <&vosys_clk_gate LIGHT_CLKGEN_MIPIDSI0_PCLK>,
+					 <&vosys_clk_gate LIGHT_CLKGEN_MIPIDSI0_PIXCLK>;
+				clock-names = "pclk", "pixclk";
+				phys = <&dphy_0>;
+				phy-names = "dphy";
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+		dsi1: dw-mipi-dsi1@ffef510000 {
+			compatible = "thead,light-mipi-dsi", "simple-bus", "syscon";
+			reg = <0xff 0xef510000 0x0 0x10000>;
+			status = "disabled";
+
+			dphy_1: dsi1-dphy {
+				compatible = "thead,light-mipi-dphy";
+				regmap = <&dsi1>;
+				vosys-regmap = <&vosys_reg>;
+				clocks = <&vosys_clk_gate LIGHT_CLKGEN_MIPIDSI1_REFCLK>,
+					 <&vosys_clk_gate LIGHT_CLKGEN_MIPIDSI1_CFG_CLK>,
+					 <&vosys_clk_gate LIGHT_CLKGEN_MIPIDSI1_PCLK>,
+					 <&clk OSC_24M>,
+					 <&clk OSC_24M>;
+				clock-names = "refclk", "cfgclk", "pclk", "prefclk", "pcfgclk";
+				#phy-cells = <0>;
+			};
+
+			dhost_1: dsi1-host {
+				compatible = "verisilicon,dw-mipi-dsi";
+				regmap = <&dsi1>;
+				interrupt-parent = <&intc>;
+				interrupts = <129>;
+				clocks = <&vosys_clk_gate LIGHT_CLKGEN_MIPIDSI1_PCLK>,
+					 <&vosys_clk_gate LIGHT_CLKGEN_MIPIDSI1_PIXCLK>;
+				clock-names = "pclk", "pixclk";
+				phys = <&dphy_1>;
+				phy-names = "dphy";
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+		vosys_reg: vosys@ffef528000 {
+			compatible = "thead,light-vo-subsys", "syscon";
+			reg = <0xff 0xef528000 0x0 0x1000>;
+			status = "okay";
+		};
+
+		hdmi_tx: dw-hdmi-tx@ffef540000 {
+			compatible = "thead,light-hdmi-tx";
+			reg = <0xff 0xef540000 0x0 0x40000>;
+			interrupt-parent = <&intc>;
+			interrupts = <111>;
+			clocks = <&vosys_clk_gate LIGHT_CLKGEN_HDMI_PCLK>,
+				 <&vosys_clk_gate LIGHT_CLKGEN_HDMI_SFR_CLK>,
+				 <&vosys_clk_gate LIGHT_CLKGEN_HDMI_CEC_CLK>,
+				 <&vosys_clk_gate LIGHT_CLKGEN_HDMI_PIXCLK>,
+				 <&vosys_clk_gate LIGHT_CLKGEN_HDMI_I2S_CLK>;
+			clock-names = "iahb", "isfr", "cec", "pixclk", "i2s";
+			reg-io-width = <4>;
+			phy_version = <301>;
+			/* TODO: add phy property */
+			status = "disabled";
+		};
+
+		dpu: dc8200@ffef600000 {
+			compatible = "verisilicon,dc8200";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xff 0xef600000 0x0 0x100>,
+			      <0xff 0xef600800 0x0 0x2000>,
+			      <0xff 0xef630010 0x0 0x60>;
+			interrupt-parent = <&intc>;
+			interrupts = <93>;
+			clocks = <&vosys_clk_gate LIGHT_CLKGEN_DPU_CCLK>,
+				 <&vosys_clk_gate LIGHT_CLKGEN_DPU_PIXCLK0>,
+				 <&vosys_clk_gate LIGHT_CLKGEN_DPU_PIXCLK1>,
+				 <&vosys_clk_gate LIGHT_CLKGEN_DPU_ACLK>,
+				 <&vosys_clk_gate LIGHT_CLKGEN_DPU_HCLK>,
+				 <&clk DPU0_PLL_DIV_CLK>,
+				 <&clk DPU1_PLL_DIV_CLK>,
+				 <&clk DPU0_PLL_FOUTPOSTDIV>,
+				 <&clk DPU1_PLL_FOUTPOSTDIV>;
+			clock-names = "core_clk", "pix_clk0", "pix_clk1",
+				      "axi_clk", "cfg_clk", "pixclk0",
+				      "pixclk1", "dpu0_pll_foutpostdiv",
+				      "dpu1_pll_foutpostdiv";
+			status = "disabled";
+
+			dpu_disp0: port@0 {
+				reg = <0>;
+
+				disp0_out: endpoint {
+					remote-endpoint = <&enc0_in>;
+				};
+			};
+
+			dpu_disp1: port@1 {
+				reg = <1>;
+
+				disp1_out: endpoint {
+					remote-endpoint = <&enc1_in>;
+				};
+			};
+		};
+
+		watchdog0: watchdog@ffefc30000 {
+			compatible = "snps,dw-wdt";
+			reg = <0xff 0xefc30000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <24>;
+			clocks = <&clk CLKGEN_WDT0_PCLK>;
+			clock-names = "tclk";
+			resets = <&rst LIGHT_RESET_WDT0>; 
+			status = "okay";
+		};
+
+		watchdog1: watchdog@ffefc31000 {
+			compatible = "snps,dw-wdt";
+			reg = <0xff 0xefc31000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <25>;
+			clocks = <&clk CLKGEN_WDT1_PCLK>;
+			clock-names = "tclk";
+			resets = <&rst LIGHT_RESET_WDT1>; 
+			status = "okay";
+		};
+
+		rtc: rtc@fffff40000 {
+			compatible = "apm,xgene-rtc";
+			reg = <0xff 0xfff40000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <74>;
+			clocks = <&dummy_clock_rtc>;
+			clock-names = "rtc";
+			status = "okay";
+		};
+
+		usb_1: usb@ffec03f000 {
+			compatible = "thead,dwc3";
+			usb3-misc-regmap = <&misc_sysreg>;
+			usb3-drd-regmap = <&usb3_drd>;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+
+			usb: dwc3@ffe7040000 {
+				compatible = "snps,dwc3";
+				reg = <0xff 0xe7040000 0x0 0x10000>;
+				interrupt-parent = <&intc>;
+				interrupts = <68>;
+				clocks = <&dummy_clock_ref>, <&dummy_clock_apb>, <&dummy_clock_suspend>;
+				clock-names = "ref", "bus_early", "suspend";
+				reg-shift = <2>;
+				reg-io-width = <4>;
+				maximum-speed = "super-speed";
+				dr_mode = "host";
+				dma-mask = <0xf 0xffffffff>;
+				snps,usb3_lpm_capable;
+				snps,usb_sofitpsync;
+				status = "okay";
+			};
+		};
+
+		pmu: pmu {
+			interrupt-parent = <&cpu0_intc>;
+			interrupts = <17>;
+			compatible = "riscv,c910_pmu";
+		};
+
+		clk: clock-controller@ffef010000 {
+			compatible = "thead,light-fm-ree-clk";
+			reg = <0xff 0xef010000 0x0 0x1000>;
+			#clock-cells = <1>;
+			clocks = <&osc_32k>, <&osc_24m>, <&rc_24m>;
+			clock-names = "osc_32k", "osc_24m", "rc_24m";
+			status = "okay";
+		};
+
+		rst: reset-controller@ffef014000 {
+			compatible = "thead,light-reset-src","syscon";
+			reg = <0xff 0xef014000 0x0 0x1000>;
+			#reset-cells = <1>;
+			status = "okay";
+		};
+
+		vpsys_rst: vpsys-reset-controller@ffecc30000 {
+			compatible = "thead,light-vpsys-reset-src","syscon";
+			reg = <0xff 0xecc30000 0x0 0x1000>;
+			#reset-cells = <1>;
+			status = "okay";
+		};
+
+		sys_reg: sys_reg@ffef010100 {
+			compatible = "thead,light_sys_reg";
+			reg = <0xff 0xef010100 0x0 0x100>;
+			status = "okay";
+		};
+
+		dmac0: dmac@ffefc00000 {
+			compatible = "snps,axi-dma-1.01a";
+			reg = <0xff 0xefc00000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <27>;
+			clocks = <&dummy_clock_apb>, <&dummy_clock_apb>;
+			clock-names = "core-clk", "cfgr-clk";
+			#dma-cells = <1>;
+			dma-channels = <4>;
+			snps,block-size = <65536 65536 65536 65536>;
+			snps,priority = <0 1 2 3>;
+			snps,dma-masters = <1>;
+			snps,data-width = <4>;
+			snps,axi-max-burst-len = <16>;
+			status = "okay";
+		};
+
+		dmac1: tee_dmac@ffff340000 {
+			compatible = "snps,axi-dma-1.01a";
+			reg = <0xff 0xff340000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <150>;
+			clocks = <&dummy_clock_apb>, <&dummy_clock_apb>;
+			clock-names = "core-clk", "cfgr-clk";
+			#dma-cells = <1>;
+			dma-channels = <4>;
+			snps,block-size = <65536 65536 65536 65536>;
+			snps,priority = <0 1 2 3>;
+			snps,dma-masters = <1>;
+			snps,data-width = <4>;
+			snps,axi-max-burst-len = <16>;
+			status = "disabled";
+		};
+
+                dmac2: audio_dmac@0xFFC8000000 {
+                        compatible = "snps,axi-dma-1.01a";
+                        reg = <0xff 0xc8000000 0x0 0x2000>;
+                        interrupt-parent = <&intc>;
+                        interrupts = <167>;
+                        clocks = <&dummy_clock_apb>, <&dummy_clock_apb>;
+                        clock-names = "core-clk", "cfgr-clk";
+                        #dma-cells = <1>;
+                        dma-channels = <16>;
+                        snps,block-size = <65536 65536 65536 65536
+                                          65536 65536 65536 65536
+                                          65536 65536 65536 65536
+                                          65536 65536 65536 65536>;
+                        snps,priority = <0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0>; // <0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15>;
+                        snps,dma-masters = <1>;
+                        snps,data-width = <4>;
+                        snps,axi-max-burst-len = <16>;
+                        status = "okay";
+                };
+
+		stmmac_axi_setup: stmmac-axi-config {
+			snps,wr_osr_lmt = <3>;
+			snps,rd_osr_lmt = <3>;
+			snps,blen = <16 8 4 0 0 0 0>;
+		};
+
+		gmac0: ethernet@ffe7070000 {
+			compatible = "thead,light-dwmac";
+			reg = <0xff 0xe7070000 0x0 0x2000
+			       0xff 0xec00301c 0x0 0x4
+			       0xff 0xec003020 0x0 0x4
+			       0xff 0xec003000 0x0 0x1c>;
+			reg-names = "gmac", "phy_if_reg", "txclk_dir_reg", "clk_mgr_reg";
+			interrupt-parent = <&intc>;
+			interrupts = <66>;
+			interrupt-names = "macirq";
+			clocks = <&clk CLKGEN_GMAC0_CCLK>;
+			clock-names = "gmac_pll_clk";
+			snps,pbl = <32>;
+			snps,fixed-burst;
+			snps,axi-config = <&stmmac_axi_setup>;
+			nvmem-cells = <&gmac0_mac_address>;
+			nvmem-cell-names = "mac-address";
+		};
+
+		gmac1: ethernet@ffe7060000 {
+			compatible = "thead,light-dwmac";
+			reg = <0xff 0xe7060000 0x0 0x2000
+			       0xff 0xec00401c 0x0 0x4
+			       0xff 0xec004020 0x0 0x4
+			       0xff 0xec004000 0x0 0x1c>;
+			reg-names = "gmac", "phy_if_reg", "txclk_dir_reg", "clk_mgr_reg";
+			interrupt-parent = <&intc>;
+			interrupts = <67>;
+			interrupt-names = "macirq";
+			clocks = <&clk CLKGEN_GMAC1_CCLK>;
+			clock-names = "gmac_pll_clk";
+			snps,pbl = <32>;
+			snps,fixed-burst;
+			snps,axi-config = <&stmmac_axi_setup>;
+			nvmem-cells = <&gmac1_mac_address>;
+			nvmem-cell-names = "mac-address";
+		};
+
+		emmc: sdhci@ffe7080000 {
+			compatible = "snps,dwcmshc-sdhci";
+			reg = <0xff 0xe7080000 0x0 0x10000>;
+			interrupt-parent = <&intc>;
+			interrupts = <62>;
+			interrupt-names = "sdhciirq";
+			clocks = <&dummy_clock_sdhci>;
+			clock-names = "core";
+		};
+
+		sdhci0: sd@ffe7090000 {
+			compatible = "snps,dwcmshc-sdhci";
+			reg = <0xff 0xe7090000 0x0 0x10000>;
+			interrupt-parent = <&intc>;
+			interrupts = <64>;
+			interrupt-names = "sdhci0irq";
+			clocks = <&dummy_clock_sdhci>;
+			clock-names = "core";
+		};
+
+		sdhci1: sd@ffe70a0000 {
+		        compatible = "snps,dwcmshc-sdhci";
+		        reg = <0xff 0xe70a0000 0x0 0x10000>;
+		        interrupt-parent = <&intc>;
+		        interrupts = <71>;
+		        interrupt-names = "sdhci1irq";
+		        clocks = <&dummy_clock_sdhci>;
+		        clock-names = "core";
+		};
+
+		hwspinlock: hwspinlock@ffefc10000 {
+			compatible = "light,hwspinlock";
+			reg = <0xff 0xefc10000 0x0 0x10000>;
+			status = "disabled";
+		};
+
+		npu: vha@fffc800000 {
+			compatible = "img,ax3386-nna";
+			reg = <0xff 0xfc800000 0x0 0x100000>;
+			interrupt-parent = <&intc>;
+			interrupts = <113>;
+			interrupt-names = "npuirq";
+			power-domains = <&pd LIGHT_AON_NPU_PD>;
+			clocks = <&clk CLKGEN_TOP_APB_SX_PCLK>,
+			         <&clk CLKGEN_TOP_AXI4S_ACLK>;
+			clock-names = "pclk", "aclk";
+			vha_clk_rate = <1000000000>;
+			ldo_vha-supply = <&npu>;
+			dma-mask = <0xff 0xffffffff>;
+			resets = <&rst LIGHT_RESET_NPU>;
+			status = "disabled";
+		};
+
+		gpu: gpu@ffef400000 {
+		    compatible = "img,gpu";
+		    reg = <0xff 0xef400000 0x0 0x100000>;
+		    interrupt-parent = <&intc>;
+		    interrupts = <102>;
+		    interrupt-names = "gpuirq";
+		    vosys-regmap = <&vosys_reg>;
+		    power-domains = <&pd LIGHT_AON_GPU_PD>;
+            clocks = <&vosys_clk_gate LIGHT_CLKGEN_GPU_CORE_CLK>,
+                     <&vosys_clk_gate LIGHT_CLKGEN_GPU_CFG_ACLK>;
+            clock-names = "cclk", "aclk";
+		    gpu_clk_rate = <18000000>;
+		    dma-mask = <0xf 0xffffffff>;
+		    status = "disabled";
+		};
+
+		fce: fce@fffcc50000 {
+			compatible = "thead,light-fce";
+			reg = <0xff 0xfcc50000 0x0 0x10000>;
+			interrupt-parent = <&intc>;
+			interrupts = <100>;
+			interrupt-names = "fceirq";
+			clocks = <&vpsys_clk_gate LIGHT_VPSYS_FCE_ACLK>,
+				<&vpsys_clk_gate LIGHT_VPSYS_FCE_PCLK>;
+			clock-names = "aclk", "pclk";
+			resets = <&vpsys_rst LIGHT_RESET_FCE>;
+			dma-mask = <0xf 0xffffffff>;
+			status = "disabled";
+		};
+
+		vdec: vdec@ffecc00000 {
+			compatible = "thead,light-vc8000d";
+			reg = <0xff 0xecc00000 0x0 0x8000>;
+			interrupt-parent = <&intc>;
+			interrupts = <131>;
+			power-domains = <&pd LIGHT_AON_VDEC_PD>;
+			clocks = <&vpsys_clk_gate LIGHT_VPSYS_VDEC_ACLK>,
+				<&vpsys_clk_gate LIGHT_VPSYS_VDEC_CCLK>,
+				<&vpsys_clk_gate LIGHT_VPSYS_VDEC_PCLK>;
+			clock-names = "aclk", "cclk", "pclk";
+			status = "disabled";
+		};
+
+		venc: venc@ffecc10000 {
+			compatible = "thead,light-vc8000e";
+			reg = <0xff 0xecc10000 0x0 0x8000>;
+			interrupt-parent = <&intc>;
+			interrupts = <133>;
+			power-domains = <&pd LIGHT_AON_VENC_PD>;
+			clocks = <&vpsys_clk_gate LIGHT_VPSYS_VENC_ACLK>,
+				<&vpsys_clk_gate LIGHT_VPSYS_VENC_CCLK>,
+				<&vpsys_clk_gate LIGHT_VPSYS_VENC_PCLK>;
+			clock-names = "aclk", "cclk", "pclk";
+			status = "disabled";
+		};
+
+		isp_venc_shake: shake@ffe4078000 {
+			compatible = "thead,light-ivs";
+			reg = <0xff 0xe4078000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <158>;
+			status = "disabled";
+		};
+
+		vidmem: vidmem@ffecc08000 {
+			compatible = "thead,light-vidmem";
+			reg = <0xff 0xecc08000 0x0 0x1000>;
+			status = "disabled";
+		};
+
+		light_i2s: light_i2s@ffe7034000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-i2s";
+			reg = <0xff 0xe7034000 0x0 0x4000>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_audio_i2s0>;
+			light,mode = "i2s-master";
+			light,sel = "ap_i2s";
+			interrupt-parent = <&intc>;
+			interrupts = <70>;
+			dmas = <&dmac0 35>, <&dmac0 40>;
+			dma-names = "tx", "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+		i2s0: audio_i2s0@0xffcb014000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-i2s";
+			reg = <0xff 0xcb014000 0x0 0x1000>;
+			audio-pin-regmap = <&audio_ioctrl>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,sel = "i2s0";
+			interrupt-parent = <&intc>;
+			interrupts = <174>;
+			dmas = <&dmac2 9>, <&dmac2 16>;
+			dma-names = "tx", "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+		i2s1: audio_i2s1@0xffcb015000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-i2s";
+			reg = <0xff 0xcb015000 0x0 0x1000>;
+			audio-pin-regmap = <&audio_ioctrl>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,sel = "i2s1";
+			interrupt-parent = <&intc>;
+			interrupts = <175>;
+			dmas = <&dmac2 11>, <&dmac2 17>;
+			dma-names = "tx", "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+		i2s2: audio_i2s2@0xffcb016000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-i2s";
+			reg = <0xff 0xcb016000 0x0 0x1000>;
+			audio-pin-regmap = <&audio_ioctrl>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,sel = "i2s2";
+			interrupt-parent = <&intc>;
+			interrupts = <176>;
+			dmas = <&dmac2 13>, <&dmac2 12>;
+			dma-names = "tx", "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+		i2s3: audio_i2s3@0xffcb017000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-i2s";
+			reg = <0xff 0xcb017000 0x0 0x1000>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,sel = "i2s3";
+			interrupt-parent = <&intc>;
+			interrupts = <177>;
+			dmas = <&dmac2 14>, <&dmac2 16>;
+			dma-names = "tx", "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+/*
+		tdm_slot1: audio_tdm_slot1@0xffcb012000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-pin-regmap = <&audio_ioctrl>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,tdm_slots = <8>;
+			light,tdm_slot_num = <1>;
+			interrupt-parent = <&intc>;
+			interrupts = <178>;
+			dmas = <&dmac2 28>;
+			dma-names = "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+		tdm_slot2: audio_tdm_slot2@0xffcb012000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-pin-regmap = <&audio_ioctrl>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,tdm_slots = <8>;
+			light,tdm_slot_num = <2>;
+			interrupt-parent = <&intc>;
+			interrupts = <178>;
+			dmas = <&dmac2 29>;
+			dma-names = "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+		tdm_slot3: audio_tdm_slot3@0xffcb012000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-pin-regmap = <&audio_ioctrl>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,tdm_slots = <8>;
+			light,tdm_slot_num = <3>;
+			interrupt-parent = <&intc>;
+			interrupts = <178>;
+			dmas = <&dmac2 30>;
+			dma-names = "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+		tdm_slot4: audio_tdm_slot4@0xffcb012000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-pin-regmap = <&audio_ioctrl>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,tdm_slots = <8>;
+			light,tdm_slot_num = <4>;
+			interrupt-parent = <&intc>;
+			interrupts = <178>;
+			dmas = <&dmac2 31>;
+			dma-names = "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+		tdm_slot5: audio_tdm_slot5@0xffcb012000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-pin-regmap = <&audio_ioctrl>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,tdm_slots = <8>;
+			light,tdm_slot_num = <5>;
+			interrupt-parent = <&intc>;
+			interrupts = <178>;
+			dmas = <&dmac2 32>;
+			dma-names = "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+		tdm_slot6: audio_tdm_slot6@0xffcb012000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-pin-regmap = <&audio_ioctrl>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,tdm_slots = <8>;
+			light,tdm_slot_num = <6>;
+			interrupt-parent = <&intc>;
+			interrupts = <178>;
+			dmas = <&dmac2 33>;
+			dma-names = "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+		tdm_slot7: audio_tdm_slot7@0xffcb012000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-pin-regmap = <&audio_ioctrl>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,tdm_slots = <8>;
+			light,tdm_slot_num = <7>;
+			interrupt-parent = <&intc>;
+			interrupts = <178>;
+			dmas = <&dmac2 34>;
+			dma-names = "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+
+		tdm_slot8: audio_tdm_slot8@0xffcb012000 {
+			#sound-dai-cells = <1>;
+			compatible = "light,light-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-pin-regmap = <&audio_ioctrl>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			light,mode = "i2s-master";
+			light,tdm_slots = <8>;
+			light,tdm_slot_num = <8>;
+			interrupt-parent = <&intc>;
+			interrupts = <178>;
+			dmas = <&dmac2 35>;
+			dma-names = "rx";
+			light,dma_maxburst = <4>;
+			#dma-cells = <1>;
+			clocks = <&dummy_clock_apb>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+*/
+		pvt: pvt@fffff4e000 {
+		    compatible = "moortec,mr75203";
+		    reg = <0xff 0xfff4e000 0x0 0x80>,
+			  <0xff 0xfff4e080 0x0 0x100>,
+			  <0xff 0xfff4e180 0x0 0x680>,
+			  <0xff 0xfff4e800 0x0 0x600>;
+		    reg-names = "common", "ts", "pd", "vm";
+		    clocks = <&dummy_clock_aonsys_clk>;
+		    #thermal-sensor-cells = <1>;
+		    status = "okay";
+		};
+
+		i2c0: i2c@ffe7f20000 {
+			compatible = "snps,designware-i2c";
+			reg = <0xff 0xe7f20000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <44>;
+			clocks = <&dummy_clock_apb>;
+			clock-frequency = <100000>;
+			ss_hcnt = /bits/ 16 <0x104>;
+			ss_lcnt = /bits/ 16 <0xec>;
+			fs_hcnt = /bits/ 16 <0x37>;
+			fs_lcnt = /bits/ 16 <0x42>;
+			fp_hcnt = /bits/ 16 <0x14>;
+			fp_lcnt = /bits/ 16 <0x1a>;
+			hs_hcnt = /bits/ 16 <0x9>;
+			hs_lcnt = /bits/ 16 <0x11>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c1: i2c@ffe7f24000 {
+			compatible = "snps,designware-i2c";
+			reg = <0xff 0xe7f24000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <45>;
+			clocks = <&dummy_clock_apb>;
+			clock-frequency = <100000>;
+			ss_hcnt = /bits/ 16 <0x104>;
+			ss_lcnt = /bits/ 16 <0xec>;
+			fs_hcnt = /bits/ 16 <0x37>;
+			fs_lcnt = /bits/ 16 <0x42>;
+			fp_hcnt = /bits/ 16 <0x14>;
+			fp_lcnt = /bits/ 16 <0x1a>;
+			hs_hcnt = /bits/ 16 <0x9>;
+			hs_lcnt = /bits/ 16 <0x11>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c2: i2c@ffec00c000{
+			compatible = "snps,designware-i2c";
+			reg = <0xff 0xec00c000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <46>;
+			clocks = <&dummy_clock_apb>;
+			clock-frequency = <100000>;
+			ss_hcnt = /bits/ 16 <0x104>;
+			ss_lcnt = /bits/ 16 <0xec>;
+			fs_hcnt = /bits/ 16 <0x37>;
+			fs_lcnt = /bits/ 16 <0x42>;
+			fp_hcnt = /bits/ 16 <0x14>;
+			fp_lcnt = /bits/ 16 <0x1a>;
+			hs_hcnt = /bits/ 16 <0x9>;
+			hs_lcnt = /bits/ 16 <0x11>;
+			status = "disabled";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c3: i2c@ffec014000{
+			compatible = "snps,designware-i2c";
+			reg = <0xff 0xec014000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <47>;
+			clocks = <&dummy_clock_apb>;
+			clock-frequency = <100000>;
+			ss_hcnt = /bits/ 16 <0x104>;
+			ss_lcnt = /bits/ 16 <0xec>;
+			fs_hcnt = /bits/ 16 <0x37>;
+			fs_lcnt = /bits/ 16 <0x42>;
+			fp_hcnt = /bits/ 16 <0x14>;
+			fp_lcnt = /bits/ 16 <0x1a>;
+			hs_hcnt = /bits/ 16 <0x9>;
+			hs_lcnt = /bits/ 16 <0x11>;
+			status = "disabled";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c4: i2c@ffe7f28000{
+			compatible = "snps,designware-i2c";
+			reg = <0xff 0xe7f28000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <48>;
+			clocks = <&dummy_clock_apb>;
+			clock-frequency = <100000>;
+			ss_hcnt = /bits/ 16 <0x104>;
+			ss_lcnt = /bits/ 16 <0xec>;
+			fs_hcnt = /bits/ 16 <0x37>;
+			fs_lcnt = /bits/ 16 <0x42>;
+			fp_hcnt = /bits/ 16 <0x14>;
+			fp_lcnt = /bits/ 16 <0x1a>;
+			hs_hcnt = /bits/ 16 <0x9>;
+			hs_lcnt = /bits/ 16 <0x11>;
+			status = "disabled";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		audio_i2c0: i2c@0xffcb01a000 {
+			compatible = "snps,designware-i2c";
+			reg = <0xff 0xcb01a000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <182>;
+			clocks = <&dummy_clock_apb>;
+			clock-frequency = <100000>;
+			ss_hcnt = /bits/ 16 <0x82>;
+			ss_lcnt = /bits/ 16 <0x78>;
+			fs_hcnt = /bits/ 16 <0x37>;
+			fs_lcnt = /bits/ 16 <0x42>;
+			fp_hcnt = /bits/ 16 <0x14>;
+			fp_lcnt = /bits/ 16 <0x1a>;
+			hs_hcnt = /bits/ 16 <0x5>;
+			hs_lcnt = /bits/ 16 <0x15>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		audio_i2c1: i2c@0xffcb01b000 {
+			compatible = "snps,designware-i2c";
+			reg = <0xff 0xcb01b000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <183>;
+			clocks = <&dummy_clock_apb>;
+			clock-frequency = <100000>;
+			ss_hcnt = /bits/ 16 <0x82>;
+			ss_lcnt = /bits/ 16 <0x78>;
+			fs_hcnt = /bits/ 16 <0x37>;
+			fs_lcnt = /bits/ 16 <0x42>;
+			fp_hcnt = /bits/ 16 <0x14>;
+			fp_lcnt = /bits/ 16 <0x1a>;
+			hs_hcnt = /bits/ 16 <0x5>;
+			hs_lcnt = /bits/ 16 <0x15>;
+			status = "disabled";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		isp0: isp@ffe4100000 {
+			compatible = "thead,light-isp";
+			reg = <0xff 0xe4100000 0x0 0x10000>;
+			interrupt-parent = <&intc>;
+			interrupts = <117>,<118>;
+			clocks =  <&visys_clk_gate LIGHT_CLKGEN_ISP0_ACLK>,
+			          <&visys_clk_gate LIGHT_CLKGEN_ISP0_HCLK>,
+				  <&visys_clk_gate LIGHT_CLKGEN_ISP0_PIXELCLK>,
+				  <&visys_clk_gate LIGHT_CLKGEN_ISP0_CLK>;
+			clock-names = "aclk", "hclk", "isp0_pclk", "cclk";
+			status = "disabled";
+		};
+
+		isp1: isp@ffe4110000 {
+			compatible = "thead,light-isp";
+			reg = <0xff 0xe4110000 0x0 0x10000>;
+			interrupt-parent = <&intc>;
+			interrupts = <120>,<121>;
+			clocks = <&visys_clk_gate LIGHT_CLKGEN_ISP0_ACLK>,
+			         <&visys_clk_gate LIGHT_CLKGEN_ISP0_HCLK>,
+				 <&visys_clk_gate LIGHT_CLKGEN_ISP0_PIXELCLK>,
+				 <&visys_clk_gate LIGHT_CLKGEN_ISP1_CLK>,
+				 <&visys_clk_gate LIGHT_CLKGEN_ISP1_PIXELCLK>;
+			clock-names = "aclk", "hclk", "isp0_pclk", "cclk", "isp1_pclk";
+			status = "disabled";
+		};
+
+		isp_ry0: isp_ry@ffe4120000 {
+			compatible = "thead,light-isp_ry";
+			reg = <0xff 0xe4120000 0x0 0x10000>;
+			interrupt-parent = <&intc>;
+			interrupts = <123>,<124>;
+			clocks = <&visys_clk_gate LIGHT_CLKGEN_ISP_RY_ACLK>,
+			         <&visys_clk_gate LIGHT_CLKGEN_ISP_RY_HCLK>,
+				 <&visys_clk_gate LIGHT_CLKGEN_ISP_RY_CCLK>;
+			clock-names = "aclk", "hclk", "cclk";
+			status = "disabled";
+		};
+
+		dewarp: dewarp@ffe4130000 {
+			compatible = "thead,light-dewarp";
+			reg = <0xff 0xe4130000 0x0 0x10000>;
+			interrupt-parent = <&intc>;
+			interrupts = <98>,<99>;
+			clocks = <&visys_clk_gate LIGHT_CLKGEN_DW200_ACLK>,
+			         <&visys_clk_gate LIGHT_CLKGEN_DW200_HCLK>,
+				 <&visys_clk_gate LIGHT_CLKGEN_DW200_CLK_VSE>,
+				 <&visys_clk_gate LIGHT_CLKGEN_DW200_CLK_DWE>;
+			clock-names = "aclk", "hclk", "vseclk", "dweclk";
+			status = "disabled";
+		};
+
+		dec400_isp0: dec400@ffe4060000 {
+			compatible = "thead,dec400";
+			reg = <0xff 0xe4060000 0x0 0x8000>;
+			status = "disabled";
+		};
+
+		dec400_isp1: dec400@ffe4068000 {
+			compatible = "thead,dec400";
+			reg = <0xff 0xe4068000 0x0 0x8000>;
+			status = "disabled";
+		};
+
+		dec400_isp2: dec400@ffe4070000 {
+			compatible = "thead,dec400";
+			reg = <0xff 0xe4070000 0x0 0x8000>;
+			status = "disabled";
+		};
+
+		bm_visys: bm_visys@ffe4040000 {
+			compatible = "thead,light-bm-visys";
+			reg = <0xff 0xe4040000 0x0 0x1000>;
+			status = "disabled";
+		};
+
+		bm_csi0: csi@ffe4000000{ //CSI2
+		    compatible = "thead,light-bm-csi";
+		    reg = < 0xff 0xe4000000 0x0 0x10000>;
+		    interrupt-parent = <&intc>;
+		    interrupts = <128>;
+		    dphyglueiftester = <0x180>;
+		    sysreg_mipi_csi_ctrl = <0x140>;
+		    clocks = <&visys_clk_gate LIGHT_CLKGEN_MIPI_CSI0_PCLK>,
+		             <&visys_clk_gate LIGHT_CLKGEN_MIPI_CSI0_PIXCLK>,
+		             <&visys_clk_gate LIGHT_CLKGEN_MIPI_CSI0_CFG_CLK>;
+		    clock-names = "pclk", "pixclk", "cfg_clk";
+		    phy_name = "CSI_4LANE";
+		    status = "disabled";
+		};
+
+		csia_reg: visys-reg@ffe4020000 {
+		    compatible = "thead,light-visys-reg", "syscon";
+		    reg = < 0xff 0xe4020000 0x0 0x10000>;
+		    status = "okay";
+		};
+
+		bm_csi1: csi@ffe4010000{ //CSI2X2_B
+		    compatible = "thead,light-bm-csi";
+		    reg = < 0xff 0xe4010000 0x0 0x10000>;
+		    interrupt-parent = <&intc>;
+		    interrupts = <126>; // 110 + 16 int_mipi_csi2x2_int0
+		    dphyglueiftester = <0x182>; // for FPGA PHY only. ASIC not needed.
+		    sysreg_mipi_csi_ctrl = <0x148>;
+		    visys-regmap = <&visys_reg>;
+		    csia-regmap = <&csia_reg>;
+		    clocks = <&visys_clk_gate LIGHT_CLKGEN_MIPI_CSI1_PCLK>,
+		             <&visys_clk_gate LIGHT_CLKGEN_MIPI_CSI1_PIXCLK>,
+		             <&visys_clk_gate LIGHT_CLKGEN_MIPI_CSI1_CFG_CLK>;
+		    clock-names = "pclk", "pixclk", "cfg_clk";
+		    phy_name = "CSI_B";
+		    status = "disabled";
+		};
+
+		bm_csi2: csi@ffe4020000{ //CSI2X2_A
+		    compatible = "thead,light-bm-csi";
+		    reg = < 0xff 0xe4020000 0x0 0x10000>;
+		    interrupt-parent = <&intc>;
+		    interrupts = <127>;
+		    dphyglueiftester = <0x184>;
+		    sysreg_mipi_csi_ctrl = <0x144>;
+		    clocks = <&visys_clk_gate LIGHT_CLKGEN_MIPI_CSI2_PCLK>,
+		             <&visys_clk_gate LIGHT_CLKGEN_MIPI_CSI2_PIXCLK>,
+		             <&visys_clk_gate LIGHT_CLKGEN_MIPI_CSI2_CFG_CLK>;
+		    clock-names = "pclk", "pixclk", "cfg_clk";
+		    phy_name = "CSI_A";
+		    status = "disabled";
+		};
+
+		bm_isp0: bm_isp@ffe4100000 {
+			compatible = "thead,light-bm-isp";
+			reg = <0xff 0xe4100000 0x0 0x10000>;
+			status = "disabled";
+		};
+
+		bm_isp1: bm_isp@ffe4110000 {
+			compatible = "thead,light-bm-isp";
+			reg = <0xff 0xe4110000 0x0 0x10000>;
+			status = "disabled";
+		};
+
+		//isp-ry
+		bm_isp2: bm_isp@ffe4120000 {
+			compatible = "thead,light-bm-isp";
+			reg = <0xff 0xe4120000 0x0 0x10000>;
+			status = "disabled";
+		};
+
+		vi_pre: vi_pre@ffe4030000 {
+			compatible = "thead,vi_pre";
+			reg = <0xff 0xe4030000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <134>;
+			clocks = <&visys_clk_gate LIGHT_CLKGEN_VIPRE_ACLK>,
+			         <&visys_clk_gate LIGHT_CLKGEN_VIPRE_PCLK>,
+				 <&visys_clk_gate LIGHT_CLKGEN_VIPRE_PIXELCLK>;
+			clock-names ="aclk", "pclk", "pixclk";
+			status = "disabled";
+		};
+
+		video0: cam_dev@100 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+		video1: cam_dev@200 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        video2: cam_dev@300 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        video3: cam_dev@400 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        video4: cam_dev@500 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        video5: cam_dev@600 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        video6: cam_dev@700 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        video7: cam_dev@800 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        video8: cam_dev@900 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        video9: cam_dev@a00 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        video10: cam_dev@b00 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        video11: cam_dev@c00 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+        video12: cam_dev@d00 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        video13: cam_dev@e00 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+		video14: cam_dev@f00 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+		video15: cam_dev@f01 {
+			compatible = "thead,video";
+			status = "disabled";
+		};
+
+        vvcam_flash_led0: vvcam_flash_led@0 {
+			compatible = "thead,light-vvcam-flash_led";
+			status = "disabled";
+		};
+
+		vvcam_sensor0: vvcam_sensor@0 {
+			compatible = "thead,light-vvcam-sensor";
+			status = "disabled";
+		};
+
+		vvcam_sensor1: vvcam_sensor@1 {
+			compatible = "thead,light-vvcam-sensor";
+			status = "disabled";
+		};
+
+		vvcam_sensor2: vvcam_sensor@2 {
+			compatible = "thead,light-vvcam-sensor";
+			status = "disabled";
+		};
+
+		vvcam_sensor3: vvcam_sensor@3 {
+			compatible = "thead,light-vvcam-sensor";
+			status = "disabled";
+		};
+
+		vvcam_sensor4: vvcam_sensor@4 {
+			compatible = "thead,light-vvcam-sensor";
+			status = "disabled";
+		};
+
+		vvcam_sensor5: vvcam_sensor@5 {
+			compatible = "thead,light-vvcam-sensor";
+			status = "disabled";
+		};
+
+        vvcam_sensor6: vvcam_sensor@6 {
+			compatible = "thead,light-vvcam-sensor";
+			status = "disabled";
+		};
+
+		vvcam_sensor7: vvcam_sensor@7 {
+			compatible = "thead,light-vvcam-sensor";
+			status = "disabled";
+		};
+
+		xtensa_dsp: dsp@01{
+			compatible = "thead,dsp-hw-common";
+			reg = <0xff 0xef040000 0x0 0x001000 >;   /*DSP_SYSREG(0x0000-0xFFF) */
+			status = "disabled";
+		};
+
+		xtensa_dsp0: dsp@0 {
+			compatible = "cdns,xrp-hw-simple";
+			reg = <0xff 0xe4040190 0x0 0x000010   /* host irq DSP->CPU INT Register  */
+				   0xff 0xe40401e0 0x0 0x000010   /* device irq CPU->DSP INT Register  */
+				   0xff 0xef048000 0x0 0x008000>;  /* DSP shared memory */
+			dsp = <0>;
+			dspsys-rst-bit = <8>;           /*bit# in DSP_SYSREG*/
+			dspsys-bus-offset = <0x90>;   /*in DSP_SYSREG*/
+			device-irq = <0x4 1 24>; /*0xff 0xe40401e4 offset to clear DSP I]RQ, bit#, IRQ# */
+			device-irq-host-offset = <0x8>;  /*0xff 0xe40401e8 offset to trigger DSP IRQ*/
+			device-irq-mode = <1>; /*level trigger*/
+			host-irq = <0x4 1>; /*0xff 0xe4040194 offset to clear, bit# */
+			host-irq-mode = <1>;   /*level trigger */
+			host-irq-offset = <0x8>;  /* 0xff 0xe4040198 offset to trigger ,device side*/
+			interrupt-parent = <&intc>;
+			interrupts = <156>;
+			firmware-name = "xrp0.elf";
+			clocks = <&dummy_clock_visys>,
+			<&dummy_clock_visys>;
+			clock-names = "pclk", "cclk";
+			status = "disabled";
+
+			#address-cells = <2>;
+			#size-cells = <1>;
+			ranges = <0x00 0x00000000 0x00 0x00000000 0xe0180000
+                      0x00 0xe01c0000 0x00 0xe01c0000 0x19E40000
+					  0x00 0xfa000000 0xff 0xe0000000 0x00180000
+				      0x00 0xe0180000 0xff 0xe0180000 0x00040000
+					  0x00 0xffc00000 0xff 0xe4000000 0x00200000 >;  /* VISYS_R */
+			dsp@0 {
+				ranges = <0x00 0x00000000 0x00 0x00000000 0xe0180000
+                          0x00 0xe01c0000 0x00 0xe01c0000 0x19E40000
+						  0x00 0xfa000000 0xff 0xe0000000 0x00180000
+						  0x00 0xe0180000 0xff 0xe0180000 0x00040000
+						  0x00 0xffc00000 0xff 0xe4000000 0x00200000 >;  /* VISYS_R */
+			};
+		};
+
+		xtensa_dsp1: dsp@1 {
+			compatible = "cdns,xrp-hw-simple";
+			reg = <0xff 0xe40401a0 0x0 0x000010   /* host irq DSP->CPU INT Register  */
+				   0xff 0xe40401d0 0x0 0x000010   /* device irq CPU->DSP INT Register  */
+				   0xff 0xef050000 0x0 0x008000>;  /* DSP shared memory */
+			dsp = <1>;
+			dspsys-rst-bit = <8>;           /*bit# in DSP_SYSREG*/
+			dspsys-bus-offset = <0x90>;   /*in DSP_SYSREG*/
+			device-irq = <0x4 1 24>; /*0xff 0xe40401e4 offset to clear DSP I]RQ, bit#, IRQ# */
+			device-irq-host-offset = <0x8>;  /*0xff 0xe40401e8 offset to trigger DSP IRQ*/
+			device-irq-mode = <1>; /*level trigger*/
+			host-irq = <0x4 1>; /*0xff 0xe4040194 offset to clear, bit# */
+			host-irq-mode = <1>;   /*level trigger */
+			host-irq-offset = <0x8>;  /* 0xff 0xe4040198 offset to trigger ,device side*/
+			interrupt-parent = <&intc>;
+			interrupts = <157>;
+			firmware-name = "xrp1.elf";
+			clocks = <&dummy_clock_visys>,
+			<&dummy_clock_visys>;
+			clock-names = "pclk", "cclk";
+			status = "disabled";
+
+			#address-cells = <2>;
+			#size-cells = <1>;
+			ranges = <0x00 0x00000000 0x00 0x00000000 0xe0180000
+                      0x00 0xe01c0000 0x00 0xe01c0000 0x19E40000
+					  0x00 0xfa000000 0xff 0xe0000000 0x00180000
+					  0x00 0xe0180000 0xff 0xe01C0000 0x00040000
+					  0x00 0xffc00000 0xff 0xe4000000 0x00200000 >;  /* VISYS_R */
+			dsp@0 {
+				ranges = <0x00 0x00000000 0x00 0x00000000 0xe0180000
+                          0x00 0xe01c0000 0x00 0xe01c0000 0x19E40000
+						  0x00 0xfa000000 0xff 0xe0000000 0x00180000
+						  0x00 0xe0180000 0xff 0xe01C0000 0x00040000
+						  0x00 0xffc00000 0xff 0xe4000000 0x00200000 >;  /* VISYS_R */
+			};
+		};
+
+		pmp: pmp@ffdc020000 {
+			compatible = "pmp";
+			reg = <0xff 0xdc020000 0x0 0x1000>;
+		};
+
+		mrvbr: mrvbr@ffff018050 {
+			compatible = "mrvbr";
+			reg = <0xff 0xff019050 0x0 0x1000>;
+		};
+
+		mrmr: mrmr@ffff014004 {
+			compatible = "mrmr";
+			reg = <0xff 0xff015004 0x0 0x1000>;
+		};
+
+		bmu: ddr-pmu@ffff008000 {
+			compatible = "thead,light-ddr-pmu";
+			reg = <0xff 0xff008000 0x0 0x800
+				0xff 0xff008800 0x0 0x800
+				0xff 0xff009000 0x0 0x800
+				0xff 0xff009800 0x0 0x800
+				0xff 0xff00a000 0x0 0x800>;
+			interrupt-parent = <&intc>;
+			interrupts = <87>;
+			status = "okay";
+		};
+
+		mbox_910t: mbox@ffffc38000 {
+		       compatible = "thead,light-mbox";
+		       reg = <0xff 0xffc38000 0x0 0x4000>,
+			     <0xff 0xffc44000 0x0 0x1000>,
+			     <0xff 0xffc4c000 0x0 0x1000>,
+			     <0xff 0xffc54000 0x0 0x1000>;
+		       reg-names = "local_base", "remote_icu0", "remote_icu1", "remote_icu2";
+		       interrupt-parent = <&intc>;
+		       interrupts = <28>;
+		       clocks = <&dummy_clock_apb>;
+		       clock-names = "ipg";
+		       icu_cpu_id = <0>;
+		       #mbox-cells = <2>;
+		};
+
+		trng: rng@ffff300000 {
+			compatible = "inside-secure,safexcel-eip76";
+			reg = <0xff 0xff300000 0x0 0x7d>;
+			interrupt-parent = <&intc>;
+			interrupts = <149>;
+			clocks = <&dummy_clock_eip>;
+			status = "disabled";
+		};
+
+
+		eip_28: eip-28@ffff300000 {
+			compatible = "xlnx,sunrise-fpga-1.0", "safexcel-eip-28";
+			reg = <0xff 0xff300000 0x0 0x40000>;
+			interrupt-parent = <&intc>;
+			interrupts = <144>,<145>,<146>,<147>;
+			clocks = <&dummy_clock_eip>;
+			status = "disabled";
+		};
+
+		khvhost: khvhost {
+			compatible = "thead,khv-host";
+			interrupt-parent = <&intc>;
+			interrupts = <215>; /* TEE INT SRC_7 */
+		};
+
+        light_event: light-event {
+                compatible = "thead,light-event";
+                aon-iram-regmap = <&aon_iram>;
+                status = "okay";
+        };
+
+		visys_clk_gate: visys-clk-gate { /* VI_SYSREG_R */
+			compatible = "thead,visys-gate-controller";
+			visys-regmap = <&visys_reg>;
+			#clock-cells = <1>;
+			status = "okay";
+		};
+
+		vpsys_clk_gate: vpsys-clk-gate@ffecc30000 { /* VP_SYSREG_R */
+			compatible = "thead,vpsys-gate-controller";
+			reg = <0xff 0xecc30000 0x0 0x1000>;
+			#clock-cells = <1>;
+			status = "okay";
+		};
+
+		vosys_clk_gate: vosys-clk-gate@ffef528000 { /* VO_SYSREG_R */
+			compatible = "thead,vosys-gate-controller";
+			reg = <0xff 0xef528000 0x0 0x1000>;
+			#clock-cells = <1>;
+			status = "okay";
+		};
+
+		dspsys_clk_gate: dspsys-clk-gate {
+			compatible = "thead,dspsys-gate-controller";
+			dspsys-regmap = <&dspsys_reg>;
+			#clock-cells = <1>;
+			status = "okay";
+		};
+	};
+
+};
+
diff --git a/arch/riscv/configs/light-oh_defconfig b/arch/riscv/configs/light-oh_defconfig
new file mode 100755
index 000000000..6312415aa
--- /dev/null
+++ b/arch/riscv/configs/light-oh_defconfig
@@ -0,0 +1,7418 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/riscv 5.10.97 Kernel Configuration
+#
+CONFIG_CC_VERSION_TEXT="riscv64-linux-gcc (Xuantie-900 linux-5.10.4 glibc gcc Toolchain V2.2.4 B-20211227) 10.2.0"
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=100200
+CONFIG_LD_VERSION=235000000
+CONFIG_CLANG_VERSION=0
+CONFIG_LLD_VERSION=0
+CONFIG_CC_CAN_LINK=y
+CONFIG_CC_CAN_LINK_STATIC=y
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_CC_HAS_ASM_INLINE=y
+CONFIG_IRQ_WORK=y
+CONFIG_THREAD_INFO_IN_TASK=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_COMPILE_TEST=y
+CONFIG_LOCALVERSION=""
+CONFIG_BUILD_SALT=""
+CONFIG_DEFAULT_INIT=""
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_WATCH_QUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_USELIB is not set
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+# end of IRQ subsystem
+
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_ARCH_CLOCKSOURCE_INIT=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+# end of Timers subsystem
+
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_PREEMPTION=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_PSI=y
+# CONFIG_PSI_DEFAULT_DISABLED is not set
+# end of CPU/Task time and stats accounting
+
+CONFIG_CPU_ISOLATION=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_TASKS_RCU_GENERIC=y
+CONFIG_TASKS_RCU=y
+CONFIG_TASKS_TRACE_RCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# end of RCU Subsystem
+
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_IKHEADERS is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+
+#
+# Scheduler features
+#
+CONFIG_UCLAMP_TASK=y
+CONFIG_UCLAMP_BUCKETS_COUNT=5
+# end of Scheduler features
+
+CONFIG_CC_HAS_INT128=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+CONFIG_CGROUPS=y
+# CONFIG_MEMCG is not set
+# CONFIG_BLK_CGROUP is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_UCLAMP_TASK_GROUP=y
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_CGROUP_RDMA is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_HUGETLB is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_DEVICE is not set
+CONFIG_CGROUP_CPUACCT=y
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_BPF=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_SOCK_CGROUP_DATA=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_RD_ZSTD=y
+# CONFIG_BOOT_CONFIG is not set
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_FHANDLE is not set
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+# CONFIG_BUG is not set
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_HAVE_FUTEX_CMPXCHG=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_IO_URING=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+# CONFIG_BPF_LSM is not set
+CONFIG_BPF_SYSCALL=y
+# CONFIG_BPF_JIT_ALWAYS_ON is not set
+# CONFIG_BPF_UNPRIV_DEFAULT_OFF is not set
+# CONFIG_USERFAULTFD is not set
+CONFIG_KCMP=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# end of Kernel Performance Events And Counters
+
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SHUFFLE_PAGE_ALLOCATOR is not set
+CONFIG_SLUB_CPU_PARTIAL=y
+CONFIG_SYSTEM_DATA_VERIFICATION=y
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+# end of General setup
+
+CONFIG_64BIT=y
+CONFIG_RISCV=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=24
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=17
+CONFIG_RISCV_SBI=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA32=y
+CONFIG_VA_BITS=39
+CONFIG_PA_BITS=56
+CONFIG_PAGE_OFFSET=0xffffffe000000000
+CONFIG_FORCE_MAX_ZONEORDER=13
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=3
+CONFIG_LOCKDEP_SUPPORT=y
+
+#
+# SoC selection
+#
+CONFIG_SOC_SIFIVE=y
+# CONFIG_SOC_VIRT is not set
+CONFIG_SOC_THEAD=y
+# CONFIG_SOC_THEAD_LIGHT_EMU is not set
+# end of SoC selection
+
+#
+# Platform type
+#
+# CONFIG_ARCH_RV32I is not set
+CONFIG_ARCH_RV64I=y
+# CONFIG_CMODEL_MEDLOW is not set
+CONFIG_CMODEL_MEDANY=y
+CONFIG_MODULE_SECTIONS=y
+CONFIG_MAXPHYSMEM_128GB=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=8
+CONFIG_HOTPLUG_CPU=y
+CONFIG_TUNE_GENERIC=y
+CONFIG_RISCV_ISA_C=y
+# CONFIG_NO_SFENCE_VMA is not set
+CONFIG_RISCV_SWIOTLB=y
+
+#
+# supported PMU type
+#
+# CONFIG_RISCV_BASE_PMU is not set
+# end of supported PMU type
+
+CONFIG_FPU=y
+CONFIG_VECTOR=y
+# CONFIG_VECTOR_1_0 is not set
+CONFIG_VECTOR_0_7=y
+# CONFIG_VLEN_256 is not set
+# CONFIG_VECTOR_EMU is not set
+# CONFIG_THEAD_ISA is not set
+# end of Platform type
+
+#
+# Kernel features
+#
+# CONFIG_HZ_12 is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_RISCV_SBI_V01=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+# CONFIG_COMPAT is not set
+# end of Kernel features
+
+#
+# Boot options
+#
+CONFIG_CMDLINE=""
+CONFIG_EFI_STUB=y
+CONFIG_EFI=y
+# end of Boot options
+
+#
+# Power management options
+#
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_CPU_IDLE_GOV_TEO is not set
+
+#
+# RISC-V CPU Idle Drivers
+#
+CONFIG_LIGHT_CPUIDLE=y
+# end of RISC-V CPU Idle Drivers
+# end of CPU Idle
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_ATTR_SET=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_TIMES is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_CPUFREQ_DT=y
+CONFIG_CPUFREQ_DT_PLATDEV=y
+# CONFIG_CPUFREQ_DUMMY is not set
+# CONFIG_QORIQ_CPUFREQ is not set
+CONFIG_RISV_THEAD_LIGHT_CPUFREQ=y
+# end of CPU Frequency scaling
+
+# CONFIG_SUSPEND is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_CLK=y
+CONFIG_PM_GENERIC_DOMAINS=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_PM_GENERIC_DOMAINS_OF=y
+CONFIG_CPU_PM=y
+CONFIG_ENERGY_MODEL=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# end of Power management options
+
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_MMIO=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_HAVE_KVM_VCPU_ASYNC_IOCTL=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_SOC_INT_SRC7=y
+
+#
+# Firmware Drivers
+#
+# CONFIG_ARM_SCMI_PROTOCOL is not set
+CONFIG_ARM_SCMI_POWER_DOMAIN=y
+# CONFIG_ARM_SCPI_PROTOCOL is not set
+CONFIG_ARM_SCPI_POWER_DOMAIN=y
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_TURRIS_MOX_RWTM is not set
+# CONFIG_BCM47XX_NVRAM is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_VARS_PSTORE=y
+# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
+CONFIG_EFI_PARAMS_FROM_FDT=y
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+CONFIG_EFI_GENERIC_STUB=y
+# CONFIG_EFI_BOOTLOADER_CONTROL is not set
+# CONFIG_EFI_CAPSULE_LOADER is not set
+# CONFIG_EFI_TEST is not set
+# CONFIG_RESET_ATTACK_MITIGATION is not set
+# CONFIG_EFI_RCI2_TABLE is not set
+# CONFIG_EFI_DISABLE_PCI_DMA is not set
+# end of EFI (Extensible Firmware Interface) Support
+
+CONFIG_EFI_EARLYCON=y
+
+#
+# Tegra firmware driver
+#
+# end of Tegra firmware driver
+
+CONFIG_LIGHT_AON=y
+CONFIG_LIGHT_AON_PD=y
+# end of Firmware Drivers
+
+#
+# General architecture-dependent options
+#
+CONFIG_CRASH_CORE=y
+CONFIG_KEXEC_CORE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_UPROBES=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_FUNCTION_ERROR_INJECTION=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_ARCH_HAS_SET_DIRECT_MAP=y
+CONFIG_HAVE_ASM_MODVERSIONS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE=y
+CONFIG_HAVE_ARCH_SECCOMP=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR_STRONG=y
+CONFIG_LTO_NONE=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT=y
+CONFIG_CLONE_BACKWARDS=y
+# CONFIG_COMPAT_32BIT_TIME is not set
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+CONFIG_ARCH_USE_MEMREMAP_PROT=y
+# CONFIG_LOCK_EVENT_COUNTS is not set
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# end of GCOV-based kernel profiling
+
+CONFIG_HAVE_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGINS is not set
+# end of General architecture-dependent options
+
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_ASM_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_WBT is not set
+CONFIG_BLK_DEBUG_FS=y
+# CONFIG_BLK_SED_OPAL is not set
+CONFIG_BLK_INLINE_ENCRYPTION=y
+# CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+# end of Partition Types
+
+CONFIG_BLK_MQ_VIRTIO=y
+CONFIG_BLK_PM=y
+
+#
+# IO Schedulers
+#
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+# end of IO Schedulers
+
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_ASN1=y
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_HAS_MMIOWB=y
+CONFIG_MMIOWB=y
+# CONFIG_GKI_HIDDEN_DRM_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_REGMAP_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_CRYPTO_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_SND_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_SND_SOC_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_MMC_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_GPIO_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_QCOM_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_MEDIA_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_VIRTUAL_CONFIGS is not set
+# CONFIG_GKI_LEGACY_WEXT_ALLCONFIG is not set
+# CONFIG_GKI_HIDDEN_USB_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_SOC_BUS_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_RPMSG_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_GPU_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_IRQ_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_HYPERVISOR_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_NET_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_PHY_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_MM_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_DMA_CONFIGS is not set
+# CONFIG_GKI_HIDDEN_ETHERNET_CONFIGS is not set
+# CONFIG_GKI_HACKS_TO_FIX is not set
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_ARCH_HAS_BINFMT_FLAT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+# end of Executable file formats
+
+#
+# Memory Management options
+#
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+# CONFIG_PAGE_REPORTING is not set
+CONFIG_MIGRATION=y
+CONFIG_CONTIG_ALLOC=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_MMU_NOTIFIER=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+CONFIG_CMA_DEBUGFS=y
+# CONFIG_CMA_SYSFS is not set
+CONFIG_CMA_AREAS=16
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FRAME_VECTOR=y
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+CONFIG_ARCH_HAS_PTE_SPECIAL=y
+
+#
+# Data Access Monitoring
+#
+# CONFIG_DAMON is not set
+# end of Data Access Monitoring
+# end of Memory Management options
+
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+CONFIG_NET_EGRESS=y
+CONFIG_SKB_EXTENSIONS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+CONFIG_UNIX_SCM=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_TLS=y
+# CONFIG_TLS_DEVICE is not set
+# CONFIG_TLS_TOE is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_ALGO=y
+CONFIG_XFRM_USER=y
+CONFIG_XFRM_INTERFACE=y
+# CONFIG_XFRM_SUB_POLICY is not set
+CONFIG_XFRM_MIGRATE=y
+CONFIG_XFRM_STATISTICS=y
+CONFIG_XFRM_ESP=y
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+# CONFIG_XDP_SOCKETS is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+CONFIG_NET_IPGRE_DEMUX=y
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_NET_IPVTI=y
+CONFIG_NET_UDP_TUNNEL=y
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_ESP_OFFLOAD is not set
+# CONFIG_INET_ESPINTCP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+# CONFIG_INET_RAW_DIAG is not set
+CONFIG_INET_DIAG_DESTROY=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+# CONFIG_INET6_AH is not set
+CONFIG_INET6_ESP=y
+# CONFIG_INET6_ESP_OFFLOAD is not set
+# CONFIG_INET6_ESPINTCP is not set
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+# CONFIG_IPV6_ILA is not set
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_IPV6_VTI=y
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+# CONFIG_IPV6_GRE is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_IPV6_RPL_LWTUNNEL is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_MPTCP is not set
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_ADVANCED=y
+# CONFIG_BRIDGE_NETFILTER is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_FAMILY_ARP=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+# CONFIG_NETFILTER_NETLINK_OSF is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_LOG_NETDEV is not set
+CONFIG_NETFILTER_CONNCOUNT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+# CONFIG_NF_CONNTRACK_ZONES is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CONNTRACK_LABELS is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+# CONFIG_NF_CONNTRACK_SIP is not set
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_GLUE_CT is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_REDIRECT=y
+CONFIG_NF_NAT_MASQUERADE=y
+# CONFIG_NF_TABLES is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_CT=y
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_NAT=y
+CONFIG_NETFILTER_XT_TARGET_NETMAP=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+CONFIG_NETFILTER_XT_TARGET_REDIRECT=y
+CONFIG_NETFILTER_XT_TARGET_MASQUERADE=y
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+CONFIG_NETFILTER_XT_MATCH_BPF=y
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+CONFIG_NETFILTER_XT_MATCH_ECN=y
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_L2TP=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# end of Core Netfilter Configuration
+
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_SOCKET_IPV4=y
+CONFIG_NF_TPROXY_IPV4=y
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+CONFIG_NF_REJECT_IPV4=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+CONFIG_IP_NF_MATCH_ECN=y
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+# end of IP: Netfilter Configuration
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_SOCKET_IPV6=y
+CONFIG_NF_TPROXY_IPV6=y
+# CONFIG_NF_DUP_IPV6 is not set
+CONFIG_NF_REJECT_IPV6=y
+# CONFIG_NF_LOG_IPV6 is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+CONFIG_IP6_NF_MATCH_RPFILTER=y
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_MATCH_SRH is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+# CONFIG_IP6_NF_TARGET_SYNPROXY is not set
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP6_NF_SECURITY is not set
+# CONFIG_IP6_NF_NAT is not set
+# end of IPv6: Netfilter Configuration
+
+CONFIG_NF_DEFRAG_IPV6=y
+# CONFIG_NF_CONNTRACK_BRIDGE is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_L2TP=y
+# CONFIG_L2TP_DEBUGFS is not set
+# CONFIG_L2TP_V3 is not set
+CONFIG_STP=y
+CONFIG_BRIDGE=y
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+# CONFIG_BRIDGE_MRP is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_CBS is not set
+# CONFIG_NET_SCH_ETF is not set
+# CONFIG_NET_SCH_TAPRIO is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+CONFIG_NET_SCH_NETEM=y
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_SKBPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_CAKE is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+CONFIG_NET_SCH_INGRESS=y
+# CONFIG_NET_SCH_PLUG is not set
+# CONFIG_NET_SCH_ETS is not set
+# CONFIG_NET_SCH_DEFAULT is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_CLS_BPF=y
+# CONFIG_NET_CLS_FLOWER is not set
+# CONFIG_NET_CLS_MATCHALL is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_U32=y
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+# CONFIG_NET_EMATCH_IPT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_SAMPLE is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_MPLS is not set
+# CONFIG_NET_ACT_VLAN is not set
+# CONFIG_NET_ACT_BPF is not set
+# CONFIG_NET_ACT_CONNMARK is not set
+# CONFIG_NET_ACT_CTINFO is not set
+# CONFIG_NET_ACT_SKBMOD is not set
+# CONFIG_NET_ACT_IFE is not set
+# CONFIG_NET_ACT_TUNNEL_KEY is not set
+# CONFIG_NET_ACT_GATE is not set
+# CONFIG_NET_TC_SKB_EXT is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+# CONFIG_DNS_RESOLVER is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_VSOCKETS=y
+CONFIG_VSOCKETS_DIAG=y
+# CONFIG_VSOCKETS_LOOPBACK is not set
+CONFIG_VIRTIO_VSOCKETS=y
+CONFIG_VIRTIO_VSOCKETS_COMMON=y
+CONFIG_NETLINK_DIAG=y
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_QRTR is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+CONFIG_BPF_JIT=y
+# CONFIG_BPF_STREAM_PARSER is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# end of Network testing
+# end of Networking options
+
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+CONFIG_BT=y
+CONFIG_BT_BREDR=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=y
+# CONFIG_BT_HS is not set
+CONFIG_BT_LE=y
+# CONFIG_BT_LEDS is not set
+# CONFIG_BT_MSFTEXT is not set
+CONFIG_BT_DEBUGFS=y
+# CONFIG_BT_SELFTEST is not set
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_RTL3WIRE=y
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_ATH3K is not set
+# CONFIG_BT_HCIUART_INTEL is not set
+# CONFIG_BT_HCIUART_AG6XX is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+# CONFIG_BT_MTKSDIO is not set
+# CONFIG_BT_QCOMSMD is not set
+# end of Bluetooth device drivers
+
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+CONFIG_STREAM_PARSER=y
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_REQUIRE_SIGNED_REGDB=y
+CONFIG_CFG80211_USE_KERNEL_REGDB_KEYS=y
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+CONFIG_CFG80211_CRDA_SUPPORT=y
+# CONFIG_CFG80211_WEXT is not set
+# CONFIG_MAC80211 is not set
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_LEDS=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_GPIO is not set
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+CONFIG_NET_SOCK_MSG=y
+CONFIG_PAGE_POOL=y
+CONFIG_FAILOVER=y
+CONFIG_ETHTOOL_NETLINK=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_HAVE_PCI=y
+# CONFIG_PCI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_UEVENT_HELPER is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+# CONFIG_FW_LOADER_COMPRESS is not set
+# end of Firmware loader
+
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_DMA_FENCE_TRACE is not set
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+# end of Generic Driver Options
+
+#
+# Bm Csi support
+#
+CONFIG_BM_CSI=y
+CONFIG_BM_ISP=y
+CONFIG_BM_VISYS=y
+# end of Bm Csi support
+
+#
+# Video Memory support
+#
+CONFIG_VIDEO_MEMORY=y
+# end of Video Memory support
+
+#
+# Bus devices
+#
+# CONFIG_ARM_INTEGRATOR_LM is not set
+# CONFIG_BT1_APB is not set
+# CONFIG_BT1_AXI is not set
+# CONFIG_MOXTET is not set
+# CONFIG_HISILICON_LPC is not set
+# CONFIG_QCOM_EBI2 is not set
+# CONFIG_SIMPLE_PM_BUS is not set
+# CONFIG_MHI_BUS is not set
+# end of Bus devices
+
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
+CONFIG_MTD=y
+CONFIG_MTD_TESTS=m
+
+#
+# Partition parsers
+#
+# CONFIG_MTD_AR7_PARTS is not set
+# CONFIG_MTD_BCM63XX_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_PARSER_IMAGETAG is not set
+# CONFIG_MTD_PARSER_TRX is not set
+# CONFIG_MTD_SHARPSL_PARTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# end of Partition parsers
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# end of RAM/ROM/Flash chip drivers
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_TS5500 is not set
+# CONFIG_MTD_PLATRAM is not set
+# end of Mapping drivers for chip access
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_MCHP23K256 is not set
+CONFIG_MTD_SPEAR_SMI=y
+# CONFIG_MTD_SST25L is not set
+CONFIG_MTD_SLRAM=m
+CONFIG_MTD_PHRAM=m
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# end of Self-contained MTD device drivers
+
+#
+# NAND
+#
+CONFIG_MTD_NAND_CORE=y
+# CONFIG_MTD_ONENAND is not set
+# CONFIG_MTD_RAW_NAND is not set
+CONFIG_MTD_SPI_NAND=y
+
+#
+# ECC engine support
+#
+# end of ECC engine support
+# end of NAND
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# end of LPDDR & LPDDR2 PCM memory drivers
+
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
+# CONFIG_SPI_ASPEED_SMC is not set
+# CONFIG_SPI_HISI_SFC is not set
+# CONFIG_SPI_NXP_SPIFI is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_LIMIT=20
+# CONFIG_MTD_UBI_FASTMAP is not set
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_BLOCK is not set
+# CONFIG_MTD_HYPERBUS is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+# CONFIG_OF_ALL_DTBS is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TCP is not set
+# CONFIG_NVME_TARGET is not set
+# end of NVME Support
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_QCOM_COINCELL is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_XILINX_SDFEC is not set
+CONFIG_UID_SYS_STATS=y
+# CONFIG_UID_SYS_STATS_DEBUG is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_HISI_HIKEY_USB is not set
+CONFIG_LIGHT_DSMART_CARD=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=y
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+# CONFIG_EEPROM_EE1004 is not set
+# end of EEPROM support
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# end of Texas Instruments shared transport line discipline
+
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_ECHO is not set
+# CONFIG_MISC_RTSX_USB is not set
+# end of Misc devices
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# end of SCSI Transports
+
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_UFS_TI_J721E is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_DH is not set
+# end of SCSI device support
+
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BCACHE is not set
+CONFIG_BLK_DEV_DM_BUILTIN=y
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_BUFIO=y
+# CONFIG_DM_DEBUG_BLOCK_MANAGER_LOCKING is not set
+# CONFIG_DM_UNSTRIPED is not set
+CONFIG_DM_CRYPT=y
+CONFIG_DM_SNAPSHOT=y
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_CACHE is not set
+# CONFIG_DM_WRITECACHE is not set
+# CONFIG_DM_EBS is not set
+# CONFIG_DM_ERA is not set
+# CONFIG_DM_CLONE is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_DUST is not set
+# CONFIG_DM_INIT is not set
+CONFIG_DM_UEVENT=y
+# CONFIG_DM_FLAKEY is not set
+CONFIG_DM_VERITY=y
+# CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG is not set
+CONFIG_DM_VERITY_FEC=y
+# CONFIG_DM_SWITCH is not set
+# CONFIG_DM_LOG_WRITES is not set
+# CONFIG_DM_INTEGRITY is not set
+CONFIG_DM_BOW=y
+CONFIG_DM_USER=y
+# CONFIG_TARGET_CORE is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# end of IEEE 1394 (FireWire) support
+
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+CONFIG_DUMMY=y
+# CONFIG_WIREGUARD is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_BAREUDP is not set
+# CONFIG_GTP is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+CONFIG_VETH=y
+CONFIG_VIRTIO_NET=y
+# CONFIG_NLMON is not set
+# CONFIG_VSOCKMON is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# end of Distributed Switch Architecture drivers
+
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_ALACRITECH=y
+# CONFIG_ALTERA_TSE is not set
+CONFIG_NET_VENDOR_AMAZON=y
+# CONFIG_NET_XGENE is not set
+# CONFIG_NET_XGENE_V2 is not set
+CONFIG_NET_VENDOR_AQUANTIA=y
+CONFIG_NET_VENDOR_ARC=y
+# CONFIG_ARC_EMAC is not set
+# CONFIG_EMAC_ROCKCHIP is not set
+CONFIG_NET_VENDOR_AURORA=y
+# CONFIG_AURORA_NB8800 is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BCMGENET is not set
+# CONFIG_BGMAC_PLATFORM is not set
+# CONFIG_SYSTEMPORT is not set
+CONFIG_NET_VENDOR_CADENCE=y
+CONFIG_MACB=y
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CAVIUM=y
+CONFIG_NET_VENDOR_CORTINA=y
+# CONFIG_GEMINI_ETHERNET is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_EZCHIP=y
+# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
+CONFIG_NET_VENDOR_FARADAY=y
+CONFIG_NET_VENDOR_FREESCALE=y
+# CONFIG_FEC is not set
+# CONFIG_FSL_FMAN is not set
+# CONFIG_FSL_PQ_MDIO is not set
+# CONFIG_FSL_XGMAC_MDIO is not set
+# CONFIG_GIANFAR is not set
+CONFIG_NET_VENDOR_GOOGLE=y
+CONFIG_NET_VENDOR_HISILICON=y
+# CONFIG_HIX5HD2_GMAC is not set
+# CONFIG_HISI_FEMAC is not set
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+CONFIG_NET_VENDOR_HUAWEI=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MV643XX_ETH is not set
+# CONFIG_MVMDIO is not set
+# CONFIG_MVNETA is not set
+# CONFIG_MVPP2 is not set
+# CONFIG_PXA168_ETH is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_MLXFW is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+# CONFIG_ENCX24J600 is not set
+CONFIG_NET_VENDOR_MICROSEMI=y
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_NETRONOME=y
+CONFIG_NET_VENDOR_NI=y
+# CONFIG_NI_XGE_MANAGEMENT_ENET is not set
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_LPC_ENET is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_PENSANDO=y
+CONFIG_NET_VENDOR_QUALCOMM=y
+# CONFIG_QCA7000_SPI is not set
+# CONFIG_QCOM_EMAC is not set
+# CONFIG_RMNET is not set
+CONFIG_NET_VENDOR_RENESAS=y
+# CONFIG_SH_ETH is not set
+# CONFIG_RAVB is not set
+CONFIG_NET_VENDOR_ROCKER=y
+CONFIG_NET_VENDOR_SAMSUNG=y
+# CONFIG_SXGBE_ETH is not set
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NET_VENDOR_SOLARFLARE=y
+CONFIG_NET_VENDOR_SOCIONEXT=y
+# CONFIG_SNI_AVE is not set
+# CONFIG_SNI_NETSEC is not set
+CONFIG_NET_VENDOR_STMICRO=y
+CONFIG_STMMAC_ETH=y
+# CONFIG_STMMAC_SELFTESTS is not set
+CONFIG_STMMAC_PLATFORM=y
+# CONFIG_DWMAC_DWC_QOS_ETH is not set
+CONFIG_DWMAC_GENERIC=y
+# CONFIG_DWMAC_ANARION is not set
+# CONFIG_DWMAC_IPQ806X is not set
+# CONFIG_DWMAC_LPC18XX is not set
+# CONFIG_DWMAC_MEDIATEK is not set
+# CONFIG_DWMAC_MESON is not set
+# CONFIG_DWMAC_OXNAS is not set
+# CONFIG_DWMAC_QCOM_ETHQOS is not set
+# CONFIG_DWMAC_ROCKCHIP is not set
+# CONFIG_DWMAC_SOCFPGA is not set
+# CONFIG_DWMAC_STI is not set
+# CONFIG_DWMAC_STM32 is not set
+# CONFIG_DWMAC_SUNXI is not set
+# CONFIG_DWMAC_SUN8I is not set
+# CONFIG_DWMAC_IMX8 is not set
+# CONFIG_DWMAC_INTEL_PLAT is not set
+CONFIG_DWMAC_LIGHT=y
+CONFIG_NET_VENDOR_SYNOPSYS=y
+# CONFIG_DWC_XLGMAC is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+CONFIG_NET_VENDOR_XILINX=y
+# CONFIG_XILINX_AXI_EMAC is not set
+# CONFIG_XILINX_LL_TEMAC is not set
+CONFIG_PHYLINK=y
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+# CONFIG_LED_TRIGGER_PHY is not set
+CONFIG_FIXED_PHY=y
+# CONFIG_SFP is not set
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_MESON_GXL_PHY is not set
+# CONFIG_ADIN_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AX88796B_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM54140_PHY is not set
+# CONFIG_BCM63XX_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM84881_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+CONFIG_MICROSEMI_PHY=y
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_NXP_TJA11XX_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+CONFIG_REALTEK_PHY=y
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+# CONFIG_DP83869_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+CONFIG_OF_MDIO=y
+CONFIG_MDIO_DEVRES=y
+# CONFIG_MDIO_SUN4I is not set
+# CONFIG_MDIO_XGENE is not set
+# CONFIG_MDIO_ASPEED is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BCM_IPROC is not set
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MDIO_HISI_FEMAC is not set
+# CONFIG_MDIO_MVUSB is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+# CONFIG_MDIO_MOXART is not set
+# CONFIG_MDIO_OCTEON is not set
+# CONFIG_MDIO_IPQ4019 is not set
+# CONFIG_MDIO_IPQ8064 is not set
+
+#
+# MDIO Multiplexers
+#
+# CONFIG_MDIO_BUS_MUX_MESON_G12A is not set
+# CONFIG_MDIO_BUS_MUX_BCM_IPROC is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MULTIPLEXER is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+
+#
+# PCS device drivers
+#
+CONFIG_PCS_XPCS=y
+# end of PCS device drivers
+
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_MPPE=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPPOE is not set
+CONFIG_PPTP=y
+CONFIG_PPPOL2TP=y
+# CONFIG_PPP_ASYNC is not set
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_RTL8152=y
+# CONFIG_USB_LAN78XX is not set
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_AX88179_178A=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_CDC_EEM is not set
+CONFIG_USB_NET_CDC_NCM=m
+# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set
+# CONFIG_USB_NET_CDC_MBIM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SR9700 is not set
+# CONFIG_USB_NET_SR9800 is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=m
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+CONFIG_USB_NET_CDC_SUBSET_ENABLE=m
+CONFIG_USB_NET_CDC_SUBSET=m
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=m
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_NET_QMI_WWAN is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_VL600 is not set
+# CONFIG_USB_NET_CH9200 is not set
+# CONFIG_USB_NET_AQC111 is not set
+CONFIG_WLAN=y
+# CONFIG_WIRELESS_WDS is not set
+CONFIG_WLAN_VENDOR_ADMTEK=y
+CONFIG_WLAN_VENDOR_ATH=y
+# CONFIG_ATH_DEBUG is not set
+# CONFIG_ATH6KL is not set
+CONFIG_WLAN_VENDOR_ATMEL=y
+CONFIG_WLAN_VENDOR_BROADCOM=y
+# CONFIG_BRCMFMAC is not set
+CONFIG_WLAN_VENDOR_CISCO=y
+CONFIG_WLAN_VENDOR_INTEL=y
+CONFIG_WLAN_VENDOR_INTERSIL=y
+# CONFIG_HOSTAP is not set
+CONFIG_WLAN_VENDOR_MARVELL=y
+# CONFIG_LIBERTAS is not set
+# CONFIG_MWIFIEX is not set
+CONFIG_WLAN_VENDOR_MEDIATEK=y
+CONFIG_WLAN_VENDOR_MICROCHIP=y
+# CONFIG_WILC1000_SDIO is not set
+# CONFIG_WILC1000_SPI is not set
+CONFIG_WLAN_VENDOR_RALINK=y
+CONFIG_WLAN_VENDOR_REALTEK=y
+CONFIG_WLAN_VENDOR_RSI=y
+CONFIG_WLAN_VENDOR_ST=y
+CONFIG_WLAN_VENDOR_TI=y
+CONFIG_WLAN_VENDOR_ZYDAS=y
+# CONFIG_USB_ZD1201 is not set
+CONFIG_WLAN_VENDOR_QUANTENNA=y
+CONFIG_RTL8723DS=y
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_VIRT_WIFI is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_NETDEVSIM is not set
+CONFIG_NET_FAILOVER=y
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_LEDS=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=m
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADC is not set
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1050 is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_CLPS711X is not set
+# CONFIG_KEYBOARD_DLINK_DIR685 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_EP93XX is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_SNVS_PWRKEY is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_GOLDFISH_EVENTS is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_ST_KEYSCAN is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_SH_KEYSC is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_TM2_TOUCHKEY is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_BCM is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_BYD=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_PS2_FOCALTECH=y
+CONFIG_MOUSE_PS2_SMBUS=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_ELAN_I2C is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADC is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+# CONFIG_JOYSTICK_PSXPAD_SPI is not set
+# CONFIG_JOYSTICK_PXRC is not set
+# CONFIG_JOYSTICK_FSIA6B is not set
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=y
+CONFIG_TABLET_USB_AIPTEK=y
+CONFIG_TABLET_USB_GTCO=y
+CONFIG_TABLET_USB_HANWANG=y
+CONFIG_TABLET_USB_KBTAB=y
+# CONFIG_TABLET_USB_PEGASUS is not set
+# CONFIG_TABLET_SERIAL_WACOM4 is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_PROPERTIES=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ADC is not set
+# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_BU21029 is not set
+# CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMA140 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_EGALAX_SERIAL is not set
+# CONFIG_TOUCHSCREEN_EXC3000 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+CONFIG_TOUCHSCREEN_GOODIX=y
+# CONFIG_TOUCHSCREEN_HIDEEP is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_IPROC is not set
+# CONFIG_TOUCHSCREEN_S6SY761 is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_EKTF2127 is not set
+# CONFIG_TOUCHSCREEN_ELAN is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MIP4 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_RASPBERRYPI_FW is not set
+# CONFIG_TOUCHSCREEN_MIGOR is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TS4800 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2004 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_RM_TS is not set
+# CONFIG_TOUCHSCREEN_SILEAD is not set
+# CONFIG_TOUCHSCREEN_SIS_I2C is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_STMFTS is not set
+# CONFIG_TOUCHSCREEN_SUN4I is not set
+# CONFIG_TOUCHSCREEN_SUR40 is not set
+# CONFIG_TOUCHSCREEN_SURFACE3_SPI is not set
+# CONFIG_TOUCHSCREEN_SX8654 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_ZET6223 is not set
+# CONFIG_TOUCHSCREEN_ZFORCE is not set
+# CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
+# CONFIG_TOUCHSCREEN_IQS5XX is not set
+# CONFIG_TOUCHSCREEN_ZINITIX is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATMEL_CAPTOUCH is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+# CONFIG_INPUT_GPIO_VIBRA is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_REGULATOR_HAPTIC is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_PWM_VIBRA is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_IQS269A is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_DRV260X_HAPTICS is not set
+# CONFIG_INPUT_DRV2665_HAPTICS is not set
+# CONFIG_INPUT_DRV2667_HAPTICS is not set
+# CONFIG_INPUT_HISI_POWERKEY is not set
+# CONFIG_INPUT_SC27XX_VIBRA is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_OLPC_APSP is not set
+# CONFIG_SERIO_SUN4I_PS2 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+# end of Hardware I/O ports
+# end of Input device support
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_LDISC_AUTOLOAD=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_16550A_VARIANTS=y
+# CONFIG_SERIAL_8250_FINTEK is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_NR_UARTS=6
+CONFIG_SERIAL_8250_RUNTIME_UARTS=6
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_ASPEED_VUART is not set
+CONFIG_SERIAL_8250_DWLIB=y
+CONFIG_SERIAL_8250_DW=y
+# CONFIG_SERIAL_8250_RT288X is not set
+# CONFIG_SERIAL_8250_LPC18XX is not set
+# CONFIG_SERIAL_8250_UNIPHIER is not set
+# CONFIG_SERIAL_8250_INGENIC is not set
+CONFIG_SERIAL_8250_TEGRA=y
+CONFIG_SERIAL_OF_PLATFORM=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_RISCV_SBI is not set
+# CONFIG_SERIAL_ATMEL is not set
+# CONFIG_SERIAL_CLPS711X is not set
+# CONFIG_SERIAL_SAMSUNG is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_IMX is not set
+# CONFIG_SERIAL_IMX_EARLYCON is not set
+# CONFIG_SERIAL_UARTLITE is not set
+# CONFIG_SERIAL_SH_SCI is not set
+# CONFIG_SERIAL_HS_LPC32XX is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_MSM_GENI_EARLY_CONSOLE is not set
+CONFIG_SERIAL_SIFIVE=y
+CONFIG_SERIAL_SIFIVE_CONSOLE=y
+# CONFIG_SERIAL_LANTIQ is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_MXS_AUART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_MPS2_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_SERIAL_SPRD is not set
+# CONFIG_SERIAL_STM32 is not set
+# CONFIG_SERIAL_MVEBU_UART is not set
+# CONFIG_SERIAL_OWL is not set
+# CONFIG_SERIAL_RDA is not set
+# CONFIG_SERIAL_MILBEAUT_USIO is not set
+# end of Serial drivers
+
+CONFIG_SERIAL_MCTRL_GPIO=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_NULL_TTY is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_HVC_DRIVER=y
+# CONFIG_HVC_RISCV_SBI is not set
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+CONFIG_VIRTIO_CONSOLE=y
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_ASPEED_KCS_IPMI_BMC is not set
+# CONFIG_NPCM7XX_KCS_IPMI_BMC is not set
+# CONFIG_ASPEED_BT_IPMI_BMC is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_BA431 is not set
+CONFIG_HW_RANDOM_OMAP=y
+CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_HW_RANDOM_IMX_RNGC=y
+CONFIG_HW_RANDOM_STM32=y
+CONFIG_HW_RANDOM_MESON=y
+CONFIG_HW_RANDOM_MTK=y
+CONFIG_HW_RANDOM_EXYNOS=y
+CONFIG_HW_RANDOM_NPCM=y
+CONFIG_HW_RANDOM_KEYSTONE=y
+# CONFIG_HW_RANDOM_CCTRNG is not set
+# CONFIG_HW_RANDOM_XIPHERA is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+# end of Character devices
+
+# CONFIG_RANDOM_TRUST_BOOTLOADER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_HIX5HD2 is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_ALTERA is not set
+# CONFIG_I2C_ASPEED is not set
+# CONFIG_I2C_AT91 is not set
+# CONFIG_I2C_AXXIA is not set
+# CONFIG_I2C_BCM2835 is not set
+# CONFIG_I2C_BCM_IPROC is not set
+# CONFIG_I2C_BCM_KONA is not set
+CONFIG_I2C_BRCMSTB=y
+# CONFIG_I2C_CADENCE is not set
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DAVINCI is not set
+CONFIG_I2C_DESIGNWARE_CORE=y
+# CONFIG_I2C_DESIGNWARE_SLAVE is not set
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+# CONFIG_I2C_DESIGNWARE_ICE is not set
+# CONFIG_I2C_DIGICOLOR is not set
+# CONFIG_I2C_EFM32 is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_EXYNOS5 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_HIGHLANDER is not set
+# CONFIG_I2C_IMG is not set
+# CONFIG_I2C_IMX_LPI2C is not set
+# CONFIG_I2C_IOP3XX is not set
+# CONFIG_I2C_JZ4780 is not set
+# CONFIG_I2C_LPC2K is not set
+# CONFIG_I2C_MESON is not set
+# CONFIG_I2C_MT65XX is not set
+# CONFIG_I2C_MT7621 is not set
+# CONFIG_I2C_MV64XXX is not set
+# CONFIG_I2C_MXS is not set
+# CONFIG_I2C_NPCM7XX is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_OMAP is not set
+# CONFIG_I2C_OWL is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PMCMSP is not set
+# CONFIG_I2C_PNX is not set
+# CONFIG_I2C_PXA is not set
+# CONFIG_I2C_QCOM_CCI is not set
+# CONFIG_I2C_QUP is not set
+# CONFIG_I2C_RIIC is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_S3C2410 is not set
+# CONFIG_I2C_SH_MOBILE is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_SIRF is not set
+# CONFIG_I2C_SPRD is not set
+# CONFIG_I2C_ST is not set
+# CONFIG_I2C_STM32F4 is not set
+# CONFIG_I2C_STM32F7 is not set
+# CONFIG_I2C_STU300 is not set
+# CONFIG_I2C_SUN6I_P2WI is not set
+# CONFIG_I2C_SYNQUACER is not set
+# CONFIG_I2C_TEGRA is not set
+# CONFIG_I2C_TEGRA_BPMP is not set
+# CONFIG_I2C_UNIPHIER is not set
+# CONFIG_I2C_UNIPHIER_F is not set
+# CONFIG_I2C_VERSATILE is not set
+# CONFIG_I2C_WMT is not set
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I2C_XLR is not set
+# CONFIG_I2C_XLP9XX is not set
+# CONFIG_I2C_RCAR is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_MLXCPLD is not set
+# end of I2C Hardware Bus support
+
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# end of I2C support
+
+# CONFIG_I3C is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AR934X is not set
+# CONFIG_SPI_ATH79 is not set
+# CONFIG_SPI_ARMADA_3700 is not set
+# CONFIG_SPI_ATMEL is not set
+# CONFIG_SPI_ATMEL_QUADSPI is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BCM2835 is not set
+# CONFIG_SPI_BCM2835AUX is not set
+# CONFIG_SPI_BCM63XX is not set
+# CONFIG_SPI_BCM63XX_HSSPI is not set
+# CONFIG_SPI_BCM_QSPI is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_CADENCE_QUADSPI is not set
+# CONFIG_SPI_CLPS711X is not set
+# CONFIG_SPI_DW_QUAD is not set
+CONFIG_SPI_DESIGNWARE=y
+# CONFIG_SPI_DW_DMA is not set
+CONFIG_SPI_DW_MMIO=y
+# CONFIG_SPI_DW_BT1 is not set
+# CONFIG_SPI_EP93XX is not set
+# CONFIG_SPI_FSL_LPSPI is not set
+# CONFIG_SPI_FSL_QUADSPI is not set
+# CONFIG_SPI_HISI_SFC_V3XX is not set
+# CONFIG_SPI_NXP_FLEXSPI is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_IMG_SPFI is not set
+# CONFIG_SPI_IMX is not set
+# CONFIG_SPI_JCORE is not set
+# CONFIG_SPI_LP8841_RTC is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_FSL_DSPI is not set
+# CONFIG_SPI_MESON_SPICC is not set
+# CONFIG_SPI_MESON_SPIFC is not set
+# CONFIG_SPI_MT65XX is not set
+# CONFIG_SPI_MT7621 is not set
+# CONFIG_SPI_MTK_NOR is not set
+# CONFIG_SPI_NPCM_FIU is not set
+# CONFIG_SPI_NPCM_PSPI is not set
+# CONFIG_SPI_LANTIQ_SSC is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_OMAP24XX is not set
+# CONFIG_SPI_TI_QSPI is not set
+# CONFIG_SPI_OMAP_100K is not set
+# CONFIG_SPI_ORION is not set
+# CONFIG_SPI_PIC32 is not set
+# CONFIG_SPI_PIC32_SQI is not set
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_RSPI is not set
+# CONFIG_SPI_QUP is not set
+# CONFIG_SPI_S3C64XX is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SH_MSIOF is not set
+# CONFIG_SPI_SH is not set
+# CONFIG_SPI_SH_HSPI is not set
+# CONFIG_SPI_SIFIVE is not set
+# CONFIG_SPI_SPRD is not set
+# CONFIG_SPI_SPRD_ADI is not set
+# CONFIG_SPI_STM32 is not set
+# CONFIG_SPI_STM32_QSPI is not set
+# CONFIG_SPI_ST_SSC4 is not set
+# CONFIG_SPI_SUN4I is not set
+# CONFIG_SPI_SUN6I is not set
+# CONFIG_SPI_SYNQUACER is not set
+# CONFIG_SPI_MXIC is not set
+# CONFIG_SPI_TEGRA114 is not set
+# CONFIG_SPI_TEGRA20_SFLASH is not set
+# CONFIG_SPI_TEGRA20_SLINK is not set
+# CONFIG_SPI_TXX9 is not set
+# CONFIG_SPI_UNIPHIER is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_XLP is not set
+# CONFIG_SPI_XTENSA_XTFPGA is not set
+# CONFIG_SPI_ZYNQ_QSPI is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+# CONFIG_SPI_AMD is not set
+
+#
+# SPI Multiplexer support
+#
+# CONFIG_SPI_MUX is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+# CONFIG_PPS is not set
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# end of PTP clock support
+
+CONFIG_PINCTRL=y
+CONFIG_GENERIC_PINCTRL_GROUPS=y
+CONFIG_PINMUX=y
+CONFIG_GENERIC_PINMUX_FUNCTIONS=y
+CONFIG_PINCONF=y
+CONFIG_GENERIC_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AT91PIO4 is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_BM1880 is not set
+# CONFIG_PINCTRL_DA850_PUPD is not set
+# CONFIG_PINCTRL_LPC18XX is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_SX150X is not set
+# CONFIG_PINCTRL_STMFX is not set
+# CONFIG_PINCTRL_INGENIC is not set
+# CONFIG_PINCTRL_OCELOT is not set
+# CONFIG_PINCTRL_OWL is not set
+# CONFIG_PINCTRL_ASPEED_G4 is not set
+# CONFIG_PINCTRL_ASPEED_G5 is not set
+# CONFIG_PINCTRL_ASPEED_G6 is not set
+# CONFIG_PINCTRL_BCM281XX is not set
+# CONFIG_PINCTRL_BCM2835 is not set
+# CONFIG_PINCTRL_IPROC_GPIO is not set
+# CONFIG_PINCTRL_CYGNUS_MUX is not set
+# CONFIG_PINCTRL_NS is not set
+# CONFIG_PINCTRL_NSP_GPIO is not set
+# CONFIG_PINCTRL_NS2_MUX is not set
+# CONFIG_PINCTRL_NSP_MUX is not set
+# CONFIG_PINCTRL_AS370 is not set
+# CONFIG_PINCTRL_BERLIN_BG4CT is not set
+# CONFIG_PINCTRL_NPCM7XX is not set
+# CONFIG_PINCTRL_PXA25X is not set
+# CONFIG_PINCTRL_PXA27X is not set
+# CONFIG_PINCTRL_APQ8064 is not set
+# CONFIG_PINCTRL_APQ8084 is not set
+# CONFIG_PINCTRL_IPQ4019 is not set
+# CONFIG_PINCTRL_IPQ8064 is not set
+# CONFIG_PINCTRL_IPQ8074 is not set
+# CONFIG_PINCTRL_IPQ6018 is not set
+# CONFIG_PINCTRL_MSM8226 is not set
+# CONFIG_PINCTRL_MSM8660 is not set
+# CONFIG_PINCTRL_MSM8960 is not set
+# CONFIG_PINCTRL_MDM9615 is not set
+# CONFIG_PINCTRL_MSM8X74 is not set
+# CONFIG_PINCTRL_MSM8916 is not set
+# CONFIG_PINCTRL_MSM8976 is not set
+# CONFIG_PINCTRL_MSM8994 is not set
+# CONFIG_PINCTRL_MSM8996 is not set
+# CONFIG_PINCTRL_MSM8998 is not set
+# CONFIG_PINCTRL_QCS404 is not set
+# CONFIG_PINCTRL_QCOM_SSBI_PMIC is not set
+# CONFIG_PINCTRL_SC7180 is not set
+# CONFIG_PINCTRL_SDM660 is not set
+# CONFIG_PINCTRL_SDM845 is not set
+# CONFIG_PINCTRL_SM8150 is not set
+# CONFIG_PINCTRL_SM8250 is not set
+
+#
+# Renesas pinctrl drivers
+#
+# CONFIG_PINCTRL_RENESAS is not set
+# CONFIG_PINCTRL_PFC_EMEV2 is not set
+# CONFIG_PINCTRL_PFC_R8A77995 is not set
+# CONFIG_PINCTRL_PFC_R8A7794 is not set
+# CONFIG_PINCTRL_PFC_R8A77990 is not set
+# CONFIG_PINCTRL_PFC_R8A7779 is not set
+# CONFIG_PINCTRL_PFC_R8A7790 is not set
+# CONFIG_PINCTRL_PFC_R8A77950 is not set
+# CONFIG_PINCTRL_PFC_R8A77951 is not set
+# CONFIG_PINCTRL_PFC_R8A7778 is not set
+# CONFIG_PINCTRL_PFC_R8A7793 is not set
+# CONFIG_PINCTRL_PFC_R8A7791 is not set
+# CONFIG_PINCTRL_PFC_R8A77965 is not set
+# CONFIG_PINCTRL_PFC_R8A77960 is not set
+# CONFIG_PINCTRL_PFC_R8A77961 is not set
+# CONFIG_PINCTRL_PFC_R8A7792 is not set
+# CONFIG_PINCTRL_PFC_R8A77980 is not set
+# CONFIG_PINCTRL_PFC_R8A77970 is not set
+# CONFIG_PINCTRL_PFC_R8A7740 is not set
+# CONFIG_PINCTRL_PFC_R8A73A4 is not set
+# CONFIG_PINCTRL_RZA1 is not set
+# CONFIG_PINCTRL_RZA2 is not set
+# CONFIG_PINCTRL_PFC_R8A77470 is not set
+# CONFIG_PINCTRL_PFC_R8A7745 is not set
+# CONFIG_PINCTRL_PFC_R8A7742 is not set
+# CONFIG_PINCTRL_PFC_R8A7743 is not set
+# CONFIG_PINCTRL_PFC_R8A7744 is not set
+# CONFIG_PINCTRL_PFC_R8A774C0 is not set
+# CONFIG_PINCTRL_PFC_R8A774E1 is not set
+# CONFIG_PINCTRL_PFC_R8A774A1 is not set
+# CONFIG_PINCTRL_PFC_R8A774B1 is not set
+# CONFIG_PINCTRL_RZN1 is not set
+# CONFIG_PINCTRL_PFC_SH7203 is not set
+# CONFIG_PINCTRL_PFC_SH7264 is not set
+# CONFIG_PINCTRL_PFC_SH7269 is not set
+# CONFIG_PINCTRL_PFC_SH7720 is not set
+# CONFIG_PINCTRL_PFC_SH7722 is not set
+# CONFIG_PINCTRL_PFC_SH7734 is not set
+# CONFIG_PINCTRL_PFC_SH7757 is not set
+# CONFIG_PINCTRL_PFC_SH7785 is not set
+# CONFIG_PINCTRL_PFC_SH7786 is not set
+# CONFIG_PINCTRL_PFC_SH73A0 is not set
+# CONFIG_PINCTRL_PFC_SH7723 is not set
+# CONFIG_PINCTRL_PFC_SH7724 is not set
+# CONFIG_PINCTRL_PFC_SHX3 is not set
+# end of Renesas pinctrl drivers
+
+# CONFIG_PINCTRL_EXYNOS is not set
+# CONFIG_PINCTRL_S3C24XX is not set
+# CONFIG_PINCTRL_S3C64XX is not set
+# CONFIG_PINCTRL_SPRD_SC9860 is not set
+# CONFIG_PINCTRL_STM32F429 is not set
+# CONFIG_PINCTRL_STM32F469 is not set
+# CONFIG_PINCTRL_STM32F746 is not set
+# CONFIG_PINCTRL_STM32F769 is not set
+# CONFIG_PINCTRL_STM32H743 is not set
+# CONFIG_PINCTRL_STM32MP157 is not set
+# CONFIG_PINCTRL_TI_IODELAY is not set
+CONFIG_PINCTRL_UNIPHIER=y
+# CONFIG_PINCTRL_UNIPHIER_LD4 is not set
+# CONFIG_PINCTRL_UNIPHIER_PRO4 is not set
+# CONFIG_PINCTRL_UNIPHIER_SLD8 is not set
+# CONFIG_PINCTRL_UNIPHIER_PRO5 is not set
+# CONFIG_PINCTRL_UNIPHIER_PXS2 is not set
+# CONFIG_PINCTRL_UNIPHIER_LD6B is not set
+# CONFIG_PINCTRL_UNIPHIER_LD11 is not set
+# CONFIG_PINCTRL_UNIPHIER_LD20 is not set
+# CONFIG_PINCTRL_UNIPHIER_PXS3 is not set
+
+#
+# MediaTek pinctrl drivers
+#
+# CONFIG_EINT_MTK is not set
+# CONFIG_PINCTRL_MT2701 is not set
+# CONFIG_PINCTRL_MT7623 is not set
+# CONFIG_PINCTRL_MT7629 is not set
+# CONFIG_PINCTRL_MT8135 is not set
+# CONFIG_PINCTRL_MT8127 is not set
+# CONFIG_PINCTRL_MT2712 is not set
+# CONFIG_PINCTRL_MT6765 is not set
+# CONFIG_PINCTRL_MT6779 is not set
+# CONFIG_PINCTRL_MT6797 is not set
+# CONFIG_PINCTRL_MT7622 is not set
+# CONFIG_PINCTRL_MT8167 is not set
+# CONFIG_PINCTRL_MT8173 is not set
+# CONFIG_PINCTRL_MT8183 is not set
+# CONFIG_PINCTRL_MT8192 is not set
+# CONFIG_PINCTRL_MT8516 is not set
+# CONFIG_PINCTRL_MT6397 is not set
+# end of MediaTek pinctrl drivers
+
+# CONFIG_PINCTRL_TMPV7700 is not set
+CONFIG_PINCTRL_LIGHT=y
+# CONFIG_PINCTRL_EQUILIBRIUM is not set
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_CDEV=y
+CONFIG_GPIO_CDEV_V1=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_ASPEED is not set
+# CONFIG_GPIO_ASPEED_SGPIO is not set
+# CONFIG_GPIO_ATH79 is not set
+# CONFIG_GPIO_RASPBERRYPI_EXP is not set
+# CONFIG_GPIO_BCM_KONA is not set
+# CONFIG_GPIO_BCM_XGS_IPROC is not set
+# CONFIG_GPIO_BRCMSTB is not set
+# CONFIG_GPIO_CADENCE is not set
+# CONFIG_GPIO_CLPS711X is not set
+CONFIG_GPIO_DWAPB=y
+# CONFIG_GPIO_EIC_SPRD is not set
+# CONFIG_GPIO_EM is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_IOP is not set
+# CONFIG_GPIO_LOGICVC is not set
+# CONFIG_GPIO_LPC18XX is not set
+# CONFIG_GPIO_LPC32XX is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_MT7621 is not set
+# CONFIG_GPIO_MXC is not set
+# CONFIG_GPIO_MXS is not set
+# CONFIG_GPIO_PMIC_EIC_SPRD is not set
+# CONFIG_GPIO_PXA is not set
+# CONFIG_GPIO_RCAR is not set
+# CONFIG_GPIO_RDA is not set
+# CONFIG_GPIO_SAMA5D2_PIOBU is not set
+# CONFIG_GPIO_SIFIVE is not set
+# CONFIG_GPIO_SNPS_CREG is not set
+# CONFIG_GPIO_SPRD is not set
+# CONFIG_GPIO_STP_XWAY is not set
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_TEGRA is not set
+# CONFIG_GPIO_TEGRA186 is not set
+# CONFIG_GPIO_TS4800 is not set
+# CONFIG_GPIO_UNIPHIER is not set
+# CONFIG_GPIO_XGENE_SB is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_XLP is not set
+# CONFIG_GPIO_ZX is not set
+# CONFIG_GPIO_AMD_FCH is not set
+# end of Memory mapped GPIO drivers
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_GW_PLD is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
+# CONFIG_GPIO_PCA9570 is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+# CONFIG_GPIO_TS4900 is not set
+# end of I2C GPIO expanders
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_GPIO_SL28CPLD is not set
+# CONFIG_GPIO_TQMX86 is not set
+# end of MFD GPIO expanders
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+# end of SPI GPIO expanders
+
+#
+# USB GPIO expanders
+#
+# end of USB GPIO expanders
+
+# CONFIG_GPIO_AGGREGATOR is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_RESET is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+CONFIG_POWER_SUPPLY_HWMON=y
+# CONFIG_PDA_POWER is not set
+# CONFIG_GENERIC_ADC_BATTERY is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_BATTERY_ACT8945A is not set
+# CONFIG_BATTERY_CW2015 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_LEGO_EV3 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_LT3651 is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_QCOM_SMBB is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24190 is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ2515X is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_BQ25980 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_BATTERY_RT5033 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_CHARGER_SC2731 is not set
+# CONFIG_FUEL_GAUGE_SC27XX is not set
+# CONFIG_CHARGER_UCS1002 is not set
+# CONFIG_CHARGER_BD99954 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM1177 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7310 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_AS370 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_AXI_FAN_CONTROL is not set
+# CONFIG_SENSORS_ASPEED is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_BT1_PVT is not set
+# CONFIG_SENSORS_CORSAIR_CPRO is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_SPARX5 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FTSTEUTATES is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IIO_HWMON is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_POWR1220 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC2947_I2C is not set
+# CONFIG_SENSORS_LTC2947_SPI is not set
+# CONFIG_SENSORS_LTC2990 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX31722 is not set
+# CONFIG_SENSORS_MAX31730 is not set
+# CONFIG_SENSORS_MAX6621 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_TC654 is not set
+# CONFIG_SENSORS_MR75203 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NCT7802 is not set
+# CONFIG_SENSORS_NCT7904 is not set
+# CONFIG_SENSORS_NPCM7XX is not set
+# CONFIG_SENSORS_NSA320 is not set
+# CONFIG_SENSORS_OCC_P8_I2C is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+CONFIG_SENSORS_PWM_FAN=y
+# CONFIG_SENSORS_RASPBERRYPI_HWMON is not set
+# CONFIG_SENSORS_SL28CPLD is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SHT3x is not set
+# CONFIG_SENSORS_SHTC1 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_STTS751 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_INA3221 is not set
+# CONFIG_SENSORS_TC74 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP103 is not set
+# CONFIG_SENSORS_TMP108 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_TMP513 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83773G is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED=y
+CONFIG_WATCHDOG_OPEN_TIMEOUT=0
+# CONFIG_WATCHDOG_SYSFS is not set
+
+#
+# Watchdog Pretimeout Governors
+#
+# CONFIG_WATCHDOG_PRETIMEOUT_GOV is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_DA9052_WATCHDOG is not set
+# CONFIG_DA9055_WATCHDOG is not set
+# CONFIG_DA9063_WATCHDOG is not set
+# CONFIG_DA9062_WATCHDOG is not set
+# CONFIG_GPIO_WATCHDOG is not set
+# CONFIG_MENF21BMC_WATCHDOG is not set
+# CONFIG_TANGOX_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_ZIIRAVE_WATCHDOG is not set
+# CONFIG_SL28CPLD_WATCHDOG is not set
+# CONFIG_ARMADA_37XX_WATCHDOG is not set
+# CONFIG_ASM9260_WATCHDOG is not set
+# CONFIG_AT91RM9200_WATCHDOG is not set
+# CONFIG_AT91SAM9X_WATCHDOG is not set
+# CONFIG_SAMA5D4_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_FTWDT010_WATCHDOG is not set
+# CONFIG_S3C2410_WATCHDOG is not set
+CONFIG_DW_WATCHDOG=y
+# CONFIG_EP93XX_WATCHDOG is not set
+# CONFIG_OMAP_WATCHDOG is not set
+# CONFIG_PNX4008_WATCHDOG is not set
+# CONFIG_DAVINCI_WATCHDOG is not set
+# CONFIG_K3_RTI_WATCHDOG is not set
+# CONFIG_RN5T618_WATCHDOG is not set
+# CONFIG_SUNXI_WATCHDOG is not set
+# CONFIG_NPCM7XX_WATCHDOG is not set
+# CONFIG_STMP3XXX_RTC_WATCHDOG is not set
+# CONFIG_TS4800_WATCHDOG is not set
+# CONFIG_TS72XX_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_MAX77620_WATCHDOG is not set
+# CONFIG_IMX2_WDT is not set
+CONFIG_ICE_WDT=y
+# CONFIG_IMX7ULP_WDT is not set
+# CONFIG_MOXART_WDT is not set
+CONFIG_SIRFSOC_WATCHDOG=y
+# CONFIG_ST_LPC_WATCHDOG is not set
+# CONFIG_TEGRA_WATCHDOG is not set
+# CONFIG_QCOM_WDT is not set
+# CONFIG_MESON_GXBB_WATCHDOG is not set
+# CONFIG_MESON_WATCHDOG is not set
+# CONFIG_MEDIATEK_WATCHDOG is not set
+# CONFIG_DIGICOLOR_WATCHDOG is not set
+# CONFIG_LPC18XX_WATCHDOG is not set
+# CONFIG_ATLAS7_WATCHDOG is not set
+# CONFIG_RENESAS_WDT is not set
+# CONFIG_RENESAS_RZAWDT is not set
+# CONFIG_ASPEED_WATCHDOG is not set
+# CONFIG_UNIPHIER_WATCHDOG is not set
+# CONFIG_RTD119X_WATCHDOG is not set
+# CONFIG_SPRD_WATCHDOG is not set
+# CONFIG_VISCONTI_WATCHDOG is not set
+CONFIG_LIGHT_PMIC_WATCHDOG=y
+# CONFIG_SC520_WDT is not set
+# CONFIG_BCM47XX_WDT is not set
+# CONFIG_BCM2835_WDT is not set
+# CONFIG_BCM_KONA_WDT is not set
+# CONFIG_BCM7038_WDT is not set
+# CONFIG_IMGPDC_WDT is not set
+# CONFIG_MPC5200_WDT is not set
+# CONFIG_MV64X60_WDT is not set
+# CONFIG_MEN_A21_WDT is not set
+# CONFIG_UML_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_SUN4I_GPADC is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_AT91_USART is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_ENE_KB3930 is not set
+# CONFIG_MFD_EXYNOS_LPASS is not set
+# CONFIG_MFD_GATEWORKS_GSC is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_MP2629 is not set
+# CONFIG_MFD_MXS_LRADC is not set
+# CONFIG_MFD_MX25_TSADC is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_MFD_HI655X_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_IQS62X is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77650 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6360 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SL28CPLD is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SC27XX_PMIC is not set
+CONFIG_ABX500_CORE=y
+# CONFIG_AB3100_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SUN6I_PRCM=y
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TQMX86 is not set
+# CONFIG_MFD_LOCHNAGAR is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_STW481X is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_MFD_ROHM_BD70528 is not set
+# CONFIG_MFD_ROHM_BD71828 is not set
+# CONFIG_MFD_STM32_LPTIMER is not set
+# CONFIG_MFD_STM32_TIMERS is not set
+# CONFIG_MFD_STPMIC1 is not set
+# CONFIG_MFD_STMFX is not set
+# CONFIG_MFD_KHADAS_MCU is not set
+# CONFIG_MFD_INTEL_M10_BMC is not set
+# end of Multifunction device drivers
+
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_88PG86X is not set
+# CONFIG_REGULATOR_ACT8865 is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ANATOP is not set
+# CONFIG_REGULATOR_DA9210 is not set
+# CONFIG_REGULATOR_DA9211 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_FAN53880 is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_ISL9305 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_LTC3589 is not set
+# CONFIG_REGULATOR_LTC3676 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX77620 is not set
+# CONFIG_REGULATOR_MAX77650 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8907 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX77686 is not set
+# CONFIG_REGULATOR_MAX77693 is not set
+# CONFIG_REGULATOR_MAX77802 is not set
+# CONFIG_REGULATOR_MAX77826 is not set
+# CONFIG_REGULATOR_MCP16502 is not set
+# CONFIG_REGULATOR_MP5416 is not set
+# CONFIG_REGULATOR_MP8859 is not set
+# CONFIG_REGULATOR_MP886X is not set
+# CONFIG_REGULATOR_MPQ7920 is not set
+# CONFIG_REGULATOR_MT6311 is not set
+# CONFIG_REGULATOR_PBIAS is not set
+# CONFIG_REGULATOR_PCA9450 is not set
+# CONFIG_REGULATOR_PFUZE100 is not set
+# CONFIG_REGULATOR_PV88060 is not set
+# CONFIG_REGULATOR_PV88080 is not set
+# CONFIG_REGULATOR_PV88090 is not set
+# CONFIG_REGULATOR_PWM is not set
+# CONFIG_REGULATOR_QCOM_RPMH is not set
+# CONFIG_REGULATOR_QCOM_SPMI is not set
+# CONFIG_REGULATOR_QCOM_USB_VBUS is not set
+# CONFIG_REGULATOR_RASPBERRYPI_TOUCHSCREEN_ATTINY is not set
+# CONFIG_REGULATOR_RT4801 is not set
+# CONFIG_REGULATOR_RTMV20 is not set
+# CONFIG_REGULATOR_S2MPA01 is not set
+# CONFIG_REGULATOR_S2MPS11 is not set
+# CONFIG_REGULATOR_S5M8767 is not set
+# CONFIG_REGULATOR_SC2731 is not set
+# CONFIG_REGULATOR_SLG51000 is not set
+# CONFIG_REGULATOR_STM32_BOOSTER is not set
+# CONFIG_REGULATOR_STM32_VREFBUF is not set
+# CONFIG_REGULATOR_STM32_PWR is not set
+# CONFIG_REGULATOR_STW481X_VMMC is not set
+# CONFIG_REGULATOR_SY8106A is not set
+# CONFIG_REGULATOR_SY8824X is not set
+# CONFIG_REGULATOR_SY8827N is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS65132 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_REGULATOR_UNIPHIER is not set
+# CONFIG_REGULATOR_VCTRL is not set
+# CONFIG_REGULATOR_QCOM_LABIBB is not set
+CONFIG_REGULATOR_LIGHT_AON=y
+# CONFIG_RC_CORE is not set
+CONFIG_MEDIA_CEC_SUPPORT=y
+# CONFIG_CEC_CH7322 is not set
+# CONFIG_CEC_MESON_AO is not set
+# CONFIG_CEC_MESON_G12A_AO is not set
+# CONFIG_CEC_GPIO is not set
+# CONFIG_CEC_SAMSUNG_S5P is not set
+# CONFIG_CEC_STI is not set
+# CONFIG_CEC_STM32 is not set
+# CONFIG_CEC_TEGRA is not set
+# CONFIG_USB_PULSE8_CEC is not set
+# CONFIG_USB_RAINSHADOW_CEC is not set
+CONFIG_MEDIA_SUPPORT=y
+# CONFIG_MEDIA_SUPPORT_FILTER is not set
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+
+#
+# Media device types
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=y
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_SDR_SUPPORT=y
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+CONFIG_MEDIA_TEST_SUPPORT=y
+# end of Media device types
+
+#
+# Media core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_DVB_CORE=y
+# end of Media core support
+
+#
+# Video4Linux options
+#
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L2_I2C=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+# end of Video4Linux options
+
+#
+# Media controller options
+#
+# CONFIG_MEDIA_CONTROLLER_DVB is not set
+# end of Media controller options
+
+#
+# Digital TV options
+#
+# CONFIG_DVB_MMAP is not set
+CONFIG_DVB_NET=y
+CONFIG_DVB_MAX_ADAPTERS=16
+CONFIG_DVB_DYNAMIC_MINORS=y
+# CONFIG_DVB_DEMUX_SECTION_LOSS_LOG is not set
+# CONFIG_DVB_ULE_DEBUG is not set
+# end of Digital TV options
+
+#
+# Media drivers
+#
+CONFIG_MEDIA_USB_SUPPORT=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_DTCS033 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STK1135 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TOUPTEK is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_VIDEO_USBTV is not set
+
+#
+# Analog TV USB devices
+#
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_STK1160_COMMON is not set
+# CONFIG_VIDEO_GO7007 is not set
+
+#
+# Analog/digital TV USB devices
+#
+# CONFIG_VIDEO_AU0828 is not set
+
+#
+# Digital TV USB devices
+#
+# CONFIG_DVB_USB_V2 is not set
+# CONFIG_SMS_USB_DRV is not set
+# CONFIG_DVB_B2C2_FLEXCOP_USB is not set
+# CONFIG_DVB_AS102 is not set
+
+#
+# Webcam, TV (analog/digital) USB devices
+#
+# CONFIG_VIDEO_EM28XX is not set
+
+#
+# Software defined radio USB devices
+#
+# CONFIG_USB_AIRSPY is not set
+# CONFIG_USB_HACKRF is not set
+# CONFIG_USB_MSI2500 is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_RADIO_SI470X is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_RADIO_SHARK is not set
+# CONFIG_RADIO_SHARK2 is not set
+# CONFIG_USB_KEENE is not set
+# CONFIG_USB_RAREMONO is not set
+# CONFIG_USB_MA901 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_SAA7706H is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_RADIO_WL1273 is not set
+# CONFIG_V4L_RADIO_ISA_DRIVERS is not set
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_V4L2=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_VMALLOC=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+# CONFIG_VIDEO_MMP_CAMERA is not set
+# CONFIG_VIDEO_CADENCE is not set
+# CONFIG_VIDEO_DAVINCI_VPIF_DISPLAY is not set
+# CONFIG_VIDEO_DAVINCI_VPIF_CAPTURE is not set
+# CONFIG_VIDEO_DM6446_CCDC is not set
+# CONFIG_VIDEO_DM355_CCDC is not set
+# CONFIG_VIDEO_DM365_ISIF is not set
+# CONFIG_VIDEO_DAVINCI_VPBE_DISPLAY is not set
+# CONFIG_VIDEO_OMAP2_VOUT is not set
+CONFIG_VIDEO_ASPEED=y
+# CONFIG_VIDEO_SH_VOU is not set
+CONFIG_VIDEO_VIU=y
+# CONFIG_VIDEO_MUX is not set
+# CONFIG_VIDEO_OMAP3 is not set
+# CONFIG_VIDEO_PXA27x is not set
+# CONFIG_VIDEO_QCOM_CAMSS is not set
+# CONFIG_VIDEO_S3C_CAMIF is not set
+# CONFIG_VIDEO_STM32_DCMI is not set
+# CONFIG_VIDEO_RENESAS_CEU is not set
+# CONFIG_VIDEO_SAMSUNG_EXYNOS4_IS is not set
+# CONFIG_VIDEO_AM437X_VPFE is not set
+# CONFIG_VIDEO_XILINX is not set
+# CONFIG_VIDEO_RCAR_CSI2 is not set
+# CONFIG_VIDEO_RCAR_VIN is not set
+# CONFIG_VIDEO_ATMEL_ISC is not set
+# CONFIG_VIDEO_ATMEL_ISI is not set
+# CONFIG_VIDEO_SUN4I_CSI is not set
+# CONFIG_VIDEO_SUN6I_CSI is not set
+# CONFIG_VIDEO_TI_CAL is not set
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+# CONFIG_VIDEO_CODA is not set
+# CONFIG_VIDEO_IMX_PXP is not set
+# CONFIG_VIDEO_MEDIATEK_JPEG is not set
+# CONFIG_VIDEO_MEDIATEK_VPU is not set
+# CONFIG_VIDEO_MEDIATEK_MDP is not set
+# CONFIG_VIDEO_MEM2MEM_DEINTERLACE is not set
+# CONFIG_VIDEO_SAMSUNG_S5P_G2D is not set
+# CONFIG_VIDEO_SAMSUNG_S5P_JPEG is not set
+# CONFIG_VIDEO_SAMSUNG_S5P_MFC is not set
+# CONFIG_VIDEO_MX2_EMMAPRP is not set
+# CONFIG_VIDEO_SAMSUNG_EXYNOS_GSC is not set
+# CONFIG_VIDEO_STI_BDISP is not set
+# CONFIG_VIDEO_STI_HVA is not set
+# CONFIG_VIDEO_STI_DELTA is not set
+# CONFIG_VIDEO_RENESAS_FDP1 is not set
+# CONFIG_VIDEO_RENESAS_JPU is not set
+# CONFIG_VIDEO_RENESAS_FCP is not set
+# CONFIG_VIDEO_RENESAS_VSP1 is not set
+# CONFIG_VIDEO_ROCKCHIP_RGA is not set
+# CONFIG_VIDEO_TI_VPE is not set
+# CONFIG_VIDEO_QCOM_VENUS is not set
+# CONFIG_VIDEO_SUN8I_DEINTERLACE is not set
+# CONFIG_VIDEO_SUN8I_ROTATE is not set
+# CONFIG_DVB_PLATFORM_DRIVERS is not set
+# CONFIG_SDR_PLATFORM_DRIVERS is not set
+
+#
+# MMC/SDIO DVB adapters
+#
+# CONFIG_SMS_SDIO_DRV is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+# CONFIG_DVB_TEST_DRIVERS is not set
+# end of Media drivers
+
+#
+# Media ancillary drivers
+#
+CONFIG_MEDIA_ATTACH=y
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA1997X is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS3308 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_UDA1342 is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+# CONFIG_VIDEO_SONY_BTF_MPX is not set
+# end of Audio decoders, processors and mixers
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+# end of RDS decoders
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_ADV7183 is not set
+# CONFIG_VIDEO_ADV748X is not set
+# CONFIG_VIDEO_ADV7604 is not set
+# CONFIG_VIDEO_ADV7842 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_ML86V7667 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_TC358743 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_TW2804 is not set
+# CONFIG_VIDEO_TW9903 is not set
+# CONFIG_VIDEO_TW9906 is not set
+# CONFIG_VIDEO_TW9910 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+# end of Video decoders
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_ADV7393 is not set
+# CONFIG_VIDEO_ADV7511 is not set
+# CONFIG_VIDEO_AD9389B is not set
+# CONFIG_VIDEO_AK881X is not set
+# CONFIG_VIDEO_THS8200 is not set
+# end of Video encoders
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# end of Video improvement chips
+
+#
+# Audio/Video compression chips
+#
+# CONFIG_VIDEO_SAA6752HS is not set
+# end of Audio/Video compression chips
+
+#
+# SDR tuner chips
+#
+# CONFIG_SDR_MAX2175 is not set
+# end of SDR tuner chips
+
+#
+# Miscellaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_I2C is not set
+# CONFIG_VIDEO_ST_MIPID02 is not set
+# end of Miscellaneous helper chips
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_HI556 is not set
+# CONFIG_VIDEO_IMX214 is not set
+# CONFIG_VIDEO_IMX219 is not set
+# CONFIG_VIDEO_IMX258 is not set
+# CONFIG_VIDEO_IMX274 is not set
+# CONFIG_VIDEO_IMX290 is not set
+# CONFIG_VIDEO_IMX319 is not set
+# CONFIG_VIDEO_IMX355 is not set
+# CONFIG_VIDEO_OV2640 is not set
+# CONFIG_VIDEO_OV2659 is not set
+# CONFIG_VIDEO_OV2680 is not set
+# CONFIG_VIDEO_OV2685 is not set
+# CONFIG_VIDEO_OV2740 is not set
+# CONFIG_VIDEO_OV5640 is not set
+# CONFIG_VIDEO_OV5645 is not set
+# CONFIG_VIDEO_OV5647 is not set
+# CONFIG_VIDEO_OV6650 is not set
+# CONFIG_VIDEO_OV5670 is not set
+# CONFIG_VIDEO_OV5675 is not set
+# CONFIG_VIDEO_OV5695 is not set
+# CONFIG_VIDEO_OV7251 is not set
+# CONFIG_VIDEO_OV772X is not set
+# CONFIG_VIDEO_OV7640 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_OV7740 is not set
+# CONFIG_VIDEO_OV8856 is not set
+# CONFIG_VIDEO_OV9640 is not set
+# CONFIG_VIDEO_OV9650 is not set
+# CONFIG_VIDEO_OV13858 is not set
+# CONFIG_VIDEO_VS6624 is not set
+# CONFIG_VIDEO_MT9M001 is not set
+# CONFIG_VIDEO_MT9M032 is not set
+# CONFIG_VIDEO_MT9M111 is not set
+# CONFIG_VIDEO_MT9P031 is not set
+# CONFIG_VIDEO_MT9T001 is not set
+# CONFIG_VIDEO_MT9T112 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_MT9V032 is not set
+# CONFIG_VIDEO_MT9V111 is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_VIDEO_M5MOLS is not set
+# CONFIG_VIDEO_RDACM20 is not set
+# CONFIG_VIDEO_RJ54N1 is not set
+# CONFIG_VIDEO_S5K6AA is not set
+# CONFIG_VIDEO_S5K6A3 is not set
+# CONFIG_VIDEO_S5K4ECGX is not set
+# CONFIG_VIDEO_S5K5BAF is not set
+# CONFIG_VIDEO_SMIAPP is not set
+# CONFIG_VIDEO_ET8EK8 is not set
+# CONFIG_VIDEO_S5C73M3 is not set
+# end of Camera sensor devices
+
+#
+# Lens drivers
+#
+# CONFIG_VIDEO_AD5820 is not set
+# CONFIG_VIDEO_AK7375 is not set
+# CONFIG_VIDEO_DW9714 is not set
+# CONFIG_VIDEO_DW9768 is not set
+# CONFIG_VIDEO_DW9807_VCM is not set
+# end of Lens drivers
+
+#
+# Flash devices
+#
+# CONFIG_VIDEO_ADP1653 is not set
+# CONFIG_VIDEO_LM3560 is not set
+# CONFIG_VIDEO_LM3646 is not set
+# end of Flash devices
+
+#
+# SPI helper chips
+#
+# CONFIG_VIDEO_GS1662 is not set
+# end of SPI helper chips
+
+#
+# Media SPI Adapters
+#
+CONFIG_CXD2880_SPI_DRV=m
+# end of Media SPI Adapters
+
+CONFIG_MEDIA_TUNER=y
+
+#
+# Customize TV tuners
+#
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA18250=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA827X=m
+CONFIG_MEDIA_TUNER_TDA18271=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MSI001=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_MT2060=m
+CONFIG_MEDIA_TUNER_MT2063=m
+CONFIG_MEDIA_TUNER_MT2266=m
+CONFIG_MEDIA_TUNER_MT2131=m
+CONFIG_MEDIA_TUNER_QT1010=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_XC4000=m
+CONFIG_MEDIA_TUNER_MXL5005S=m
+CONFIG_MEDIA_TUNER_MXL5007T=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_MEDIA_TUNER_MAX2165=m
+CONFIG_MEDIA_TUNER_TDA18218=m
+CONFIG_MEDIA_TUNER_FC0011=m
+CONFIG_MEDIA_TUNER_FC0012=m
+CONFIG_MEDIA_TUNER_FC0013=m
+CONFIG_MEDIA_TUNER_TDA18212=m
+CONFIG_MEDIA_TUNER_E4000=m
+CONFIG_MEDIA_TUNER_FC2580=m
+CONFIG_MEDIA_TUNER_M88RS6000T=m
+CONFIG_MEDIA_TUNER_TUA9001=m
+CONFIG_MEDIA_TUNER_SI2157=m
+CONFIG_MEDIA_TUNER_IT913X=m
+CONFIG_MEDIA_TUNER_R820T=m
+CONFIG_MEDIA_TUNER_MXL301RF=m
+CONFIG_MEDIA_TUNER_QM1D1C0042=m
+CONFIG_MEDIA_TUNER_QM1D1B0004=m
+# end of Customize TV tuners
+
+#
+# Customise DVB Frontends
+#
+
+#
+# Multistandard (satellite) frontends
+#
+CONFIG_DVB_STB0899=m
+CONFIG_DVB_STB6100=m
+CONFIG_DVB_STV090x=m
+CONFIG_DVB_STV0910=m
+CONFIG_DVB_STV6110x=m
+CONFIG_DVB_STV6111=m
+CONFIG_DVB_MXL5XX=m
+
+#
+# Multistandard (cable + terrestrial) frontends
+#
+CONFIG_DVB_DRXK=m
+CONFIG_DVB_TDA18271C2DD=m
+CONFIG_DVB_SI2165=m
+CONFIG_DVB_MN88472=m
+CONFIG_DVB_MN88473=m
+
+#
+# DVB-S (satellite) frontends
+#
+CONFIG_DVB_CX24110=m
+CONFIG_DVB_CX24123=m
+CONFIG_DVB_MT312=m
+CONFIG_DVB_ZL10036=m
+CONFIG_DVB_ZL10039=m
+CONFIG_DVB_S5H1420=m
+CONFIG_DVB_STV0288=m
+CONFIG_DVB_STB6000=m
+CONFIG_DVB_STV0299=m
+CONFIG_DVB_STV6110=m
+CONFIG_DVB_STV0900=m
+CONFIG_DVB_TDA8083=m
+CONFIG_DVB_TDA10086=m
+CONFIG_DVB_TDA8261=m
+CONFIG_DVB_VES1X93=m
+CONFIG_DVB_TUNER_ITD1000=m
+CONFIG_DVB_TUNER_CX24113=m
+CONFIG_DVB_TDA826X=m
+CONFIG_DVB_TUA6100=m
+CONFIG_DVB_CX24116=m
+CONFIG_DVB_CX24117=m
+CONFIG_DVB_CX24120=m
+CONFIG_DVB_SI21XX=m
+CONFIG_DVB_TS2020=m
+CONFIG_DVB_DS3000=m
+CONFIG_DVB_MB86A16=m
+CONFIG_DVB_TDA10071=m
+
+#
+# DVB-T (terrestrial) frontends
+#
+CONFIG_DVB_SP8870=m
+CONFIG_DVB_SP887X=m
+CONFIG_DVB_CX22700=m
+CONFIG_DVB_CX22702=m
+CONFIG_DVB_S5H1432=m
+CONFIG_DVB_DRXD=m
+CONFIG_DVB_L64781=m
+CONFIG_DVB_TDA1004X=m
+CONFIG_DVB_NXT6000=m
+CONFIG_DVB_MT352=m
+CONFIG_DVB_ZL10353=m
+CONFIG_DVB_DIB3000MB=m
+CONFIG_DVB_DIB3000MC=m
+CONFIG_DVB_DIB7000M=m
+CONFIG_DVB_DIB7000P=m
+CONFIG_DVB_DIB9000=m
+CONFIG_DVB_TDA10048=m
+CONFIG_DVB_EC100=m
+CONFIG_DVB_STV0367=m
+CONFIG_DVB_CXD2820R=m
+CONFIG_DVB_CXD2841ER=m
+CONFIG_DVB_ZD1301_DEMOD=m
+CONFIG_DVB_CXD2880=m
+
+#
+# DVB-C (cable) frontends
+#
+CONFIG_DVB_VES1820=m
+CONFIG_DVB_TDA10021=m
+CONFIG_DVB_TDA10023=m
+CONFIG_DVB_STV0297=m
+
+#
+# ATSC (North American/Korean Terrestrial/Cable DTV) frontends
+#
+CONFIG_DVB_NXT200X=m
+CONFIG_DVB_OR51211=m
+CONFIG_DVB_OR51132=m
+CONFIG_DVB_BCM3510=m
+CONFIG_DVB_LGDT330X=m
+CONFIG_DVB_LGDT3305=m
+CONFIG_DVB_LG2160=m
+CONFIG_DVB_S5H1409=m
+CONFIG_DVB_AU8522=m
+CONFIG_DVB_AU8522_DTV=m
+CONFIG_DVB_AU8522_V4L=m
+CONFIG_DVB_S5H1411=m
+
+#
+# ISDB-T (terrestrial) frontends
+#
+CONFIG_DVB_S921=m
+CONFIG_DVB_DIB8000=m
+CONFIG_DVB_MB86A20S=m
+
+#
+# ISDB-S (satellite) & ISDB-T (terrestrial) frontends
+#
+CONFIG_DVB_TC90522=m
+CONFIG_DVB_MN88443X=m
+
+#
+# Digital terrestrial only tuners/PLL
+#
+CONFIG_DVB_PLL=m
+CONFIG_DVB_TUNER_DIB0070=m
+CONFIG_DVB_TUNER_DIB0090=m
+
+#
+# SEC control devices for DVB-S
+#
+CONFIG_DVB_DRX39XYJ=m
+CONFIG_DVB_LNBH25=m
+CONFIG_DVB_LNBH29=m
+CONFIG_DVB_LNBP21=m
+CONFIG_DVB_LNBP22=m
+CONFIG_DVB_ISL6405=m
+CONFIG_DVB_ISL6421=m
+CONFIG_DVB_ISL6423=m
+CONFIG_DVB_A8293=m
+CONFIG_DVB_LGS8GL5=m
+CONFIG_DVB_LGS8GXX=m
+CONFIG_DVB_ATBM8830=m
+CONFIG_DVB_TDA665x=m
+CONFIG_DVB_IX2505V=m
+CONFIG_DVB_M88RS2000=m
+CONFIG_DVB_AF9033=m
+CONFIG_DVB_HORUS3A=m
+CONFIG_DVB_ASCOT2E=m
+CONFIG_DVB_HELENE=m
+
+#
+# Common Interface (EN50221) controller drivers
+#
+CONFIG_DVB_CXD2099=m
+CONFIG_DVB_SP2=m
+# end of Customise DVB Frontends
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+# end of Media ancillary drivers
+
+#
+# Graphics support
+#
+# CONFIG_IMX_IPUV3_CORE is not set
+CONFIG_DRM=y
+CONFIG_DRM_IGNORE_IOTCL_PERMIT=y
+CONFIG_DRM_MIPI_DSI=y
+# CONFIG_DRM_DP_AUX_CHARDEV is not set
+# CONFIG_DRM_DEBUG_MM is not set
+# CONFIG_DRM_DEBUG_SELFTEST is not set
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_DRM_KMS_FB_HELPER=y
+# CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS is not set
+CONFIG_DRM_FBDEV_EMULATION=y
+CONFIG_DRM_FBDEV_OVERALLOC=100
+# CONFIG_DRM_FBDEV_LEAK_PHYS_SMEM is not set
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+# CONFIG_DRM_DP_CEC is not set
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_I2C_NXP_TDA9950 is not set
+# end of I2C encoder or helper chips
+
+#
+# ARM devices
+#
+# CONFIG_DRM_HDLCD is not set
+# CONFIG_DRM_MALI_DISPLAY is not set
+# CONFIG_DRM_KOMEDA is not set
+# end of ARM devices
+
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VKMS is not set
+# CONFIG_DRM_EXYNOS is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_RCAR_DW_HDMI is not set
+# CONFIG_DRM_RCAR_LVDS is not set
+CONFIG_DRM_PANEL=y
+
+#
+# Display Panels
+#
+# CONFIG_DRM_PANEL_ARM_VERSATILE is not set
+# CONFIG_DRM_PANEL_ASUS_Z00T_TM5P5_NT35596 is not set
+# CONFIG_DRM_PANEL_BOE_HIMAX8279D is not set
+# CONFIG_DRM_PANEL_BOE_TV101WUM_NL6 is not set
+# CONFIG_DRM_PANEL_LVDS is not set
+CONFIG_DRM_PANEL_SIMPLE=y
+# CONFIG_DRM_PANEL_ELIDA_KD35T133 is not set
+# CONFIG_DRM_PANEL_FEIXIN_K101_IM2BA02 is not set
+# CONFIG_DRM_PANEL_FEIYANG_FY07024DI26A30D is not set
+# CONFIG_DRM_PANEL_ILITEK_IL9322 is not set
+CONFIG_DRM_PANEL_ILITEK_ILI9881C=y
+CONFIG_DRM_PANEL_ILI9881D=y
+CONFIG_DRM_PANEL_HX8394=y
+CONFIG_DRM_PANEL_JADARD_JD9365DA_H3=y
+# CONFIG_DRM_PANEL_INNOLUX_P079ZCA is not set
+# CONFIG_DRM_PANEL_JDI_LT070ME05000 is not set
+# CONFIG_DRM_PANEL_KINGDISPLAY_KD097D04 is not set
+# CONFIG_DRM_PANEL_LEADTEK_LTK050H3146W is not set
+# CONFIG_DRM_PANEL_LEADTEK_LTK500HD1829 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_LD9040 is not set
+# CONFIG_DRM_PANEL_LG_LB035Q02 is not set
+# CONFIG_DRM_PANEL_LG_LG4573 is not set
+# CONFIG_DRM_PANEL_NEC_NL8048HL11 is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT35510 is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT39016 is not set
+# CONFIG_DRM_PANEL_MANTIX_MLAF057WE51 is not set
+# CONFIG_DRM_PANEL_OLIMEX_LCD_OLINUXINO is not set
+# CONFIG_DRM_PANEL_ORISETECH_OTM8009A is not set
+# CONFIG_DRM_PANEL_OSD_OSD101T2587_53TS is not set
+# CONFIG_DRM_PANEL_PANASONIC_VVX10F034N00 is not set
+# CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN is not set
+# CONFIG_DRM_PANEL_RAYDIUM_RM67191 is not set
+# CONFIG_DRM_PANEL_RAYDIUM_RM68200 is not set
+# CONFIG_DRM_PANEL_RONBO_RB070D30 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6D16D0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E3HA2 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E63J0X03 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E63M0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E88A0_AMS452EF01 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E8AA0 is not set
+# CONFIG_DRM_PANEL_SEIKO_43WVF1G is not set
+# CONFIG_DRM_PANEL_SHARP_LQ101R1SX01 is not set
+# CONFIG_DRM_PANEL_SHARP_LS037V7DW01 is not set
+# CONFIG_DRM_PANEL_SHARP_LS043T1LE01 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7701 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7703 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7789V is not set
+# CONFIG_DRM_PANEL_SONY_ACX424AKP is not set
+# CONFIG_DRM_PANEL_SONY_ACX565AKM is not set
+# CONFIG_DRM_PANEL_TPO_TD028TTEC1 is not set
+# CONFIG_DRM_PANEL_TPO_TD043MTEA1 is not set
+# CONFIG_DRM_PANEL_TPO_TPG110 is not set
+# CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA is not set
+# CONFIG_DRM_PANEL_VISIONOX_RM69299 is not set
+# CONFIG_DRM_PANEL_XINPENG_XPP055C272 is not set
+# end of Display Panels
+
+CONFIG_DRM_BRIDGE=y
+CONFIG_DRM_PANEL_BRIDGE=y
+
+#
+# Display Interface Bridges
+#
+# CONFIG_DRM_CDNS_DSI is not set
+# CONFIG_DRM_CHRONTEL_CH7033 is not set
+# CONFIG_DRM_DISPLAY_CONNECTOR is not set
+# CONFIG_DRM_LONTIUM_LT9611 is not set
+# CONFIG_DRM_LVDS_CODEC is not set
+# CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW is not set
+# CONFIG_DRM_NWL_MIPI_DSI is not set
+# CONFIG_DRM_NXP_PTN3460 is not set
+# CONFIG_DRM_PARADE_PS8622 is not set
+# CONFIG_DRM_PARADE_PS8640 is not set
+# CONFIG_DRM_SIL_SII8620 is not set
+# CONFIG_DRM_SII902X is not set
+# CONFIG_DRM_SII9234 is not set
+# CONFIG_DRM_SIMPLE_BRIDGE is not set
+# CONFIG_DRM_THINE_THC63LVD1024 is not set
+# CONFIG_DRM_TOSHIBA_TC358762 is not set
+# CONFIG_DRM_TOSHIBA_TC358764 is not set
+# CONFIG_DRM_TOSHIBA_TC358767 is not set
+# CONFIG_DRM_TOSHIBA_TC358768 is not set
+# CONFIG_DRM_TOSHIBA_TC358775 is not set
+# CONFIG_DRM_TI_TFP410 is not set
+# CONFIG_DRM_TI_SN65DSI86 is not set
+# CONFIG_DRM_TI_TPD12S015 is not set
+# CONFIG_DRM_ANALOGIX_ANX6345 is not set
+# CONFIG_DRM_ANALOGIX_ANX78XX is not set
+# CONFIG_DRM_I2C_ADV7511 is not set
+# CONFIG_DRM_CDNS_MHDP8546 is not set
+CONFIG_DRM_DW_HDMI=y
+# CONFIG_DRM_DW_HDMI_AHB_AUDIO is not set
+# CONFIG_DRM_DW_HDMI_I2S_AUDIO is not set
+# CONFIG_DRM_DW_HDMI_CEC is not set
+# end of Display Interface Bridges
+
+# CONFIG_DRM_INGENIC is not set
+# CONFIG_DRM_V3D is not set
+# CONFIG_DRM_VC4 is not set
+# CONFIG_DRM_ETNAVIV is not set
+# CONFIG_DRM_ARCPGU is not set
+# CONFIG_DRM_MXSFB is not set
+# CONFIG_DRM_GM12U320 is not set
+# CONFIG_TINYDRM_HX8357D is not set
+# CONFIG_TINYDRM_ILI9225 is not set
+# CONFIG_TINYDRM_ILI9341 is not set
+# CONFIG_TINYDRM_ILI9486 is not set
+# CONFIG_TINYDRM_MI0283QT is not set
+# CONFIG_TINYDRM_REPAPER is not set
+# CONFIG_TINYDRM_ST7586 is not set
+# CONFIG_TINYDRM_ST7735R is not set
+# CONFIG_DRM_PL111 is not set
+# CONFIG_DRM_TVE200 is not set
+# CONFIG_DRM_LIMA is not set
+# CONFIG_DRM_PANFROST is not set
+# CONFIG_DRM_ASPEED_GFX is not set
+# CONFIG_DRM_MCDE is not set
+# CONFIG_DRM_TIDSS is not set
+# CONFIG_DRM_ZYNQMP_DPSUB is not set
+CONFIG_DRM_VERISILICON=y
+# CONFIG_VERISILICON_VIRTUAL_DISPLAY is not set
+CONFIG_VERISILICON_DW_MIPI_DSI=y
+CONFIG_VERISILICON_DW_HDMI_LIGHT=y
+# CONFIG_VERISILICON_MMU is not set
+# CONFIG_VERISILICON_DEC is not set
+# CONFIG_DRM_LEGACY is not set
+CONFIG_DRM_PANEL_ORIENTATION_QUIRKS=y
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CLPS711X is not set
+# CONFIG_FB_IMX is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_CONTROL is not set
+# CONFIG_FB_EFI is not set
+# CONFIG_FB_GBE is not set
+# CONFIG_FB_PVR2 is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_ATMEL is not set
+# CONFIG_FB_WM8505 is not set
+# CONFIG_FB_PXA168 is not set
+# CONFIG_FB_W100 is not set
+# CONFIG_FB_SH_MOBILE_LCDC is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_S3C is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_DA8XX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_FB_OMAP2 is not set
+# CONFIG_MMP_DISP is not set
+# end of Frame buffer Devices
+
+#
+# Backlight & LCD device support
+#
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_KTD253 is not set
+CONFIG_BACKLIGHT_PWM=y
+# CONFIG_BACKLIGHT_QCOM_WLED is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630A is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+# CONFIG_BACKLIGHT_GPIO is not set
+# CONFIG_BACKLIGHT_LV5207LP is not set
+# CONFIG_BACKLIGHT_BD6107 is not set
+# CONFIG_BACKLIGHT_ARCXCNN is not set
+# CONFIG_BACKLIGHT_LED is not set
+# end of Backlight & LCD device support
+
+CONFIG_VIDEOMODE_HELPERS=y
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_LEGACY_ACCELERATION is not set
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER is not set
+# end of Console display driver support
+
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# end of Graphics support
+
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_DMAENGINE_PCM=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=y
+CONFIG_SND_JACK=y
+CONFIG_SND_JACK_INPUT_DEV=y
+# CONFIG_SND_OSSEMUL is not set
+CONFIG_SND_PCM_TIMER=y
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_PROC_FS=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# HD-Audio
+#
+# end of HD-Audio
+
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_AUDIO_USE_MEDIA_CONTROLLER=y
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_US122L is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_VARIAX is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM=y
+# CONFIG_SND_SOC_ADI is not set
+# CONFIG_SND_SOC_AMD_ACP is not set
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_BCM2835_SOC_I2S is not set
+# CONFIG_SND_SOC_CYGNUS is not set
+# CONFIG_SND_BCM63XX_I2S_WHISTLER is not set
+# CONFIG_SND_EP93XX_SOC is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+
+#
+# SoC Audio for Freescale CPUs
+#
+
+#
+# Common SoC Audio options for Freescale CPUs:
+#
+# CONFIG_SND_SOC_FSL_ASRC is not set
+# CONFIG_SND_SOC_FSL_SAI is not set
+# CONFIG_SND_SOC_FSL_AUDMIX is not set
+# CONFIG_SND_SOC_FSL_SSI is not set
+# CONFIG_SND_SOC_FSL_SPDIF is not set
+# CONFIG_SND_SOC_FSL_ESAI is not set
+# CONFIG_SND_SOC_FSL_MICFIL is not set
+# CONFIG_SND_SOC_IMX_AUDMUX is not set
+# CONFIG_SND_IMX_SOC is not set
+# end of SoC Audio for Freescale CPUs
+
+# CONFIG_SND_I2S_HI6210_I2S is not set
+# CONFIG_SND_I2S_HI3660_I2S is not set
+# CONFIG_SND_JZ4740_SOC_I2S is not set
+# CONFIG_SND_KIRKWOOD_SOC is not set
+# CONFIG_SND_SOC_IMG is not set
+CONFIG_SND_SOC_INTEL_SST_TOPLEVEL=y
+# CONFIG_SND_SOC_INTEL_KEEMBAY is not set
+CONFIG_SND_SOC_INTEL_MACH=y
+# CONFIG_SND_SOC_INTEL_USER_FRIENDLY_LONG_NAMES is not set
+# CONFIG_SND_SOC_MTK_BTCVSD is not set
+
+#
+# ASoC support for Amlogic platforms
+#
+# CONFIG_SND_MESON_AIU is not set
+# CONFIG_SND_MESON_AXG_FRDDR is not set
+# CONFIG_SND_MESON_AXG_TODDR is not set
+# CONFIG_SND_MESON_AXG_TDMIN is not set
+# CONFIG_SND_MESON_AXG_TDMOUT is not set
+# CONFIG_SND_MESON_AXG_SOUND_CARD is not set
+# CONFIG_SND_MESON_AXG_SPDIFOUT is not set
+# CONFIG_SND_MESON_AXG_SPDIFIN is not set
+# CONFIG_SND_MESON_AXG_PDM is not set
+# CONFIG_SND_MESON_GX_SOUND_CARD is not set
+# CONFIG_SND_MESON_G12A_TOACODEC is not set
+# CONFIG_SND_MESON_G12A_TOHDMITX is not set
+# CONFIG_SND_SOC_MESON_T9015 is not set
+# end of ASoC support for Amlogic platforms
+
+# CONFIG_SND_MXS_SOC is not set
+# CONFIG_SND_PXA2XX_SOC is not set
+# CONFIG_SND_SOC_QCOM is not set
+# CONFIG_SND_SOC_ROCKCHIP is not set
+# CONFIG_SND_SOC_SAMSUNG is not set
+
+#
+# SoC Audio support for Renesas SoCs
+#
+# CONFIG_SND_SOC_SH4_FSI is not set
+# CONFIG_SND_SOC_RCAR is not set
+# end of SoC Audio support for Renesas SoCs
+
+# CONFIG_SND_SOC_SIRF is not set
+# CONFIG_SND_SOC_SOF_TOPLEVEL is not set
+# CONFIG_SND_SOC_SPRD is not set
+# CONFIG_SND_SOC_STI is not set
+
+#
+# STMicroelectronics STM32 SOC audio support
+#
+# CONFIG_SND_SOC_STM32_SAI is not set
+# CONFIG_SND_SOC_STM32_I2S is not set
+# CONFIG_SND_SOC_STM32_SPDIFRX is not set
+# end of STMicroelectronics STM32 SOC audio support
+
+#
+# Allwinner SoC Audio support
+#
+# CONFIG_SND_SUN4I_CODEC is not set
+# CONFIG_SND_SUN8I_CODEC is not set
+# CONFIG_SND_SUN8I_CODEC_ANALOG is not set
+# CONFIG_SND_SUN50I_CODEC_ANALOG is not set
+# CONFIG_SND_SUN4I_I2S is not set
+# CONFIG_SND_SUN4I_SPDIF is not set
+# end of Allwinner SoC Audio support
+
+# CONFIG_SND_SOC_TEGRA is not set
+
+#
+# Audio support for Texas Instruments SoCs
+#
+
+#
+# Texas Instruments DAI support for:
+#
+# CONFIG_SND_SOC_DAVINCI_ASP is not set
+# CONFIG_SND_SOC_DAVINCI_MCASP is not set
+# CONFIG_SND_SOC_DAVINCI_VCIF is not set
+# CONFIG_SND_SOC_OMAP_DMIC is not set
+# CONFIG_SND_SOC_OMAP_MCBSP is not set
+# CONFIG_SND_SOC_OMAP_MCPDM is not set
+
+#
+# Audio support for boards with Texas Instruments SoCs
+#
+# CONFIG_SND_SOC_OMAP_HDMI is not set
+# CONFIG_SND_SOC_J721E_EVM is not set
+# end of Audio support for Texas Instruments SoCs
+
+# CONFIG_SND_SOC_UNIPHIER is not set
+# CONFIG_SND_SOC_XILINX_I2S is not set
+# CONFIG_SND_SOC_XILINX_AUDIO_FORMATTER is not set
+# CONFIG_SND_SOC_XILINX_SPDIF is not set
+# CONFIG_SND_SOC_XTFPGA_I2S is not set
+# CONFIG_ZX_SPDIF is not set
+# CONFIG_ZX_I2S is not set
+# CONFIG_ZX_TDM is not set
+# CONFIG_SND_SOC_THEAD_LIGHT is not set
+# CONFIG_SND_SOC_AW87519 is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+
+#
+# CODEC drivers
+#
+# CONFIG_SND_SOC_ALL_CODECS is not set
+# CONFIG_SND_SOC_AC97_CODEC is not set
+# CONFIG_SND_SOC_ADAU1701 is not set
+# CONFIG_SND_SOC_ADAU1761_I2C is not set
+# CONFIG_SND_SOC_ADAU1761_SPI is not set
+# CONFIG_SND_SOC_ADAU7002 is not set
+# CONFIG_SND_SOC_ADAU7118_HW is not set
+# CONFIG_SND_SOC_ADAU7118_I2C is not set
+# CONFIG_SND_SOC_AK4104 is not set
+# CONFIG_SND_SOC_AK4118 is not set
+# CONFIG_SND_SOC_AK4458 is not set
+# CONFIG_SND_SOC_AK4554 is not set
+# CONFIG_SND_SOC_AK4613 is not set
+# CONFIG_SND_SOC_AK4642 is not set
+# CONFIG_SND_SOC_AK5386 is not set
+# CONFIG_SND_SOC_AK5558 is not set
+# CONFIG_SND_SOC_ALC5623 is not set
+# CONFIG_SND_SOC_BD28623 is not set
+CONFIG_SND_SOC_BT_SCO=y
+# CONFIG_SND_SOC_CS35L32 is not set
+# CONFIG_SND_SOC_CS35L33 is not set
+# CONFIG_SND_SOC_CS35L34 is not set
+# CONFIG_SND_SOC_CS35L35 is not set
+# CONFIG_SND_SOC_CS35L36 is not set
+# CONFIG_SND_SOC_CS42L42 is not set
+# CONFIG_SND_SOC_CS42L51_I2C is not set
+# CONFIG_SND_SOC_CS42L52 is not set
+# CONFIG_SND_SOC_CS42L56 is not set
+# CONFIG_SND_SOC_CS42L73 is not set
+# CONFIG_SND_SOC_CS4234 is not set
+# CONFIG_SND_SOC_CS4265 is not set
+# CONFIG_SND_SOC_CS4270 is not set
+# CONFIG_SND_SOC_CS4271_I2C is not set
+# CONFIG_SND_SOC_CS4271_SPI is not set
+# CONFIG_SND_SOC_CS42XX8_I2C is not set
+# CONFIG_SND_SOC_CS43130 is not set
+# CONFIG_SND_SOC_CS4341 is not set
+# CONFIG_SND_SOC_CS4349 is not set
+# CONFIG_SND_SOC_CS53L30 is not set
+# CONFIG_SND_SOC_CX2072X is not set
+# CONFIG_SND_SOC_JZ4740_CODEC is not set
+# CONFIG_SND_SOC_JZ4725B_CODEC is not set
+# CONFIG_SND_SOC_JZ4770_CODEC is not set
+# CONFIG_SND_SOC_DA7213 is not set
+# CONFIG_SND_SOC_DMIC is not set
+# CONFIG_SND_SOC_ES7134 is not set
+# CONFIG_SND_SOC_ES7210 is not set
+# CONFIG_SND_SOC_ES7241 is not set
+# CONFIG_SND_SOC_ES8156 is not set
+# CONFIG_SND_SOC_ES8316 is not set
+# CONFIG_SND_SOC_ES8328_I2C is not set
+# CONFIG_SND_SOC_ES8328_SPI is not set
+# CONFIG_SND_SOC_GTM601 is not set
+# CONFIG_SND_SOC_INNO_RK3036 is not set
+# CONFIG_SND_SOC_MAX98088 is not set
+# CONFIG_SND_SOC_MAX98357A is not set
+# CONFIG_SND_SOC_MAX98504 is not set
+# CONFIG_SND_SOC_MAX9867 is not set
+# CONFIG_SND_SOC_MAX98927 is not set
+# CONFIG_SND_SOC_MAX98373_I2C is not set
+# CONFIG_SND_SOC_MAX98390 is not set
+# CONFIG_SND_SOC_MAX9860 is not set
+# CONFIG_SND_SOC_MSM8916_WCD_ANALOG is not set
+# CONFIG_SND_SOC_MSM8916_WCD_DIGITAL is not set
+# CONFIG_SND_SOC_PCM1681 is not set
+# CONFIG_SND_SOC_PCM1789_I2C is not set
+# CONFIG_SND_SOC_PCM179X_I2C is not set
+# CONFIG_SND_SOC_PCM179X_SPI is not set
+# CONFIG_SND_SOC_PCM186X_I2C is not set
+# CONFIG_SND_SOC_PCM186X_SPI is not set
+# CONFIG_SND_SOC_PCM3060_I2C is not set
+# CONFIG_SND_SOC_PCM3060_SPI is not set
+# CONFIG_SND_SOC_PCM3168A_I2C is not set
+# CONFIG_SND_SOC_PCM3168A_SPI is not set
+# CONFIG_SND_SOC_PCM512x_I2C is not set
+# CONFIG_SND_SOC_PCM512x_SPI is not set
+# CONFIG_SND_SOC_RK3328 is not set
+# CONFIG_SND_SOC_RT5616 is not set
+# CONFIG_SND_SOC_RT5631 is not set
+# CONFIG_SND_SOC_SGTL5000 is not set
+# CONFIG_SND_SOC_SIMPLE_AMPLIFIER is not set
+# CONFIG_SND_SOC_SIRF_AUDIO_CODEC is not set
+# CONFIG_SND_SOC_SPDIF is not set
+# CONFIG_SND_SOC_SSM2305 is not set
+# CONFIG_SND_SOC_SSM2602_SPI is not set
+# CONFIG_SND_SOC_SSM2602_I2C is not set
+# CONFIG_SND_SOC_SSM4567 is not set
+# CONFIG_SND_SOC_STA32X is not set
+# CONFIG_SND_SOC_STA350 is not set
+# CONFIG_SND_SOC_STI_SAS is not set
+# CONFIG_SND_SOC_TAS2552 is not set
+# CONFIG_SND_SOC_TAS2562 is not set
+# CONFIG_SND_SOC_TAS2764 is not set
+# CONFIG_SND_SOC_TAS2770 is not set
+# CONFIG_SND_SOC_TAS5086 is not set
+# CONFIG_SND_SOC_TAS571X is not set
+# CONFIG_SND_SOC_TAS5720 is not set
+# CONFIG_SND_SOC_TAS6424 is not set
+# CONFIG_SND_SOC_TDA7419 is not set
+# CONFIG_SND_SOC_TFA9879 is not set
+# CONFIG_SND_SOC_TLV320AIC23_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC23_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC31XX is not set
+# CONFIG_SND_SOC_TLV320AIC32X4_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC32X4_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC3X is not set
+# CONFIG_SND_SOC_TLV320ADCX140 is not set
+# CONFIG_SND_SOC_TS3A227E is not set
+# CONFIG_SND_SOC_TSCS42XX is not set
+# CONFIG_SND_SOC_TSCS454 is not set
+# CONFIG_SND_SOC_UDA1334 is not set
+# CONFIG_SND_SOC_WM8510 is not set
+# CONFIG_SND_SOC_WM8523 is not set
+# CONFIG_SND_SOC_WM8524 is not set
+# CONFIG_SND_SOC_WM8580 is not set
+# CONFIG_SND_SOC_WM8711 is not set
+# CONFIG_SND_SOC_WM8728 is not set
+# CONFIG_SND_SOC_WM8731 is not set
+# CONFIG_SND_SOC_WM8737 is not set
+# CONFIG_SND_SOC_WM8741 is not set
+# CONFIG_SND_SOC_WM8750 is not set
+# CONFIG_SND_SOC_WM8753 is not set
+# CONFIG_SND_SOC_WM8770 is not set
+# CONFIG_SND_SOC_WM8776 is not set
+# CONFIG_SND_SOC_WM8782 is not set
+# CONFIG_SND_SOC_WM8804_I2C is not set
+# CONFIG_SND_SOC_WM8804_SPI is not set
+# CONFIG_SND_SOC_WM8903 is not set
+# CONFIG_SND_SOC_WM8904 is not set
+CONFIG_SND_SOC_WM8960=y
+# CONFIG_SND_SOC_WM8962 is not set
+# CONFIG_SND_SOC_WM8974 is not set
+# CONFIG_SND_SOC_WM8978 is not set
+# CONFIG_SND_SOC_WM8985 is not set
+# CONFIG_SND_SOC_ZL38060 is not set
+# CONFIG_SND_SOC_ZX_AUD96P22 is not set
+# CONFIG_SND_SOC_MAX9759 is not set
+# CONFIG_SND_SOC_MT6351 is not set
+# CONFIG_SND_SOC_MT6358 is not set
+# CONFIG_SND_SOC_MT6660 is not set
+# CONFIG_SND_SOC_NAU8540 is not set
+# CONFIG_SND_SOC_NAU8810 is not set
+# CONFIG_SND_SOC_NAU8822 is not set
+# CONFIG_SND_SOC_NAU8824 is not set
+# CONFIG_SND_SOC_TPA6130A2 is not set
+# end of CODEC drivers
+
+CONFIG_SND_SIMPLE_CARD_UTILS=y
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_SND_AUDIO_GRAPH_CARD=y
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACCUTOUCH is not set
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_ASUS is not set
+# CONFIG_HID_AUREAL is not set
+CONFIG_HID_BELKIN=y
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_BIGBEN_FF is not set
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_CORSAIR is not set
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_MACALLY is not set
+CONFIG_HID_PRODIKEYS=y
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CP2112 is not set
+# CONFIG_HID_CREATIVE_SB0540 is not set
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+# CONFIG_HID_ELAN is not set
+CONFIG_HID_ELECOM=y
+# CONFIG_HID_ELO is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_GLORIOUS is not set
+CONFIG_HID_HOLTEK=y
+# CONFIG_HOLTEK_FF is not set
+# CONFIG_HID_VIVALDI is not set
+# CONFIG_HID_GT683R is not set
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+# CONFIG_HID_VIEWSONIC is not set
+CONFIG_HID_GYRATION=y
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_JABRA is not set
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+# CONFIG_HID_LED is not set
+# CONFIG_HID_LENOVO is not set
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=y
+CONFIG_HID_LOGITECH_HIDPP=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWHEELS_FF=y
+CONFIG_HID_MAGICMOUSE=y
+# CONFIG_HID_MALTRON is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_REDRAGON is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+# CONFIG_HID_NINTENDO is not set
+# CONFIG_HID_NTI is not set
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+# CONFIG_HID_PENMOUNT is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+# CONFIG_HID_PICOLCD_FB is not set
+# CONFIG_HID_PICOLCD_BACKLIGHT is not set
+# CONFIG_HID_PICOLCD_LEDS is not set
+# CONFIG_HID_PLANTRONICS is not set
+CONFIG_HID_PLAYSTATION=y
+CONFIG_PLAYSTATION_FF=y
+CONFIG_HID_PRIMAX=y
+# CONFIG_HID_RETRODE is not set
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_SAITEK=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_SONY_FF=y
+CONFIG_HID_SPEEDLINK=y
+CONFIG_HID_STEAM=y
+# CONFIG_HID_STEELSERIES is not set
+CONFIG_HID_SUNPLUS=y
+# CONFIG_HID_RMI is not set
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TIVO=y
+CONFIG_HID_TOPSEED=y
+# CONFIG_HID_THINGM is not set
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_U2FZERO is not set
+CONFIG_HID_WACOM=y
+CONFIG_HID_WIIMOTE=y
+# CONFIG_HID_XINMO is not set
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_HID_ZYDACRON=y
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+# CONFIG_HID_MCP2221 is not set
+# end of Special HID drivers
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+# end of USB HID support
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+# end of I2C HID support
+# end of HID support
+
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+# CONFIG_USB_LED_TRIG is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_CONN_GPIO is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_FEW_INIT_RETRIES is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_PRODUCTLIST is not set
+# CONFIG_USB_OTG_DISABLE_EXTERNAL_HUB is not set
+# CONFIG_USB_OTG_FSM is not set
+# CONFIG_USB_LEDS_TRIGGER_USBPORT is not set
+CONFIG_USB_AUTOSUSPEND_DELAY=2
+# CONFIG_USB_MON is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DBGCAP is not set
+# CONFIG_USB_XHCI_PCI_RENESAS is not set
+CONFIG_USB_XHCI_PLATFORM=y
+# CONFIG_USB_XHCI_HISTB is not set
+# CONFIG_USB_XHCI_MTK is not set
+# CONFIG_USB_XHCI_MVEBU is not set
+# CONFIG_USB_XHCI_RCAR is not set
+# CONFIG_USB_BRCMSTB is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHCI_FSL is not set
+# CONFIG_USB_EHCI_MXC is not set
+# CONFIG_USB_EHCI_HCD_NPCM7XX is not set
+# CONFIG_USB_EHCI_HCD_ORION is not set
+# CONFIG_USB_EHCI_HCD_SPEAR is not set
+# CONFIG_USB_EHCI_HCD_STI is not set
+# CONFIG_USB_EHCI_HCD_AT91 is not set
+# CONFIG_USB_EHCI_SH is not set
+# CONFIG_USB_EHCI_EXYNOS is not set
+# CONFIG_USB_EHCI_MV is not set
+# CONFIG_USB_CNS3XXX_EHCI is not set
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_MAX3421_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_HCD_SPEAR is not set
+# CONFIG_USB_OHCI_HCD_STI is not set
+# CONFIG_USB_OHCI_HCD_S3C2410 is not set
+# CONFIG_USB_OHCI_HCD_AT91 is not set
+# CONFIG_USB_OHCI_HCD_OMAP3 is not set
+# CONFIG_USB_OHCI_HCD_DAVINCI is not set
+# CONFIG_USB_OHCI_SH is not set
+# CONFIG_USB_OHCI_EXYNOS is not set
+# CONFIG_USB_CNS3XXX_OHCI is not set
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_CDNS3 is not set
+# CONFIG_USB_MTU3 is not set
+# CONFIG_USB_MUSB_HDRC is not set
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_HOST is not set
+# CONFIG_USB_DWC3_GADGET is not set
+CONFIG_USB_DWC3_DUAL_ROLE=y
+
+#
+# Platform Glue Driver Support
+#
+CONFIG_USB_DWC3_OMAP=y
+CONFIG_USB_DWC3_EXYNOS=y
+CONFIG_USB_DWC3_KEYSTONE=y
+CONFIG_USB_DWC3_MESON_G12A=y
+CONFIG_USB_DWC3_OF_SIMPLE=y
+CONFIG_USB_DWC3_ST=y
+CONFIG_USB_DWC3_QCOM=y
+CONFIG_USB_DWC3_IMX8MP=y
+CONFIG_USB_DWC3_THEAD=y
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_APPLE_MFI_FASTCHARGE is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HUB_USB251XB is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSIC_USB4604 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_TEGRA_PHY is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_JZ4770_PHY is not set
+# end of USB Physical Layer drivers
+
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DEBUG=y
+# CONFIG_USB_GADGET_VERBOSE is not set
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_DEBUG_FS=y
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+# CONFIG_U_SERIAL_CONSOLE is not set
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_LPC32XX is not set
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_RENESAS_USB3 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_SNP_UDC_PLAT is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_BDC_UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_MAX3420_UDC is not set
+# CONFIG_USB_ASPEED_VHUB is not set
+# CONFIG_USB_DUMMY_HCD is not set
+# end of USB Peripheral Controller
+
+CONFIG_USB_LIBCOMPOSITE=y
+CONFIG_USB_F_ACM=m
+CONFIG_USB_F_SS_LB=m
+CONFIG_USB_U_SERIAL=m
+CONFIG_USB_U_ETHER=m
+CONFIG_USB_F_SERIAL=m
+CONFIG_USB_F_OBEX=m
+CONFIG_USB_F_NCM=m
+CONFIG_USB_F_ECM=m
+CONFIG_USB_F_EEM=m
+CONFIG_USB_F_SUBSET=m
+CONFIG_USB_F_RNDIS=m
+CONFIG_USB_F_MASS_STORAGE=m
+CONFIG_USB_F_FS=y
+CONFIG_USB_F_MIDI=y
+CONFIG_USB_F_ACC=y
+CONFIG_USB_F_AUDIO_SRC=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_UEVENT=y
+# CONFIG_USB_CONFIGFS_SERIAL is not set
+# CONFIG_USB_CONFIGFS_ACM is not set
+# CONFIG_USB_CONFIGFS_OBEX is not set
+# CONFIG_USB_CONFIGFS_NCM is not set
+# CONFIG_USB_CONFIGFS_ECM is not set
+# CONFIG_USB_CONFIGFS_ECM_SUBSET is not set
+# CONFIG_USB_CONFIGFS_RNDIS is not set
+# CONFIG_USB_CONFIGFS_EEM is not set
+# CONFIG_USB_CONFIGFS_MASS_STORAGE is not set
+# CONFIG_USB_CONFIGFS_F_LB_SS is not set
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_ACC=y
+CONFIG_USB_CONFIGFS_F_AUDIO_SRC=y
+# CONFIG_USB_CONFIGFS_F_UAC1 is not set
+# CONFIG_USB_CONFIGFS_F_UAC1_LEGACY is not set
+# CONFIG_USB_CONFIGFS_F_UAC2 is not set
+CONFIG_USB_CONFIGFS_F_MIDI=y
+# CONFIG_USB_CONFIGFS_F_HID is not set
+# CONFIG_USB_CONFIGFS_F_UVC is not set
+# CONFIG_USB_CONFIGFS_F_PRINTER is not set
+
+#
+# USB Gadget precomposed configurations
+#
+CONFIG_USB_ZERO=m
+# CONFIG_USB_ZERO_HNPTEST is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_USB_ETH_EEM=y
+CONFIG_USB_G_NCM=m
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+CONFIG_USB_G_MULTI=m
+CONFIG_USB_G_MULTI_RNDIS=y
+# CONFIG_USB_G_MULTI_CDC is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+# CONFIG_USB_RAW_GADGET is not set
+# end of USB Gadget precomposed configurations
+
+# CONFIG_TYPEC is not set
+CONFIG_USB_ROLE_SWITCH=y
+CONFIG_MMC=y
+CONFIG_PWRSEQ_EMMC=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_CRYPTO is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+# CONFIG_MMC_SDHCI_OF_ARASAN is not set
+# CONFIG_MMC_SDHCI_OF_ASPEED is not set
+# CONFIG_MMC_SDHCI_OF_AT91 is not set
+# CONFIG_MMC_SDHCI_OF_ESDHC is not set
+CONFIG_MMC_SDHCI_OF_DWCMSHC=y
+# CONFIG_MMC_SDHCI_OF_LIGHT_MPW is not set
+# CONFIG_MMC_SDHCI_OF_SPARX5 is not set
+# CONFIG_MMC_SDHCI_CADENCE is not set
+# CONFIG_MMC_SDHCI_CNS3XXX is not set
+# CONFIG_MMC_SDHCI_ESDHC_IMX is not set
+# CONFIG_MMC_SDHCI_DOVE is not set
+# CONFIG_MMC_SDHCI_TEGRA is not set
+# CONFIG_MMC_SDHCI_S3C is not set
+# CONFIG_MMC_SDHCI_SIRF is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_SDHCI_SPEAR is not set
+# CONFIG_MMC_SDHCI_BCM_KONA is not set
+# CONFIG_MMC_SDHCI_F_SDH30 is not set
+# CONFIG_MMC_SDHCI_MILBEAUT is not set
+# CONFIG_MMC_SDHCI_IPROC is not set
+# CONFIG_MMC_MESON_GX is not set
+# CONFIG_MMC_MESON_MX_SDHC is not set
+# CONFIG_MMC_MESON_MX_SDIO is not set
+# CONFIG_MMC_MOXART is not set
+# CONFIG_MMC_SDHCI_ST is not set
+# CONFIG_MMC_OMAP_HS is not set
+# CONFIG_MMC_SDHCI_MSM is not set
+# CONFIG_MMC_DAVINCI is not set
+# CONFIG_MMC_GOLDFISH is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_SDHCI_SPRD is not set
+# CONFIG_MMC_TMIO is not set
+# CONFIG_MMC_SDHI is not set
+# CONFIG_MMC_UNIPHIER is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_SH_MMCIF is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+# CONFIG_MMC_SUNXI is not set
+# CONFIG_MMC_CQHCI is not set
+# CONFIG_MMC_HSQ is not set
+# CONFIG_MMC_BCM2835 is not set
+# CONFIG_MMC_MTK is not set
+# CONFIG_MMC_SDHCI_XENON is not set
+# CONFIG_MMC_SDHCI_OMAP is not set
+# CONFIG_MMC_SDHCI_AM654 is not set
+# CONFIG_MMC_OWL is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+# CONFIG_LEDS_CLASS_MULTICOLOR is not set
+# CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_AN30259A is not set
+# CONFIG_LEDS_ARIEL is not set
+# CONFIG_LEDS_AW2013 is not set
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_CR0014114 is not set
+# CONFIG_LEDS_EL15203000 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3532 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_LM3692X is not set
+# CONFIG_LEDS_S3C24XX is not set
+# CONFIG_LEDS_COBALT_QUBE is not set
+# CONFIG_LEDS_COBALT_RAQ is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP3952 is not set
+# CONFIG_LEDS_LP50XX is not set
+# CONFIG_LEDS_LP55XX_COMMON is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_NS2=y
+CONFIG_LEDS_NETXBIG=y
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TLC591XX is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_IS31FL319X is not set
+# CONFIG_LEDS_IS31FL32XX is not set
+
+#
+# LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)
+#
+# CONFIG_LEDS_BLINKM is not set
+# CONFIG_LEDS_SYSCON is not set
+# CONFIG_LEDS_MLXREG is not set
+# CONFIG_LEDS_USER is not set
+# CONFIG_LEDS_SPI_BYTE is not set
+# CONFIG_LEDS_TI_LMU_COMMON is not set
+# CONFIG_LEDS_IP30 is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+# CONFIG_LEDS_TRIGGER_MTD is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_CPU is not set
+# CONFIG_LEDS_TRIGGER_ACTIVITY is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+# CONFIG_LEDS_TRIGGER_PANIC is not set
+# CONFIG_LEDS_TRIGGER_NETDEV is not set
+# CONFIG_LEDS_TRIGGER_PATTERN is not set
+# CONFIG_LEDS_TRIGGER_AUDIO is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABEOZ9 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_BRCMSTB is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_MAX8907 is not set
+# CONFIG_RTC_DRV_MAX77686 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3028 is not set
+# CONFIG_RTC_DRV_RV3032 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+# CONFIG_RTC_DRV_S5M is not set
+# CONFIG_RTC_DRV_SD3078 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_EFI is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_SC27XX is not set
+CONFIG_RTC_DRV_SPEAR=y
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_ASM9260 is not set
+# CONFIG_RTC_DRV_DAVINCI is not set
+# CONFIG_RTC_DRV_DIGICOLOR is not set
+# CONFIG_RTC_DRV_FSL_FTM_ALARM is not set
+# CONFIG_RTC_DRV_MESON is not set
+# CONFIG_RTC_DRV_MESON_VRTC is not set
+# CONFIG_RTC_DRV_OMAP is not set
+# CONFIG_RTC_DRV_S3C is not set
+# CONFIG_RTC_DRV_EP93XX is not set
+# CONFIG_RTC_DRV_VR41XX is not set
+# CONFIG_RTC_DRV_AT91RM9200 is not set
+# CONFIG_RTC_DRV_AT91SAM9 is not set
+# CONFIG_RTC_DRV_GENERIC is not set
+# CONFIG_RTC_DRV_VT8500 is not set
+# CONFIG_RTC_DRV_SUN6I is not set
+# CONFIG_RTC_DRV_SUNXI is not set
+# CONFIG_RTC_DRV_TX4939 is not set
+# CONFIG_RTC_DRV_MV is not set
+# CONFIG_RTC_DRV_ARMADA38X is not set
+# CONFIG_RTC_DRV_CADENCE is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_COH901331 is not set
+# CONFIG_RTC_DRV_STMP is not set
+# CONFIG_RTC_DRV_JZ4740 is not set
+# CONFIG_RTC_DRV_LPC24XX is not set
+# CONFIG_RTC_DRV_LPC32XX is not set
+# CONFIG_RTC_DRV_PM8XXX is not set
+# CONFIG_RTC_DRV_TEGRA is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_MOXART is not set
+# CONFIG_RTC_DRV_MT2712 is not set
+# CONFIG_RTC_DRV_MT6397 is not set
+# CONFIG_RTC_DRV_MT7622 is not set
+CONFIG_RTC_DRV_XGENE=y
+# CONFIG_RTC_DRV_R7301 is not set
+# CONFIG_RTC_DRV_STM32 is not set
+# CONFIG_RTC_DRV_RTD119X is not set
+# CONFIG_RTC_DRV_ASPEED is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_GOLDFISH is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_VIRTUAL_CHANNELS=y
+CONFIG_DMA_OF=y
+# CONFIG_ALTERA_MSGDMA is not set
+# CONFIG_AXI_DMAC is not set
+# CONFIG_COH901318 is not set
+# CONFIG_DMA_JZ4780 is not set
+# CONFIG_DMA_SA11X0 is not set
+# CONFIG_DMA_SUN6I is not set
+CONFIG_DW_AXI_DMAC=y
+# CONFIG_EP93XX_DMA is not set
+# CONFIG_FSL_EDMA is not set
+# CONFIG_IMG_MDC_DMA is not set
+# CONFIG_INTEL_IDMA64 is not set
+# CONFIG_INTEL_IOP_ADMA is not set
+# CONFIG_K3_DMA is not set
+# CONFIG_MCF_EDMA is not set
+# CONFIG_MILBEAUT_HDMAC is not set
+# CONFIG_MILBEAUT_XDMAC is not set
+# CONFIG_MMP_PDMA is not set
+# CONFIG_MMP_TDMA is not set
+# CONFIG_MV_XOR is not set
+# CONFIG_MXS_DMA is not set
+# CONFIG_NBPFAXI_DMA is not set
+# CONFIG_STM32_DMA is not set
+# CONFIG_STM32_DMAMUX is not set
+# CONFIG_STM32_MDMA is not set
+# CONFIG_SPRD_DMA is not set
+# CONFIG_S3C24XX_DMAC is not set
+# CONFIG_TEGRA20_APB_DMA is not set
+# CONFIG_TEGRA210_ADMA is not set
+# CONFIG_TIMB_DMA is not set
+# CONFIG_UNIPHIER_MDMAC is not set
+# CONFIG_UNIPHIER_XDMAC is not set
+# CONFIG_XGENE_DMA is not set
+# CONFIG_XILINX_ZYNQMP_DPDMA is not set
+# CONFIG_ZX_DMA is not set
+# CONFIG_MTK_HSDMA is not set
+# CONFIG_MTK_CQDMA is not set
+# CONFIG_QCOM_HIDMA_MGMT is not set
+# CONFIG_QCOM_HIDMA is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_SF_PDMA is not set
+CONFIG_RENESAS_DMA=y
+CONFIG_SH_DMAE_BASE=y
+# CONFIG_SH_DMAE is not set
+# CONFIG_RCAR_DMAC is not set
+# CONFIG_RENESAS_USB_DMAC is not set
+CONFIG_TI_EDMA=y
+CONFIG_DMA_OMAP=y
+CONFIG_TI_DMA_CROSSBAR=y
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+CONFIG_DMATEST=y
+CONFIG_DMA_ENGINE_RAID=y
+
+#
+# DMABUF options
+#
+CONFIG_SYNC_FILE=y
+CONFIG_SW_SYNC=y
+CONFIG_UDMABUF=y
+# CONFIG_DMABUF_MOVE_NOTIFY is not set
+CONFIG_DMABUF_SELFTESTS=m
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_SYSFS_STATS=y
+CONFIG_DMABUF_HEAPS_DEFERRED_FREE=y
+CONFIG_DMABUF_HEAPS_PAGE_POOL=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+# CONFIG_DMABUF_HEAPS_CMA is not set
+# end of DMABUF options
+
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_CHARLCD is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VDPA is not set
+CONFIG_VHOST_IOTLB=y
+CONFIG_VHOST_RING=y
+CONFIG_VHOST=y
+CONFIG_VHOST_MENU=y
+CONFIG_VHOST_NET=y
+CONFIG_VHOST_VSOCK=y
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+CONFIG_VHOST_VDMABUF=y
+
+#
+# Microsoft Hyper-V guest support
+#
+# end of Microsoft Hyper-V guest support
+
+# CONFIG_GREYBUS is not set
+CONFIG_STAGING=y
+# CONFIG_PRISM2_USB is not set
+# CONFIG_COMEDI is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_RTL8723BS is not set
+# CONFIG_R8712U is not set
+# CONFIG_R8188EU is not set
+# CONFIG_OCTEON_ETHERNET is not set
+
+#
+# IIO staging drivers
+#
+
+#
+# Accelerometers
+#
+# CONFIG_ADIS16203 is not set
+# CONFIG_ADIS16240 is not set
+# end of Accelerometers
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7816 is not set
+# CONFIG_AD7280 is not set
+# end of Analog to digital converters
+
+#
+# Analog digital bi-direction converters
+#
+# CONFIG_ADT7316 is not set
+# end of Analog digital bi-direction converters
+
+#
+# Capacitance to digital converters
+#
+# CONFIG_AD7150 is not set
+# CONFIG_AD7746 is not set
+# end of Capacitance to digital converters
+
+#
+# Direct Digital Synthesis
+#
+# CONFIG_AD9832 is not set
+# CONFIG_AD9834 is not set
+# end of Direct Digital Synthesis
+
+#
+# Network Analyzer, Impedance Converters
+#
+# CONFIG_AD5933 is not set
+# end of Network Analyzer, Impedance Converters
+
+#
+# Active energy metering IC
+#
+# CONFIG_ADE7854 is not set
+# end of Active energy metering IC
+
+#
+# Resolver to digital converters
+#
+# CONFIG_AD2S1210 is not set
+# end of Resolver to digital converters
+# end of IIO staging drivers
+
+# CONFIG_USB_EMXX is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+CONFIG_ASHMEM=y
+# CONFIG_DEBUG_KINFO is not set
+CONFIG_ION=y
+CONFIG_ION_SYSTEM_HEAP=y
+CONFIG_ION_CMA_HEAP=y
+# end of Android
+
+# CONFIG_STAGING_BOARD is not set
+# CONFIG_LTE_GDM724X is not set
+# CONFIG_GS_FPGABOOT is not set
+# CONFIG_UNISYSSPAR is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+# CONFIG_FB_TFT is not set
+# CONFIG_KS7010 is not set
+CONFIG_BCM_VIDEOCORE=y
+# CONFIG_BCM2835_VCHIQ is not set
+# CONFIG_SND_BCM2835 is not set
+# CONFIG_VIDEO_BCM2835 is not set
+# CONFIG_PI433 is not set
+
+#
+# Gasket devices
+#
+# end of Gasket devices
+
+# CONFIG_XIL_AXIS_FIFO is not set
+# CONFIG_FIELDBUS_DEV is not set
+# CONFIG_PHY_HI3670_USB is not set
+CONFIG_HILOG=y
+CONFIG_HILOG_BUFFER_SIZE=4096
+CONFIG_HIEVENT=y
+CONFIG_BBOX_BUFFER_SIZE=2048
+# CONFIG_HISYSEVENT is not set
+# CONFIG_DFX_HUNGTASK is not set
+
+#
+# Blackbox Options
+#
+# CONFIG_BLACKBOX is not set
+# end of Blackbox Options
+
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+# CONFIG_OLPC_XO175 is not set
+CONFIG_HAVE_CLK=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Clock driver for ARM Reference designs
+#
+# CONFIG_ICST is not set
+# CONFIG_CLK_SP810 is not set
+# end of Clock driver for ARM Reference designs
+
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_MAX77686 is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_HI655X is not set
+# CONFIG_COMMON_CLK_SCMI is not set
+# CONFIG_COMMON_CLK_SCPI is not set
+# CONFIG_COMMON_CLK_SI5341 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_BM1880 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_COMMON_CLK_FSL_SAI is not set
+# CONFIG_COMMON_CLK_GEMINI is not set
+# CONFIG_COMMON_CLK_ASPEED is not set
+# CONFIG_COMMON_CLK_S2MPS11 is not set
+# CONFIG_COMMON_CLK_AXI_CLKGEN is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_CLK_LS1028A_PLLDIG is not set
+# CONFIG_COMMON_CLK_XGENE is not set
+# CONFIG_COMMON_CLK_PWM is not set
+# CONFIG_COMMON_CLK_OXNAS is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+# CONFIG_COMMON_CLK_MMP2_AUDIO is not set
+# CONFIG_COMMON_CLK_FIXED_MMIO is not set
+# CONFIG_CLK_ACTIONS is not set
+CONFIG_CLK_ANALOGBITS_WRPLL_CLN28HPC=y
+# CONFIG_CLK_BAIKAL_T1 is not set
+# CONFIG_CLK_BCM2711_DVP is not set
+# CONFIG_CLK_BCM2835 is not set
+# CONFIG_CLK_BCM_63XX is not set
+# CONFIG_CLK_BCM_63XX_GATE is not set
+# CONFIG_CLK_BCM_KONA is not set
+# CONFIG_CLK_BCM_CYGNUS is not set
+# CONFIG_CLK_BCM_HR2 is not set
+# CONFIG_CLK_BCM_NSP is not set
+# CONFIG_CLK_BCM_NS2 is not set
+# CONFIG_CLK_BCM_SR is not set
+# CONFIG_CLK_RASPBERRYPI is not set
+# CONFIG_COMMON_CLK_HI3516CV300 is not set
+# CONFIG_COMMON_CLK_HI3519 is not set
+# CONFIG_COMMON_CLK_HI3660 is not set
+# CONFIG_COMMON_CLK_HI3670 is not set
+# CONFIG_COMMON_CLK_HI3798CV200 is not set
+# CONFIG_COMMON_CLK_HI6220 is not set
+# CONFIG_RESET_HISI is not set
+# CONFIG_STUB_CLK_HI6220 is not set
+# CONFIG_STUB_CLK_HI3660 is not set
+# CONFIG_COMMON_CLK_BOSTON is not set
+# CONFIG_MXC_CLK is not set
+# CONFIG_CLK_IMX8MM is not set
+# CONFIG_CLK_IMX8MN is not set
+# CONFIG_CLK_IMX8MP is not set
+# CONFIG_CLK_IMX8MQ is not set
+
+#
+# Ingenic SoCs drivers
+#
+# CONFIG_INGENIC_CGU_JZ4740 is not set
+# CONFIG_INGENIC_CGU_JZ4725B is not set
+# CONFIG_INGENIC_CGU_JZ4770 is not set
+# CONFIG_INGENIC_CGU_JZ4780 is not set
+# CONFIG_INGENIC_CGU_X1000 is not set
+# CONFIG_INGENIC_CGU_X1830 is not set
+# CONFIG_INGENIC_TCU_CLK is not set
+# end of Ingenic SoCs drivers
+
+# CONFIG_COMMON_CLK_KEYSTONE is not set
+# CONFIG_TI_SYSCON_CLK is not set
+
+#
+# Clock driver for MediaTek SoC
+#
+# CONFIG_COMMON_CLK_MT2701 is not set
+# CONFIG_COMMON_CLK_MT2712 is not set
+# CONFIG_COMMON_CLK_MT6765 is not set
+# CONFIG_COMMON_CLK_MT6779 is not set
+# CONFIG_COMMON_CLK_MT6797 is not set
+# CONFIG_COMMON_CLK_MT7622 is not set
+# CONFIG_COMMON_CLK_MT7629 is not set
+# CONFIG_COMMON_CLK_MT8135 is not set
+# CONFIG_COMMON_CLK_MT8167 is not set
+# CONFIG_COMMON_CLK_MT8167_AUDSYS is not set
+# CONFIG_COMMON_CLK_MT8167_IMGSYS is not set
+# CONFIG_COMMON_CLK_MT8167_MFGCFG is not set
+# CONFIG_COMMON_CLK_MT8167_MMSYS is not set
+# CONFIG_COMMON_CLK_MT8167_VDECSYS is not set
+# CONFIG_COMMON_CLK_MT8173 is not set
+# CONFIG_COMMON_CLK_MT8183 is not set
+# CONFIG_COMMON_CLK_MT8516 is not set
+# end of Clock driver for MediaTek SoC
+
+#
+# Clock support for Amlogic platforms
+#
+# end of Clock support for Amlogic platforms
+
+# CONFIG_COMMON_CLK_QCOM is not set
+# CONFIG_CLK_RENESAS is not set
+# CONFIG_COMMON_CLK_SAMSUNG is not set
+# CONFIG_S3C2410_COMMON_CLK is not set
+# CONFIG_S3C2412_COMMON_CLK is not set
+# CONFIG_S3C2443_COMMON_CLK is not set
+CONFIG_CLK_SIFIVE=y
+CONFIG_CLK_SIFIVE_FU540_PRCI=y
+# CONFIG_SPRD_COMMON_CLK is not set
+CONFIG_CLK_SUNXI=y
+CONFIG_CLK_SUNXI_CLOCKS=y
+CONFIG_CLK_SUNXI_PRCM_SUN6I=y
+CONFIG_CLK_SUNXI_PRCM_SUN8I=y
+CONFIG_CLK_SUNXI_PRCM_SUN9I=y
+# CONFIG_SUNXI_CCU is not set
+# CONFIG_COMMON_CLK_TI_ADPLL is not set
+# CONFIG_CLK_UNIPHIER is not set
+# CONFIG_CLK_LGM_CGU is not set
+CONFIG_THEAD_CLK=y
+# CONFIG_CLK_LIGHT_MPW is not set
+CONFIG_CLK_LIGHT_FM=y
+CONFIG_HWSPINLOCK=y
+# CONFIG_HWSPINLOCK_OMAP is not set
+# CONFIG_HWSPINLOCK_QCOM is not set
+# CONFIG_HWSPINLOCK_SIRF is not set
+# CONFIG_HWSPINLOCK_SPRD is not set
+# CONFIG_HWSPINLOCK_STM32 is not set
+# CONFIG_HSEM_U8500 is not set
+CONFIG_HWSPINLOCK_LIGHT=y
+CONFIG_HWSPINLOCK_LIGHT_TEST=m
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+# CONFIG_BCM2835_TIMER is not set
+# CONFIG_BCM_KONA_TIMER is not set
+# CONFIG_DAVINCI_TIMER is not set
+# CONFIG_DIGICOLOR_TIMER is not set
+# CONFIG_DW_APB_TIMER is not set
+# CONFIG_FTTMR010_TIMER is not set
+# CONFIG_IXP4XX_TIMER is not set
+# CONFIG_MESON6_TIMER is not set
+# CONFIG_OWL_TIMER is not set
+# CONFIG_RDA_TIMER is not set
+# CONFIG_SUN4I_TIMER is not set
+# CONFIG_SUN5I_HSTIMER is not set
+# CONFIG_TEGRA_TIMER is not set
+# CONFIG_VT8500_TIMER is not set
+# CONFIG_NPCM7XX_TIMER is not set
+# CONFIG_CADENCE_TTC_TIMER is not set
+# CONFIG_ASM9260_TIMER is not set
+# CONFIG_CLKSRC_DBX500_PRCMU is not set
+# CONFIG_CLPS711X_TIMER is not set
+# CONFIG_ATLAS7_TIMER is not set
+# CONFIG_MXS_TIMER is not set
+# CONFIG_PRIMA2_TIMER is not set
+# CONFIG_NSPIRE_TIMER is not set
+# CONFIG_INTEGRATOR_AP_TIMER is not set
+# CONFIG_CLKSRC_PISTACHIO is not set
+# CONFIG_CLKSRC_TI_32K is not set
+# CONFIG_CLKSRC_STM32_LP is not set
+# CONFIG_CLKSRC_MPS2 is not set
+# CONFIG_ARC_TIMERS is not set
+# CONFIG_ARM_TIMER_SP804 is not set
+# CONFIG_ARMV7M_SYSTICK is not set
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_ATMEL_ST is not set
+# CONFIG_CLKSRC_SAMSUNG_PWM is not set
+# CONFIG_FSL_FTM_TIMER is not set
+# CONFIG_OXNAS_RPS_TIMER is not set
+# CONFIG_MTK_TIMER is not set
+# CONFIG_SPRD_TIMER is not set
+# CONFIG_CLKSRC_JCORE_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_RENESAS_OSTM is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_CLKSRC_VERSATILE is not set
+# CONFIG_CLKSRC_PXA is not set
+# CONFIG_H8300_TMR8 is not set
+# CONFIG_H8300_TMR16 is not set
+# CONFIG_H8300_TPU is not set
+# CONFIG_TIMER_IMX_SYS_CTR is not set
+# CONFIG_CLKSRC_ST_LPC is not set
+# CONFIG_ATCPIT100_TIMER is not set
+CONFIG_RISCV_TIMER=y
+# CONFIG_CLINT_TIMER is not set
+# CONFIG_INGENIC_TIMER is not set
+# CONFIG_INGENIC_SYSOST is not set
+# CONFIG_INGENIC_OST is not set
+# CONFIG_MICROCHIP_PIT64B is not set
+# end of Clock Source drivers
+
+CONFIG_MAILBOX=y
+# CONFIG_IMX_MBOX is not set
+# CONFIG_PLATFORM_MHU is not set
+# CONFIG_ARMADA_37XX_RWTM_MBOX is not set
+# CONFIG_ROCKCHIP_MBOX is not set
+# CONFIG_ALTERA_MBOX is not set
+# CONFIG_HI3660_MBOX is not set
+# CONFIG_HI6220_MBOX is not set
+# CONFIG_MAILBOX_TEST is not set
+# CONFIG_VIRTIO_MAILBOX_TEST is not set
+# CONFIG_QCOM_APCS_IPC is not set
+# CONFIG_BCM_PDC_MBOX is not set
+# CONFIG_MTK_CMDQ_MBOX is not set
+# CONFIG_SUN6I_MSGBOX is not set
+# CONFIG_SPRD_MBOX is not set
+# CONFIG_QCOM_IPCC is not set
+CONFIG_THEAD_LIGHT_MBOX=y
+CONFIG_VIRTIO_MAILBOX=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+# CONFIG_IOMMU_IO_PGTABLE_LPAE is not set
+# CONFIG_IOMMU_IO_PGTABLE_ARMV7S is not set
+# end of Generic IOMMU Pagetable Support
+
+# CONFIG_IOMMU_DEBUGFS is not set
+# CONFIG_OMAP_IOMMU is not set
+# CONFIG_ROCKCHIP_IOMMU is not set
+# CONFIG_SUN50I_IOMMU is not set
+# CONFIG_EXYNOS_IOMMU is not set
+# CONFIG_IPMMU_VMSA is not set
+# CONFIG_ARM_SMMU is not set
+# CONFIG_S390_CCW_IOMMU is not set
+# CONFIG_S390_AP_IOMMU is not set
+# CONFIG_MTK_IOMMU is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+# end of Remoteproc drivers
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_QCOM_GLINK_RPM is not set
+# CONFIG_RPMSG_VIRTIO is not set
+# end of Rpmsg drivers
+
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_OWL_PM_DOMAINS is not set
+
+#
+# Amlogic SoC drivers
+#
+# CONFIG_MESON_CANVAS is not set
+# CONFIG_MESON_CLK_MEASURE is not set
+# CONFIG_MESON_GX_SOCINFO is not set
+# CONFIG_MESON_GX_PM_DOMAINS is not set
+# CONFIG_MESON_EE_PM_DOMAINS is not set
+# CONFIG_MESON_MX_SOCINFO is not set
+# end of Amlogic SoC drivers
+
+#
+# Aspeed SoC drivers
+#
+CONFIG_SOC_ASPEED=y
+# CONFIG_ASPEED_LPC_CTRL is not set
+# CONFIG_ASPEED_LPC_SNOOP is not set
+# CONFIG_ASPEED_P2A_CTRL is not set
+# end of Aspeed SoC drivers
+
+# CONFIG_AT91_SOC_ID is not set
+# CONFIG_AT91_SOC_SFR is not set
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_BCM2835_POWER is not set
+# CONFIG_SOC_BCM63XX is not set
+# CONFIG_SOC_BRCMSTB is not set
+# end of Broadcom SoC drivers
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+# CONFIG_QUICC_ENGINE is not set
+CONFIG_DPAA2_CONSOLE=y
+# end of NXP/Freescale QorIQ SoC drivers
+
+#
+# i.MX SoC drivers
+#
+# CONFIG_IMX_GPCV2_PM_DOMAINS is not set
+# CONFIG_SOC_IMX8M is not set
+# end of i.MX SoC drivers
+
+#
+# IXP4xx SoC drivers
+#
+# CONFIG_IXP4XX_QMGR is not set
+# CONFIG_IXP4XX_NPE is not set
+# end of IXP4xx SoC drivers
+
+#
+# MediaTek SoC drivers
+#
+# CONFIG_MTK_CMDQ is not set
+# CONFIG_MTK_INFRACFG is not set
+# CONFIG_MTK_PMIC_WRAP is not set
+# CONFIG_MTK_SCPSYS is not set
+# CONFIG_MTK_MMSYS is not set
+# end of MediaTek SoC drivers
+
+#
+# Qualcomm SoC drivers
+#
+# CONFIG_QCOM_AOSS_QMP is not set
+# CONFIG_QCOM_COMMAND_DB is not set
+# CONFIG_QCOM_GENI_SE is not set
+# CONFIG_QCOM_GSBI is not set
+# CONFIG_QCOM_LLCC is not set
+# CONFIG_QCOM_RPMH is not set
+# CONFIG_QCOM_SMEM is not set
+# end of Qualcomm SoC drivers
+
+# CONFIG_SOC_RENESAS is not set
+# CONFIG_ROCKCHIP_GRF is not set
+# CONFIG_ROCKCHIP_IODOMAIN is not set
+# CONFIG_ROCKCHIP_PM_DOMAINS is not set
+# CONFIG_SOC_SAMSUNG is not set
+# CONFIG_SIFIVE_L2 is not set
+# CONFIG_SOC_TEGRA20_VOLTAGE_COUPLER is not set
+# CONFIG_SOC_TEGRA30_VOLTAGE_COUPLER is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_UX500_SOC_ID is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# end of Xilinx SoC drivers
+
+# CONFIG_SOC_ZTE is not set
+
+#
+# Thead SoC drivers
+#
+CONFIG_LIGHT_IOPMP=y
+# CONFIG_LIGHT_SUSPEND is not set
+CONFIG_NO_GKI=y
+# end of Thead SoC drivers
+# end of SOC (System On Chip) specific Drivers
+
+# CONFIG_PM_DEVFREQ is not set
+CONFIG_EXTCON=y
+
+#
+# Extcon Device Drivers
+#
+# CONFIG_EXTCON_ADC_JACK is not set
+# CONFIG_EXTCON_FSA9480 is not set
+# CONFIG_EXTCON_GPIO is not set
+# CONFIG_EXTCON_MAX3355 is not set
+# CONFIG_EXTCON_PTN5150 is not set
+# CONFIG_EXTCON_QCOM_SPMI_MISC is not set
+# CONFIG_EXTCON_RT8973A is not set
+# CONFIG_EXTCON_SM5502 is not set
+# CONFIG_EXTCON_USB_GPIO is not set
+# CONFIG_MEMORY is not set
+CONFIG_IIO=y
+# CONFIG_IIO_BUFFER is not set
+CONFIG_IIO_CONFIGFS=y
+# CONFIG_IIO_TRIGGER is not set
+CONFIG_IIO_SW_DEVICE=y
+# CONFIG_IIO_SW_TRIGGER is not set
+# CONFIG_IIO_TRIGGERED_EVENT is not set
+
+#
+# Accelerometers
+#
+# CONFIG_ADIS16201 is not set
+# CONFIG_ADIS16209 is not set
+# CONFIG_ADXL345_I2C is not set
+# CONFIG_ADXL345_SPI is not set
+# CONFIG_ADXL372_SPI is not set
+# CONFIG_ADXL372_I2C is not set
+# CONFIG_BMA180 is not set
+# CONFIG_BMA220 is not set
+# CONFIG_BMA400 is not set
+# CONFIG_BMC150_ACCEL is not set
+# CONFIG_DA280 is not set
+# CONFIG_DA311 is not set
+# CONFIG_DMARD06 is not set
+# CONFIG_DMARD09 is not set
+# CONFIG_DMARD10 is not set
+# CONFIG_IIO_ST_ACCEL_3AXIS is not set
+# CONFIG_KXSD9 is not set
+# CONFIG_KXCJK1013 is not set
+# CONFIG_MC3230 is not set
+# CONFIG_MMA7455_I2C is not set
+# CONFIG_MMA7455_SPI is not set
+# CONFIG_MMA7660 is not set
+# CONFIG_MMA8452 is not set
+# CONFIG_MMA9551 is not set
+# CONFIG_MMA9553 is not set
+# CONFIG_MXC4005 is not set
+# CONFIG_MXC6255 is not set
+# CONFIG_SCA3000 is not set
+# CONFIG_STK8312 is not set
+# CONFIG_STK8BA50 is not set
+# end of Accelerometers
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7091R5 is not set
+# CONFIG_AD7124 is not set
+# CONFIG_AD7192 is not set
+# CONFIG_AD7266 is not set
+# CONFIG_AD7291 is not set
+# CONFIG_AD7292 is not set
+# CONFIG_AD7298 is not set
+# CONFIG_AD7476 is not set
+# CONFIG_AD7606_IFACE_PARALLEL is not set
+# CONFIG_AD7606_IFACE_SPI is not set
+# CONFIG_AD7766 is not set
+# CONFIG_AD7768_1 is not set
+# CONFIG_AD7780 is not set
+# CONFIG_AD7791 is not set
+# CONFIG_AD7793 is not set
+# CONFIG_AD7887 is not set
+# CONFIG_AD7923 is not set
+# CONFIG_AD7949 is not set
+# CONFIG_AD799X is not set
+# CONFIG_ADI_AXI_ADC is not set
+# CONFIG_ASPEED_ADC is not set
+# CONFIG_AT91_ADC is not set
+# CONFIG_AT91_SAMA5D2_ADC is not set
+# CONFIG_BCM_IPROC_ADC is not set
+# CONFIG_CC10001_ADC is not set
+# CONFIG_ENVELOPE_DETECTOR is not set
+# CONFIG_EXYNOS_ADC is not set
+# CONFIG_HI8435 is not set
+# CONFIG_HX711 is not set
+# CONFIG_INA2XX_ADC is not set
+# CONFIG_INGENIC_ADC is not set
+# CONFIG_IMX7D_ADC is not set
+# CONFIG_LPC18XX_ADC is not set
+# CONFIG_LPC32XX_ADC is not set
+# CONFIG_LTC2471 is not set
+# CONFIG_LTC2485 is not set
+# CONFIG_LTC2496 is not set
+# CONFIG_LTC2497 is not set
+# CONFIG_MAX1027 is not set
+# CONFIG_MAX11100 is not set
+# CONFIG_MAX1118 is not set
+# CONFIG_MAX1241 is not set
+# CONFIG_MAX1363 is not set
+# CONFIG_MAX9611 is not set
+# CONFIG_MCP320X is not set
+# CONFIG_MCP3422 is not set
+# CONFIG_MCP3911 is not set
+# CONFIG_MEDIATEK_MT6577_AUXADC is not set
+# CONFIG_MESON_SARADC is not set
+# CONFIG_NAU7802 is not set
+# CONFIG_NPCM_ADC is not set
+# CONFIG_RCAR_GYRO_ADC is not set
+# CONFIG_ROCKCHIP_SARADC is not set
+# CONFIG_SC27XX_ADC is not set
+# CONFIG_SPEAR_ADC is not set
+# CONFIG_SD_ADC_MODULATOR is not set
+# CONFIG_STM32_ADC_CORE is not set
+# CONFIG_STM32_DFSDM_CORE is not set
+# CONFIG_STM32_DFSDM_ADC is not set
+# CONFIG_TI_ADC081C is not set
+# CONFIG_TI_ADC0832 is not set
+# CONFIG_TI_ADC084S021 is not set
+# CONFIG_TI_ADC12138 is not set
+# CONFIG_TI_ADC108S102 is not set
+# CONFIG_TI_ADC128S052 is not set
+# CONFIG_TI_ADC161S626 is not set
+# CONFIG_TI_ADS1015 is not set
+# CONFIG_TI_ADS7950 is not set
+# CONFIG_TI_ADS8344 is not set
+# CONFIG_TI_ADS8688 is not set
+# CONFIG_TI_ADS124S08 is not set
+# CONFIG_TI_TLC4541 is not set
+# CONFIG_VF610_ADC is not set
+# CONFIG_XILINX_XADC is not set
+CONFIG_LIGHT_ADC=y
+# end of Analog to digital converters
+
+#
+# Analog Front Ends
+#
+# CONFIG_IIO_RESCALE is not set
+# end of Analog Front Ends
+
+#
+# Amplifiers
+#
+# CONFIG_AD8366 is not set
+# CONFIG_HMC425 is not set
+# end of Amplifiers
+
+#
+# Chemical Sensors
+#
+# CONFIG_ATLAS_PH_SENSOR is not set
+# CONFIG_ATLAS_EZO_SENSOR is not set
+# CONFIG_BME680 is not set
+# CONFIG_CCS811 is not set
+# CONFIG_IAQCORE is not set
+# CONFIG_SCD30_CORE is not set
+# CONFIG_SENSIRION_SGP30 is not set
+# CONFIG_SPS30 is not set
+# CONFIG_VZ89X is not set
+# end of Chemical Sensors
+
+#
+# Hid Sensor IIO Common
+#
+# end of Hid Sensor IIO Common
+
+#
+# SSP Sensor Common
+#
+# CONFIG_IIO_SSP_SENSORHUB is not set
+# end of SSP Sensor Common
+
+#
+# Digital to analog converters
+#
+# CONFIG_AD5064 is not set
+# CONFIG_AD5360 is not set
+# CONFIG_AD5380 is not set
+# CONFIG_AD5421 is not set
+# CONFIG_AD5446 is not set
+# CONFIG_AD5449 is not set
+# CONFIG_AD5592R is not set
+# CONFIG_AD5593R is not set
+# CONFIG_AD5504 is not set
+# CONFIG_AD5624R_SPI is not set
+# CONFIG_AD5686_SPI is not set
+# CONFIG_AD5696_I2C is not set
+# CONFIG_AD5755 is not set
+# CONFIG_AD5758 is not set
+# CONFIG_AD5761 is not set
+# CONFIG_AD5764 is not set
+# CONFIG_AD5770R is not set
+# CONFIG_AD5791 is not set
+# CONFIG_AD7303 is not set
+# CONFIG_AD8801 is not set
+# CONFIG_DPOT_DAC is not set
+# CONFIG_DS4424 is not set
+# CONFIG_LPC18XX_DAC is not set
+# CONFIG_LTC1660 is not set
+# CONFIG_LTC2632 is not set
+# CONFIG_M62332 is not set
+# CONFIG_MAX517 is not set
+# CONFIG_MAX5821 is not set
+# CONFIG_MCP4725 is not set
+# CONFIG_MCP4922 is not set
+# CONFIG_STM32_DAC is not set
+# CONFIG_TI_DAC082S085 is not set
+# CONFIG_TI_DAC5571 is not set
+# CONFIG_TI_DAC7311 is not set
+# CONFIG_TI_DAC7612 is not set
+# CONFIG_VF610_DAC is not set
+# end of Digital to analog converters
+
+#
+# IIO dummy driver
+#
+# CONFIG_IIO_SIMPLE_DUMMY is not set
+# end of IIO dummy driver
+
+#
+# Frequency Synthesizers DDS/PLL
+#
+
+#
+# Clock Generator/Distribution
+#
+# CONFIG_AD9523 is not set
+# end of Clock Generator/Distribution
+
+#
+# Phase-Locked Loop (PLL) frequency synthesizers
+#
+# CONFIG_ADF4350 is not set
+# CONFIG_ADF4371 is not set
+# end of Phase-Locked Loop (PLL) frequency synthesizers
+# end of Frequency Synthesizers DDS/PLL
+
+#
+# Digital gyroscope sensors
+#
+# CONFIG_ADIS16080 is not set
+# CONFIG_ADIS16130 is not set
+# CONFIG_ADIS16136 is not set
+# CONFIG_ADIS16260 is not set
+# CONFIG_ADXRS290 is not set
+# CONFIG_ADXRS450 is not set
+# CONFIG_BMG160 is not set
+# CONFIG_FXAS21002C is not set
+# CONFIG_MPU3050_I2C is not set
+# CONFIG_IIO_ST_GYRO_3AXIS is not set
+# CONFIG_ITG3200 is not set
+# end of Digital gyroscope sensors
+
+#
+# Health Sensors
+#
+
+#
+# Heart Rate Monitors
+#
+# CONFIG_AFE4403 is not set
+# CONFIG_AFE4404 is not set
+# CONFIG_MAX30100 is not set
+# CONFIG_MAX30102 is not set
+# end of Heart Rate Monitors
+# end of Health Sensors
+
+#
+# Humidity sensors
+#
+# CONFIG_AM2315 is not set
+# CONFIG_DHT11 is not set
+# CONFIG_HDC100X is not set
+# CONFIG_HDC2010 is not set
+# CONFIG_HTS221 is not set
+# CONFIG_HTU21 is not set
+# CONFIG_SI7005 is not set
+# CONFIG_SI7020 is not set
+# end of Humidity sensors
+
+#
+# Inertial measurement units
+#
+# CONFIG_ADIS16400 is not set
+# CONFIG_ADIS16460 is not set
+# CONFIG_ADIS16475 is not set
+# CONFIG_ADIS16480 is not set
+# CONFIG_BMI160_I2C is not set
+# CONFIG_BMI160_SPI is not set
+# CONFIG_FXOS8700_I2C is not set
+# CONFIG_FXOS8700_SPI is not set
+# CONFIG_KMX61 is not set
+# CONFIG_INV_ICM42600_I2C is not set
+# CONFIG_INV_ICM42600_SPI is not set
+# CONFIG_INV_MPU6050_I2C is not set
+# CONFIG_INV_MPU6050_SPI is not set
+# CONFIG_IIO_ST_LSM6DSX is not set
+# end of Inertial measurement units
+
+#
+# Light sensors
+#
+# CONFIG_ADJD_S311 is not set
+# CONFIG_ADUX1020 is not set
+# CONFIG_AL3010 is not set
+# CONFIG_AL3320A is not set
+# CONFIG_APDS9300 is not set
+# CONFIG_APDS9960 is not set
+# CONFIG_AS73211 is not set
+# CONFIG_BH1750 is not set
+# CONFIG_BH1780 is not set
+# CONFIG_CM32181 is not set
+# CONFIG_CM3232 is not set
+# CONFIG_CM3323 is not set
+# CONFIG_CM3605 is not set
+# CONFIG_CM36651 is not set
+# CONFIG_GP2AP002 is not set
+# CONFIG_GP2AP020A00F is not set
+# CONFIG_IQS621_ALS is not set
+# CONFIG_SENSORS_ISL29018 is not set
+# CONFIG_SENSORS_ISL29028 is not set
+# CONFIG_ISL29125 is not set
+# CONFIG_JSA1212 is not set
+# CONFIG_RPR0521 is not set
+# CONFIG_LTR501 is not set
+# CONFIG_LV0104CS is not set
+# CONFIG_MAX44000 is not set
+# CONFIG_MAX44009 is not set
+# CONFIG_NOA1305 is not set
+# CONFIG_OPT3001 is not set
+# CONFIG_PA12203001 is not set
+# CONFIG_SI1133 is not set
+# CONFIG_SI1145 is not set
+# CONFIG_STK3310 is not set
+# CONFIG_ST_UVIS25 is not set
+# CONFIG_TCS3414 is not set
+# CONFIG_TCS3472 is not set
+# CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_TSL2583 is not set
+# CONFIG_TSL2772 is not set
+# CONFIG_TSL4531 is not set
+# CONFIG_US5182D is not set
+# CONFIG_VCNL4000 is not set
+# CONFIG_VCNL4035 is not set
+# CONFIG_VEML6030 is not set
+# CONFIG_VEML6070 is not set
+# CONFIG_VL6180 is not set
+# CONFIG_ZOPT2201 is not set
+# end of Light sensors
+
+#
+# Magnetometer sensors
+#
+# CONFIG_AK8974 is not set
+# CONFIG_AK8975 is not set
+# CONFIG_AK09911 is not set
+# CONFIG_BMC150_MAGN_I2C is not set
+# CONFIG_BMC150_MAGN_SPI is not set
+# CONFIG_MAG3110 is not set
+# CONFIG_MMC35240 is not set
+# CONFIG_IIO_ST_MAGN_3AXIS is not set
+# CONFIG_SENSORS_HMC5843_I2C is not set
+# CONFIG_SENSORS_HMC5843_SPI is not set
+# CONFIG_SENSORS_RM3100_I2C is not set
+# CONFIG_SENSORS_RM3100_SPI is not set
+# end of Magnetometer sensors
+
+#
+# Multiplexers
+#
+# CONFIG_IIO_MUX is not set
+# end of Multiplexers
+
+#
+# Inclinometer sensors
+#
+# end of Inclinometer sensors
+
+#
+# Linear and angular position sensors
+#
+# CONFIG_IQS624_POS is not set
+# end of Linear and angular position sensors
+
+#
+# Digital potentiometers
+#
+# CONFIG_AD5272 is not set
+# CONFIG_DS1803 is not set
+# CONFIG_MAX5432 is not set
+# CONFIG_MAX5481 is not set
+# CONFIG_MAX5487 is not set
+# CONFIG_MCP4018 is not set
+# CONFIG_MCP4131 is not set
+# CONFIG_MCP4531 is not set
+# CONFIG_MCP41010 is not set
+# CONFIG_TPL0102 is not set
+# end of Digital potentiometers
+
+#
+# Digital potentiostats
+#
+# CONFIG_LMP91000 is not set
+# end of Digital potentiostats
+
+#
+# Pressure sensors
+#
+# CONFIG_ABP060MG is not set
+# CONFIG_BMP280 is not set
+# CONFIG_DLHL60D is not set
+# CONFIG_DPS310 is not set
+# CONFIG_HP03 is not set
+# CONFIG_ICP10100 is not set
+# CONFIG_MPL115_I2C is not set
+# CONFIG_MPL115_SPI is not set
+# CONFIG_MPL3115 is not set
+# CONFIG_MS5611 is not set
+# CONFIG_MS5637 is not set
+# CONFIG_IIO_ST_PRESS is not set
+# CONFIG_T5403 is not set
+# CONFIG_HP206C is not set
+# CONFIG_ZPA2326 is not set
+# end of Pressure sensors
+
+#
+# Lightning sensors
+#
+# CONFIG_AS3935 is not set
+# end of Lightning sensors
+
+#
+# Proximity and distance sensors
+#
+# CONFIG_ISL29501 is not set
+# CONFIG_LIDAR_LITE_V2 is not set
+# CONFIG_MB1232 is not set
+# CONFIG_PING is not set
+# CONFIG_RFD77402 is not set
+# CONFIG_SRF04 is not set
+# CONFIG_SX9310 is not set
+# CONFIG_SX9500 is not set
+# CONFIG_SRF08 is not set
+# CONFIG_VCNL3020 is not set
+# CONFIG_VL53L0X_I2C is not set
+# end of Proximity and distance sensors
+
+#
+# Resolver to digital converters
+#
+# CONFIG_AD2S90 is not set
+# CONFIG_AD2S1200 is not set
+# end of Resolver to digital converters
+
+#
+# Temperature sensors
+#
+# CONFIG_IQS620AT_TEMP is not set
+# CONFIG_LTC2983 is not set
+# CONFIG_MAXIM_THERMOCOUPLE is not set
+# CONFIG_MLX90614 is not set
+# CONFIG_MLX90632 is not set
+# CONFIG_TMP006 is not set
+# CONFIG_TMP007 is not set
+# CONFIG_TSYS01 is not set
+# CONFIG_TSYS02D is not set
+# CONFIG_MAX31856 is not set
+# end of Temperature sensors
+
+CONFIG_PWM=y
+CONFIG_PWM_SYSFS=y
+# CONFIG_PWM_DEBUG is not set
+# CONFIG_PWM_ATMEL is not set
+# CONFIG_PWM_BCM_IPROC is not set
+# CONFIG_PWM_BCM_KONA is not set
+# CONFIG_PWM_BCM2835 is not set
+# CONFIG_PWM_BERLIN is not set
+# CONFIG_PWM_BRCMSTB is not set
+# CONFIG_PWM_CLPS711X is not set
+# CONFIG_PWM_EP93XX is not set
+# CONFIG_PWM_FSL_FTM is not set
+# CONFIG_PWM_HIBVT is not set
+# CONFIG_PWM_IMG is not set
+# CONFIG_PWM_IMX1 is not set
+# CONFIG_PWM_IMX27 is not set
+# CONFIG_PWM_IMX_TPM is not set
+# CONFIG_PWM_IQS620A is not set
+# CONFIG_PWM_LPC18XX_SCT is not set
+# CONFIG_PWM_LPC32XX is not set
+# CONFIG_PWM_MESON is not set
+# CONFIG_PWM_MTK_DISP is not set
+# CONFIG_PWM_MEDIATEK is not set
+# CONFIG_PWM_MXS is not set
+# CONFIG_PWM_OMAP_DMTIMER is not set
+# CONFIG_PWM_PCA9685 is not set
+# CONFIG_PWM_PXA is not set
+# CONFIG_PWM_RCAR is not set
+# CONFIG_PWM_RENESAS_TPU is not set
+# CONFIG_PWM_ROCKCHIP is not set
+# CONFIG_PWM_SAMSUNG is not set
+# CONFIG_PWM_SIFIVE is not set
+# CONFIG_PWM_SL28CPLD is not set
+# CONFIG_PWM_SPEAR is not set
+# CONFIG_PWM_SPRD is not set
+# CONFIG_PWM_STI is not set
+# CONFIG_PWM_STM32 is not set
+# CONFIG_PWM_STM32_LP is not set
+# CONFIG_PWM_SUN4I is not set
+# CONFIG_PWM_TEGRA is not set
+CONFIG_PWM_LIGHT=y
+# CONFIG_PWM_TIECAP is not set
+# CONFIG_PWM_TIEHRPWM is not set
+# CONFIG_PWM_VT8500 is not set
+# CONFIG_PWM_ZX is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+# CONFIG_AL_FIC is not set
+# CONFIG_JCORE_AIC is not set
+# CONFIG_RENESAS_INTC_IRQPIN is not set
+# CONFIG_RENESAS_IRQC is not set
+# CONFIG_RENESAS_RZA1_IRQC is not set
+# CONFIG_SL28CPLD_INTC is not set
+# CONFIG_TS4800_IRQ is not set
+# CONFIG_INGENIC_TCU_IRQ is not set
+# CONFIG_RENESAS_H8S_INTC is not set
+# CONFIG_IRQ_UNIPHIER_AIDET is not set
+# CONFIG_MESON_IRQ_GPIO is not set
+# CONFIG_IMX_IRQSTEER is not set
+# CONFIG_IMX_INTMUX is not set
+CONFIG_RISCV_INTC=y
+CONFIG_SIFIVE_PLIC=y
+# CONFIG_EXYNOS_IRQ_COMBINER is not set
+# CONFIG_LOONGSON_PCH_PIC is not set
+# CONFIG_MST_IRQ is not set
+# end of IRQ chip support
+
+# CONFIG_IPACK_BUS is not set
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_ATH79 is not set
+# CONFIG_RESET_AXS10X is not set
+# CONFIG_RESET_BERLIN is not set
+# CONFIG_RESET_BRCMSTB is not set
+# CONFIG_RESET_BRCMSTB_RESCAL is not set
+# CONFIG_RESET_HSDK is not set
+# CONFIG_RESET_IMX7 is not set
+# CONFIG_RESET_INTEL_GW is not set
+# CONFIG_RESET_LANTIQ is not set
+# CONFIG_RESET_LPC18XX is not set
+# CONFIG_RESET_MESON is not set
+# CONFIG_RESET_MESON_AUDIO_ARB is not set
+# CONFIG_RESET_NPCM is not set
+# CONFIG_RESET_PISTACHIO is not set
+# CONFIG_RESET_QCOM_AOSS is not set
+# CONFIG_RESET_QCOM_PDC is not set
+# CONFIG_RESET_RASPBERRYPI is not set
+# CONFIG_RESET_SCMI is not set
+# CONFIG_RESET_SIMPLE is not set
+# CONFIG_RESET_STM32MP157 is not set
+# CONFIG_RESET_SOCFPGA is not set
+# CONFIG_RESET_SUNXI is not set
+# CONFIG_RESET_TI_SYSCON is not set
+# CONFIG_RESET_UNIPHIER is not set
+# CONFIG_RESET_UNIPHIER_GLUE is not set
+# CONFIG_RESET_ZYNQ is not set
+CONFIG_RESET_LIGHT=y
+# CONFIG_COMMON_RESET_HI3660 is not set
+# CONFIG_COMMON_RESET_HI6220 is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+CONFIG_GENERIC_PHY_MIPI_DPHY=y
+# CONFIG_PHY_LPC18XX_USB_OTG is not set
+# CONFIG_PHY_XGENE is not set
+# CONFIG_USB_LGM_PHY is not set
+# CONFIG_PHY_SUN4I_USB is not set
+# CONFIG_PHY_SUN6I_MIPI_DPHY is not set
+# CONFIG_PHY_SUN9I_USB is not set
+# CONFIG_PHY_SUN50I_USB3 is not set
+# CONFIG_PHY_MESON8B_USB2 is not set
+# CONFIG_PHY_MESON_GXL_USB2 is not set
+# CONFIG_PHY_MESON_G12A_USB2 is not set
+# CONFIG_PHY_MESON_G12A_USB3_PCIE is not set
+# CONFIG_PHY_MESON_AXG_PCIE is not set
+# CONFIG_PHY_MESON_AXG_MIPI_PCIE_ANALOG is not set
+# CONFIG_PHY_BCM63XX_USBH is not set
+# CONFIG_PHY_CYGNUS_PCIE is not set
+# CONFIG_PHY_BCM_SR_USB is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_BCM_NS_USB2 is not set
+# CONFIG_PHY_BCM_NS_USB3 is not set
+# CONFIG_PHY_NS2_PCIE is not set
+# CONFIG_PHY_NS2_USB_DRD is not set
+# CONFIG_PHY_BRCM_SATA is not set
+# CONFIG_PHY_BRCM_USB is not set
+# CONFIG_PHY_BCM_SR_PCIE is not set
+# CONFIG_PHY_CADENCE_TORRENT is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_CADENCE_SIERRA is not set
+# CONFIG_PHY_CADENCE_SALVO is not set
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+# CONFIG_PHY_MIXEL_MIPI_DPHY is not set
+# CONFIG_PHY_HI6220_USB is not set
+# CONFIG_PHY_HI3660_USB is not set
+# CONFIG_PHY_HISTB_COMBPHY is not set
+# CONFIG_PHY_HISI_INNO_USB2 is not set
+# CONFIG_PHY_LANTIQ_VRX200_PCIE is not set
+# CONFIG_PHY_LANTIQ_RCU_USB2 is not set
+# CONFIG_ARMADA375_USBCLUSTER_PHY is not set
+# CONFIG_PHY_BERLIN_SATA is not set
+# CONFIG_PHY_BERLIN_USB is not set
+CONFIG_PHY_MVEBU_A3700_UTMI=y
+# CONFIG_PHY_MVEBU_A38X_COMPHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_PXA_USB is not set
+# CONFIG_PHY_MMP3_USB is not set
+# CONFIG_PHY_MTK_TPHY is not set
+# CONFIG_PHY_MTK_UFS is not set
+# CONFIG_PHY_MTK_XSPHY is not set
+# CONFIG_PHY_MTK_HDMI is not set
+# CONFIG_PHY_CPCAP_USB is not set
+# CONFIG_PHY_MAPPHONE_MDM6600 is not set
+# CONFIG_PHY_OCELOT_SERDES is not set
+# CONFIG_PHY_ATH79_USB is not set
+# CONFIG_PHY_QCOM_IPQ4019_USB is not set
+# CONFIG_PHY_QCOM_PCIE2 is not set
+# CONFIG_PHY_QCOM_QMP is not set
+# CONFIG_PHY_QCOM_QUSB2 is not set
+# CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2 is not set
+# CONFIG_PHY_QCOM_USB_HS_28NM is not set
+# CONFIG_PHY_QCOM_USB_SS is not set
+# CONFIG_PHY_QCOM_IPQ806X_USB is not set
+# CONFIG_PHY_RALINK_USB is not set
+# CONFIG_PHY_RCAR_GEN3_USB3 is not set
+# CONFIG_PHY_ROCKCHIP_DPHY_RX0 is not set
+# CONFIG_PHY_ROCKCHIP_INNO_HDMI is not set
+# CONFIG_PHY_ROCKCHIP_INNO_USB2 is not set
+# CONFIG_PHY_ROCKCHIP_INNO_DSIDPHY is not set
+# CONFIG_PHY_ROCKCHIP_PCIE is not set
+# CONFIG_PHY_ROCKCHIP_TYPEC is not set
+# CONFIG_PHY_EXYNOS_DP_VIDEO is not set
+# CONFIG_PHY_EXYNOS_MIPI_VIDEO is not set
+# CONFIG_PHY_EXYNOS_PCIE is not set
+# CONFIG_PHY_SAMSUNG_UFS is not set
+# CONFIG_PHY_SAMSUNG_USB2 is not set
+CONFIG_PHY_EXYNOS5_USBDRD=y
+# CONFIG_PHY_UNIPHIER_USB2 is not set
+# CONFIG_PHY_UNIPHIER_USB3 is not set
+# CONFIG_PHY_UNIPHIER_PCIE is not set
+# CONFIG_PHY_UNIPHIER_AHCI is not set
+# CONFIG_PHY_ST_SPEAR1310_MIPHY is not set
+# CONFIG_PHY_ST_SPEAR1340_MIPHY is not set
+# CONFIG_PHY_STIH407_USB is not set
+# CONFIG_PHY_STM32_USBPHYC is not set
+CONFIG_PHY_DW_DPHY=y
+# CONFIG_PHY_TEGRA194_P2U is not set
+# CONFIG_PHY_DA8XX_USB is not set
+# CONFIG_PHY_DM816X_USB is not set
+# CONFIG_PHY_AM654_SERDES is not set
+# CONFIG_PHY_J721E_WIZ is not set
+# CONFIG_OMAP_CONTROL_PHY is not set
+# CONFIG_TI_PIPE3 is not set
+# CONFIG_PHY_INTEL_KEEMBAY_EMMC is not set
+# CONFIG_PHY_INTEL_LGM_COMBO is not set
+# CONFIG_PHY_INTEL_LGM_EMMC is not set
+# CONFIG_PHY_XILINX_ZYNQMP is not set
+# end of PHY Subsystem
+
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+# CONFIG_ARM_CMN is not set
+# end of Performance monitor support
+
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+# CONFIG_ANDROID_BINDERFS is not set
+CONFIG_ANDROID_BINDER_DEVICES="binder,hwbinder,vndbinder"
+# CONFIG_ANDROID_BINDER_IPC_SELFTEST is not set
+CONFIG_BINDER_TRANSACTION_PROC_BRIEF=y
+# end of Android
+
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+CONFIG_NVMEM_SYSFS=y
+# CONFIG_NVMEM_IMX_IIM is not set
+# CONFIG_NVMEM_IMX_OCOTP is not set
+# CONFIG_JZ4780_EFUSE is not set
+# CONFIG_NVMEM_LPC18XX_EEPROM is not set
+# CONFIG_NVMEM_LPC18XX_OTP is not set
+CONFIG_NVMEM_THEAD_LIGHT_EFUSE=y
+# CONFIG_NVMEM_MXS_OCOTP is not set
+# CONFIG_MTK_EFUSE is not set
+# CONFIG_QCOM_QFPROM is not set
+# CONFIG_ROCKCHIP_EFUSE is not set
+# CONFIG_ROCKCHIP_OTP is not set
+# CONFIG_NVMEM_BCM_OCOTP is not set
+# CONFIG_NVMEM_STM32_ROMEM is not set
+# CONFIG_UNIPHIER_EFUSE is not set
+# CONFIG_NVMEM_VF610_OCOTP is not set
+# CONFIG_MESON_MX_EFUSE is not set
+# CONFIG_NVMEM_SNVS_LPGPR is not set
+# CONFIG_SC27XX_EFUSE is not set
+# CONFIG_SPRD_EFUSE is not set
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# end of HW tracing support
+
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_TEE is not set
+CONFIG_PM_OPP=y
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_INTERCONNECT is not set
+# CONFIG_COUNTER is not set
+CONFIG_DRIVERS_HDF=y
+CONFIG_HDF_SUPPORT_LEVEL=2
+CONFIG_DRIVERS_HDF_PLATFORM=y
+# CONFIG_DRIVERS_HDF_PLATFORM_MIPI_DSI is not set
+# CONFIG_DRIVERS_HDF_PLATFORM_MIPI_CSI is not set
+CONFIG_DRIVERS_HDF_PLATFORM_GPIO=y
+CONFIG_DRIVERS_HDF_PLATFORM_I2C=y
+# CONFIG_DRIVERS_HDF_PLATFORM_WATCHDOG is not set
+# CONFIG_DRIVERS_HDF_PLATFORM_PWM is not set
+# CONFIG_DRIVERS_HDF_PLATFORM_UART is not set
+# CONFIG_DRIVERS_HDF_PLATFORM_EMMC is not set
+# CONFIG_DRIVERS_HDF_PLATFORM_MMC is not set
+# CONFIG_DRIVERS_HDF_PLATFORM_SPI is not set
+# CONFIG_DRIVERS_HDF_PLATFORM_RTC is not set
+# CONFIG_PWM_HI35XX is not set
+# CONFIG_DRIVERS_HDF_PLATFORM_REGULATOR is not set
+# CONFIG_DRIVERS_HDF_PLATFORM_ADC is not set
+# CONFIG_DRIVERS_HDF_PLATFORM_TRACE is not set
+# CONFIG_DRIVERS_HDF_TEST is not set
+# CONFIG_DRIVERS_HDF_DISP is not set
+CONFIG_DRIVERS_HDF_INPUT=y
+# CONFIG_DRIVERS_HDF_TP_5P5_GT911 is not set
+CONFIG_DRIVERS_HDF_TP_C9XX_GT911=y
+# CONFIG_DRIVERS_HDF_TP_2P35_FT6236 is not set
+# CONFIG_DRIVERS_HDF_INPUT_INFRARED is not set
+# CONFIG_DRIVERS_HDF_NETDEV_EXT is not set
+# CONFIG_DRIVERS_HDF_BT is not set
+# CONFIG_DRIVERS_HDF_SENSOR is not set
+# CONFIG_DRIVERS_HDF_STORAGE is not set
+# CONFIG_DRIVERS_HDF_USB_PNP_NOTIFY is not set
+CONFIG_DRIVERS_HDF_AUDIO=y
+# CONFIG_DRIVERS_HDF_AUDIO_HI3516CODEC is not set
+CONFIG_DRIVERS_HDF_AUDIO_THEAD=y
+# CONFIG_DRIVERS_HDF_AUDIO_RK3568 is not set
+# CONFIG_DRIVERS_HDF_AUDIO_CAP_REPORT is not set
+# CONFIG_DRIVERS_HDF_AUDIO_TEST is not set
+# CONFIG_DRIVERS_HDF_VIBRATOR is not set
+# CONFIG_DRIVERS_HDF_DSOFTBUS is not set
+# CONFIG_DRIVERS_HDF_LIGHT is not set
+# CONFIG_MOST is not set
+
+#
+# Light Vivante GPU support
+#
+CONFIG_LIGHT_GPU_VIV=m
+# end of Light Vivante GPU support
+
+#
+# Light backend drivers
+#
+CONFIG_LIGHT_MAILBOX=y
+CONFIG_LIGHT_BLK=y
+# CONFIG_LIGHT_NET is not set
+# end of Light backend drivers
+
+CONFIG_ACCESS_TOKENID=y
+# end of Device Drivers
+
+#
+# File systems
+#
+# CONFIG_VALIDATE_FS_PARSER is not set
+CONFIG_FS_IOMAP=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT2=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_HMDFS_FS=y
+CONFIG_HMDFS_FS_PERMISSION=y
+CONFIG_HMDFS_FS_ENCRYPTION=y
+# CONFIG_HMDFS_FS_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_XFS_FS=y
+CONFIG_XFS_SUPPORT_V4=y
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_ONLINE_SCRUB is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_F2FS_FS=y
+CONFIG_F2FS_STAT_FS=y
+CONFIG_F2FS_FS_XATTR=y
+CONFIG_F2FS_FS_POSIX_ACL=y
+CONFIG_F2FS_FS_SECURITY=y
+# CONFIG_F2FS_CHECK_FS is not set
+# CONFIG_F2FS_FAULT_INJECTION is not set
+# CONFIG_F2FS_FS_COMPRESSION is not set
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+CONFIG_FS_ENCRYPTION=y
+CONFIG_FS_ENCRYPTION_ALGS=y
+# CONFIG_FS_ENCRYPTION_INLINE_CRYPT is not set
+# CONFIG_FS_VERITY is not set
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_AUTOFS_FS=y
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+# CONFIG_VIRTIO_FS is not set
+CONFIG_OVERLAY_FS=y
+# CONFIG_OVERLAY_FS_REDIRECT_DIR is not set
+CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW=y
+# CONFIG_OVERLAY_FS_INDEX is not set
+# CONFIG_OVERLAY_FS_XINO_AUTO is not set
+# CONFIG_OVERLAY_FS_METACOPY is not set
+# CONFIG_INCREMENTAL_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# end of Caches
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+# end of CD-ROM/DVD Filesystems
+
+#
+# DOS/FAT/EXFAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+CONFIG_EXFAT_FS=y
+CONFIG_NTFS_FS=y
+# end of DOS/FAT/EXFAT/NT Filesystems
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_PROC_VMCORE=y
+# CONFIG_PROC_VMCORE_DEVICE_DUMP is not set
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_TMPFS_INODE64 is not set
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_MEMFD_CREATE=y
+CONFIG_ARCH_HAS_GIGANTIC_PAGE=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_EFIVAR_FS=m
+# end of Pseudo filesystems
+
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+CONFIG_UBIFS_FS_ZSTD=y
+# CONFIG_UBIFS_ATIME_SUPPORT is not set
+CONFIG_UBIFS_FS_XATTR=y
+CONFIG_UBIFS_FS_SECURITY=y
+# CONFIG_UBIFS_FS_AUTHENTICATION is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+CONFIG_PSTORE_DEFLATE_COMPRESS=y
+# CONFIG_PSTORE_LZO_COMPRESS is not set
+# CONFIG_PSTORE_LZ4_COMPRESS is not set
+# CONFIG_PSTORE_LZ4HC_COMPRESS is not set
+# CONFIG_PSTORE_842_COMPRESS is not set
+# CONFIG_PSTORE_ZSTD_COMPRESS is not set
+CONFIG_PSTORE_COMPRESS=y
+CONFIG_PSTORE_DEFLATE_COMPRESS_DEFAULT=y
+CONFIG_PSTORE_COMPRESS_DEFAULT="deflate"
+CONFIG_PSTORE_CONSOLE=y
+# CONFIG_PSTORE_PMSG is not set
+CONFIG_PSTORE_RAM=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_EROFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_9P_FS=y
+# CONFIG_9P_FS_POSIX_ACL is not set
+# CONFIG_9P_FS_SECURITY is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+# CONFIG_UNICODE is not set
+CONFIG_IO_WQ=y
+# end of File systems
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_REQUEST_CACHE is not set
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+CONFIG_LSM_MMAP_MIN_ADDR=65536
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+CONFIG_HARDENED_USERCOPY=y
+CONFIG_HARDENED_USERCOPY_FALLBACK=y
+# CONFIG_HARDENED_USERCOPY_PAGESPAN is not set
+CONFIG_STATIC_USERMODEHELPER=y
+CONFIG_STATIC_USERMODEHELPER_PATH="/sbin/usermode-helper"
+CONFIG_SECURITY_SELINUX=y
+# CONFIG_SECURITY_SELINUX_BOOTPARAM is not set
+# CONFIG_SECURITY_SELINUX_DISABLE is not set
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=0
+CONFIG_SECURITY_SELINUX_SIDTAB_HASH_BITS=9
+CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE=256
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_LOADPIN is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_SECURITY_SAFESETID is not set
+# CONFIG_SECURITY_LOCKDOWN_LSM is not set
+CONFIG_INTEGRITY=y
+# CONFIG_INTEGRITY_SIGNATURE is not set
+CONFIG_INTEGRITY_AUDIT=y
+# CONFIG_IMA is not set
+# CONFIG_EVM is not set
+CONFIG_DEFAULT_SECURITY_SELINUX=y
+# CONFIG_DEFAULT_SECURITY_DAC is not set
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor,bpf"
+
+#
+# Kernel hardening options
+#
+
+#
+# Memory initialization
+#
+CONFIG_INIT_STACK_NONE=y
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+# end of Memory initialization
+# end of Kernel hardening options
+# end of Security options
+
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_SKCIPHER=y
+CONFIG_CRYPTO_SKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_KPP=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+CONFIG_CRYPTO_ENGINE=y
+
+#
+# Public-key cryptography
+#
+CONFIG_CRYPTO_RSA=y
+CONFIG_CRYPTO_DH=y
+CONFIG_CRYPTO_ECC=y
+CONFIG_CRYPTO_ECDH=y
+# CONFIG_CRYPTO_ECRDSA is not set
+# CONFIG_CRYPTO_SM2 is not set
+CONFIG_CRYPTO_CURVE25519=y
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_CHACHA20POLY1305=y
+# CONFIG_CRYPTO_AEGIS128 is not set
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ECHAINIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CFB is not set
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_OFB=y
+# CONFIG_CRYPTO_PCBC is not set
+CONFIG_CRYPTO_XTS=y
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_ADIANTUM is not set
+CONFIG_CRYPTO_ESSIV=y
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_XCBC=y
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRC32=y
+# CONFIG_CRYPTO_XXHASH is not set
+# CONFIG_CRYPTO_BLAKE2B is not set
+# CONFIG_CRYPTO_BLAKE2S is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+CONFIG_CRYPTO_GHASH=y
+CONFIG_CRYPTO_POLY1305=y
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_SHA3=y
+CONFIG_CRYPTO_SM3=y
+# CONFIG_CRYPTO_STREEBOG is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+CONFIG_CRYPTO_CHACHA20=y
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+CONFIG_CRYPTO_ZSTD=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+CONFIG_CRYPTO_USER_API=y
+CONFIG_CRYPTO_USER_API_HASH=y
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_USER_API_ENABLE_OBSOLETE=y
+CONFIG_CRYPTO_HASH_INFO=y
+
+#
+# Crypto library routines
+#
+CONFIG_CRYPTO_LIB_AES=y
+CONFIG_CRYPTO_LIB_ARC4=y
+# CONFIG_CRYPTO_LIB_BLAKE2S is not set
+CONFIG_CRYPTO_LIB_CHACHA_GENERIC=y
+# CONFIG_CRYPTO_LIB_CHACHA is not set
+CONFIG_CRYPTO_LIB_CURVE25519_GENERIC=y
+# CONFIG_CRYPTO_LIB_CURVE25519 is not set
+CONFIG_CRYPTO_LIB_DES=y
+CONFIG_CRYPTO_LIB_POLY1305_RSIZE=1
+CONFIG_CRYPTO_LIB_POLY1305_GENERIC=y
+# CONFIG_CRYPTO_LIB_POLY1305 is not set
+# CONFIG_CRYPTO_LIB_CHACHA20POLY1305 is not set
+CONFIG_CRYPTO_LIB_SHA256=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_ALLWINNER is not set
+# CONFIG_CRYPTO_DEV_PICOXCELL is not set
+# CONFIG_CRYPTO_DEV_EXYNOS_RNG is not set
+# CONFIG_CRYPTO_DEV_S5P is not set
+# CONFIG_CRYPTO_DEV_ATMEL_AES is not set
+# CONFIG_CRYPTO_DEV_ATMEL_TDES is not set
+# CONFIG_CRYPTO_DEV_ATMEL_SHA is not set
+# CONFIG_CRYPTO_DEV_ATMEL_ECC is not set
+# CONFIG_CRYPTO_DEV_ATMEL_SHA204A is not set
+# CONFIG_CRYPTO_DEV_QCE is not set
+# CONFIG_CRYPTO_DEV_QCOM_RNG is not set
+# CONFIG_CRYPTO_DEV_IMGTEC_HASH is not set
+# CONFIG_CRYPTO_DEV_ZYNQMP_AES is not set
+# CONFIG_CRYPTO_DEV_MEDIATEK is not set
+# CONFIG_CRYPTO_DEV_VIRTIO is not set
+# CONFIG_CRYPTO_DEV_SAFEXCEL is not set
+# CONFIG_CRYPTO_DEV_CCREE is not set
+# CONFIG_CRYPTO_DEV_HISI_SEC is not set
+# CONFIG_CRYPTO_DEV_AMLOGIC_GXL is not set
+# CONFIG_CRYPTO_DEV_SA2UL is not set
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+# CONFIG_PKCS8_PRIVATE_KEY_PARSER is not set
+CONFIG_PKCS7_MESSAGE_PARSER=y
+# CONFIG_PKCS7_TEST_KEY is not set
+# CONFIG_SIGNED_PE_FILE_VERIFICATION is not set
+
+#
+# Certificates for signature checking
+#
+CONFIG_SYSTEM_TRUSTED_KEYRING=y
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+# CONFIG_SYSTEM_EXTRA_CERTIFICATE is not set
+# CONFIG_SECONDARY_TRUSTED_KEYRING is not set
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+# end of Certificates for signature checking
+
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_LINEAR_RANGES=y
+# CONFIG_PACKING is not set
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+# CONFIG_CORDIC is not set
+# CONFIG_PRIME_NUMBERS is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_PCI_IOMAP=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_XXHASH=y
+CONFIG_AUDIT_GENERIC=y
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_ZSTD_COMPRESS=y
+CONFIG_ZSTD_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_DECOMPRESS_ZSTD=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_INTERVAL_TREE=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_ARCH_HAS_DMA_WRITE_COMBINE=y
+CONFIG_DMA_DECLARE_COHERENT=y
+CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE=y
+CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU=y
+CONFIG_ARCH_HAS_DMA_PREP_COHERENT=y
+CONFIG_SWIOTLB=y
+CONFIG_DMA_NONCOHERENT_MMAP=y
+CONFIG_DMA_COHERENT_POOL=y
+CONFIG_DMA_REMAP=y
+CONFIG_DMA_DIRECT_REMAP=y
+CONFIG_DMA_CMA=y
+CONFIG_DMA_PERNUMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=32
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_SGL_ALLOC=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_CLZ_TAB=y
+# CONFIG_IRQ_POLL is not set
+CONFIG_MPILIB=y
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_UCS2_STRING=y
+CONFIG_HAVE_GENERIC_VDSO=y
+CONFIG_GENERIC_GETTIMEOFDAY=y
+CONFIG_FONT_SUPPORT=y
+CONFIG_FONT_8x16=y
+CONFIG_FONT_AUTOSELECT=y
+CONFIG_SG_POOL=y
+CONFIG_SBITMAP=y
+# CONFIG_PARMAN is not set
+# CONFIG_OBJAGG is not set
+# CONFIG_STRING_SELFTEST is not set
+# end of Library routines
+
+CONFIG_GENERIC_IOREMAP=y
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+# CONFIG_PRINTK_CALLER is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DYNAMIC_DEBUG_CORE=y
+CONFIG_SYMBOLIC_ERRNAME=y
+# end of printk and dmesg options
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_HEADERS_INSTALL is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_FUNCTION_ALIGN_32B is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# end of Compile-time checks and compiler options
+
+#
+# Generic Kernel Debugging Instruments
+#
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_MAGIC_SYSRQ_SERIAL_SEQUENCE=""
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_FS_ALLOW_ALL=y
+# CONFIG_DEBUG_FS_DISALLOW_MOUNT is not set
+# CONFIG_DEBUG_FS_ALLOW_NONE is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARCH_KGDB_QXFER_PKT=y
+# CONFIG_KGDB is not set
+# CONFIG_UBSAN is not set
+# end of Generic Kernel Debugging Instruments
+
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_MISC=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_PAGE_PINNER is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_PAGE_REF is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+CONFIG_ARCH_HAS_DEBUG_WX=y
+# CONFIG_DEBUG_WX is not set
+CONFIG_GENERIC_PTDUMP=y
+# CONFIG_PTDUMP_DEBUGFS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+CONFIG_ARCH_HAS_DEBUG_VM_PGTABLE=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VM_PGTABLE is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_ARCH_KASAN=y
+CONFIG_CC_HAS_WORKING_NOSANITIZE_ADDRESS=y
+# end of Memory Debugging
+
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Oops, Lockups and Hangs
+#
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=5
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_TEST_LOCKUP is not set
+# end of Debug Oops, Lockups and Hangs
+
+#
+# Scheduler Debugging
+#
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+# end of Scheduler Debugging
+
+# CONFIG_DEBUG_TIMEKEEPING is not set
+CONFIG_DEBUG_PREEMPT=y
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_SCF_TORTURE_TEST is not set
+# CONFIG_CSD_LOCK_WAIT_DEBUG is not set
+# end of Lock Debugging (spinlocks, mutexes, etc...)
+
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+
+#
+# Debug kernel data structures
+#
+CONFIG_DEBUG_LIST=y
+# CONFIG_DEBUG_PLIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# end of Debug kernel data structures
+
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_SCALE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_REF_SCALE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# end of RCU Debugging
+
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+# CONFIG_TRACEFS_DISABLE_AUTOMOUNT is not set
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_BOOTTIME_TRACING is not set
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_HWLAT_TRACER is not set
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+# CONFIG_FTRACE_SYSCALLS is not set
+# CONFIG_TRACER_SNAPSHOT is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+CONFIG_UPROBE_EVENTS=y
+CONFIG_BPF_EVENTS=y
+CONFIG_DYNAMIC_EVENTS=y
+CONFIG_PROBE_EVENTS=y
+# CONFIG_SYNTH_EVENTS is not set
+# CONFIG_TRACE_EVENT_INJECT is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_TRACE_EVAL_MAP_FILE is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_PREEMPTIRQ_DELAY_TEST is not set
+# CONFIG_SAMPLES is not set
+# CONFIG_STRICT_DEVMEM is not set
+
+#
+# riscv Debugging
+#
+
+#
+# Kernel Testing and Coverage
+#
+# CONFIG_KUNIT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_MIN_HEAP is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_REED_SOLOMON_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_STRSCPY is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_XARRAY is not set
+# CONFIG_TEST_OVERFLOW is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_BITOPS is not set
+# CONFIG_TEST_VMALLOC is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_BLACKHOLE_DEV is not set
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_KMOD is not set
+# CONFIG_TEST_MEMCAT_P is not set
+# CONFIG_TEST_STACKINIT is not set
+# CONFIG_TEST_MEMINIT is not set
+# CONFIG_TEST_FREE_PAGES is not set
+# CONFIG_MEMTEST is not set
+# end of Kernel Testing and Coverage
+
+# CONFIG_WARN_MISSING_DOCUMENTS is not set
+# CONFIG_WARN_ABI_ERRORS is not set
+# end of Kernel hacking
+# 1.2.0 add
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_THEAD_ISA=y
+
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_SM4=y
+
+#CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_USER_API_RNG=y
+CONFIG_CRYPTO_USER_API_AEAD=y
+
+#CONFIG_SCHED_INFO=y
+CONFIG_STMMAC_RX_ZERO_COPY=y
+CONFIG_EXTCON=y
+
+#CONFIG_RPMSG=y
+#CONFIG_RPMSG_CHAR=y
+#CONFIG_RPMSG_VIRTIO=y
+#CONFIG_RPMSG_THEAD_LIGHT=y
+
diff --git a/arch/riscv/include/asm/Kbuild b/arch/riscv/include/asm/Kbuild
index 445ccc973..240452e38 100644
--- a/arch/riscv/include/asm/Kbuild
+++ b/arch/riscv/include/asm/Kbuild
@@ -3,5 +3,8 @@ generic-y += early_ioremap.h
 generic-y += extable.h
 generic-y += flat.h
 generic-y += kvm_para.h
+generic-y += mcs_spinlock.h
+generic-y += qspinlock.h
+generic-y += qrwlock.h
 generic-y += user.h
 generic-y += vmlinux.lds.h
diff --git a/arch/riscv/include/asm/asid.h b/arch/riscv/include/asm/asid.h
new file mode 100755
index 000000000..ac08b0ffb
--- /dev/null
+++ b/arch/riscv/include/asm/asid.h
@@ -0,0 +1,78 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ASM_ASM_ASID_H
+#define __ASM_ASM_ASID_H
+
+#include <linux/atomic.h>
+#include <linux/compiler.h>
+#include <linux/cpumask.h>
+#include <linux/percpu.h>
+#include <linux/spinlock.h>
+
+struct asid_info
+{
+	atomic64_t	generation;
+	unsigned long	*map;
+	atomic64_t __percpu	*active;
+	u64 __percpu		*reserved;
+	u32			bits;
+	/* Lock protecting the structure */
+	raw_spinlock_t		lock;
+	/* Which CPU requires context flush on next call */
+	cpumask_t		flush_pending;
+	/* Number of ASID allocated by context (shift value) */
+	unsigned int		ctxt_shift;
+	/* Callback to locally flush the context. */
+	void			(*flush_cpu_ctxt_cb)(void);
+};
+
+#define NUM_ASIDS(info)			(1UL << ((info)->bits))
+#define NUM_CTXT_ASIDS(info)		(NUM_ASIDS(info) >> (info)->ctxt_shift)
+
+#define active_asid(info, cpu)	*per_cpu_ptr((info)->active, cpu)
+
+void asid_new_context(struct asid_info *info, atomic64_t *pasid,
+		      unsigned int cpu, struct mm_struct *mm);
+
+/*
+ * Check the ASID is still valid for the context. If not generate a new ASID.
+ *
+ * @pasid: Pointer to the current ASID batch
+ * @cpu: current CPU ID. Must have been acquired throught get_cpu()
+ */
+static inline void asid_check_context(struct asid_info *info,
+				      atomic64_t *pasid, unsigned int cpu,
+				      struct mm_struct *mm)
+{
+	u64 asid, old_active_asid;
+
+	asid = atomic64_read(pasid);
+
+	/*
+	 * The memory ordering here is subtle.
+	 * If our active_asid is non-zero and the ASID matches the current
+	 * generation, then we update the active_asid entry with a relaxed
+	 * cmpxchg. Racing with a concurrent rollover means that either:
+	 *
+	 * - We get a zero back from the cmpxchg and end up waiting on the
+	 *   lock. Taking the lock synchronises with the rollover and so
+	 *   we are forced to see the updated generation.
+	 *
+	 * - We get a valid ASID back from the cmpxchg, which means the
+	 *   relaxed xchg in flush_context will treat us as reserved
+	 *   because atomic RmWs are totally ordered for a given location.
+	 */
+	old_active_asid = atomic64_read(&active_asid(info, cpu));
+	if (old_active_asid &&
+	    !((asid ^ atomic64_read(&info->generation)) >> info->bits) &&
+	    atomic64_cmpxchg_relaxed(&active_asid(info, cpu),
+				     old_active_asid, asid))
+		return;
+
+	asid_new_context(info, pasid, cpu, mm);
+}
+
+int asid_allocator_init(struct asid_info *info,
+			u32 bits, unsigned int asid_per_ctxt,
+			void (*flush_cpu_ctxt_cb)(void));
+
+#endif
diff --git a/arch/riscv/include/asm/cache.h b/arch/riscv/include/asm/cache.h
index 9b58b1045..6c616ebf2 100644
--- a/arch/riscv/include/asm/cache.h
+++ b/arch/riscv/include/asm/cache.h
@@ -11,6 +11,8 @@
 
 #define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
 
+#define ARCH_DMA_MINALIGN      L1_CACHE_BYTES
+
 /*
  * RISC-V requires the stack pointer to be 16-byte aligned, so ensure that
  * the flat loader aligns it accordingly.
diff --git a/arch/riscv/include/asm/cacheflush.h b/arch/riscv/include/asm/cacheflush.h
index 23ff70350..a4d3ce5b9 100644
--- a/arch/riscv/include/asm/cacheflush.h
+++ b/arch/riscv/include/asm/cacheflush.h
@@ -42,6 +42,9 @@ void flush_icache_mm(struct mm_struct *mm, bool local);
 
 #endif /* CONFIG_SMP */
 
+void dma_wbinv_range(unsigned long start, unsigned long end);
+void dma_wb_range(unsigned long start, unsigned long end);
+
 /*
  * Bits in sys_riscv_flush_icache()'s flags argument.
  */
diff --git a/arch/riscv/include/asm/cmpxchg.h b/arch/riscv/include/asm/cmpxchg.h
index 262e5bbb2..fe0d9a037 100644
--- a/arch/riscv/include/asm/cmpxchg.h
+++ b/arch/riscv/include/asm/cmpxchg.h
@@ -11,12 +11,36 @@
 #include <asm/barrier.h>
 #include <asm/fence.h>
 
+static inline ulong __xchg16_relaxed(ulong new, void *ptr)
+{
+       ulong ret, tmp;
+       ulong shif = ((ulong)ptr & 2) ? 16 : 0;
+       ulong mask = 0xffff << shif;
+       ulong *__ptr = (ulong *)((ulong)ptr & ~2);
+
+       __asm__ __volatile__ (
+               "0:     lr.w %0, %2\n"
+               "       and  %1, %0, %z3\n"
+               "       or   %1, %1, %z4\n"
+               "       sc.w %1, %1, %2\n"
+               "       bnez %1, 0b\n"
+               : "=&r" (ret), "=&r" (tmp), "+A" (*__ptr)
+               : "rJ" (~mask), "rJ" (new << shif)
+               : "memory");
+
+       return (ulong)((ret & mask) >> shif);
+}
+
 #define __xchg_relaxed(ptr, new, size)					\
 ({									\
 	__typeof__(ptr) __ptr = (ptr);					\
 	__typeof__(new) __new = (new);					\
 	__typeof__(*(ptr)) __ret;					\
 	switch (size) {							\
+        case 2: {                                                       \
+                __ret = (__typeof__(*(ptr)))                            \
+                         __xchg16_relaxed((ulong)__new, __ptr);         \
+                break;}                                                 \
 	case 4:								\
 		__asm__ __volatile__ (					\
 			"	amoswap.w %0, %2, %1\n"			\
diff --git a/arch/riscv/include/asm/compat.h b/arch/riscv/include/asm/compat.h
new file mode 100755
index 000000000..0198b8d00
--- /dev/null
+++ b/arch/riscv/include/asm/compat.h
@@ -0,0 +1,272 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#ifndef __ASM_COMPAT_H
+#define __ASM_COMPAT_H
+
+#define compat_mode_t	compat_mode_t
+typedef u16		compat_mode_t;
+
+/*
+ * Architecture specific compatibility types
+ */
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/sched/task_stack.h>
+#include <asm-generic/compat.h>
+
+#define COMPAT_USER_HZ		100
+#define COMPAT_UTS_MACHINE	"riscv\0\0"
+
+#define _COMPAT_NSIG		_NSIG
+#define _COMPAT_NSIG_BPW	32
+
+typedef compat_uint_t	__compat_uid_t;
+typedef compat_uint_t	__compat_gid_t;
+typedef compat_uint_t	__compat_uid32_t;
+typedef compat_uint_t	__compat_gid32_t;
+typedef compat_uint_t	compat_dev_t;
+typedef compat_int_t	compat_ipc_pid_t;
+
+typedef u32             compat_sigset_word;
+typedef u32		compat_caddr_t;
+struct compat_stat {
+	compat_ulong_t	st_dev;
+	compat_ulong_t	st_ino;
+	compat_uint_t	st_mode;
+	compat_uint_t	st_nlink;
+	compat_uint_t	st_uid;
+	compat_uint_t	st_gid;
+	compat_ulong_t	st_rdev;
+	compat_ulong_t	__pad1;
+	compat_long_t	st_size;
+	compat_int_t	st_blksize;
+	compat_int_t	__pad2;
+	compat_long_t	st_blocks;
+	compat_long_t	st_atime;
+	compat_ulong_t	st_atime_nsec;
+	compat_long_t	st_mtime;
+	compat_ulong_t	st_mtime_nsec;
+	compat_long_t	st_ctime;
+	compat_ulong_t	st_ctime_nsec;
+	compat_uint_t	__unused4;
+	compat_uint_t	__unused5;
+};
+
+struct compat_flock {
+	compat_short_t	l_type;
+	compat_short_t	l_whence;
+	compat_off_t	l_start;
+	compat_off_t	l_len;
+	compat_pid_t	l_pid;
+	/* No __ARCH_FLOCK_PAD in riscv */
+};
+
+#define F_GETLK64	12
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
+struct compat_flock64 {
+	compat_short_t	l_type;
+	compat_short_t	l_whence;
+	compat_loff_t	l_start;
+	compat_loff_t	l_len;
+	compat_pid_t	l_pid;
+	/* No __ARCH_FLOCK64_PAD in riscv */
+};
+
+struct compat_statfs {
+	compat_uint_t	f_type;
+	compat_uint_t	f_bsize;
+	compat_uint_t	f_blocks;
+	compat_uint_t	f_bfree;
+	compat_uint_t	f_bavail;
+	compat_uint_t	f_files;
+	compat_uint_t	f_ffree;
+	__kernel_fsid_t	f_fsid;
+	compat_uint_t	f_namelen;
+	compat_uint_t	f_frsize;
+	compat_uint_t	f_flags;
+	compat_uint_t	f_spare[4];
+};
+
+#define COMPAT_RLIM_INFINITY	0x7fffffff
+#define COMPAT_OFF_T_MAX	COMPAT_RLIM_INFINITY
+
+#define compat_user_stack_pointer() (user_stack_pointer(task_pt_regs(current)))
+static inline void __user *arch_compat_alloc_user_space(long len)
+{
+	return (void __user *)compat_user_stack_pointer() - len;
+}
+
+struct compat_ipc64_perm {
+	compat_key_t key;
+	__compat_uid32_t uid;
+	__compat_gid32_t gid;
+	__compat_uid32_t cuid;
+	__compat_gid32_t cgid;
+	compat_mode_t	mode;
+	unsigned char	__pad1[4 - sizeof(compat_mode_t)];
+	compat_ushort_t	seq;
+	compat_ushort_t	__pad2;
+	compat_ulong_t	unused1;
+	compat_ulong_t	unused2;
+};
+
+struct compat_semid64_ds {
+	struct compat_ipc64_perm sem_perm;
+	compat_ulong_t sem_otime;
+	compat_ulong_t sem_otime_high;
+	compat_ulong_t sem_ctime;
+	compat_ulong_t sem_ctime_high;
+	compat_ulong_t sem_nsems;
+	compat_ulong_t __unused3;
+	compat_ulong_t __unused4;
+};
+
+struct compat_msqid64_ds {
+	struct compat_ipc64_perm msg_perm;
+	compat_ulong_t msg_stime;
+	compat_ulong_t msg_stime_high;
+	compat_ulong_t msg_rtime;
+	compat_ulong_t msg_rtime_high;
+	compat_ulong_t msg_ctime;
+	compat_ulong_t msg_ctime_high;
+	compat_ulong_t msg_cbytes;
+	compat_ulong_t msg_qnum;
+	compat_ulong_t msg_qbytes;
+	compat_pid_t   msg_lspid;
+	compat_pid_t   msg_lrpid;
+	compat_ulong_t __unused4;
+	compat_ulong_t __unused5;
+};
+
+struct compat_shmid64_ds {
+	struct compat_ipc64_perm shm_perm;
+	compat_size_t  shm_segsz;
+	compat_ulong_t shm_atime;
+	compat_ulong_t shm_atime_high;
+	compat_ulong_t shm_dtime;
+	compat_ulong_t shm_dtime_high;
+	compat_ulong_t shm_ctime;
+	compat_ulong_t shm_ctime_high;
+	compat_pid_t   shm_cpid;
+	compat_pid_t   shm_lpid;
+	compat_ulong_t shm_nattch;
+	compat_ulong_t __unused4;
+	compat_ulong_t __unused5;
+};
+
+static inline int is_compat_task(void)
+{
+	return test_thread_flag(TIF_32BIT);
+}
+
+struct compat_user_regs_struct {
+	compat_ulong_t pc;
+	compat_ulong_t ra;
+	compat_ulong_t sp;
+	compat_ulong_t gp;
+	compat_ulong_t tp;
+	compat_ulong_t t0;
+	compat_ulong_t t1;
+	compat_ulong_t t2;
+	compat_ulong_t s0;
+	compat_ulong_t s1;
+	compat_ulong_t a0;
+	compat_ulong_t a1;
+	compat_ulong_t a2;
+	compat_ulong_t a3;
+	compat_ulong_t a4;
+	compat_ulong_t a5;
+	compat_ulong_t a6;
+	compat_ulong_t a7;
+	compat_ulong_t s2;
+	compat_ulong_t s3;
+	compat_ulong_t s4;
+	compat_ulong_t s5;
+	compat_ulong_t s6;
+	compat_ulong_t s7;
+	compat_ulong_t s8;
+	compat_ulong_t s9;
+	compat_ulong_t s10;
+	compat_ulong_t s11;
+	compat_ulong_t t3;
+	compat_ulong_t t4;
+	compat_ulong_t t5;
+	compat_ulong_t t6;
+};
+
+static inline void regs_to_cregs(struct compat_user_regs_struct *cregs,
+				 struct pt_regs *regs)
+{
+	cregs->pc = (compat_ulong_t) regs->epc;
+	cregs->ra = (compat_ulong_t) regs->ra;
+	cregs->sp = (compat_ulong_t) regs->sp;
+	cregs->gp = (compat_ulong_t) regs->gp;
+	cregs->tp = (compat_ulong_t) regs->tp;
+	cregs->t0 = (compat_ulong_t) regs->t0;
+	cregs->t1 = (compat_ulong_t) regs->t1;
+	cregs->t2 = (compat_ulong_t) regs->t2;
+	cregs->s0 = (compat_ulong_t) regs->s0;
+	cregs->s1 = (compat_ulong_t) regs->s1;
+	cregs->a0 = (compat_ulong_t) regs->a0;
+	cregs->a1 = (compat_ulong_t) regs->a1;
+	cregs->a2 = (compat_ulong_t) regs->a2;
+	cregs->a3 = (compat_ulong_t) regs->a3;
+	cregs->a4 = (compat_ulong_t) regs->a4;
+	cregs->a5 = (compat_ulong_t) regs->a5;
+	cregs->a6 = (compat_ulong_t) regs->a6;
+	cregs->a7 = (compat_ulong_t) regs->a7;
+	cregs->s2 = (compat_ulong_t) regs->s2;
+	cregs->s3 = (compat_ulong_t) regs->s3;
+	cregs->s4 = (compat_ulong_t) regs->s4;
+	cregs->s5 = (compat_ulong_t) regs->s5;
+	cregs->s6 = (compat_ulong_t) regs->s6;
+	cregs->s7 = (compat_ulong_t) regs->s7;
+	cregs->s8 = (compat_ulong_t) regs->s8;
+	cregs->s9 = (compat_ulong_t) regs->s9;
+	cregs->s10 = (compat_ulong_t) regs->s10;
+	cregs->s11 = (compat_ulong_t) regs->s11;
+	cregs->t3 = (compat_ulong_t) regs->t3;
+	cregs->t4 = (compat_ulong_t) regs->t4;
+	cregs->t5 = (compat_ulong_t) regs->t5;
+	cregs->t6 = (compat_ulong_t) regs->t6;
+};
+
+static inline void cregs_to_regs(struct compat_user_regs_struct *cregs,
+				 struct pt_regs *regs)
+{
+	regs->epc = (unsigned long) cregs->pc;
+	regs->ra = (unsigned long) cregs->ra;
+	regs->sp = (unsigned long) cregs->sp;
+	regs->gp = (unsigned long) cregs->gp;
+	regs->tp = (unsigned long) cregs->tp;
+	regs->t0 = (unsigned long) cregs->t0;
+	regs->t1 = (unsigned long) cregs->t1;
+	regs->t2 = (unsigned long) cregs->t2;
+	regs->s0 = (unsigned long) cregs->s0;
+	regs->s1 = (unsigned long) cregs->s1;
+	regs->a0 = (unsigned long) cregs->a0;
+	regs->a1 = (unsigned long) cregs->a1;
+	regs->a2 = (unsigned long) cregs->a2;
+	regs->a3 = (unsigned long) cregs->a3;
+	regs->a4 = (unsigned long) cregs->a4;
+	regs->a5 = (unsigned long) cregs->a5;
+	regs->a6 = (unsigned long) cregs->a6;
+	regs->a7 = (unsigned long) cregs->a7;
+	regs->s2 = (unsigned long) cregs->s2;
+	regs->s3 = (unsigned long) cregs->s3;
+	regs->s4 = (unsigned long) cregs->s4;
+	regs->s5 = (unsigned long) cregs->s5;
+	regs->s6 = (unsigned long) cregs->s6;
+	regs->s7 = (unsigned long) cregs->s7;
+	regs->s8 = (unsigned long) cregs->s8;
+	regs->s9 = (unsigned long) cregs->s9;
+	regs->s10 = (unsigned long) cregs->s10;
+	regs->s11 = (unsigned long) cregs->s11;
+	regs->t3 = (unsigned long) cregs->t3;
+	regs->t4 = (unsigned long) cregs->t4;
+	regs->t5 = (unsigned long) cregs->t5;
+	regs->t6 = (unsigned long) cregs->t6;
+};
+
+#endif /* __ASM_COMPAT_H */
diff --git a/arch/riscv/include/asm/cpuidle.h b/arch/riscv/include/asm/cpuidle.h
new file mode 100755
index 000000000..71fdc607d
--- /dev/null
+++ b/arch/riscv/include/asm/cpuidle.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Allwinner Ltd
+ * Copyright (C) 2021 Western Digital Corporation or its affiliates.
+ */
+
+#ifndef _ASM_RISCV_CPUIDLE_H
+#define _ASM_RISCV_CPUIDLE_H
+
+#include <asm/barrier.h>
+#include <asm/processor.h>
+
+static inline void cpu_do_idle(void)
+{
+	/*
+	 * Add mb() here to ensure that all
+	 * IO/MEM accesses are completed prior
+	 * to entering WFI.
+	 */
+	mb();
+	wait_for_interrupt();
+}
+
+#endif
diff --git a/arch/riscv/include/asm/csr.h b/arch/riscv/include/asm/csr.h
index cec462e19..2eab1caf4 100644
--- a/arch/riscv/include/asm/csr.h
+++ b/arch/riscv/include/asm/csr.h
@@ -24,6 +24,21 @@
 #define SR_FS_CLEAN	_AC(0x00004000, UL)
 #define SR_FS_DIRTY	_AC(0x00006000, UL)
 
+#define SR_VS_OFF	_AC(0x00000000, UL)
+
+#if (defined(CONFIG_VECTOR_1_0) && defined(__THEAD_VERSION__))
+#define SR_VS		_AC(0x00000600, UL) /* Vector Status */
+#define SR_VS_INITIAL	_AC(0x00000200, UL)
+#define SR_VS_CLEAN	_AC(0x00000400, UL)
+#define SR_VS_DIRTY	_AC(0x00000600, UL)
+#else
+#define SR_VS		_AC(0x01800000, UL) /* Vector Status */
+#define SR_VS_INITIAL	_AC(0x00800000, UL)
+#define SR_VS_CLEAN	_AC(0x01000000, UL)
+#define SR_VS_DIRTY	_AC(0x01800000, UL)
+
+#endif
+
 #define SR_XS		_AC(0x00018000, UL) /* Extension Status */
 #define SR_XS_OFF	_AC(0x00000000, UL)
 #define SR_XS_INITIAL	_AC(0x00008000, UL)
@@ -36,6 +51,13 @@
 #define SR_SD		_AC(0x8000000000000000, UL) /* FS/XS dirty */
 #endif
 
+#ifdef CONFIG_COMPAT
+#define SR_UXL		_AC(0x300000000, UL) /* XLEN mask for U-mode */
+#define SR_UXL_32	_AC(0x100000000, UL) /* XLEN = 32 for U-mode */
+#define SR_UXL_64	_AC(0x200000000, UL) /* XLEN = 64 for U-mode */
+#define SR_UXL_SHIFT	32
+#endif
+
 /* SATP flags */
 #ifndef CONFIG_64BIT
 #define SATP_PPN	_AC(0x003FFFFF, UL)
@@ -45,6 +67,9 @@
 #define SATP_PPN	_AC(0x00000FFFFFFFFFFF, UL)
 #define SATP_MODE_39	_AC(0x8000000000000000, UL)
 #define SATP_MODE	SATP_MODE_39
+#define SATP_ASID_BITS	16
+#define SATP_ASID_SHIFT	44
+#define SATP_ASID_MASK	_AC(0xFFFF, UL)
 #endif
 
 /* Exception cause high bit - is an interrupt if set */
@@ -111,6 +136,13 @@
 #define CSR_PMPADDR0		0x3b0
 #define CSR_MHARTID		0xf14
 
+#define CSR_VSTART		0x8
+#define CSR_VXSAT		0x9
+#define CSR_VXRM		0xa
+#define CSR_VL			0xc20
+#define CSR_VTYPE		0xc21
+#define CSR_VLENB		0xc22
+
 #ifdef CONFIG_RISCV_M_MODE
 # define CSR_STATUS	CSR_MSTATUS
 # define CSR_IE		CSR_MIE
diff --git a/arch/riscv/include/asm/elf.h b/arch/riscv/include/asm/elf.h
index 5c725e1df..4c5797f44 100644
--- a/arch/riscv/include/asm/elf.h
+++ b/arch/riscv/include/asm/elf.h
@@ -8,6 +8,8 @@
 #ifndef _ASM_RISCV_ELF_H
 #define _ASM_RISCV_ELF_H
 
+#include <uapi/linux/elf.h>
+#include <linux/compat.h>
 #include <uapi/asm/elf.h>
 #include <asm/auxvec.h>
 #include <asm/byteorder.h>
@@ -18,11 +20,13 @@
  */
 #define ELF_ARCH	EM_RISCV
 
+#ifndef ELF_CLASS
 #ifdef CONFIG_64BIT
 #define ELF_CLASS	ELFCLASS64
 #else
 #define ELF_CLASS	ELFCLASS32
 #endif
+#endif
 
 #define ELF_DATA	ELFDATA2LSB
 
@@ -31,6 +35,8 @@
  */
 #define elf_check_arch(x) ((x)->e_machine == EM_RISCV)
 
+#define compat_elf_check_arch(x) ((x)->e_machine == EM_RISCV)
+
 #define CORE_DUMP_USE_REGSET
 #define ELF_EXEC_PAGESIZE	(PAGE_SIZE)
 
@@ -57,11 +63,19 @@ extern unsigned long elf_hwcap;
  */
 #define ELF_PLATFORM	(NULL)
 
+#define COMPAT_ELF_PLATFORM	(NULL)
+
 #ifdef CONFIG_MMU
 #define ARCH_DLINFO						\
 do {								\
+	/*							\
+	 * Note that we add ulong after elf_addr_t because	\
+	 * casting current->mm->context.vdso triggers a cast	\
+	 * warning of cast from pointer to integer for		\
+	 * COMPAT ELFCLASS32.					\
+	 */							\
 	NEW_AUX_ENT(AT_SYSINFO_EHDR,				\
-		(elf_addr_t)current->mm->context.vdso);		\
+		(elf_addr_t)(ulong)current->mm->context.vdso);	\
 	NEW_AUX_ENT(AT_L1I_CACHESIZE,				\
 		get_cache_size(1, CACHE_TYPE_INST));		\
 	NEW_AUX_ENT(AT_L1I_CACHEGEOMETRY,			\
@@ -81,4 +95,34 @@ extern int arch_setup_additional_pages(struct linux_binprm *bprm,
 	int uses_interp);
 #endif /* CONFIG_MMU */
 
+#define ELF_CORE_COPY_REGS(dest, regs)			\
+do {							\
+	*(struct user_regs_struct *)&(dest) =		\
+		*(struct user_regs_struct *)regs;	\
+} while (0);
+
+#ifdef CONFIG_COMPAT
+
+#define SET_PERSONALITY(ex)					\
+do {    if ((ex).e_ident[EI_CLASS] == ELFCLASS32)		\
+		set_thread_flag(TIF_32BIT);			\
+	else							\
+		clear_thread_flag(TIF_32BIT);			\
+	if (personality(current->personality) != PER_LINUX32)	\
+		set_personality(PER_LINUX |			\
+			(current->personality & (~PER_MASK)));	\
+} while (0)
+
+#define COMPAT_ELF_ET_DYN_BASE		((TASK_SIZE_32 / 3) * 2)
+
+/* rv32 registers */
+typedef compat_ulong_t			compat_elf_greg_t;
+typedef compat_elf_greg_t		compat_elf_gregset_t[ELF_NGREG];
+
+extern int compat_arch_setup_additional_pages(struct linux_binprm *bprm,
+					      int uses_interp);
+#define compat_arch_setup_additional_pages \
+				compat_arch_setup_additional_pages
+
+#endif /* CONFIG_COMPAT */
 #endif /* _ASM_RISCV_ELF_H */
diff --git a/arch/riscv/include/asm/fixmap.h b/arch/riscv/include/asm/fixmap.h
index 54cbf07fb..913765df0 100644
--- a/arch/riscv/include/asm/fixmap.h
+++ b/arch/riscv/include/asm/fixmap.h
@@ -43,7 +43,7 @@ enum fixed_addresses {
 	__end_of_fixed_addresses
 };
 
-#define FIXMAP_PAGE_IO		PAGE_KERNEL
+#define FIXMAP_PAGE_IO		__pgprot(_PAGE_IOREMAP)
 
 #define __early_set_fixmap	__set_fixmap
 
diff --git a/arch/riscv/include/asm/kexec.h b/arch/riscv/include/asm/kexec.h
new file mode 100755
index 000000000..1e9541019
--- /dev/null
+++ b/arch/riscv/include/asm/kexec.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019 FORTH-ICS/CARV
+ *  Nick Kossifidis <mick@ics.forth.gr>
+ */
+
+#ifndef _RISCV_KEXEC_H
+#define _RISCV_KEXEC_H
+
+#include <asm/page.h>    /* For PAGE_SIZE */
+
+/* Maximum physical address we can use pages from */
+#define KEXEC_SOURCE_MEMORY_LIMIT (-1UL)
+
+/* Maximum address we can reach in physical address mode */
+#define KEXEC_DESTINATION_MEMORY_LIMIT (-1UL)
+
+/* Maximum address we can use for the control code buffer */
+#define KEXEC_CONTROL_MEMORY_LIMIT (-1UL)
+
+/* Reserve a page for the control code buffer */
+#define KEXEC_CONTROL_PAGE_SIZE PAGE_SIZE
+
+#define KEXEC_ARCH KEXEC_ARCH_RISCV
+
+extern void riscv_crash_save_regs(struct pt_regs *newregs);
+
+static inline void
+crash_setup_regs(struct pt_regs *newregs,
+		 struct pt_regs *oldregs)
+{
+	if (oldregs)
+		memcpy(newregs, oldregs, sizeof(struct pt_regs));
+	else
+		riscv_crash_save_regs(newregs);
+}
+
+
+#define ARCH_HAS_KIMAGE_ARCH
+
+struct kimage_arch {
+	unsigned long fdt_addr;
+};
+
+const extern unsigned char riscv_kexec_relocate[];
+const extern unsigned int riscv_kexec_relocate_size;
+
+typedef void (*riscv_kexec_method)(unsigned long first_ind_entry,
+				   unsigned long jump_addr,
+				   unsigned long fdt_addr,
+				   unsigned long hartid,
+				   unsigned long va_pa_off);
+
+extern riscv_kexec_method riscv_kexec_norelocate;
+
+#endif
diff --git a/arch/riscv/include/asm/kprobes.h b/arch/riscv/include/asm/kprobes.h
index 56a98ea30..4647d3801 100644
--- a/arch/riscv/include/asm/kprobes.h
+++ b/arch/riscv/include/asm/kprobes.h
@@ -11,4 +11,44 @@
 
 #include <asm-generic/kprobes.h>
 
+#ifdef CONFIG_KPROBES
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/percpu.h>
+
+#define __ARCH_WANT_KPROBES_INSN_SLOT
+#define MAX_INSN_SIZE			2
+
+#define flush_insn_slot(p)		do { } while (0)
+#define kretprobe_blacklist_size	0
+
+#include <asm/probes.h>
+
+struct prev_kprobe {
+	struct kprobe *kp;
+	unsigned int status;
+};
+
+/* Single step context for kprobe */
+struct kprobe_step_ctx {
+	unsigned long ss_pending;
+	unsigned long match_addr;
+};
+
+/* per-cpu kprobe control block */
+struct kprobe_ctlblk {
+	unsigned int kprobe_status;
+	unsigned long saved_status;
+	struct prev_kprobe prev_kprobe;
+	struct kprobe_step_ctx ss_ctx;
+};
+
+void arch_remove_kprobe(struct kprobe *p);
+int kprobe_fault_handler(struct pt_regs *regs, unsigned int trapnr);
+bool kprobe_breakpoint_handler(struct pt_regs *regs);
+bool kprobe_single_step_handler(struct pt_regs *regs);
+void kretprobe_trampoline(void);
+void __kprobes *trampoline_probe_handler(struct pt_regs *regs);
+
+#endif /* CONFIG_KPROBES */
 #endif /* _ASM_RISCV_KPROBES_H */
diff --git a/arch/riscv/include/asm/kvm_host.h b/arch/riscv/include/asm/kvm_host.h
new file mode 100755
index 000000000..011167a7c
--- /dev/null
+++ b/arch/riscv/include/asm/kvm_host.h
@@ -0,0 +1,300 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2019 Western Digital Corporation or its affiliates.
+ *
+ * Authors:
+ *     Anup Patel <anup.patel@wdc.com>
+ */
+
+#ifndef __RISCV_KVM_HOST_H__
+#define __RISCV_KVM_HOST_H__
+
+#include <linux/types.h>
+#include <linux/kvm.h>
+#include <linux/kvm_types.h>
+#include <asm/kvm_vcpu_timer.h>
+
+#ifdef CONFIG_64BIT
+#define KVM_MAX_VCPUS			(1U << 16)
+#else
+#define KVM_MAX_VCPUS			(1U << 9)
+#endif
+
+#define KVM_USER_MEM_SLOTS		512
+#define KVM_HALT_POLL_NS_DEFAULT	500000
+
+#define KVM_VCPU_MAX_FEATURES		0
+
+#define KVM_REQ_SLEEP \
+	KVM_ARCH_REQ_FLAGS(0, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)
+#define KVM_REQ_VCPU_RESET		KVM_ARCH_REQ(1)
+#define KVM_REQ_UPDATE_HGATP		KVM_ARCH_REQ(2)
+
+struct kvm_vm_stat {
+	ulong remote_tlb_flush;
+};
+
+struct kvm_vcpu_stat {
+	u64 halt_successful_poll;
+	u64 halt_attempted_poll;
+	u64 halt_poll_success_ns;
+	u64 halt_poll_fail_ns;
+	u64 halt_poll_invalid;
+	u64 halt_wakeup;
+	u64 ecall_exit_stat;
+	u64 wfi_exit_stat;
+	u64 mmio_exit_user;
+	u64 mmio_exit_kernel;
+	u64 exits;
+};
+
+struct kvm_arch_memory_slot {
+};
+
+struct kvm_vmid {
+	/*
+	 * Writes to vmid_version and vmid happen with vmid_lock held
+	 * whereas reads happen without any lock held.
+	 */
+	unsigned long vmid_version;
+	unsigned long vmid;
+};
+
+#define RVBM_STATUS_INIT	0
+#define RVBM_STATUS_START	1
+#define RVBM_STATUS_READY	2
+#define RVBM_STATUS_ACK		3
+#define RVBM_STATUS_MASK	0x7
+#define RVBM_WRITE		BIT(7)
+
+struct khv_io {
+	u64 status;
+	u64 addr;
+	u64 value;
+	u64 reserved;
+};
+
+struct kvm_arch {
+	/* stage2 vmid */
+	struct kvm_vmid vmid;
+
+	/* stage2 page table */
+	pgd_t *pgd;
+	phys_addr_t pgd_phys;
+
+	/* Guest Timer */
+	struct kvm_guest_timer timer;
+	wait_queue_head_t waitq;
+	struct khv_io *io_switch;
+	volatile unsigned char __iomem *backend_intr_reg;
+	volatile unsigned char __iomem *frontend_intr_reg;
+	u32 enable_intr;
+	u32 clear_intr;
+	unsigned long khv_base;
+	phys_addr_t khv_base_phys_addr;
+};
+
+struct kvm_mmio_decode {
+	unsigned long insn;
+	int insn_len;
+	int len;
+	int shift;
+	int return_handled;
+};
+
+struct kvm_sbi_context {
+	int return_handled;
+};
+
+#define KVM_MMU_PAGE_CACHE_NR_OBJS	32
+
+struct kvm_mmu_page_cache {
+	int nobjs;
+	void *objects[KVM_MMU_PAGE_CACHE_NR_OBJS];
+};
+
+struct kvm_cpu_trap {
+	unsigned long sepc;
+	unsigned long scause;
+	unsigned long stval;
+	unsigned long htval;
+	unsigned long htinst;
+};
+
+struct kvm_cpu_context {
+	unsigned long zero;
+	unsigned long ra;
+	unsigned long sp;
+	unsigned long gp;
+	unsigned long tp;
+	unsigned long t0;
+	unsigned long t1;
+	unsigned long t2;
+	unsigned long s0;
+	unsigned long s1;
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+	unsigned long a4;
+	unsigned long a5;
+	unsigned long a6;
+	unsigned long a7;
+	unsigned long s2;
+	unsigned long s3;
+	unsigned long s4;
+	unsigned long s5;
+	unsigned long s6;
+	unsigned long s7;
+	unsigned long s8;
+	unsigned long s9;
+	unsigned long s10;
+	unsigned long s11;
+	unsigned long t3;
+	unsigned long t4;
+	unsigned long t5;
+	unsigned long t6;
+	unsigned long sepc;
+	unsigned long sstatus;
+	unsigned long hstatus;
+	union __riscv_fp_state fp;
+};
+
+struct kvm_vcpu_csr {
+	unsigned long vsstatus;
+	unsigned long hie;
+	unsigned long vstvec;
+	unsigned long vsscratch;
+	unsigned long vsepc;
+	unsigned long vscause;
+	unsigned long vstval;
+	unsigned long hvip;
+	unsigned long vsatp;
+	unsigned long scounteren;
+};
+
+struct kvm_vcpu_arch {
+	/* VCPU ran atleast once */
+	bool ran_atleast_once;
+
+	/* ISA feature bits (similar to MISA) */
+	unsigned long isa;
+
+	/* SSCRATCH, STVEC, and SCOUNTEREN of Host */
+	unsigned long host_sscratch;
+	unsigned long host_stvec;
+	unsigned long host_scounteren;
+
+	/* CPU context of Host */
+	struct kvm_cpu_context host_context;
+
+	/* CPU context of Guest VCPU */
+	struct kvm_cpu_context guest_context;
+
+	/* CPU CSR context of Guest VCPU */
+	struct kvm_vcpu_csr guest_csr;
+
+	/* CPU context upon Guest VCPU reset */
+	struct kvm_cpu_context guest_reset_context;
+
+	/* CPU CSR context upon Guest VCPU reset */
+	struct kvm_vcpu_csr guest_reset_csr;
+
+	/*
+	 * VCPU interrupts
+	 *
+	 * We have a lockless approach for tracking pending VCPU interrupts
+	 * implemented using atomic bitops. The irqs_pending bitmap represent
+	 * pending interrupts whereas irqs_pending_mask represent bits changed
+	 * in irqs_pending. Our approach is modeled around multiple producer
+	 * and single consumer problem where the consumer is the VCPU itself.
+	 */
+	unsigned long irqs_pending;
+	unsigned long irqs_pending_mask;
+
+	/* VCPU Timer */
+	struct kvm_vcpu_timer timer;
+
+	/* MMIO instruction details */
+	struct kvm_mmio_decode mmio_decode;
+
+	/* SBI context */
+	struct kvm_sbi_context sbi_context;
+
+	/* Cache pages needed to program page tables with spinlock held */
+	struct kvm_mmu_page_cache mmu_page_cache;
+
+	/* VCPU power-off state */
+	bool power_off;
+
+	/* Don't run the VCPU (blocked) */
+	bool pause;
+
+	/* SRCU lock index for in-kernel run loop */
+	int srcu_idx;
+};
+
+static inline void kvm_arch_hardware_unsetup(void) {}
+static inline void kvm_arch_sync_events(struct kvm *kvm) {}
+static inline void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu) {}
+static inline void kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu) {}
+static inline void kvm_arch_vcpu_block_finish(struct kvm_vcpu *vcpu) {}
+
+#define KVM_ARCH_WANT_MMU_NOTIFIER
+int kvm_unmap_hva_range(struct kvm *kvm, unsigned long start,
+			unsigned long end, unsigned int flags);
+int kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte);
+int kvm_age_hva(struct kvm *kvm, unsigned long start, unsigned long end);
+int kvm_test_age_hva(struct kvm *kvm, unsigned long hva);
+
+void __kvm_riscv_hfence_gvma_vmid_gpa(unsigned long gpa, unsigned long vmid);
+void __kvm_riscv_hfence_gvma_vmid(unsigned long vmid);
+void __kvm_riscv_hfence_gvma_gpa(unsigned long gpa);
+void __kvm_riscv_hfence_gvma_all(void);
+
+int kvm_riscv_stage2_map(struct kvm_vcpu *vcpu,
+			 struct kvm_memory_slot *memslot,
+			 gpa_t gpa, unsigned long hva, bool is_write);
+void kvm_riscv_stage2_flush_cache(struct kvm_vcpu *vcpu);
+int kvm_riscv_stage2_alloc_pgd(struct kvm *kvm);
+void kvm_riscv_stage2_free_pgd(struct kvm *kvm);
+void kvm_riscv_stage2_update_hgatp(struct kvm_vcpu *vcpu);
+void kvm_riscv_stage2_mode_detect(void);
+unsigned long kvm_riscv_stage2_mode(void);
+
+void kvm_riscv_stage2_vmid_detect(void);
+unsigned long kvm_riscv_stage2_vmid_bits(void);
+int kvm_riscv_stage2_vmid_init(struct kvm *kvm);
+bool kvm_riscv_stage2_vmid_ver_changed(struct kvm_vmid *vmid);
+void kvm_riscv_stage2_vmid_update(struct kvm_vcpu *vcpu);
+
+void __kvm_riscv_unpriv_trap(void);
+
+unsigned long kvm_riscv_vcpu_unpriv_read(struct kvm_vcpu *vcpu,
+					 bool read_insn,
+					 unsigned long guest_addr,
+					 struct kvm_cpu_trap *trap);
+void kvm_riscv_vcpu_trap_redirect(struct kvm_vcpu *vcpu,
+				  struct kvm_cpu_trap *trap);
+int kvm_riscv_vcpu_mmio_return(struct kvm_vcpu *vcpu, struct kvm_run *run);
+int kvm_riscv_vcpu_exit(struct kvm_vcpu *vcpu, struct kvm_run *run,
+			struct kvm_cpu_trap *trap);
+
+void __kvm_riscv_switch_to(struct kvm_vcpu_arch *vcpu_arch);
+void __kvm_riscv_fp_f_save(struct kvm_cpu_context *context);
+void __kvm_riscv_fp_f_restore(struct kvm_cpu_context *context);
+void __kvm_riscv_fp_d_save(struct kvm_cpu_context *context);
+void __kvm_riscv_fp_d_restore(struct kvm_cpu_context *context);
+
+int kvm_riscv_vcpu_set_interrupt(struct kvm_vcpu *vcpu, unsigned int irq);
+int kvm_riscv_vcpu_unset_interrupt(struct kvm_vcpu *vcpu, unsigned int irq);
+void kvm_riscv_vcpu_flush_interrupts(struct kvm_vcpu *vcpu);
+void kvm_riscv_vcpu_sync_interrupts(struct kvm_vcpu *vcpu);
+bool kvm_riscv_vcpu_has_interrupts(struct kvm_vcpu *vcpu, unsigned long mask);
+void kvm_riscv_vcpu_power_off(struct kvm_vcpu *vcpu);
+void kvm_riscv_vcpu_power_on(struct kvm_vcpu *vcpu);
+
+int kvm_riscv_vcpu_sbi_return(struct kvm_vcpu *vcpu, struct kvm_run *run);
+int kvm_riscv_vcpu_sbi_ecall(struct kvm_vcpu *vcpu, struct kvm_run *run);
+
+#endif /* __RISCV_KVM_HOST_H__ */
diff --git a/arch/riscv/include/asm/kvm_types.h b/arch/riscv/include/asm/kvm_types.h
new file mode 100755
index 000000000..e476b404e
--- /dev/null
+++ b/arch/riscv/include/asm/kvm_types.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _ASM_RISCV_KVM_TYPES_H
+#define _ASM_RISCV_KVM_TYPES_H
+
+#define KVM_ARCH_NR_OBJS_PER_MEMORY_CACHE 40
+
+#endif /* _ASM_RISCV_KVM_TYPES_H */
diff --git a/arch/riscv/include/asm/kvm_vcpu_timer.h b/arch/riscv/include/asm/kvm_vcpu_timer.h
new file mode 100755
index 000000000..375281eb4
--- /dev/null
+++ b/arch/riscv/include/asm/kvm_vcpu_timer.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2019 Western Digital Corporation or its affiliates.
+ *
+ * Authors:
+ *	Atish Patra <atish.patra@wdc.com>
+ */
+
+#ifndef __KVM_VCPU_RISCV_TIMER_H
+#define __KVM_VCPU_RISCV_TIMER_H
+
+#include <linux/hrtimer.h>
+
+struct kvm_guest_timer {
+	/* Mult & Shift values to get nanoseconds from cycles */
+	u32 nsec_mult;
+	u32 nsec_shift;
+	/* Time delta value */
+	u64 time_delta;
+};
+
+struct kvm_vcpu_timer {
+	/* Flag for whether init is done */
+	bool init_done;
+	/* Flag for whether timer event is configured */
+	bool next_set;
+	/* Next timer event cycles */
+	u64 next_cycles;
+	/* Underlying hrtimer instance */
+	struct hrtimer hrt;
+};
+
+int kvm_riscv_vcpu_timer_next_event(struct kvm_vcpu *vcpu, u64 ncycles);
+int kvm_riscv_vcpu_get_reg_timer(struct kvm_vcpu *vcpu,
+				 const struct kvm_one_reg *reg);
+int kvm_riscv_vcpu_set_reg_timer(struct kvm_vcpu *vcpu,
+				 const struct kvm_one_reg *reg);
+int kvm_riscv_vcpu_timer_init(struct kvm_vcpu *vcpu);
+int kvm_riscv_vcpu_timer_deinit(struct kvm_vcpu *vcpu);
+int kvm_riscv_vcpu_timer_reset(struct kvm_vcpu *vcpu);
+void kvm_riscv_vcpu_timer_restore(struct kvm_vcpu *vcpu);
+int kvm_riscv_guest_timer_init(struct kvm *kvm);
+
+#endif
diff --git a/arch/riscv/include/asm/mmio.h b/arch/riscv/include/asm/mmio.h
index aff6c33ab..88414b5a7 100644
--- a/arch/riscv/include/asm/mmio.h
+++ b/arch/riscv/include/asm/mmio.h
@@ -133,7 +133,7 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 #define __io_br()	do {} while (0)
 #define __io_ar(v)	__asm__ __volatile__ ("fence i,r" : : : "memory")
 #define __io_bw()	__asm__ __volatile__ ("fence w,o" : : : "memory")
-#define __io_aw()	mmiowb_set_pending()
+#define __io_aw()	__asm__ __volatile__ ("fence o,w" : : : "memory")
 
 #define readb(c)	({ u8  __v; __io_br(); __v = readb_cpu(c); __io_ar(__v); __v; })
 #define readw(c)	({ u16 __v; __io_br(); __v = readw_cpu(c); __io_ar(__v); __v; })
diff --git a/arch/riscv/include/asm/mmu.h b/arch/riscv/include/asm/mmu.h
index dabcf2cfb..ac35dfe5e 100644
--- a/arch/riscv/include/asm/mmu.h
+++ b/arch/riscv/include/asm/mmu.h
@@ -14,6 +14,8 @@ typedef struct {
 	unsigned long	end_brk;
 #endif
 	void *vdso;
+	atomic64_t asid;
+	void *vdso_info;
 #ifdef CONFIG_SMP
 	/* A local icache flush is needed before user execution can resume. */
 	cpumask_t icache_stale_mask;
diff --git a/arch/riscv/include/asm/mmu_context.h b/arch/riscv/include/asm/mmu_context.h
index 67c463812..5f44a8e08 100644
--- a/arch/riscv/include/asm/mmu_context.h
+++ b/arch/riscv/include/asm/mmu_context.h
@@ -12,19 +12,20 @@
 
 #include <linux/mm.h>
 #include <linux/sched.h>
+#include <asm/tlbflush.h>
+#include <asm/cacheflush.h>
+#include <asm/asid.h>
+
+#define ASID_MASK		((1 << SATP_ASID_BITS) - 1)
+#define cpu_asid(mm)		(atomic64_read(&mm->context.asid) & ASID_MASK)
+
+#define init_new_context(tsk,mm)	({ atomic64_set(&(mm)->context.asid, 0); 0; })
 
 static inline void enter_lazy_tlb(struct mm_struct *mm,
 	struct task_struct *task)
 {
 }
 
-/* Initialize context-related info for a new mm_struct */
-static inline int init_new_context(struct task_struct *task,
-	struct mm_struct *mm)
-{
-	return 0;
-}
-
 static inline void destroy_context(struct mm_struct *mm)
 {
 }
@@ -32,6 +33,8 @@ static inline void destroy_context(struct mm_struct *mm)
 void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	struct task_struct *task);
 
+void check_and_switch_context(struct mm_struct *mm, unsigned int cpu);
+
 static inline void activate_mm(struct mm_struct *prev,
 			       struct mm_struct *next)
 {
diff --git a/arch/riscv/include/asm/patch.h b/arch/riscv/include/asm/patch.h
index 9a7d73460..98d9de07c 100644
--- a/arch/riscv/include/asm/patch.h
+++ b/arch/riscv/include/asm/patch.h
@@ -9,4 +9,6 @@
 int patch_text_nosync(void *addr, const void *insns, size_t len);
 int patch_text(void *addr, u32 insn);
 
+extern int riscv_patch_in_stop_machine;
+
 #endif /* _ASM_RISCV_PATCH_H */
diff --git a/arch/riscv/include/asm/pgtable-64.h b/arch/riscv/include/asm/pgtable-64.h
index f3b0da64c..c4c638409 100644
--- a/arch/riscv/include/asm/pgtable-64.h
+++ b/arch/riscv/include/asm/pgtable-64.h
@@ -62,7 +62,7 @@ static inline void pud_clear(pud_t *pudp)
 
 static inline unsigned long pud_page_vaddr(pud_t pud)
 {
-	return (unsigned long)pfn_to_virt(pud_val(pud) >> _PAGE_PFN_SHIFT);
+	return (unsigned long)pfn_to_virt((pud_val(pud) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 static inline struct page *pud_page(pud_t pud)
diff --git a/arch/riscv/include/asm/pgtable-bits.h b/arch/riscv/include/asm/pgtable-bits.h
index bbaeb5d35..906420370 100644
--- a/arch/riscv/include/asm/pgtable-bits.h
+++ b/arch/riscv/include/asm/pgtable-bits.h
@@ -24,6 +24,13 @@
 #define _PAGE_DIRTY     (1 << 7)    /* Set by hardware on any write */
 #define _PAGE_SOFT      (1 << 8)    /* Reserved for software */
 
+/* T-HEAD C9xx extend */
+#define _PAGE_SEC	(1UL << 59)   /* Security */
+#define _PAGE_SHARE	(1UL << 60)   /* Shareable */
+#define _PAGE_BUF	(1UL << 61)   /* Bufferable */
+#define _PAGE_CACHE	(1UL << 62)   /* Cacheable */
+#define _PAGE_SO	(1UL << 63)   /* Strong Order */
+
 #define _PAGE_SPECIAL   _PAGE_SOFT
 #define _PAGE_TABLE     _PAGE_PRESENT
 
@@ -38,6 +45,9 @@
 /* Set of bits to preserve across pte_modify() */
 #define _PAGE_CHG_MASK  (~(unsigned long)(_PAGE_PRESENT | _PAGE_READ |	\
 					  _PAGE_WRITE | _PAGE_EXEC |	\
-					  _PAGE_USER | _PAGE_GLOBAL))
+					  _PAGE_USER | _PAGE_GLOBAL |	\
+					  _PAGE_SEC | _PAGE_SHARE |	\
+					  _PAGE_BUF | _PAGE_CACHE |	\
+					  _PAGE_SO ))
 
 #endif /* _ASM_RISCV_PGTABLE_BITS_H */
diff --git a/arch/riscv/include/asm/pgtable.h b/arch/riscv/include/asm/pgtable.h
index 73e8b5e5b..1dcd1e1ad 100644
--- a/arch/riscv/include/asm/pgtable.h
+++ b/arch/riscv/include/asm/pgtable.h
@@ -76,9 +76,11 @@
 #define USER_PTRS_PER_PGD   (TASK_SIZE / PGDIR_SIZE)
 
 /* Page protection bits */
-#define _PAGE_BASE	(_PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_USER)
+#define _PAGE_BASE	(_PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_USER | \
+			 _PAGE_SHARE | _PAGE_CACHE | _PAGE_BUF)
 
-#define PAGE_NONE		__pgprot(_PAGE_PROT_NONE)
+#define PAGE_NONE		__pgprot(_PAGE_PROT_NONE | _PAGE_CACHE | \
+					 _PAGE_BUF | _PAGE_SHARE | _PAGE_SHARE)
 #define PAGE_READ		__pgprot(_PAGE_BASE | _PAGE_READ)
 #define PAGE_WRITE		__pgprot(_PAGE_BASE | _PAGE_READ | _PAGE_WRITE)
 #define PAGE_EXEC		__pgprot(_PAGE_BASE | _PAGE_EXEC)
@@ -95,8 +97,12 @@
 #define _PAGE_KERNEL		(_PAGE_READ \
 				| _PAGE_WRITE \
 				| _PAGE_PRESENT \
+				| _PAGE_GLOBAL \
 				| _PAGE_ACCESSED \
-				| _PAGE_DIRTY)
+				| _PAGE_DIRTY \
+				| _PAGE_CACHE \
+				| _PAGE_SHARE \
+				| _PAGE_BUF)
 
 #define PAGE_KERNEL		__pgprot(_PAGE_KERNEL)
 #define PAGE_KERNEL_READ	__pgprot(_PAGE_KERNEL & ~_PAGE_WRITE)
@@ -110,7 +116,16 @@
  * The RISC-V ISA doesn't yet specify how to query or modify PMAs, so we can't
  * change the properties of memory regions.
  */
-#define _PAGE_IOREMAP _PAGE_KERNEL
+#define _PAGE_IOREMAP		(_PAGE_READ \
+				| _PAGE_WRITE \
+				| _PAGE_PRESENT \
+				| _PAGE_GLOBAL \
+				| _PAGE_ACCESSED \
+				| _PAGE_DIRTY \
+				| _PAGE_SHARE \
+				| _PAGE_SO)
+
+#define PAGE_KERNEL_IO		__pgprot(_PAGE_IOREMAP)
 
 extern pgd_t swapper_pg_dir[];
 
@@ -178,18 +193,18 @@ static inline unsigned long _pgd_pfn(pgd_t pgd)
 
 static inline struct page *pmd_page(pmd_t pmd)
 {
-	return pfn_to_page(pmd_val(pmd) >> _PAGE_PFN_SHIFT);
+	return pfn_to_page((pmd_val(pmd) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 static inline unsigned long pmd_page_vaddr(pmd_t pmd)
 {
-	return (unsigned long)pfn_to_virt(pmd_val(pmd) >> _PAGE_PFN_SHIFT);
+	return (unsigned long)pfn_to_virt((pmd_val(pmd) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 /* Yields the page frame number (PFN) of a page table entry */
 static inline unsigned long pte_pfn(pte_t pte)
 {
-	return (pte_val(pte) >> _PAGE_PFN_SHIFT);
+	return ((pte_val(pte) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 #define pte_page(x)     pfn_to_page(pte_pfn(x))
@@ -406,6 +421,32 @@ static inline int ptep_clear_flush_young(struct vm_area_struct *vma,
 	return ptep_test_and_clear_young(vma, address, ptep);
 }
 
+#define __HAVE_PHYS_MEM_ACCESS_PROT
+struct file;
+extern pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
+				     unsigned long size, pgprot_t vma_prot);
+
+#define pgprot_noncached pgprot_noncached
+static inline pgprot_t pgprot_noncached(pgprot_t _prot)
+{
+	unsigned long prot = pgprot_val(_prot);
+
+	prot &= ~(_PAGE_CACHE | _PAGE_BUF);
+	prot |= _PAGE_SO;
+
+	return __pgprot(prot);
+}
+
+#define pgprot_writecombine pgprot_writecombine
+static inline pgprot_t pgprot_writecombine(pgprot_t _prot)
+{
+	unsigned long prot = pgprot_val(_prot);
+
+	prot &= ~(_PAGE_CACHE | _PAGE_BUF);
+
+	return __pgprot(prot);
+}
+
 /*
  * Encode and decode a swap entry
  *
@@ -446,7 +487,16 @@ static inline int ptep_clear_flush_young(struct vm_area_struct *vma,
  * Note that PGDIR_SIZE must evenly divide TASK_SIZE.
  */
 #ifdef CONFIG_64BIT
-#define TASK_SIZE (PGDIR_SIZE * PTRS_PER_PGD / 2)
+#define TASK_SIZE_64	(PGDIR_SIZE * PTRS_PER_PGD / 2)
+
+#ifdef CONFIG_COMPAT
+#define TASK_SIZE_32	(_AC(0x80000000, UL) - PAGE_SIZE)
+#define TASK_SIZE	(test_thread_flag(TIF_32BIT) ? \
+			 TASK_SIZE_32 : TASK_SIZE_64)
+#else
+#define TASK_SIZE	TASK_SIZE_64
+#endif
+
 #else
 #define TASK_SIZE FIXADDR_START
 #endif
diff --git a/arch/riscv/include/asm/probes.h b/arch/riscv/include/asm/probes.h
new file mode 100755
index 000000000..a787e6d53
--- /dev/null
+++ b/arch/riscv/include/asm/probes.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef _ASM_RISCV_PROBES_H
+#define _ASM_RISCV_PROBES_H
+
+typedef u32 probe_opcode_t;
+typedef bool (probes_handler_t) (u32 opcode, unsigned long addr, struct pt_regs *);
+
+/* architecture specific copy of original instruction */
+struct arch_probe_insn {
+	probe_opcode_t *insn;
+	probes_handler_t *handler;
+	/* restore address after simulation */
+	unsigned long restore;
+};
+
+#ifdef CONFIG_KPROBES
+typedef u32 kprobe_opcode_t;
+struct arch_specific_insn {
+	struct arch_probe_insn api;
+};
+#endif
+
+#endif /* _ASM_RISCV_PROBES_H */
diff --git a/arch/riscv/include/asm/processor.h b/arch/riscv/include/asm/processor.h
index bdddcd5c1..770a11a51 100644
--- a/arch/riscv/include/asm/processor.h
+++ b/arch/riscv/include/asm/processor.h
@@ -19,7 +19,11 @@
 #define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE / 3)
 
 #define STACK_TOP		TASK_SIZE
+#ifdef CONFIG_64BIT
+#define STACK_TOP_MAX		TASK_SIZE_64
+#else
 #define STACK_TOP_MAX		STACK_TOP
+#endif
 #define STACK_ALIGN		16
 
 #ifndef __ASSEMBLY__
@@ -27,6 +31,15 @@
 struct task_struct;
 struct pt_regs;
 
+#ifdef CONFIG_VECTOR_EMU
+struct vsetvl_info {
+	unsigned long last_vector_pc;
+	unsigned long regid;
+	unsigned long vl;
+	unsigned long vtype;
+};
+#endif
+
 /* CPU-specific state of a task */
 struct thread_struct {
 	/* Callee-saved registers */
@@ -34,6 +47,11 @@ struct thread_struct {
 	unsigned long sp;	/* Kernel mode stack */
 	unsigned long s[12];	/* s[0]: frame pointer */
 	struct __riscv_d_ext_state fstate;
+	unsigned long bad_cause;
+	struct __riscv_v_state vstate;
+#ifdef CONFIG_VECTOR_EMU
+	struct vsetvl_info vsetvl_state;
+#endif
 };
 
 #define INIT_THREAD {					\
@@ -52,6 +70,12 @@ struct thread_struct {
 extern void start_thread(struct pt_regs *regs,
 			unsigned long pc, unsigned long sp);
 
+#ifdef CONFIG_COMPAT
+#define DEFAULT_MAP_WINDOW_64 TASK_SIZE_64
+#else
+#define DEFAULT_MAP_WINDOW_64 TASK_SIZE
+#endif
+
 /* Free all resources held by a thread. */
 static inline void release_thread(struct task_struct *dead_task)
 {
diff --git a/arch/riscv/include/asm/ptrace.h b/arch/riscv/include/asm/ptrace.h
index ee49f80c9..cb4abb639 100644
--- a/arch/riscv/include/asm/ptrace.h
+++ b/arch/riscv/include/asm/ptrace.h
@@ -8,6 +8,7 @@
 
 #include <uapi/asm/ptrace.h>
 #include <asm/csr.h>
+#include <linux/compiler.h>
 
 #ifndef __ASSEMBLY__
 
@@ -60,6 +61,7 @@ struct pt_regs {
 
 #define user_mode(regs) (((regs)->status & SR_PP) == 0)
 
+#define MAX_REG_OFFSET offsetof(struct pt_regs, orig_a0)
 
 /* Helpers for working with the instruction pointer */
 static inline unsigned long instruction_pointer(struct pt_regs *regs)
@@ -85,6 +87,12 @@ static inline void user_stack_pointer_set(struct pt_regs *regs,
 	regs->sp =  val;
 }
 
+/* Valid only for Kernel mode traps. */
+static inline unsigned long kernel_stack_pointer(struct pt_regs *regs)
+{
+	return regs->sp;
+}
+
 /* Helpers for working with the frame pointer */
 static inline unsigned long frame_pointer(struct pt_regs *regs)
 {
@@ -101,6 +109,33 @@ static inline unsigned long regs_return_value(struct pt_regs *regs)
 	return regs->a0;
 }
 
+static inline void regs_set_return_value(struct pt_regs *regs,
+					 unsigned long val)
+{
+	regs->a0 = val;
+}
+
+extern int regs_query_register_offset(const char *name);
+extern unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs,
+					       unsigned int n);
+
+/**
+ * regs_get_register() - get register value from its offset
+ * @regs:	pt_regs from which register value is gotten
+ * @offset:	offset of the register.
+ *
+ * regs_get_register returns the value of a register whose offset from @regs.
+ * The @offset is the offset of the register in struct pt_regs.
+ * If @offset is bigger than MAX_REG_OFFSET, this returns 0.
+ */
+static inline unsigned long regs_get_register(struct pt_regs *regs,
+					      unsigned int offset)
+{
+	if (unlikely(offset > MAX_REG_OFFSET))
+		return 0;
+
+	return *(unsigned long *)((unsigned long)regs + offset);
+}
 #endif /* __ASSEMBLY__ */
 
 #endif /* _ASM_RISCV_PTRACE_H */
diff --git a/arch/riscv/include/asm/sbi.h b/arch/riscv/include/asm/sbi.h
index c0fdb05ff..072c91f65 100644
--- a/arch/riscv/include/asm/sbi.h
+++ b/arch/riscv/include/asm/sbi.h
@@ -97,6 +97,9 @@ struct sbiret sbi_ecall(int ext, int fid, unsigned long arg0,
 
 void sbi_console_putchar(int ch);
 int sbi_console_getchar(void);
+long sbi_get_mvendorid(void);
+long sbi_get_marchid(void);
+long sbi_get_mimpid(void);
 void sbi_set_timer(uint64_t stime_value);
 void sbi_shutdown(void);
 void sbi_clear_ipi(void);
diff --git a/arch/riscv/include/asm/seccomp.h b/arch/riscv/include/asm/seccomp.h
index bf7744ee3..c7ee6a350 100644
--- a/arch/riscv/include/asm/seccomp.h
+++ b/arch/riscv/include/asm/seccomp.h
@@ -7,4 +7,14 @@
 
 #include <asm-generic/seccomp.h>
 
+#ifdef CONFIG_64BIT
+# define SECCOMP_ARCH_NATIVE		AUDIT_ARCH_RISCV64
+# define SECCOMP_ARCH_NATIVE_NR		NR_syscalls
+# define SECCOMP_ARCH_NATIVE_NAME	"riscv64"
+#else /* !CONFIG_64BIT */
+# define SECCOMP_ARCH_NATIVE		AUDIT_ARCH_RISCV32
+# define SECCOMP_ARCH_NATIVE_NR		NR_syscalls
+# define SECCOMP_ARCH_NATIVE_NAME	"riscv32"
+#endif
+
 #endif /* _ASM_SECCOMP_H */
diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index df1f7c4cd..74abc2bfe 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -51,6 +51,9 @@ void riscv_set_ipi_ops(struct riscv_ipi_ops *ops);
 /* Clear IPI for current CPU */
 void riscv_clear_ipi(void);
 
+void crash_smp_send_stop(void);
+bool smp_crash_stop_failed(void);
+
 /* Secondary hart entry */
 asmlinkage void smp_callin(void);
 
diff --git a/arch/riscv/include/asm/spinlock.h b/arch/riscv/include/asm/spinlock.h
index f4f7fa1b7..4e2696d54 100644
--- a/arch/riscv/include/asm/spinlock.h
+++ b/arch/riscv/include/asm/spinlock.h
@@ -1,135 +1,9 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * Copyright (C) 2015 Regents of the University of California
- * Copyright (C) 2017 SiFive
- */
+/* SPDX-License-Identifier: GPL-2.0 */
 
-#ifndef _ASM_RISCV_SPINLOCK_H
-#define _ASM_RISCV_SPINLOCK_H
+#ifndef __ASM_GENERIC_SPINLOCK_H
+#define __ASM_GENERIC_SPINLOCK_H
 
-#include <linux/kernel.h>
-#include <asm/current.h>
-#include <asm/fence.h>
+#include <asm-generic/qspinlock.h>
+#include <asm/qrwlock.h>
 
-/*
- * Simple spin lock operations.  These provide no fairness guarantees.
- */
-
-/* FIXME: Replace this with a ticket lock, like MIPS. */
-
-#define arch_spin_is_locked(x)	(READ_ONCE((x)->lock) != 0)
-
-static inline void arch_spin_unlock(arch_spinlock_t *lock)
-{
-	smp_store_release(&lock->lock, 0);
-}
-
-static inline int arch_spin_trylock(arch_spinlock_t *lock)
-{
-	int tmp = 1, busy;
-
-	__asm__ __volatile__ (
-		"	amoswap.w %0, %2, %1\n"
-		RISCV_ACQUIRE_BARRIER
-		: "=r" (busy), "+A" (lock->lock)
-		: "r" (tmp)
-		: "memory");
-
-	return !busy;
-}
-
-static inline void arch_spin_lock(arch_spinlock_t *lock)
-{
-	while (1) {
-		if (arch_spin_is_locked(lock))
-			continue;
-
-		if (arch_spin_trylock(lock))
-			break;
-	}
-}
-
-/***********************************************************/
-
-static inline void arch_read_lock(arch_rwlock_t *lock)
-{
-	int tmp;
-
-	__asm__ __volatile__(
-		"1:	lr.w	%1, %0\n"
-		"	bltz	%1, 1b\n"
-		"	addi	%1, %1, 1\n"
-		"	sc.w	%1, %1, %0\n"
-		"	bnez	%1, 1b\n"
-		RISCV_ACQUIRE_BARRIER
-		: "+A" (lock->lock), "=&r" (tmp)
-		:: "memory");
-}
-
-static inline void arch_write_lock(arch_rwlock_t *lock)
-{
-	int tmp;
-
-	__asm__ __volatile__(
-		"1:	lr.w	%1, %0\n"
-		"	bnez	%1, 1b\n"
-		"	li	%1, -1\n"
-		"	sc.w	%1, %1, %0\n"
-		"	bnez	%1, 1b\n"
-		RISCV_ACQUIRE_BARRIER
-		: "+A" (lock->lock), "=&r" (tmp)
-		:: "memory");
-}
-
-static inline int arch_read_trylock(arch_rwlock_t *lock)
-{
-	int busy;
-
-	__asm__ __volatile__(
-		"1:	lr.w	%1, %0\n"
-		"	bltz	%1, 1f\n"
-		"	addi	%1, %1, 1\n"
-		"	sc.w	%1, %1, %0\n"
-		"	bnez	%1, 1b\n"
-		RISCV_ACQUIRE_BARRIER
-		"1:\n"
-		: "+A" (lock->lock), "=&r" (busy)
-		:: "memory");
-
-	return !busy;
-}
-
-static inline int arch_write_trylock(arch_rwlock_t *lock)
-{
-	int busy;
-
-	__asm__ __volatile__(
-		"1:	lr.w	%1, %0\n"
-		"	bnez	%1, 1f\n"
-		"	li	%1, -1\n"
-		"	sc.w	%1, %1, %0\n"
-		"	bnez	%1, 1b\n"
-		RISCV_ACQUIRE_BARRIER
-		"1:\n"
-		: "+A" (lock->lock), "=&r" (busy)
-		:: "memory");
-
-	return !busy;
-}
-
-static inline void arch_read_unlock(arch_rwlock_t *lock)
-{
-	__asm__ __volatile__(
-		RISCV_RELEASE_BARRIER
-		"	amoadd.w x0, %1, %0\n"
-		: "+A" (lock->lock)
-		: "r" (-1)
-		: "memory");
-}
-
-static inline void arch_write_unlock(arch_rwlock_t *lock)
-{
-	smp_store_release(&lock->lock, 0);
-}
-
-#endif /* _ASM_RISCV_SPINLOCK_H */
+#endif /* __ASM_GENERIC_SPINLOCK_H */
diff --git a/arch/riscv/include/asm/spinlock_types.h b/arch/riscv/include/asm/spinlock_types.h
index f398e7638..f534aa5de 100644
--- a/arch/riscv/include/asm/spinlock_types.h
+++ b/arch/riscv/include/asm/spinlock_types.h
@@ -1,25 +1,9 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * Copyright (C) 2015 Regents of the University of California
- */
+/* SPDX-License-Identifier: GPL-2.0 */
 
-#ifndef _ASM_RISCV_SPINLOCK_TYPES_H
-#define _ASM_RISCV_SPINLOCK_TYPES_H
+#ifndef __ASM_GENERIC_SPINLOCK_TYPES_H
+#define __ASM_GENERIC_SPINLOCK_TYPES_H
 
-#ifndef __LINUX_SPINLOCK_TYPES_H
-# error "please don't include this file directly"
-#endif
+#include <asm-generic/qspinlock_types.h>
+#include <asm-generic/qrwlock_types.h>
 
-typedef struct {
-	volatile unsigned int lock;
-} arch_spinlock_t;
-
-#define __ARCH_SPIN_LOCK_UNLOCKED	{ 0 }
-
-typedef struct {
-	volatile unsigned int lock;
-} arch_rwlock_t;
-
-#define __ARCH_RW_LOCK_UNLOCKED		{ 0 }
-
-#endif /* _ASM_RISCV_SPINLOCK_TYPES_H */
+#endif /* __ASM_GENERIC_SPINLOCK_TYPES_H */
diff --git a/arch/riscv/include/asm/switch_to.h b/arch/riscv/include/asm/switch_to.h
index 407bcc96a..465275f89 100644
--- a/arch/riscv/include/asm/switch_to.h
+++ b/arch/riscv/include/asm/switch_to.h
@@ -63,6 +63,52 @@ extern bool has_fpu;
 #define __switch_to_aux(__prev, __next) do { } while (0)
 #endif
 
+#ifdef CONFIG_VECTOR
+extern void __vstate_save(struct task_struct *save_to);
+extern void __vstate_restore(struct task_struct *restore_from);
+
+static inline void __vstate_clean(struct pt_regs *regs)
+{
+	regs->status |= (regs->status & ~(SR_VS)) | SR_VS_CLEAN;
+}
+
+static inline void vstate_save(struct task_struct *task,
+			       struct pt_regs *regs)
+{
+	if ((regs->status & SR_VS) == SR_VS_DIRTY) {
+		__vstate_save(task);
+		__vstate_clean(regs);
+	}
+}
+
+static inline void vstate_restore(struct task_struct *task,
+				  struct pt_regs *regs)
+{
+	if ((regs->status & SR_VS) != SR_VS_OFF) {
+		__vstate_restore(task);
+		__vstate_clean(regs);
+	}
+}
+
+static inline void __switch_to_vector(struct task_struct *prev,
+				   struct task_struct *next)
+{
+	struct pt_regs *regs;
+
+	regs = task_pt_regs(prev);
+	if (unlikely(regs->status & SR_SD))
+		vstate_save(prev, regs);
+	vstate_restore(next, task_pt_regs(next));
+}
+
+extern bool has_vector;
+#else
+#define has_vector false
+#define vstate_save(task, regs) do { } while (0)
+#define vstate_restore(task, regs) do { } while (0)
+#define __switch_to_vector(__prev, __next) do { } while (0)
+#endif
+
 extern struct task_struct *__switch_to(struct task_struct *,
 				       struct task_struct *);
 
@@ -72,6 +118,8 @@ do {							\
 	struct task_struct *__next = (next);		\
 	if (has_fpu)					\
 		__switch_to_aux(__prev, __next);	\
+	if (has_vector)					\
+		__switch_to_vector(__prev, __next);	\
 	((last) = __switch_to(__prev, __next));		\
 } while (0)
 
diff --git a/arch/riscv/include/asm/syscall.h b/arch/riscv/include/asm/syscall.h
index 49350c8bd..6d34f858f 100644
--- a/arch/riscv/include/asm/syscall.h
+++ b/arch/riscv/include/asm/syscall.h
@@ -15,7 +15,10 @@
 #include <linux/err.h>
 
 /* The array of function pointers for syscalls. */
-extern void *sys_call_table[];
+extern const void *sys_call_table[];
+#ifdef CONFIG_COMPAT
+extern const void *compat_sys_call_table[];
+#endif
 
 /*
  * Only the low 32 bits of orig_r0 are meaningful, so we return int.
diff --git a/arch/riscv/include/asm/thread_info.h b/arch/riscv/include/asm/thread_info.h
index a39071112..0e26d3420 100644
--- a/arch/riscv/include/asm/thread_info.h
+++ b/arch/riscv/include/asm/thread_info.h
@@ -11,11 +11,17 @@
 #include <asm/page.h>
 #include <linux/const.h>
 
+#ifdef CONFIG_KASAN
+#define KASAN_STACK_ORDER 1
+#else
+#define KASAN_STACK_ORDER 0
+#endif
+
 /* thread information allocation */
 #ifdef CONFIG_64BIT
-#define THREAD_SIZE_ORDER	(2)
+#define THREAD_SIZE_ORDER	(2 + KASAN_STACK_ORDER)
 #else
-#define THREAD_SIZE_ORDER	(1)
+#define THREAD_SIZE_ORDER	(1 + KASAN_STACK_ORDER)
 #endif
 #define THREAD_SIZE		(PAGE_SIZE << THREAD_SIZE_ORDER)
 
@@ -74,6 +80,9 @@ struct thread_info {
 #define TIF_SYSCALL_TRACEPOINT  6       /* syscall tracepoint instrumentation */
 #define TIF_SYSCALL_AUDIT	7	/* syscall auditing */
 #define TIF_SECCOMP		8	/* syscall secure computing */
+#define TIF_NOTIFY_SIGNAL	9	/* signal notifications exist */
+#define TIF_UPROBE		10	/* uprobe breakpoint or singlestep */
+#define TIF_32BIT		11	/* 32bit process */
 
 #define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
@@ -82,9 +91,12 @@ struct thread_info {
 #define _TIF_SYSCALL_TRACEPOINT	(1 << TIF_SYSCALL_TRACEPOINT)
 #define _TIF_SYSCALL_AUDIT	(1 << TIF_SYSCALL_AUDIT)
 #define _TIF_SECCOMP		(1 << TIF_SECCOMP)
+#define _TIF_NOTIFY_SIGNAL	(1 << TIF_NOTIFY_SIGNAL)
+#define _TIF_UPROBE		(1 << TIF_UPROBE)
 
 #define _TIF_WORK_MASK \
-	(_TIF_NOTIFY_RESUME | _TIF_SIGPENDING | _TIF_NEED_RESCHED)
+	(_TIF_NOTIFY_RESUME | _TIF_SIGPENDING | _TIF_NEED_RESCHED | \
+	 _TIF_NOTIFY_SIGNAL | _TIF_UPROBE)
 
 #define _TIF_SYSCALL_WORK \
 	(_TIF_SYSCALL_TRACE | _TIF_SYSCALL_TRACEPOINT | _TIF_SYSCALL_AUDIT | \
diff --git a/arch/riscv/include/asm/tlbflush.h b/arch/riscv/include/asm/tlbflush.h
index 394cfbccd..e75a2746c 100644
--- a/arch/riscv/include/asm/tlbflush.h
+++ b/arch/riscv/include/asm/tlbflush.h
@@ -13,13 +13,21 @@
 #ifdef CONFIG_MMU
 static inline void local_flush_tlb_all(void)
 {
+#ifdef CONFIG_NO_SFENCE_VMA
+	csr_write(0x9c3, 1 << 26);
+#else
 	__asm__ __volatile__ ("sfence.vma" : : : "memory");
+#endif
 }
 
 /* Flush one page from local TLB */
 static inline void local_flush_tlb_page(unsigned long addr)
 {
+#ifdef CONFIG_NO_SFENCE_VMA
+	csr_write(0x9c3, 1 << 26);
+#else
 	__asm__ __volatile__ ("sfence.vma %0" : : "r" (addr) : "memory");
+#endif
 }
 #else /* CONFIG_MMU */
 #define local_flush_tlb_all()			do { } while (0)
diff --git a/arch/riscv/include/asm/uaccess.h b/arch/riscv/include/asm/uaccess.h
index f944062c9..1fdc93faf 100644
--- a/arch/riscv/include/asm/uaccess.h
+++ b/arch/riscv/include/asm/uaccess.h
@@ -360,6 +360,8 @@ unsigned long __must_check __asm_copy_to_user(void __user *to,
 	const void *from, unsigned long n);
 unsigned long __must_check __asm_copy_from_user(void *to,
 	const void __user *from, unsigned long n);
+unsigned long __must_check __asm_copy_in_user(void __user *to,
+	const void *from, unsigned long n);
 
 static inline unsigned long
 raw_copy_from_user(void *to, const void __user *from, unsigned long n)
@@ -373,6 +375,12 @@ raw_copy_to_user(void __user *to, const void *from, unsigned long n)
 	return __asm_copy_to_user(to, from, n);
 }
 
+static inline unsigned long
+raw_copy_in_user(void __user *to, const void *from, unsigned long n)
+{
+	return __asm_copy_in_user(to, from, n);
+}
+
 extern long strncpy_from_user(char *dest, const char __user *src, long count);
 
 extern long __must_check strlen_user(const char __user *str);
diff --git a/arch/riscv/include/asm/uprobes.h b/arch/riscv/include/asm/uprobes.h
new file mode 100755
index 000000000..f2183e00f
--- /dev/null
+++ b/arch/riscv/include/asm/uprobes.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#ifndef _ASM_RISCV_UPROBES_H
+#define _ASM_RISCV_UPROBES_H
+
+#include <asm/probes.h>
+#include <asm/patch.h>
+#include <asm/bug.h>
+
+#define MAX_UINSN_BYTES		8
+
+#ifdef CONFIG_RISCV_ISA_C
+#define UPROBE_SWBP_INSN	__BUG_INSN_16
+#define UPROBE_SWBP_INSN_SIZE	2
+#else
+#define UPROBE_SWBP_INSN	__BUG_INSN_32
+#define UPROBE_SWBP_INSN_SIZE	4
+#endif
+#define UPROBE_XOL_SLOT_BYTES	MAX_UINSN_BYTES
+
+typedef u32 uprobe_opcode_t;
+
+struct arch_uprobe_task {
+	unsigned long   saved_cause;
+};
+
+struct arch_uprobe {
+	union {
+		u8 insn[MAX_UINSN_BYTES];
+		u8 ixol[MAX_UINSN_BYTES];
+	};
+	struct arch_probe_insn api;
+	unsigned long insn_size;
+	bool simulate;
+};
+
+bool uprobe_breakpoint_handler(struct pt_regs *regs);
+bool uprobe_single_step_handler(struct pt_regs *regs);
+
+#endif /* _ASM_RISCV_UPROBES_H */
diff --git a/arch/riscv/include/asm/vdso.h b/arch/riscv/include/asm/vdso.h
index 1453a2f56..0a2846be4 100644
--- a/arch/riscv/include/asm/vdso.h
+++ b/arch/riscv/include/asm/vdso.h
@@ -9,25 +9,23 @@
 #define _ASM_RISCV_VDSO_H
 
 #include <linux/types.h>
+#include <generated/vdso-offsets.h>
 
 #ifndef CONFIG_GENERIC_TIME_VSYSCALL
 struct vdso_data {
 };
 #endif
 
-/*
- * The VDSO symbols are mapped into Linux so we can just use regular symbol
- * addressing to get their offsets in userspace.  The symbols are mapped at an
- * offset of 0, but since the linker must support setting weak undefined
- * symbols to the absolute address 0 it also happens to support other low
- * addresses even when the code model suggests those low addresses would not
- * otherwise be availiable.
- */
 #define VDSO_SYMBOL(base, name)							\
-({										\
-	extern const char __vdso_##name[];					\
-	(void __user *)((unsigned long)(base) + __vdso_##name);			\
-})
+	(void __user *)((unsigned long)(base) + __vdso_##name##_offset)
+
+#ifdef CONFIG_COMPAT
+#include <generated/compat_vdso-offsets.h>
+
+#define COMPAT_VDSO_SYMBOL(base, name)						\
+	(void __user *)((unsigned long)(base) + compat__vdso_##name##_offset)
+
+#endif /* CONFIG_COMPAT */
 
 asmlinkage long sys_riscv_flush_icache(uintptr_t, uintptr_t, uintptr_t);
 
diff --git a/arch/riscv/include/uapi/asm/elf.h b/arch/riscv/include/uapi/asm/elf.h
index d696d6610..1a36fe6fe 100644
--- a/arch/riscv/include/uapi/asm/elf.h
+++ b/arch/riscv/include/uapi/asm/elf.h
@@ -24,6 +24,8 @@ typedef __u64 elf_fpreg_t;
 typedef union __riscv_fp_state elf_fpregset_t;
 #define ELF_NFPREG (sizeof(struct __riscv_d_ext_state) / sizeof(elf_fpreg_t))
 
+#define ELF_NVREG  (sizeof(struct __riscv_v_state) / sizeof(elf_greg_t))
+
 #if __riscv_xlen == 64
 #define ELF_RISCV_R_SYM(r_info)		ELF64_R_SYM(r_info)
 #define ELF_RISCV_R_TYPE(r_info)	ELF64_R_TYPE(r_info)
diff --git a/arch/riscv/include/uapi/asm/hwcap.h b/arch/riscv/include/uapi/asm/hwcap.h
index 46dc3f5ee..c52bb7bbb 100644
--- a/arch/riscv/include/uapi/asm/hwcap.h
+++ b/arch/riscv/include/uapi/asm/hwcap.h
@@ -21,5 +21,6 @@
 #define COMPAT_HWCAP_ISA_F	(1 << ('F' - 'A'))
 #define COMPAT_HWCAP_ISA_D	(1 << ('D' - 'A'))
 #define COMPAT_HWCAP_ISA_C	(1 << ('C' - 'A'))
+#define COMPAT_HWCAP_ISA_V	(1 << ('V' - 'A'))
 
 #endif /* _UAPI_ASM_RISCV_HWCAP_H */
diff --git a/arch/riscv/include/uapi/asm/kvm.h b/arch/riscv/include/uapi/asm/kvm.h
new file mode 100755
index 000000000..ba458c433
--- /dev/null
+++ b/arch/riscv/include/uapi/asm/kvm.h
@@ -0,0 +1,128 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2019 Western Digital Corporation or its affiliates.
+ *
+ * Authors:
+ *     Anup Patel <anup.patel@wdc.com>
+ */
+
+#ifndef __LINUX_KVM_RISCV_H
+#define __LINUX_KVM_RISCV_H
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <asm/ptrace.h>
+
+#define __KVM_HAVE_READONLY_MEM
+
+#define KVM_COALESCED_MMIO_PAGE_OFFSET 0
+
+#define KVM_INTERRUPT_SET	-1U
+#define KVM_INTERRUPT_UNSET	-2U
+
+/* for KVM_GET_REGS and KVM_SET_REGS */
+struct kvm_regs {
+};
+
+/* for KVM_GET_FPU and KVM_SET_FPU */
+struct kvm_fpu {
+};
+
+/* KVM Debug exit structure */
+struct kvm_debug_exit_arch {
+};
+
+/* for KVM_SET_GUEST_DEBUG */
+struct kvm_guest_debug_arch {
+};
+
+/* definition of registers in kvm_run */
+struct kvm_sync_regs {
+};
+
+/* for KVM_GET_SREGS and KVM_SET_SREGS */
+struct kvm_sregs {
+};
+
+/* CONFIG registers for KVM_GET_ONE_REG and KVM_SET_ONE_REG */
+struct kvm_riscv_config {
+	unsigned long isa;
+};
+
+/* CORE registers for KVM_GET_ONE_REG and KVM_SET_ONE_REG */
+struct kvm_riscv_core {
+	struct user_regs_struct regs;
+	unsigned long mode;
+};
+
+/* Possible privilege modes for kvm_riscv_core */
+#define KVM_RISCV_MODE_S	1
+#define KVM_RISCV_MODE_U	0
+
+/* CSR registers for KVM_GET_ONE_REG and KVM_SET_ONE_REG */
+struct kvm_riscv_csr {
+	unsigned long sstatus;
+	unsigned long sie;
+	unsigned long stvec;
+	unsigned long sscratch;
+	unsigned long sepc;
+	unsigned long scause;
+	unsigned long stval;
+	unsigned long sip;
+	unsigned long satp;
+	unsigned long scounteren;
+};
+
+/* TIMER registers for KVM_GET_ONE_REG and KVM_SET_ONE_REG */
+struct kvm_riscv_timer {
+	__u64 frequency;
+	__u64 time;
+	__u64 compare;
+	__u64 state;
+};
+
+/* Possible states for kvm_riscv_timer */
+#define KVM_RISCV_TIMER_STATE_OFF	0
+#define KVM_RISCV_TIMER_STATE_ON	1
+
+#define KVM_REG_SIZE(id)		\
+	(1U << (((id) & KVM_REG_SIZE_MASK) >> KVM_REG_SIZE_SHIFT))
+
+/* If you need to interpret the index values, here is the key: */
+#define KVM_REG_RISCV_TYPE_MASK		0x00000000FF000000
+#define KVM_REG_RISCV_TYPE_SHIFT	24
+
+/* Config registers are mapped as type 1 */
+#define KVM_REG_RISCV_CONFIG		(0x01 << KVM_REG_RISCV_TYPE_SHIFT)
+#define KVM_REG_RISCV_CONFIG_REG(name)	\
+	(offsetof(struct kvm_riscv_config, name) / sizeof(unsigned long))
+
+/* Core registers are mapped as type 2 */
+#define KVM_REG_RISCV_CORE		(0x02 << KVM_REG_RISCV_TYPE_SHIFT)
+#define KVM_REG_RISCV_CORE_REG(name)	\
+		(offsetof(struct kvm_riscv_core, name) / sizeof(unsigned long))
+
+/* Control and status registers are mapped as type 3 */
+#define KVM_REG_RISCV_CSR		(0x03 << KVM_REG_RISCV_TYPE_SHIFT)
+#define KVM_REG_RISCV_CSR_REG(name)	\
+		(offsetof(struct kvm_riscv_csr, name) / sizeof(unsigned long))
+
+/* Timer registers are mapped as type 4 */
+#define KVM_REG_RISCV_TIMER		(0x04 << KVM_REG_RISCV_TYPE_SHIFT)
+#define KVM_REG_RISCV_TIMER_REG(name)	\
+		(offsetof(struct kvm_riscv_timer, name) / sizeof(__u64))
+
+/* F extension registers are mapped as type 5 */
+#define KVM_REG_RISCV_FP_F		(0x05 << KVM_REG_RISCV_TYPE_SHIFT)
+#define KVM_REG_RISCV_FP_F_REG(name)	\
+		(offsetof(struct __riscv_f_ext_state, name) / sizeof(__u32))
+
+/* D extension registers are mapped as type 6 */
+#define KVM_REG_RISCV_FP_D		(0x06 << KVM_REG_RISCV_TYPE_SHIFT)
+#define KVM_REG_RISCV_FP_D_REG(name)	\
+		(offsetof(struct __riscv_d_ext_state, name) / sizeof(__u64))
+
+#endif
+
+#endif /* __LINUX_KVM_RISCV_H */
diff --git a/arch/riscv/include/uapi/asm/ptrace.h b/arch/riscv/include/uapi/asm/ptrace.h
index 882547f6b..0390a8ba3 100644
--- a/arch/riscv/include/uapi/asm/ptrace.h
+++ b/arch/riscv/include/uapi/asm/ptrace.h
@@ -77,6 +77,25 @@ union __riscv_fp_state {
 	struct __riscv_q_ext_state q;
 };
 
+#ifdef CONFIG_VLEN_256
+struct __riscv_vblen {
+	__uint128_t v[2];
+};
+#endif
+
+struct __riscv_v_state {
+#ifdef CONFIG_VLEN_256
+	struct __riscv_vblen v[32];
+#else
+	__uint128_t v[32];
+#endif
+	unsigned long vstart;
+	unsigned long vxsat;
+	unsigned long vxrm;
+	unsigned long vl;
+	unsigned long vtype;
+};
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _UAPI_ASM_RISCV_PTRACE_H */
diff --git a/arch/riscv/include/uapi/asm/setup.h b/arch/riscv/include/uapi/asm/setup.h
new file mode 100755
index 000000000..66b13a522
--- /dev/null
+++ b/arch/riscv/include/uapi/asm/setup.h
@@ -0,0 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+
+#ifndef _UAPI_ASM_RISCV_SETUP_H
+#define _UAPI_ASM_RISCV_SETUP_H
+
+#define COMMAND_LINE_SIZE	1024
+
+#endif /* _UAPI_ASM_RISCV_SETUP_H */
diff --git a/arch/riscv/include/uapi/asm/sigcontext.h b/arch/riscv/include/uapi/asm/sigcontext.h
index 84f2dfcfd..f74b3c814 100644
--- a/arch/riscv/include/uapi/asm/sigcontext.h
+++ b/arch/riscv/include/uapi/asm/sigcontext.h
@@ -17,6 +17,7 @@
 struct sigcontext {
 	struct user_regs_struct sc_regs;
 	union __riscv_fp_state sc_fpregs;
+	struct __riscv_v_state sc_vregs;
 };
 
 #endif /* _UAPI_ASM_RISCV_SIGCONTEXT_H */
diff --git a/arch/riscv/include/uapi/asm/unistd.h b/arch/riscv/include/uapi/asm/unistd.h
index 8062996c2..c9e50eed1 100644
--- a/arch/riscv/include/uapi/asm/unistd.h
+++ b/arch/riscv/include/uapi/asm/unistd.h
@@ -15,7 +15,7 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-#ifdef __LP64__
+#if defined(__LP64__) && !defined(__SYSCALL_COMPAT)
 #define __ARCH_WANT_NEW_STAT
 #define __ARCH_WANT_SET_GET_RLIMIT
 #endif /* __LP64__ */
diff --git a/arch/riscv/kernel/Makefile b/arch/riscv/kernel/Makefile
index 62de075fc..7f25f2d8c 100644
--- a/arch/riscv/kernel/Makefile
+++ b/arch/riscv/kernel/Makefile
@@ -9,6 +9,10 @@ CFLAGS_REMOVE_patch.o	= $(CC_FLAGS_FTRACE)
 CFLAGS_REMOVE_sbi.o	= $(CC_FLAGS_FTRACE)
 endif
 
+ifdef CONFIG_KEXEC
+AFLAGS_kexec_relocate.o := -mcmodel=medany $(call cc-option,-mno-relax)
+endif
+
 extra-y += head.o
 extra-y += vmlinux.lds
 
@@ -30,10 +34,13 @@ obj-y	+= riscv_ksyms.o
 obj-y	+= stacktrace.o
 obj-y	+= cacheinfo.o
 obj-y	+= patch.o
+obj-y	+= probes/
 obj-$(CONFIG_MMU) += vdso.o vdso/
+obj-$(CONFIG_VECTOR_EMU) += soft_vector/
 
 obj-$(CONFIG_RISCV_M_MODE)	+= traps_misaligned.o
 obj-$(CONFIG_FPU)		+= fpu.o
+obj-$(CONFIG_VECTOR)		+= vector.o
 obj-$(CONFIG_SMP)		+= smpboot.o
 obj-$(CONFIG_SMP)		+= smp.o
 obj-$(CONFIG_SMP)		+= cpu_ops.o
@@ -44,6 +51,8 @@ obj-$(CONFIG_MODULE_SECTIONS)	+= module-sections.o
 obj-$(CONFIG_FUNCTION_TRACER)	+= mcount.o ftrace.o
 obj-$(CONFIG_DYNAMIC_FTRACE)	+= mcount-dyn.o
 
+obj-$(CONFIG_TRACE_IRQFLAGS)	+= trace_irq.o
+
 obj-$(CONFIG_RISCV_BASE_PMU)	+= perf_event.o
 obj-$(CONFIG_PERF_EVENTS)	+= perf_callchain.o
 obj-$(CONFIG_HAVE_PERF_REGS)	+= perf_regs.o
@@ -53,9 +62,15 @@ obj-$(CONFIG_SMP) += cpu_ops_sbi.o
 endif
 obj-$(CONFIG_HOTPLUG_CPU)	+= cpu-hotplug.o
 obj-$(CONFIG_KGDB)		+= kgdb.o
+obj-$(CONFIG_KEXEC)		+= kexec_relocate.o crash_save_regs.o machine_kexec.o
+obj-$(CONFIG_CRASH_DUMP)	+= crash_dump.o
 
 obj-$(CONFIG_JUMP_LABEL)	+= jump_label.o
 
 obj-$(CONFIG_EFI)		+= efi.o
 
+obj-$(CONFIG_COMPAT)		+= compat_syscall_table.o
+obj-$(CONFIG_COMPAT)		+= compat_signal.o
+obj-$(CONFIG_COMPAT)		+= compat_vdso/
+
 clean:
diff --git a/arch/riscv/kernel/asm-offsets.c b/arch/riscv/kernel/asm-offsets.c
index db203442c..431afa56c 100644
--- a/arch/riscv/kernel/asm-offsets.c
+++ b/arch/riscv/kernel/asm-offsets.c
@@ -67,6 +67,49 @@ void asm_offsets(void)
 	OFFSET(TASK_THREAD_F31, task_struct, thread.fstate.f[31]);
 	OFFSET(TASK_THREAD_FCSR, task_struct, thread.fstate.fcsr);
 
+	OFFSET(TASK_THREAD_V0,  task_struct, thread.vstate.v[0]);
+	OFFSET(TASK_THREAD_V1,  task_struct, thread.vstate.v[1]);
+	OFFSET(TASK_THREAD_V2,  task_struct, thread.vstate.v[2]);
+	OFFSET(TASK_THREAD_V3,  task_struct, thread.vstate.v[3]);
+	OFFSET(TASK_THREAD_V4,  task_struct, thread.vstate.v[4]);
+	OFFSET(TASK_THREAD_V5,  task_struct, thread.vstate.v[5]);
+	OFFSET(TASK_THREAD_V6,  task_struct, thread.vstate.v[6]);
+	OFFSET(TASK_THREAD_V7,  task_struct, thread.vstate.v[7]);
+	OFFSET(TASK_THREAD_V8,  task_struct, thread.vstate.v[8]);
+	OFFSET(TASK_THREAD_V9,  task_struct, thread.vstate.v[9]);
+	OFFSET(TASK_THREAD_V10, task_struct, thread.vstate.v[10]);
+	OFFSET(TASK_THREAD_V11, task_struct, thread.vstate.v[11]);
+	OFFSET(TASK_THREAD_V12, task_struct, thread.vstate.v[12]);
+	OFFSET(TASK_THREAD_V13, task_struct, thread.vstate.v[13]);
+	OFFSET(TASK_THREAD_V14, task_struct, thread.vstate.v[14]);
+	OFFSET(TASK_THREAD_V15, task_struct, thread.vstate.v[15]);
+	OFFSET(TASK_THREAD_V16, task_struct, thread.vstate.v[16]);
+	OFFSET(TASK_THREAD_V17, task_struct, thread.vstate.v[17]);
+	OFFSET(TASK_THREAD_V18, task_struct, thread.vstate.v[18]);
+	OFFSET(TASK_THREAD_V19, task_struct, thread.vstate.v[19]);
+	OFFSET(TASK_THREAD_V20, task_struct, thread.vstate.v[20]);
+	OFFSET(TASK_THREAD_V21, task_struct, thread.vstate.v[21]);
+	OFFSET(TASK_THREAD_V22, task_struct, thread.vstate.v[22]);
+	OFFSET(TASK_THREAD_V23, task_struct, thread.vstate.v[23]);
+	OFFSET(TASK_THREAD_V24, task_struct, thread.vstate.v[24]);
+	OFFSET(TASK_THREAD_V25, task_struct, thread.vstate.v[25]);
+	OFFSET(TASK_THREAD_V26, task_struct, thread.vstate.v[26]);
+	OFFSET(TASK_THREAD_V27, task_struct, thread.vstate.v[27]);
+	OFFSET(TASK_THREAD_V28, task_struct, thread.vstate.v[28]);
+	OFFSET(TASK_THREAD_V29, task_struct, thread.vstate.v[29]);
+	OFFSET(TASK_THREAD_V30, task_struct, thread.vstate.v[30]);
+	OFFSET(TASK_THREAD_V31, task_struct, thread.vstate.v[31]);
+	OFFSET(TASK_THREAD_VSTART, task_struct, thread.vstate.vstart);
+	OFFSET(TASK_THREAD_VXSAT, task_struct, thread.vstate.vxsat);
+	OFFSET(TASK_THREAD_VXRM, task_struct, thread.vstate.vxrm);
+	OFFSET(TASK_THREAD_VL, task_struct, thread.vstate.vl);
+	OFFSET(TASK_THREAD_VTYPE, task_struct, thread.vstate.vtype);
+#ifdef CONFIG_VLEN_256
+	DEFINE(RISCV_VECTOR_VLENB, sizeof(struct __riscv_vblen));
+#else
+	DEFINE(RISCV_VECTOR_VLENB, sizeof(__uint128_t));
+#endif
+
 	DEFINE(PT_SIZE, sizeof(struct pt_regs));
 	OFFSET(PT_EPC, pt_regs, epc);
 	OFFSET(PT_RA, pt_regs, ra);
@@ -168,6 +211,7 @@ void asm_offsets(void)
 		- offsetof(struct task_struct, thread.ra)
 	);
 
+	/* Float Point */
 	DEFINE(TASK_THREAD_F0_F0,
 		  offsetof(struct task_struct, thread.fstate.f[0])
 		- offsetof(struct task_struct, thread.fstate.f[0])
@@ -301,6 +345,156 @@ void asm_offsets(void)
 		- offsetof(struct task_struct, thread.fstate.f[0])
 	);
 
+	/* Vector */
+	DEFINE(TASK_THREAD_V0_V0,
+		  offsetof(struct task_struct, thread.vstate.v[0])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V1_V0,
+		  offsetof(struct task_struct, thread.vstate.v[1])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V2_V0,
+		  offsetof(struct task_struct, thread.vstate.v[2])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V3_V0,
+		  offsetof(struct task_struct, thread.vstate.v[3])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V4_V0,
+		  offsetof(struct task_struct, thread.vstate.v[4])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V5_V0,
+		  offsetof(struct task_struct, thread.vstate.v[5])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V6_V0,
+		  offsetof(struct task_struct, thread.vstate.v[6])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V7_V0,
+		  offsetof(struct task_struct, thread.vstate.v[7])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V8_V0,
+		  offsetof(struct task_struct, thread.vstate.v[8])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V9_V0,
+		  offsetof(struct task_struct, thread.vstate.v[9])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V10_V0,
+		  offsetof(struct task_struct, thread.vstate.v[10])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V11_V0,
+		  offsetof(struct task_struct, thread.vstate.v[11])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V12_V0,
+		  offsetof(struct task_struct, thread.vstate.v[12])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V13_V0,
+		  offsetof(struct task_struct, thread.vstate.v[13])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V14_V0,
+		  offsetof(struct task_struct, thread.vstate.v[14])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V15_V0,
+		  offsetof(struct task_struct, thread.vstate.v[15])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V16_V0,
+		  offsetof(struct task_struct, thread.vstate.v[16])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V17_V0,
+		  offsetof(struct task_struct, thread.vstate.v[17])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V18_V0,
+		  offsetof(struct task_struct, thread.vstate.v[18])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V19_V0,
+		  offsetof(struct task_struct, thread.vstate.v[19])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V20_V0,
+		  offsetof(struct task_struct, thread.vstate.v[20])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V21_V0,
+		  offsetof(struct task_struct, thread.vstate.v[21])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V22_V0,
+		  offsetof(struct task_struct, thread.vstate.v[22])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V23_V0,
+		  offsetof(struct task_struct, thread.vstate.v[23])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V24_V0,
+		  offsetof(struct task_struct, thread.vstate.v[24])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V25_V0,
+		  offsetof(struct task_struct, thread.vstate.v[25])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V26_V0,
+		  offsetof(struct task_struct, thread.vstate.v[26])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V27_V0,
+		  offsetof(struct task_struct, thread.vstate.v[27])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V28_V0,
+		  offsetof(struct task_struct, thread.vstate.v[28])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V29_V0,
+		  offsetof(struct task_struct, thread.vstate.v[29])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V30_V0,
+		  offsetof(struct task_struct, thread.vstate.v[30])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V31_V0,
+		  offsetof(struct task_struct, thread.vstate.v[31])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VSTART_V0,
+		  offsetof(struct task_struct, thread.vstate.vstart)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VXSAT_V0,
+		  offsetof(struct task_struct, thread.vstate.vxsat)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VXRM_V0,
+		  offsetof(struct task_struct, thread.vstate.vxrm)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VL_V0,
+		  offsetof(struct task_struct, thread.vstate.vl)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VTYPE_V0,
+		  offsetof(struct task_struct, thread.vstate.vtype)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+
 	/*
 	 * We allocate a pt_regs on the stack when entering the kernel.  This
 	 * ensures the alignment is sane.
diff --git a/arch/riscv/kernel/compat_signal.c b/arch/riscv/kernel/compat_signal.c
new file mode 100755
index 000000000..d7f9f1154
--- /dev/null
+++ b/arch/riscv/kernel/compat_signal.c
@@ -0,0 +1,287 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/compat.h>
+#include <linux/signal.h>
+#include <linux/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/tracehook.h>
+#include <linux/linkage.h>
+
+#include <asm/ucontext.h>
+#include <asm/vdso.h>
+#include <asm/switch_to.h>
+#include <asm/csr.h>
+
+#define COMPAT_DEBUG_SIG 0
+
+struct compat_sigcontext {
+	struct compat_user_regs_struct sc_regs;
+	union __riscv_fp_state sc_fpregs;
+	struct __riscv_v_state sc_vregs;
+};
+
+struct compat_ucontext {
+	compat_ulong_t		uc_flags;
+	struct compat_ucontext	*uc_link;
+	compat_stack_t		uc_stack;
+	sigset_t		uc_sigmask;
+	/* There's some padding here to allow sigset_t to be expanded in the
+	 * future.  Though this is unlikely, other architectures put uc_sigmask
+	 * at the end of this structure and explicitly state it can be
+	 * expanded, so we didn't want to box ourselves in here. */
+	__u8		  __unused[1024 / 8 - sizeof(sigset_t)];
+	/* We can't put uc_sigmask at the end of this structure because we need
+	 * to be able to expand sigcontext in the future.  For example, the
+	 * vector ISA extension will almost certainly add ISA state.  We want
+	 * to ensure all user-visible ISA state can be saved and restored via a
+	 * ucontext, so we're putting this at the end in order to allow for
+	 * infinite extensibility.  Since we know this will be extended and we
+	 * assume sigset_t won't be extended an extreme amount, we're
+	 * prioritizing this. */
+	struct compat_sigcontext uc_mcontext;
+};
+
+struct compat_rt_sigframe {
+	struct compat_siginfo info;
+	struct compat_ucontext uc;
+};
+
+#ifdef CONFIG_FPU
+static long compat_restore_fp_state(struct pt_regs *regs,
+	union __riscv_fp_state __user *sc_fpregs)
+{
+	long err;
+	struct __riscv_d_ext_state __user *state = &sc_fpregs->d;
+	size_t i;
+
+	err = __copy_from_user(&current->thread.fstate, state, sizeof(*state));
+	if (unlikely(err))
+		return err;
+
+	fstate_restore(current, regs);
+
+	/* We support no other extension state at this time. */
+	for (i = 0; i < ARRAY_SIZE(sc_fpregs->q.reserved); i++) {
+		u32 value;
+
+		err = __get_user(value, &sc_fpregs->q.reserved[i]);
+		if (unlikely(err))
+			break;
+		if (value != 0)
+			return -EINVAL;
+	}
+
+	return err;
+}
+
+static long compat_save_fp_state(struct pt_regs *regs,
+			  union __riscv_fp_state __user *sc_fpregs)
+{
+	long err;
+	struct __riscv_d_ext_state __user *state = &sc_fpregs->d;
+	size_t i;
+
+	fstate_save(current, regs);
+	err = __copy_to_user(state, &current->thread.fstate, sizeof(*state));
+	if (unlikely(err))
+		return err;
+
+	/* We support no other extension state at this time. */
+	for (i = 0; i < ARRAY_SIZE(sc_fpregs->q.reserved); i++) {
+		err = __put_user(0, &sc_fpregs->q.reserved[i]);
+		if (unlikely(err))
+			break;
+	}
+
+	return err;
+}
+#else
+#define compat_save_fp_state(task, regs) (0)
+#define compat_restore_fp_state(task, regs) (0)
+#endif
+
+#ifdef CONFIG_VECTOR
+static long compat_restore_v_state(struct pt_regs *regs,
+			    struct __riscv_v_state *sc_vregs)
+{
+	long err;
+	struct __riscv_v_state __user *state = sc_vregs;
+
+	err = __copy_from_user(&current->thread.vstate, state, sizeof(*state));
+	if (unlikely(err))
+		return err;
+
+	vstate_restore(current, regs);
+
+	return err;
+}
+
+static long compat_save_v_state(struct pt_regs *regs,
+			 struct __riscv_v_state *sc_vregs)
+{
+	long err;
+	struct __riscv_v_state __user *state = sc_vregs;
+
+	vstate_save(current, regs);
+	err = __copy_to_user(state, &current->thread.vstate, sizeof(*state));
+	if (unlikely(err))
+		return err;
+
+	return err;
+}
+#else
+#define compat_save_v_state(task, regs) (0)
+#define compat_restore_v_state(task, regs) (0)
+#endif
+
+static long compat_restore_sigcontext(struct pt_regs *regs,
+	struct compat_sigcontext __user *sc)
+{
+	long err;
+	struct compat_user_regs_struct cregs;
+
+	/* sc_regs is structured the same as the start of pt_regs */
+	err = __copy_from_user(&cregs, &sc->sc_regs, sizeof(sc->sc_regs));
+
+	cregs_to_regs(&cregs, regs);
+
+	/* Restore the floating-point state. */
+	if (has_fpu)
+		err |= compat_restore_fp_state(regs, &sc->sc_fpregs);
+
+	/* Restore the vector state. */
+	if (has_vector)
+		err |= compat_restore_v_state(regs, &sc->sc_vregs);
+
+	return err;
+}
+
+COMPAT_SYSCALL_DEFINE0(rt_sigreturn)
+{
+	struct pt_regs *regs = current_pt_regs();
+	struct compat_rt_sigframe __user *frame;
+	struct task_struct *task;
+	sigset_t set;
+
+	/* Always make any pending restarted system calls return -EINTR */
+	current->restart_block.fn = do_no_restart_syscall;
+
+	frame = (struct compat_rt_sigframe __user *)regs->sp;
+
+	if (!access_ok(frame, sizeof(*frame)))
+		goto badframe;
+
+	if (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))
+		goto badframe;
+
+	set_current_blocked(&set);
+
+	if (compat_restore_sigcontext(regs, &frame->uc.uc_mcontext))
+		goto badframe;
+
+	if (compat_restore_altstack(&frame->uc.uc_stack))
+		goto badframe;
+
+	return regs->a0;
+
+badframe:
+	task = current;
+	if (show_unhandled_signals) {
+		pr_info_ratelimited(
+			"%s[%d]: bad frame in %s: frame=%p pc=%p sp=%p\n",
+			task->comm, task_pid_nr(task), __func__,
+			frame, (void *)regs->epc, (void *)regs->sp);
+	}
+	force_sig(SIGSEGV);
+	return 0;
+}
+
+static long compat_setup_sigcontext(struct compat_rt_sigframe __user *frame,
+	struct pt_regs *regs)
+{
+	struct compat_sigcontext __user *sc = &frame->uc.uc_mcontext;
+	struct compat_user_regs_struct cregs;
+	long err;
+
+	regs_to_cregs(&cregs, regs);
+
+	/* sc_regs is structured the same as the start of pt_regs */
+	err = __copy_to_user(&sc->sc_regs, &cregs, sizeof(sc->sc_regs));
+	/* Save the floating-point state. */
+	if (has_fpu)
+		err |= compat_save_fp_state(regs, &sc->sc_fpregs);
+	/* Save the vector state. */
+	if (has_vector)
+		err |= compat_save_v_state(regs, &sc->sc_vregs);
+
+	return err;
+}
+
+static inline void __user *compat_get_sigframe(struct ksignal *ksig,
+	struct pt_regs *regs, size_t framesize)
+{
+	unsigned long sp;
+	/* Default to using normal stack */
+	sp = regs->sp;
+
+	/*
+	 * If we are on the alternate signal stack and would overflow it, don't.
+	 * Return an always-bogus address instead so we will die with SIGSEGV.
+	 */
+	if (on_sig_stack(sp) && !likely(on_sig_stack(sp - framesize)))
+		return (void __user __force *)(-1UL);
+
+	/* This is the X/Open sanctioned signal stack switching. */
+	sp = sigsp(sp, ksig) - framesize;
+
+	/* Align the stack frame. */
+	sp &= ~0xfUL;
+
+	return (void __user *)sp;
+}
+
+int compat_setup_rt_frame(struct ksignal *ksig, sigset_t *set,
+	struct pt_regs *regs)
+{
+	struct compat_rt_sigframe __user *frame;
+	long err = 0;
+
+	frame = compat_get_sigframe(ksig, regs, sizeof(*frame));
+	if (!access_ok(frame, sizeof(*frame)))
+		return -EFAULT;
+
+	err |= copy_siginfo_to_user32(&frame->info, &ksig->info);
+
+	/* Create the ucontext. */
+	err |= __put_user(0, &frame->uc.uc_flags);
+	err |= __put_user(NULL, &frame->uc.uc_link);
+	err |= __compat_save_altstack(&frame->uc.uc_stack, regs->sp);
+	err |= compat_setup_sigcontext(frame, regs);
+	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
+	if (err)
+		return -EFAULT;
+
+	regs->ra = (unsigned long)COMPAT_VDSO_SYMBOL(
+			current->mm->context.vdso, rt_sigreturn);
+
+	/*
+	 * Set up registers for signal handler.
+	 * Registers that we don't modify keep the value they had from
+	 * user-space at the time we took the signal.
+	 * We always pass siginfo and mcontext, regardless of SA_SIGINFO,
+	 * since some things rely on this (e.g. glibc's debug/segfault.c).
+	 */
+	regs->epc = (unsigned long)ksig->ka.sa.sa_handler;
+	regs->sp = (unsigned long)frame;
+	regs->a0 = ksig->sig;                     /* a0: signal number */
+	regs->a1 = (unsigned long)(&frame->info); /* a1: siginfo pointer */
+	regs->a2 = (unsigned long)(&frame->uc);   /* a2: ucontext pointer */
+
+#if COMPAT_DEBUG_SIG
+	pr_info("SIG deliver (%s:%d): sig=%d pc=%p ra=%p sp=%p\n",
+		current->comm, task_pid_nr(current), ksig->sig,
+		(void *)regs->epc, (void *)regs->ra, frame);
+#endif
+
+	return 0;
+}
diff --git a/arch/riscv/kernel/compat_syscall_table.c b/arch/riscv/kernel/compat_syscall_table.c
new file mode 100755
index 000000000..6d1a408e5
--- /dev/null
+++ b/arch/riscv/kernel/compat_syscall_table.c
@@ -0,0 +1,84 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#define __SYSCALL_COMPAT
+
+#include <linux/compat.h>
+#include <linux/syscalls.h>
+#include <asm/cacheflush.h>
+#include <asm-generic/mman-common.h>
+
+SYSCALL_DEFINE6(mmap2, unsigned long, addr, unsigned long, len,
+	unsigned long, prot, unsigned long, flags,
+	unsigned long, fd, unsigned long, offset)
+{
+	if ((prot & PROT_WRITE) && (prot & PROT_EXEC))
+		if (unlikely(!(prot & PROT_READ)))
+			return -EINVAL;
+
+	return ksys_mmap_pgoff(addr, len, prot, flags, fd, offset);
+}
+
+#define arg_u32p(name)  u32, name##_lo, u32, name##_hi
+
+#define arg_u64(name)   (((u64)name##_hi << 32) | \
+			 ((u64)name##_lo & 0xffffffff))
+
+COMPAT_SYSCALL_DEFINE3(truncate64, const char __user *, pathname,
+		       arg_u32p(length))
+{
+	return ksys_truncate(pathname, arg_u64(length));
+}
+
+COMPAT_SYSCALL_DEFINE3(ftruncate64, unsigned int, fd, arg_u32p(length))
+{
+	return ksys_ftruncate(fd, arg_u64(length));
+}
+
+COMPAT_SYSCALL_DEFINE6(fallocate, int, fd, int, mode,
+		       arg_u32p(offset), arg_u32p(len))
+{
+	return ksys_fallocate(fd, mode, arg_u64(offset), arg_u64(len));
+}
+
+COMPAT_SYSCALL_DEFINE5(pread64, unsigned int, fd, char __user *, buf,
+		       size_t, count, arg_u32p(pos))
+{
+	return ksys_pread64(fd, buf, count, arg_u64(pos));
+}
+
+COMPAT_SYSCALL_DEFINE5(pwrite64, unsigned int, fd,
+		       const char __user *, buf, size_t, count, arg_u32p(pos))
+{
+	return ksys_pwrite64(fd, buf, count, arg_u64(pos));
+}
+
+COMPAT_SYSCALL_DEFINE6(sync_file_range, int, fd, arg_u32p(offset),
+		       arg_u32p(nbytes), unsigned int, flags)
+{
+	return ksys_sync_file_range(fd, arg_u64(offset), arg_u64(nbytes),
+				    flags);
+}
+
+COMPAT_SYSCALL_DEFINE4(readahead, int, fd, arg_u32p(offset),
+		       size_t, count)
+{
+	return ksys_readahead(fd, arg_u64(offset), count);
+}
+
+COMPAT_SYSCALL_DEFINE6(fadvise64_64, int, fd, arg_u32p(offset),
+		       arg_u32p(len), int, advice)
+{
+	return ksys_fadvise64_64(fd, arg_u64(offset), arg_u64(len), advice);
+}
+
+#undef __SYSCALL
+#define __SYSCALL(nr, call)      [nr] = (call),
+
+asmlinkage long compat_sys_rt_sigreturn(void);
+
+asmlinkage long sys_riscv_flush_icache(uintptr_t, uintptr_t, uintptr_t);
+
+const void *compat_sys_call_table[__NR_syscalls] = {
+	[0 ... __NR_syscalls - 1] = sys_ni_syscall,
+#include <asm/unistd.h>
+};
diff --git a/arch/riscv/kernel/compat_vdso/Makefile b/arch/riscv/kernel/compat_vdso/Makefile
new file mode 100755
index 000000000..f0c00d293
--- /dev/null
+++ b/arch/riscv/kernel/compat_vdso/Makefile
@@ -0,0 +1,66 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+# Absolute relocation type $(ARCH_REL_TYPE_ABS) needs to be defined before
+# the inclusion of generic Makefile.
+ARCH_REL_TYPE_ABS := R_RISCV_32|R_RISCV_64|R_RISCV_JUMP_SLOT
+include $(srctree)/lib/vdso/Makefile
+# Symbols present in the compat_vdso
+compat_vdso-syms  = rt_sigreturn
+compat_vdso-syms += getcpu
+compat_vdso-syms += flush_icache
+
+# Files to link into the compat_vdso
+obj-compat_vdso = $(patsubst %, %.o, $(compat_vdso-syms)) note.o
+
+ccflags-y := -fno-stack-protector
+
+# Build rules
+targets := $(obj-compat_vdso) compat_vdso.so compat_vdso.so.dbg compat_vdso.lds
+obj-compat_vdso := $(addprefix $(obj)/, $(obj-compat_vdso))
+
+obj-y += compat_vdso.o
+CPPFLAGS_compat_vdso.lds += -P -C -U$(ARCH)
+
+# Disable profiling and instrumentation for VDSO code
+GCOV_PROFILE := n
+KCOV_INSTRUMENT := n
+
+# Force dependency
+$(obj)/compat_vdso.o: $(obj)/compat_vdso.so
+
+# link rule for the .so file, .lds has to be first
+$(obj)/compat_vdso.so.dbg: $(obj)/compat_vdso.lds $(obj-compat_vdso) FORCE
+	$(call if_changed,compat_vdsold)
+LDFLAGS_compat_vdso.so.dbg = -shared -S -soname=linux-compat_vdso.so.1 \
+	--build-id=sha1 --hash-style=both --eh-frame-hdr
+
+# strip rule for the .so file
+$(obj)/%.so: OBJCOPYFLAGS := -S
+$(obj)/%.so: $(obj)/%.so.dbg FORCE
+	$(call if_changed,objcopy)
+
+# Generate VDSO offsets using helper script
+gen-compat_vdsosym := $(srctree)/$(src)/gen_compat_vdso_offsets.sh
+quiet_cmd_compat_vdsosym = VDSOSYM $@
+	cmd_compat_vdsosym = $(NM) $< | $(gen-compat_vdsosym) | LC_ALL=C sort > $@
+
+include/generated/compat_vdso-offsets.h: $(obj)/compat_vdso.so.dbg FORCE
+	$(call if_changed,compat_vdsosym)
+
+# actual build commands
+# The DSO images are built using a special linker script
+# Make sure only to export the intended __compat_vdso_xxx symbol offsets.
+quiet_cmd_compat_vdsold = VDSOLD  $@
+      cmd_compat_vdsold = $(LD) $(ld_flags) -T $(filter-out FORCE,$^) -o $@.tmp && \
+                   $(OBJCOPY) $(patsubst %, -G __compat_vdso_%, $(compat_vdso-syms)) $@.tmp $@ && \
+                   rm $@.tmp
+
+# install commands for the unstripped file
+quiet_cmd_compat_vdso_install = INSTALL $@
+      cmd_compat_vdso_install = cp $(obj)/$@.dbg $(MODLIB)/compat_vdso/$@
+
+compat_vdso.so: $(obj)/compat_vdso.so.dbg
+	@mkdir -p $(MODLIB)/compat_vdso
+	$(call cmd,compat_vdso_install)
+
+compat_vdso_install: compat_vdso.so
diff --git a/arch/riscv/kernel/compat_vdso/compat_vdso.S b/arch/riscv/kernel/compat_vdso/compat_vdso.S
new file mode 100755
index 000000000..ffd66237e
--- /dev/null
+++ b/arch/riscv/kernel/compat_vdso/compat_vdso.S
@@ -0,0 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#define	vdso_start	compat_vdso_start
+#define	vdso_end	compat_vdso_end
+
+#define	__VDSO_PATH	"arch/riscv/kernel/compat_vdso/compat_vdso.so"
+
+#include "../vdso/vdso.S"
diff --git a/arch/riscv/kernel/compat_vdso/compat_vdso.lds.S b/arch/riscv/kernel/compat_vdso/compat_vdso.lds.S
new file mode 100755
index 000000000..c7c9355d3
--- /dev/null
+++ b/arch/riscv/kernel/compat_vdso/compat_vdso.lds.S
@@ -0,0 +1,3 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#include "../vdso/vdso.lds.S"
diff --git a/arch/riscv/kernel/compat_vdso/flush_icache.S b/arch/riscv/kernel/compat_vdso/flush_icache.S
new file mode 100755
index 000000000..523dd8b96
--- /dev/null
+++ b/arch/riscv/kernel/compat_vdso/flush_icache.S
@@ -0,0 +1,3 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#include "../vdso/flush_icache.S"
diff --git a/arch/riscv/kernel/compat_vdso/gen_compat_vdso_offsets.sh b/arch/riscv/kernel/compat_vdso/gen_compat_vdso_offsets.sh
new file mode 100755
index 000000000..8ac070c78
--- /dev/null
+++ b/arch/riscv/kernel/compat_vdso/gen_compat_vdso_offsets.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0
+
+LC_ALL=C
+sed -n -e 's/^[0]\+\(0[0-9a-fA-F]*\) . \(__vdso_[a-zA-Z0-9_]*\)$/\#define compat\2_offset\t0x\1/p'
diff --git a/arch/riscv/kernel/compat_vdso/getcpu.S b/arch/riscv/kernel/compat_vdso/getcpu.S
new file mode 100755
index 000000000..10f463efe
--- /dev/null
+++ b/arch/riscv/kernel/compat_vdso/getcpu.S
@@ -0,0 +1,3 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#include "../vdso/getcpu.S"
diff --git a/arch/riscv/kernel/compat_vdso/note.S b/arch/riscv/kernel/compat_vdso/note.S
new file mode 100755
index 000000000..b10312907
--- /dev/null
+++ b/arch/riscv/kernel/compat_vdso/note.S
@@ -0,0 +1,3 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#include "../vdso/note.S"
diff --git a/arch/riscv/kernel/compat_vdso/rt_sigreturn.S b/arch/riscv/kernel/compat_vdso/rt_sigreturn.S
new file mode 100755
index 000000000..884aada4f
--- /dev/null
+++ b/arch/riscv/kernel/compat_vdso/rt_sigreturn.S
@@ -0,0 +1,3 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#include "../vdso/rt_sigreturn.S"
diff --git a/arch/riscv/kernel/cpu.c b/arch/riscv/kernel/cpu.c
index 6d59e6906..58972bbc4 100644
--- a/arch/riscv/kernel/cpu.c
+++ b/arch/riscv/kernel/cpu.c
@@ -107,6 +107,7 @@ static int c_show(struct seq_file *m, void *v)
 	unsigned long cpu_id = (unsigned long)v - 1;
 	struct device_node *node = of_get_cpu_node(cpu_id, NULL);
 	const char *compat, *isa, *mmu;
+	const char  *freq, *icache, *dcache, *l2cache, *tlb, *cacheline, *vecver;
 
 	seq_printf(m, "processor\t: %lu\n", cpu_id);
 	seq_printf(m, "hart\t\t: %lu\n", cpuid_to_hartid_map(cpu_id));
@@ -117,6 +118,28 @@ static int c_show(struct seq_file *m, void *v)
 	if (!of_property_read_string(node, "compatible", &compat)
 	    && strcmp(compat, "riscv"))
 		seq_printf(m, "uarch\t\t: %s\n", compat);
+
+	if (!of_property_read_string(node, "cpu-freq", &freq))
+		seq_printf(m, "cpu-freq\t: %s\n", freq);
+
+	if (!of_property_read_string(node, "cpu-icache", &icache))
+		seq_printf(m, "cpu-icache\t: %s\n", icache);
+
+	if (!of_property_read_string(node, "cpu-dcache", &dcache))
+		seq_printf(m, "cpu-dcache\t: %s\n", dcache);
+
+	if (!of_property_read_string(node, "cpu-l2cache", &l2cache))
+		seq_printf(m, "cpu-l2cache\t: %s\n", l2cache);
+
+	if (!of_property_read_string(node, "cpu-tlb", &tlb))
+		seq_printf(m, "cpu-tlb\t\t: %s\n", tlb);
+
+	if (!of_property_read_string(node, "cpu-cacheline", &cacheline))
+		seq_printf(m, "cpu-cacheline\t: %s\n", cacheline);
+
+	if (!of_property_read_string(node, "cpu-vector", &vecver))
+		seq_printf(m, "cpu-vector\t: %s\n", vecver);
+
 	seq_puts(m, "\n");
 	of_node_put(node);
 
diff --git a/arch/riscv/kernel/cpu_ops_spinwait.c b/arch/riscv/kernel/cpu_ops_spinwait.c
index b2c957bb6..4d980d8bd 100644
--- a/arch/riscv/kernel/cpu_ops_spinwait.c
+++ b/arch/riscv/kernel/cpu_ops_spinwait.c
@@ -33,6 +33,8 @@ static int spinwait_cpu_start(unsigned int cpuid, struct task_struct *tidle)
 	 */
 	cpu_update_secondary_bootdata(cpuid, tidle);
 
+	sbi_ecall(0x09000003, 0, cpuid_to_hartid_map(cpuid), 0, 0, 0, 0, 0);
+
 	return 0;
 }
 
diff --git a/arch/riscv/kernel/cpufeature.c b/arch/riscv/kernel/cpufeature.c
index ac202f44a..0905ea573 100644
--- a/arch/riscv/kernel/cpufeature.c
+++ b/arch/riscv/kernel/cpufeature.c
@@ -59,6 +59,10 @@ bool __riscv_isa_extension_available(const unsigned long *isa_bitmap, int bit)
 }
 EXPORT_SYMBOL_GPL(__riscv_isa_extension_available);
 
+#ifdef CONFIG_VECTOR
+bool has_vector __read_mostly;
+#endif
+
 void riscv_fill_hwcap(void)
 {
 	struct device_node *node;
@@ -73,6 +77,7 @@ void riscv_fill_hwcap(void)
 	isa2hwcap['f'] = isa2hwcap['F'] = COMPAT_HWCAP_ISA_F;
 	isa2hwcap['d'] = isa2hwcap['D'] = COMPAT_HWCAP_ISA_D;
 	isa2hwcap['c'] = isa2hwcap['C'] = COMPAT_HWCAP_ISA_C;
+	isa2hwcap['v'] = isa2hwcap['V'] = COMPAT_HWCAP_ISA_V;
 
 	elf_hwcap = 0;
 
@@ -148,4 +153,9 @@ void riscv_fill_hwcap(void)
 	if (elf_hwcap & (COMPAT_HWCAP_ISA_F | COMPAT_HWCAP_ISA_D))
 		has_fpu = true;
 #endif
+
+#ifdef CONFIG_VECTOR
+	if (elf_hwcap & COMPAT_HWCAP_ISA_V)
+		has_vector = true;
+#endif
 }
diff --git a/arch/riscv/kernel/crash_dump.c b/arch/riscv/kernel/crash_dump.c
new file mode 100755
index 000000000..86cc0ada5
--- /dev/null
+++ b/arch/riscv/kernel/crash_dump.c
@@ -0,0 +1,46 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * This code comes from arch/arm64/kernel/crash_dump.c
+ * Created by: AKASHI Takahiro <takahiro.akashi@linaro.org>
+ * Copyright (C) 2017 Linaro Limited
+ */
+
+#include <linux/crash_dump.h>
+#include <linux/io.h>
+
+/**
+ * copy_oldmem_page() - copy one page from old kernel memory
+ * @pfn: page frame number to be copied
+ * @buf: buffer where the copied page is placed
+ * @csize: number of bytes to copy
+ * @offset: offset in bytes into the page
+ * @userbuf: if set, @buf is in a user address space
+ *
+ * This function copies one page from old kernel memory into buffer pointed by
+ * @buf. If @buf is in userspace, set @userbuf to %1. Returns number of bytes
+ * copied or negative error in case of failure.
+ */
+ssize_t copy_oldmem_page(unsigned long pfn, char *buf,
+			 size_t csize, unsigned long offset,
+			 int userbuf)
+{
+	void *vaddr;
+
+	if (!csize)
+		return 0;
+
+	vaddr = memremap(__pfn_to_phys(pfn), PAGE_SIZE, MEMREMAP_WB);
+	if (!vaddr)
+		return -ENOMEM;
+
+	if (userbuf) {
+		if (copy_to_user((char __user *)buf, vaddr + offset, csize)) {
+			memunmap(vaddr);
+			return -EFAULT;
+		}
+	} else
+		memcpy(buf, vaddr + offset, csize);
+
+	memunmap(vaddr);
+	return csize;
+}
diff --git a/arch/riscv/kernel/crash_save_regs.S b/arch/riscv/kernel/crash_save_regs.S
new file mode 100755
index 000000000..7832fb763
--- /dev/null
+++ b/arch/riscv/kernel/crash_save_regs.S
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 FORTH-ICS/CARV
+ *  Nick Kossifidis <mick@ics.forth.gr>
+ */
+
+#include <asm/asm.h>    	/* For RISCV_* and REG_* macros */
+#include <asm/csr.h>		/* For CSR_* macros */
+#include <asm/asm-offsets.h>	/* For offsets on pt_regs */
+#include <linux/linkage.h>	/* For SYM_* macros */
+
+.section ".text"
+SYM_CODE_START(riscv_crash_save_regs)
+	REG_S ra,  PT_RA(a0)	/* x1 */
+	REG_S sp,  PT_SP(a0)	/* x2 */
+	REG_S gp,  PT_GP(a0)	/* x3 */
+	REG_S tp,  PT_TP(a0)	/* x4 */
+	REG_S t0,  PT_T0(a0)	/* x5 */
+	REG_S t1,  PT_T1(a0)	/* x6 */
+	REG_S t2,  PT_T2(a0)	/* x7 */
+	REG_S s0,  PT_S0(a0)	/* x8/fp */
+	REG_S s1,  PT_S1(a0)	/* x9 */
+	REG_S a0,  PT_A0(a0)	/* x10 */
+	REG_S a1,  PT_A1(a0)	/* x11 */
+	REG_S a2,  PT_A2(a0)	/* x12 */
+	REG_S a3,  PT_A3(a0)	/* x13 */
+	REG_S a4,  PT_A4(a0)	/* x14 */
+	REG_S a5,  PT_A5(a0)	/* x15 */
+	REG_S a6,  PT_A6(a0)	/* x16 */
+	REG_S a7,  PT_A7(a0)	/* x17 */
+	REG_S s2,  PT_S2(a0)	/* x18 */
+	REG_S s3,  PT_S3(a0)	/* x19 */
+	REG_S s4,  PT_S4(a0)	/* x20 */
+	REG_S s5,  PT_S5(a0)	/* x21 */
+	REG_S s6,  PT_S6(a0)	/* x22 */
+	REG_S s7,  PT_S7(a0)	/* x23 */
+	REG_S s8,  PT_S8(a0)	/* x24 */
+	REG_S s9,  PT_S9(a0)	/* x25 */
+	REG_S s10, PT_S10(a0)	/* x26 */
+	REG_S s11, PT_S11(a0)	/* x27 */
+	REG_S t3,  PT_T3(a0)	/* x28 */
+	REG_S t4,  PT_T4(a0)	/* x29 */
+	REG_S t5,  PT_T5(a0)	/* x30 */
+	REG_S t6,  PT_T6(a0)	/* x31 */
+
+	csrr t1, CSR_STATUS
+	csrr t2, CSR_EPC
+	csrr t3, CSR_TVAL
+	csrr t4, CSR_CAUSE
+
+	REG_S t1, PT_STATUS(a0)
+	REG_S t2, PT_EPC(a0)
+	REG_S t3, PT_BADADDR(a0)
+	REG_S t4, PT_CAUSE(a0)
+	ret
+SYM_CODE_END(riscv_crash_save_regs)
diff --git a/arch/riscv/kernel/entry.S b/arch/riscv/kernel/entry.S
index 76274a4a1..ffe52667b 100644
--- a/arch/riscv/kernel/entry.S
+++ b/arch/riscv/kernel/entry.S
@@ -70,7 +70,7 @@ _save_context:
 	 * Disable the FPU to detect illegal usage of floating point in kernel
 	 * space.
 	 */
-	li t0, SR_SUM | SR_FS
+	li t0, SR_SUM | SR_FS | SR_VS
 
 	REG_L s0, TASK_TI_USER_SP(tp)
 	csrrc s1, CSR_STATUS, t0
@@ -98,7 +98,7 @@ _save_context:
 .option pop
 
 #ifdef CONFIG_TRACE_IRQFLAGS
-	call trace_hardirqs_off
+	call __trace_hardirqs_off
 #endif
 
 #ifdef CONFIG_CONTEXT_TRACKING
@@ -131,14 +131,30 @@ skip_context_tracking:
 	andi t0, s1, SR_PIE
 	beqz t0, 1f
 #ifdef CONFIG_TRACE_IRQFLAGS
-	call trace_hardirqs_on
+	call __trace_hardirqs_on
+
+	REG_L s1, PT_STATUS(sp)
 #endif
 	csrs CSR_STATUS, SR_IE
 
 1:
+#ifdef CONFIG_TRACE_IRQFLAGS
+	REG_L a0, PT_A0(sp)
+	REG_L a1, PT_A1(sp)
+	REG_L a2, PT_A2(sp)
+	REG_L a3, PT_A3(sp)
+	REG_L a4, PT_A4(sp)
+	REG_L a5, PT_A5(sp)
+	REG_L a6, PT_A6(sp)
+	REG_L a7, PT_A7(sp)
+#endif
 	la ra, ret_from_exception
 	/* Handle syscalls */
 	li t0, EXC_SYSCALL
+
+#ifdef CONFIG_TRACE_IRQFLAGS
+	REG_L s4, PT_CAUSE(sp)
+#endif
 	beq s4, t0, handle_syscall
 
 	/* Handle other exceptions */
@@ -181,6 +197,9 @@ handle_syscall:
 	 * Advance SEPC to avoid executing the original
 	 * scall instruction on sret
 	 */
+#ifdef CONFIG_TRACE_IRQFLAGS
+	REG_L s2, PT_EPC(sp)
+#endif
 	addi s2, s2, 0x4
 	REG_S s2, PT_EPC(sp)
 	/* Trace syscalls, but only if requested by the user. */
@@ -195,13 +214,27 @@ check_syscall_nr:
 	 * Syscall number held in a7.
 	 * If syscall number is above allowed value, redirect to ni_syscall.
 	 */
-	bgeu a7, t0, 1f
+	bgeu a7, t0, 3f
+#ifdef CONFIG_COMPAT
+	REG_L s0, PT_STATUS(sp)
+	srli s0, s0, SR_UXL_SHIFT
+	andi s0, s0, (SR_UXL >> SR_UXL_SHIFT)
+	li t0, (SR_UXL_32 >> SR_UXL_SHIFT)
+	sub t0, s0, t0
+	bnez t0, 1f
+
+	/* Call compat_syscall */
+	la s0, compat_sys_call_table
+	j 2f
+1:
+#endif
 	/* Call syscall */
 	la s0, sys_call_table
+2:
 	slli t0, a7, RISCV_LGPTR
 	add s0, s0, t0
 	REG_L s0, 0(s0)
-1:
+3:
 	jalr s0
 
 ret_from_syscall:
@@ -218,11 +251,11 @@ ret_from_syscall_rejected:
 	andi t0, t0, _TIF_SYSCALL_WORK
 	bnez t0, handle_syscall_trace_exit
 
-ret_from_exception:
+ENTRY(ret_from_exception)
 	REG_L s0, PT_STATUS(sp)
 	csrc CSR_STATUS, SR_IE
 #ifdef CONFIG_TRACE_IRQFLAGS
-	call trace_hardirqs_off
+	call __trace_hardirqs_off
 #endif
 #ifdef CONFIG_RISCV_M_MODE
 	/* the MPP value is too large to be used as an immediate arg for addi */
@@ -258,10 +291,10 @@ restore_all:
 	REG_L s1, PT_STATUS(sp)
 	andi t0, s1, SR_PIE
 	beqz t0, 1f
-	call trace_hardirqs_on
+	call __trace_hardirqs_on
 	j 2f
 1:
-	call trace_hardirqs_off
+	call __trace_hardirqs_off
 2:
 #endif
 	REG_L a0, PT_STATUS(sp)
diff --git a/arch/riscv/kernel/ftrace.c b/arch/riscv/kernel/ftrace.c
index 765b62434..7f1e5203d 100644
--- a/arch/riscv/kernel/ftrace.c
+++ b/arch/riscv/kernel/ftrace.c
@@ -72,29 +72,56 @@ static int __ftrace_modify_call(unsigned long hook_pos, unsigned long target,
 	return 0;
 }
 
+/*
+ * Put 5 instructions with 16 bytes at the front of function within
+ * patchable function entry nops' area.
+ *
+ * 0: REG_S  ra, -SZREG(sp)
+ * 1: auipc  ra, 0x?
+ * 2: jalr   -?(ra)
+ * 3: REG_L  ra, -SZREG(sp)
+ *
+ * So the opcodes is:
+ * 0: 0xfe113c23 (sd)/0xfe112e23 (sw)
+ * 1: 0x???????? -> auipc
+ * 2: 0x???????? -> jalr
+ * 3: 0xff813083 (ld)/0xffc12083 (lw)
+ */
+#if __riscv_xlen == 64
+#define INSN0	0xfe113c23
+#define INSN3	0xff813083
+#elif __riscv_xlen == 32
+#define INSN0	0xfe112e23
+#define INSN3	0xffc12083
+#endif
+
+#define FUNC_ENTRY_SIZE	16
+#define FUNC_ENTRY_JMP	4
+
 int ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)
 {
-	int ret = ftrace_check_current_call(rec->ip, NULL);
+	unsigned int call[4] = {INSN0, 0, 0, INSN3};
+	unsigned long target = addr;
+	unsigned long caller = rec->ip + FUNC_ENTRY_JMP;
 
-	if (ret)
-		return ret;
+	call[1] = to_auipc_insn((unsigned int)(target - caller));
+	call[2] = to_jalr_insn((unsigned int)(target - caller));
 
-	return __ftrace_modify_call(rec->ip, addr, true);
+	if (patch_text_nosync((void *)rec->ip, call, FUNC_ENTRY_SIZE))
+		return -EPERM;
+
+	return 0;
 }
 
 int ftrace_make_nop(struct module *mod, struct dyn_ftrace *rec,
 		    unsigned long addr)
 {
-	unsigned int call[2];
-	int ret;
+	unsigned int nops[4] = {NOP4, NOP4, NOP4, NOP4};
 
-	make_call(rec->ip, addr, call);
-	ret = ftrace_check_current_call(rec->ip, call);
-
-	if (ret)
-		return ret;
+	if (patch_text_nosync((void *)rec->ip, nops, FUNC_ENTRY_SIZE))
+		return -EPERM;
 
-	return __ftrace_modify_call(rec->ip, addr, false);
+	return 0;
 }
 
 
@@ -139,15 +166,16 @@ int ftrace_modify_call(struct dyn_ftrace *rec, unsigned long old_addr,
 		       unsigned long addr)
 {
 	unsigned int call[2];
+	unsigned long caller = rec->ip + FUNC_ENTRY_JMP;
 	int ret;
 
-	make_call(rec->ip, old_addr, call);
-	ret = ftrace_check_current_call(rec->ip, call);
+	make_call(caller, old_addr, call);
+	ret = ftrace_check_current_call(caller, call);
 
 	if (ret)
 		return ret;
 
-	return __ftrace_modify_call(rec->ip, addr, true);
+	return __ftrace_modify_call(caller, addr, true);
 }
 #endif
 
@@ -176,53 +204,30 @@ void prepare_ftrace_return(unsigned long *parent, unsigned long self_addr,
 
 #ifdef CONFIG_DYNAMIC_FTRACE
 extern void ftrace_graph_call(void);
+extern void ftrace_graph_regs_call(void);
 int ftrace_enable_ftrace_graph_caller(void)
 {
-	unsigned int call[2];
-	static int init_graph = 1;
 	int ret;
 
-	make_call(&ftrace_graph_call, &ftrace_stub, call);
-
-	/*
-	 * When enabling graph tracer for the first time, ftrace_graph_call
-	 * should contains a call to ftrace_stub.  Once it has been disabled,
-	 * the 8-bytes at the position becomes NOPs.
-	 */
-	if (init_graph) {
-		ret = ftrace_check_current_call((unsigned long)&ftrace_graph_call,
-						call);
-		init_graph = 0;
-	} else {
-		ret = ftrace_check_current_call((unsigned long)&ftrace_graph_call,
-						NULL);
-	}
-
+	ret = __ftrace_modify_call((unsigned long)&ftrace_graph_call,
+				    (unsigned long)&prepare_ftrace_return, true);
 	if (ret)
 		return ret;
 
-	return __ftrace_modify_call((unsigned long)&ftrace_graph_call,
+	return __ftrace_modify_call((unsigned long)&ftrace_graph_regs_call,
 				    (unsigned long)&prepare_ftrace_return, true);
 }
 
 int ftrace_disable_ftrace_graph_caller(void)
 {
-	unsigned int call[2];
 	int ret;
 
-	make_call(&ftrace_graph_call, &prepare_ftrace_return, call);
-
-	/*
-	 * This is to make sure that ftrace_enable_ftrace_graph_caller
-	 * did the right thing.
-	 */
-	ret = ftrace_check_current_call((unsigned long)&ftrace_graph_call,
-					call);
-
+	ret = __ftrace_modify_call((unsigned long)&ftrace_graph_call,
+				    (unsigned long)&prepare_ftrace_return, false);
 	if (ret)
 		return ret;
 
-	return __ftrace_modify_call((unsigned long)&ftrace_graph_call,
+	return __ftrace_modify_call((unsigned long)&ftrace_graph_regs_call,
 				    (unsigned long)&prepare_ftrace_return, false);
 }
 #endif /* CONFIG_DYNAMIC_FTRACE */
diff --git a/arch/riscv/kernel/head.S b/arch/riscv/kernel/head.S
index 1a819c18b..6c11fd130 100644
--- a/arch/riscv/kernel/head.S
+++ b/arch/riscv/kernel/head.S
@@ -228,7 +228,7 @@ pmp_done:
 	 * Disable FPU to detect illegal usage of
 	 * floating point in kernel space
 	 */
-	li t0, SR_FS
+	li t0, SR_FS | SR_VS
 	csrc CSR_STATUS, t0
 
 #ifdef CONFIG_SMP
diff --git a/arch/riscv/kernel/kexec_relocate.S b/arch/riscv/kernel/kexec_relocate.S
new file mode 100755
index 000000000..1bc4b0cdf
--- /dev/null
+++ b/arch/riscv/kernel/kexec_relocate.S
@@ -0,0 +1,221 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019 FORTH-ICS/CARV
+ *  Nick Kossifidis <mick@ics.forth.gr>
+ */
+
+#include <asm/asm.h>	/* For RISCV_* and REG_* macros */
+#include <asm/csr.h>	/* For CSR_* macros */
+#include <asm/page.h>	/* For PAGE_SIZE */
+#include <linux/linkage.h> /* For SYM_* macros */
+
+.section ".rodata"
+SYM_CODE_START(riscv_kexec_relocate)
+
+	/*
+	 * s0: Pointer to the current entry
+	 * s1: (const) Phys address to jump to after relocation
+	 * s2: (const) Phys address of the FDT image
+	 * s3: (const) The hartid of the current hart
+	 * s4: Pointer to the destination address for the relocation
+	 * s5: (const) Number of words per page
+	 * s6: (const) 1, used for subtraction
+	 * s7: (const) va_pa_offset, used when switching MMU off
+	 * s8: (const) Physical address of the main loop
+	 * s9: (debug) indirection page counter
+	 * s10: (debug) entry counter
+	 * s11: (debug) copied words counter
+	 */
+	mv	s0, a0
+	mv	s1, a1
+	mv	s2, a2
+	mv	s3, a3
+	mv	s4, zero
+	li	s5, (PAGE_SIZE / RISCV_SZPTR)
+	li	s6, 1
+	mv	s7, a4
+	mv	s8, zero
+	mv	s9, zero
+	mv	s10, zero
+	mv	s11, zero
+
+	/* Disable / cleanup interrupts */
+	csrw	CSR_SIE, zero
+	csrw	CSR_SIP, zero
+
+	/*
+	 * When we switch SATP.MODE to "Bare" we'll only
+	 * play with physical addresses. However the first time
+	 * we try to jump somewhere, the offset on the jump
+	 * will be relative to pc which will still be on VA. To
+	 * deal with this we set stvec to the physical address at
+	 * the start of the loop below so that we jump there in
+	 * any case.
+	 */
+	la	s8, 1f
+	sub	s8, s8, s7
+	csrw	CSR_STVEC, s8
+
+	/* Process entries in a loop */
+.align 2
+1:
+	addi	s10, s10, 1
+	REG_L	t0, 0(s0)		/* t0 = *image->entry */
+	addi	s0, s0, RISCV_SZPTR	/* image->entry++ */
+
+	/* IND_DESTINATION entry ? -> save destination address */
+	andi	t1, t0, 0x1
+	beqz	t1, 2f
+	andi	s4, t0, ~0x1
+	j	1b
+
+2:
+	/* IND_INDIRECTION entry ? -> update next entry ptr (PA) */
+	andi	t1, t0, 0x2
+	beqz	t1, 2f
+	andi	s0, t0, ~0x2
+	addi	s9, s9, 1
+	csrw	CSR_SATP, zero
+	jalr	zero, s8, 0
+
+2:
+	/* IND_DONE entry ? -> jump to done label */
+	andi	t1, t0, 0x4
+	beqz	t1, 2f
+	j	4f
+
+2:
+	/*
+	 * IND_SOURCE entry ? -> copy page word by word to the
+	 * destination address we got from IND_DESTINATION
+	 */
+	andi	t1, t0, 0x8
+	beqz	t1, 1b		/* Unknown entry type, ignore it */
+	andi	t0, t0, ~0x8
+	mv	t3, s5		/* i = num words per page */
+3:	/* copy loop */
+	REG_L	t1, (t0)	/* t1 = *src_ptr */
+	REG_S	t1, (s4)	/* *dst_ptr = *src_ptr */
+	addi	t0, t0, RISCV_SZPTR /* stc_ptr++ */
+	addi	s4, s4, RISCV_SZPTR /* dst_ptr++ */
+	sub	t3, t3, s6	/* i-- */
+	addi	s11, s11, 1	/* c++ */
+	beqz	t3, 1b		/* copy done ? */
+	j	3b
+
+4:
+	/* Pass the arguments to the next kernel  / Cleanup*/
+	mv	a0, s3
+	mv	a1, s2
+	mv	a2, s1
+
+	/* Cleanup */
+	mv	a3, zero
+	mv	a4, zero
+	mv	a5, zero
+	mv	a6, zero
+	mv	a7, zero
+
+	mv	s0, zero
+	mv	s1, zero
+	mv	s2, zero
+	mv	s3, zero
+	mv	s4, zero
+	mv	s5, zero
+	mv	s6, zero
+	mv	s7, zero
+	mv	s8, zero
+	mv	s9, zero
+	mv	s10, zero
+	mv	s11, zero
+
+	mv	t0, zero
+	mv	t1, zero
+	mv	t2, zero
+	mv	t3, zero
+	mv	t4, zero
+	mv	t5, zero
+	mv	t6, zero
+	csrw	CSR_SEPC, zero
+	csrw	CSR_SCAUSE, zero
+	csrw	CSR_SSCRATCH, zero
+
+	/*
+	 * Make sure the relocated code is visible
+	 * and jump to the new kernel
+	 */
+	fence.i
+
+	jalr	zero, a2, 0
+
+SYM_CODE_END(riscv_kexec_relocate)
+riscv_kexec_relocate_end:
+
+
+/* Used for jumping to crashkernel */
+.section ".text"
+SYM_CODE_START(riscv_kexec_norelocate)
+	/*
+	 * s0: (const) Phys address to jump to
+	 * s1: (const) Phys address of the FDT image
+	 * s2: (const) The hartid of the current hart
+	 */
+	mv	s0, a1
+	mv	s1, a2
+	mv	s2, a3
+
+	/* Disable / cleanup interrupts */
+	csrw	CSR_SIE, zero
+	csrw	CSR_SIP, zero
+
+	/* Pass the arguments to the next kernel  / Cleanup*/
+	mv	a0, s2
+	mv	a1, s1
+	mv	a2, s0
+
+	/* Cleanup */
+	mv	a3, zero
+	mv	a4, zero
+	mv	a5, zero
+	mv	a6, zero
+	mv	a7, zero
+
+	mv	s0, zero
+	mv	s1, zero
+	mv	s2, zero
+	mv	s3, zero
+	mv	s4, zero
+	mv	s5, zero
+	mv	s6, zero
+	mv	s7, zero
+	mv	s8, zero
+	mv	s9, zero
+	mv	s10, zero
+	mv	s11, zero
+
+	mv	t0, zero
+	mv	t1, zero
+	mv	t2, zero
+	mv	t3, zero
+	mv	t4, zero
+	mv	t5, zero
+	mv	t6, zero
+	csrw	CSR_SEPC, zero
+	csrw	CSR_SCAUSE, zero
+	csrw	CSR_SSCRATCH, zero
+
+	/*
+	 * Switch to physical addressing
+	 * This will also trigger a jump to CSR_STVEC
+	 * which in this case is the address of the new
+	 * kernel.
+	 */
+	csrw	CSR_STVEC, a2
+	csrw	CSR_SATP, zero
+
+SYM_CODE_END(riscv_kexec_norelocate)
+
+.section ".rodata"
+SYM_DATA(riscv_kexec_relocate_size,
+	.long riscv_kexec_relocate_end - riscv_kexec_relocate)
+
diff --git a/arch/riscv/kernel/machine_kexec.c b/arch/riscv/kernel/machine_kexec.c
new file mode 100755
index 000000000..e008d8ede
--- /dev/null
+++ b/arch/riscv/kernel/machine_kexec.c
@@ -0,0 +1,237 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 FORTH-ICS/CARV
+ *  Nick Kossifidis <mick@ics.forth.gr>
+ */
+
+#include <linux/kexec.h>
+#include <asm/kexec.h>		/* For riscv_kexec_* symbol defines */
+#include <linux/smp.h>		/* For smp_send_stop () */
+#include <asm/cacheflush.h>	/* For local_flush_icache_all() */
+#include <asm/barrier.h>	/* For smp_wmb() */
+#include <asm/page.h>		/* For PAGE_MASK */
+#include <linux/libfdt.h>	/* For fdt_check_header() */
+#include <asm/set_memory.h>	/* For set_memory_x() */
+#include <linux/compiler.h>	/* For unreachable() */
+#include <linux/cpu.h>		/* For cpu_down() */
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+/**
+ * kexec_image_info - Print received image details
+ */
+static void
+kexec_image_info(const struct kimage *image)
+{
+	unsigned long i;
+
+	pr_debug("Kexec image info:\n");
+	pr_debug("\ttype:        %d\n", image->type);
+	pr_debug("\tstart:       %lx\n", image->start);
+	pr_debug("\thead:        %lx\n", image->head);
+	pr_debug("\tnr_segments: %lu\n", image->nr_segments);
+
+	for (i = 0; i < image->nr_segments; i++) {
+		pr_debug("\t    segment[%lu]: %016lx - %016lx", i,
+			image->segment[i].mem,
+			image->segment[i].mem + image->segment[i].memsz);
+		pr_debug("\t\t0x%lx bytes, %lu pages\n",
+			(unsigned long) image->segment[i].memsz,
+			(unsigned long) image->segment[i].memsz /  PAGE_SIZE);
+	}
+}
+
+/**
+ * machine_kexec_prepare - Initialize kexec
+ *
+ * This function is called from do_kexec_load, when the user has
+ * provided us with an image to be loaded. Its goal is to validate
+ * the image and prepare the control code buffer as needed.
+ * Note that kimage_alloc_init has already been called and the
+ * control buffer has already been allocated.
+ */
+int
+machine_kexec_prepare(struct kimage *image)
+{
+	struct kimage_arch *internal = &image->arch;
+	struct fdt_header fdt = {0};
+	void *control_code_buffer = NULL;
+	unsigned int control_code_buffer_sz = 0;
+	int i = 0;
+
+	kexec_image_info(image);
+
+	/* Find the Flattened Device Tree and save its physical address */
+	for (i = 0; i < image->nr_segments; i++) {
+		if (image->segment[i].memsz <= sizeof(fdt))
+			continue;
+
+		if (copy_from_user(&fdt, image->segment[i].buf, sizeof(fdt)))
+			continue;
+
+		if (fdt_check_header(&fdt))
+			continue;
+
+		internal->fdt_addr = (unsigned long) image->segment[i].mem;
+		break;
+	}
+
+	if (!internal->fdt_addr) {
+		pr_err("Device tree not included in the provided image\n");
+		return -EINVAL;
+	}
+
+	/* Copy the assembler code for relocation to the control page */
+	if (image->type != KEXEC_TYPE_CRASH) {
+		control_code_buffer = page_address(image->control_code_page);
+		control_code_buffer_sz = page_size(image->control_code_page);
+
+		if (unlikely(riscv_kexec_relocate_size > control_code_buffer_sz)) {
+			pr_err("Relocation code doesn't fit within a control page\n");
+			return -EINVAL;
+		}
+
+		memcpy(control_code_buffer, riscv_kexec_relocate,
+			riscv_kexec_relocate_size);
+
+		/* Mark the control page executable */
+		set_memory_x((unsigned long) control_code_buffer, 1);
+	}
+
+	return 0;
+}
+
+
+/**
+ * machine_kexec_cleanup - Cleanup any leftovers from
+ *			   machine_kexec_prepare
+ *
+ * This function is called by kimage_free to handle any arch-specific
+ * allocations done on machine_kexec_prepare. Since we didn't do any
+ * allocations there, this is just an empty function. Note that the
+ * control buffer is freed by kimage_free.
+ */
+void
+machine_kexec_cleanup(struct kimage *image)
+{
+}
+
+
+/*
+ * machine_shutdown - Prepare for a kexec reboot
+ *
+ * This function is called by kernel_kexec just before machine_kexec
+ * below. Its goal is to prepare the rest of the system (the other
+ * harts and possibly devices etc) for a kexec reboot.
+ */
+void machine_shutdown(void)
+{
+	/*
+	 * No more interrupts on this hart
+	 * until we are back up.
+	 */
+	local_irq_disable();
+
+#if defined(CONFIG_HOTPLUG_CPU)
+	smp_shutdown_nonboot_cpus(smp_processor_id());
+#endif
+}
+
+static void machine_kexec_mask_interrupts(void)
+{
+	unsigned int i;
+	struct irq_desc *desc;
+
+	for_each_irq_desc(i, desc) {
+		struct irq_chip *chip;
+		int ret;
+
+		chip = irq_desc_get_chip(desc);
+		if (!chip)
+			continue;
+
+		/*
+		 * First try to remove the active state. If this
+		 * fails, try to EOI the interrupt.
+		 */
+		ret = irq_set_irqchip_state(i, IRQCHIP_STATE_ACTIVE, false);
+
+		if (ret && irqd_irq_inprogress(&desc->irq_data) &&
+		    chip->irq_eoi)
+			chip->irq_eoi(&desc->irq_data);
+
+		if (chip->irq_mask)
+			chip->irq_mask(&desc->irq_data);
+
+		if (chip->irq_disable && !irqd_irq_disabled(&desc->irq_data))
+			chip->irq_disable(&desc->irq_data);
+	}
+}
+
+/*
+ * machine_crash_shutdown - Prepare to kexec after a kernel crash
+ *
+ * This function is called by crash_kexec just before machine_kexec
+ * and its goal is to shutdown non-crashing cpus and save registers.
+ */
+void
+machine_crash_shutdown(struct pt_regs *regs)
+{
+	local_irq_disable();
+
+#ifdef CONFIG_SMP
+	/* shutdown non-crashing cpus */
+	crash_smp_send_stop();
+#endif
+	crash_save_cpu(regs, smp_processor_id());
+	machine_kexec_mask_interrupts();
+
+	pr_info("Starting crashdump kernel...\n");
+}
+
+/**
+ * machine_kexec - Jump to the loaded kimage
+ *
+ * This function is called by kernel_kexec which is called by the
+ * reboot system call when the reboot cmd is LINUX_REBOOT_CMD_KEXEC,
+ * or by crash_kernel which is called by the kernel's arch-specific
+ * trap handler in case of a kernel panic. It's the final stage of
+ * the kexec process where the pre-loaded kimage is ready to be
+ * executed. We assume at this point that all other harts are
+ * suspended and this hart will be the new boot hart.
+ */
+void __noreturn
+machine_kexec(struct kimage *image)
+{
+	struct kimage_arch *internal = &image->arch;
+	unsigned long jump_addr = (unsigned long) image->start;
+	unsigned long first_ind_entry = (unsigned long) &image->head;
+	unsigned long this_cpu_id = __smp_processor_id();
+	unsigned long this_hart_id = cpuid_to_hartid_map(this_cpu_id);
+	unsigned long fdt_addr = internal->fdt_addr;
+	void *control_code_buffer = page_address(image->control_code_page);
+	riscv_kexec_method kexec_method = NULL;
+
+#ifdef CONFIG_SMP
+	WARN(smp_crash_stop_failed(),
+		"Some CPUs may be stale, kdump will be unreliable.\n");
+#endif
+
+	if (image->type != KEXEC_TYPE_CRASH)
+		kexec_method = control_code_buffer;
+	else
+		kexec_method = (riscv_kexec_method) &riscv_kexec_norelocate;
+
+	pr_notice("Will call new kernel at %08lx from hart id %lx\n",
+		  jump_addr, this_hart_id);
+	pr_notice("FDT image at %08lx\n", fdt_addr);
+
+	/* Make sure the relocation code is visible to the hart */
+	local_flush_icache_all();
+
+	/* Jump to the relocation code */
+	pr_notice("Bye...\n");
+	kexec_method(first_ind_entry, jump_addr, fdt_addr,
+		     this_hart_id, va_pa_offset);
+	unreachable();
+}
diff --git a/arch/riscv/kernel/mcount-dyn.S b/arch/riscv/kernel/mcount-dyn.S
index 35a6ed76c..d171eca62 100644
--- a/arch/riscv/kernel/mcount-dyn.S
+++ b/arch/riscv/kernel/mcount-dyn.S
@@ -13,224 +13,186 @@
 
 	.text
 
-	.macro SAVE_ABI_STATE
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	addi    sp, sp, -48
-	sd      s0, 32(sp)
-	sd      ra, 40(sp)
-	addi    s0, sp, 48
-	sd      t0, 24(sp)
-	sd      t1, 16(sp)
-#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
-	sd      t2, 8(sp)
-#endif
-#else
-	addi	sp, sp, -16
-	sd	s0, 0(sp)
-	sd	ra, 8(sp)
-	addi	s0, sp, 16
-#endif
+#define FENTRY_RA_OFFSET	12
+#define ABI_SIZE_ON_STACK	72
+#define ABI_A0			0
+#define ABI_A1			8
+#define ABI_A2			16
+#define ABI_A3			24
+#define ABI_A4			32
+#define ABI_A5			40
+#define ABI_A6			48
+#define ABI_A7			56
+#define ABI_RA			64
+
+	.macro SAVE_ABI
+	addi	sp, sp, -SZREG
+	addi	sp, sp, -ABI_SIZE_ON_STACK
+
+	REG_S	a0, ABI_A0(sp)
+	REG_S	a1, ABI_A1(sp)
+	REG_S	a2, ABI_A2(sp)
+	REG_S	a3, ABI_A3(sp)
+	REG_S	a4, ABI_A4(sp)
+	REG_S	a5, ABI_A5(sp)
+	REG_S	a6, ABI_A6(sp)
+	REG_S	a7, ABI_A7(sp)
+	REG_S	ra, ABI_RA(sp)
 	.endm
 
-	.macro RESTORE_ABI_STATE
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	ld	s0, 32(sp)
-	ld	ra, 40(sp)
-	addi	sp, sp, 48
-#else
-	ld	ra, 8(sp)
-	ld	s0, 0(sp)
-	addi	sp, sp, 16
-#endif
+	.macro RESTORE_ABI
+	REG_L	a0, ABI_A0(sp)
+	REG_L	a1, ABI_A1(sp)
+	REG_L	a2, ABI_A2(sp)
+	REG_L	a3, ABI_A3(sp)
+	REG_L	a4, ABI_A4(sp)
+	REG_L	a5, ABI_A5(sp)
+	REG_L	a6, ABI_A6(sp)
+	REG_L	a7, ABI_A7(sp)
+	REG_L	ra, ABI_RA(sp)
+
+	addi	sp, sp, ABI_SIZE_ON_STACK
+	addi	sp, sp, SZREG
 	.endm
 
-	.macro RESTORE_GRAPH_ARGS
-	ld	a0, 24(sp)
-	ld	a1, 16(sp)
-#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
-	ld	a2, 8(sp)
-#endif
+#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS
+	.macro SAVE_ALL
+	addi	sp, sp, -SZREG
+	addi	sp, sp, -PT_SIZE_ON_STACK
+
+	REG_S x1,  PT_EPC(sp)
+	addi	sp, sp, PT_SIZE_ON_STACK
+	REG_L x1,  (sp)
+	addi	sp, sp, -PT_SIZE_ON_STACK
+	REG_S x1,  PT_RA(sp)
+	REG_L x1,  PT_EPC(sp)
+
+	REG_S x2,  PT_SP(sp)
+	REG_S x3,  PT_GP(sp)
+	REG_S x4,  PT_TP(sp)
+	REG_S x5,  PT_T0(sp)
+	REG_S x6,  PT_T1(sp)
+	REG_S x7,  PT_T2(sp)
+	REG_S x8,  PT_S0(sp)
+	REG_S x9,  PT_S1(sp)
+	REG_S x10, PT_A0(sp)
+	REG_S x11, PT_A1(sp)
+	REG_S x12, PT_A2(sp)
+	REG_S x13, PT_A3(sp)
+	REG_S x14, PT_A4(sp)
+	REG_S x15, PT_A5(sp)
+	REG_S x16, PT_A6(sp)
+	REG_S x17, PT_A7(sp)
+	REG_S x18, PT_S2(sp)
+	REG_S x19, PT_S3(sp)
+	REG_S x20, PT_S4(sp)
+	REG_S x21, PT_S5(sp)
+	REG_S x22, PT_S6(sp)
+	REG_S x23, PT_S7(sp)
+	REG_S x24, PT_S8(sp)
+	REG_S x25, PT_S9(sp)
+	REG_S x26, PT_S10(sp)
+	REG_S x27, PT_S11(sp)
+	REG_S x28, PT_T3(sp)
+	REG_S x29, PT_T4(sp)
+	REG_S x30, PT_T5(sp)
+	REG_S x31, PT_T6(sp)
 	.endm
 
-ENTRY(ftrace_graph_caller)
-	addi	sp, sp, -16
-	sd	s0, 0(sp)
-	sd	ra, 8(sp)
-	addi	s0, sp, 16
-ftrace_graph_call:
-	.global ftrace_graph_call
-	/*
-	 * Calling ftrace_enable/disable_ftrace_graph_caller would overwrite the
-	 * call below.  Check ftrace_modify_all_code for details.
-	 */
-	call	ftrace_stub
-	ld	ra, 8(sp)
-	ld	s0, 0(sp)
-	addi	sp, sp, 16
-	ret
-ENDPROC(ftrace_graph_caller)
+	.macro RESTORE_ALL
+	REG_L x1,  PT_RA(sp)
+	addi	sp, sp, PT_SIZE_ON_STACK
+	REG_S x1,  (sp)
+	addi	sp, sp, -PT_SIZE_ON_STACK
+	REG_L x1,  PT_EPC(sp)
+	REG_L x2,  PT_SP(sp)
+	REG_L x3,  PT_GP(sp)
+	REG_L x4,  PT_TP(sp)
+	REG_L x5,  PT_T0(sp)
+	REG_L x6,  PT_T1(sp)
+	REG_L x7,  PT_T2(sp)
+	REG_L x8,  PT_S0(sp)
+	REG_L x9,  PT_S1(sp)
+	REG_L x10, PT_A0(sp)
+	REG_L x11, PT_A1(sp)
+	REG_L x12, PT_A2(sp)
+	REG_L x13, PT_A3(sp)
+	REG_L x14, PT_A4(sp)
+	REG_L x15, PT_A5(sp)
+	REG_L x16, PT_A6(sp)
+	REG_L x17, PT_A7(sp)
+	REG_L x18, PT_S2(sp)
+	REG_L x19, PT_S3(sp)
+	REG_L x20, PT_S4(sp)
+	REG_L x21, PT_S5(sp)
+	REG_L x22, PT_S6(sp)
+	REG_L x23, PT_S7(sp)
+	REG_L x24, PT_S8(sp)
+	REG_L x25, PT_S9(sp)
+	REG_L x26, PT_S10(sp)
+	REG_L x27, PT_S11(sp)
+	REG_L x28, PT_T3(sp)
+	REG_L x29, PT_T4(sp)
+	REG_L x30, PT_T5(sp)
+	REG_L x31, PT_T6(sp)
+
+	addi	sp, sp, PT_SIZE_ON_STACK
+	addi	sp, sp, SZREG
+	.endm
+#endif /* CONFIG_DYNAMIC_FTRACE_WITH_REGS */
 
 ENTRY(ftrace_caller)
-	/*
-	 * a0: the address in the caller when calling ftrace_caller
-	 * a1: the caller's return address
-	 * a2: the address of global variable function_trace_op
-	 */
-	ld	a1, -8(s0)
-	addi	a0, ra, -MCOUNT_INSN_SIZE
-	la	t5, function_trace_op
-	ld	a2, 0(t5)
+	SAVE_ABI
 
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	/*
-	 * the graph tracer (specifically, prepare_ftrace_return) needs these
-	 * arguments but for now the function tracer occupies the regs, so we
-	 * save them in temporary regs to recover later.
-	 */
-	addi	t0, s0, -8
-	mv	t1, a0
-#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
-	ld	t2, -16(s0)
-#endif
-#endif
+	addi	a0, ra, -FENTRY_RA_OFFSET
+	la	a1, function_trace_op
+	REG_L	a2, 0(a1)
+	REG_L	a1, ABI_SIZE_ON_STACK(sp)
+	mv	a3, sp
 
-	SAVE_ABI_STATE
 ftrace_call:
 	.global ftrace_call
-	/*
-	 * For the dynamic ftrace to work, here we should reserve at least
-	 * 8 bytes for a functional auipc-jalr pair.  The following call
-	 * serves this purpose.
-	 *
-	 * Calling ftrace_update_ftrace_func would overwrite the nops below.
-	 * Check ftrace_modify_all_code for details.
-	 */
 	call	ftrace_stub
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	RESTORE_GRAPH_ARGS
-	call	ftrace_graph_caller
+	addi	a0, sp, ABI_SIZE_ON_STACK
+	REG_L	a1, ABI_RA(sp)
+	addi	a1, a1, -FENTRY_RA_OFFSET
+#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
+	mv	a2, s0
 #endif
-
-	RESTORE_ABI_STATE
+ftrace_graph_call:
+	.global ftrace_graph_call
+	call	ftrace_stub
+#endif
+	RESTORE_ABI
 	ret
 ENDPROC(ftrace_caller)
 
 #ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS
-	.macro SAVE_ALL
-	addi	sp, sp, -(PT_SIZE_ON_STACK+16)
-	sd	s0, (PT_SIZE_ON_STACK)(sp)
-	sd	ra, (PT_SIZE_ON_STACK+8)(sp)
-	addi	s0, sp, (PT_SIZE_ON_STACK+16)
-
-	sd x1,  PT_RA(sp)
-	sd x2,  PT_SP(sp)
-	sd x3,  PT_GP(sp)
-	sd x4,  PT_TP(sp)
-	sd x5,  PT_T0(sp)
-	sd x6,  PT_T1(sp)
-	sd x7,  PT_T2(sp)
-	sd x8,  PT_S0(sp)
-	sd x9,  PT_S1(sp)
-	sd x10, PT_A0(sp)
-	sd x11, PT_A1(sp)
-	sd x12, PT_A2(sp)
-	sd x13, PT_A3(sp)
-	sd x14, PT_A4(sp)
-	sd x15, PT_A5(sp)
-	sd x16, PT_A6(sp)
-	sd x17, PT_A7(sp)
-	sd x18, PT_S2(sp)
-	sd x19, PT_S3(sp)
-	sd x20, PT_S4(sp)
-	sd x21, PT_S5(sp)
-	sd x22, PT_S6(sp)
-	sd x23, PT_S7(sp)
-	sd x24, PT_S8(sp)
-	sd x25, PT_S9(sp)
-	sd x26, PT_S10(sp)
-	sd x27, PT_S11(sp)
-	sd x28, PT_T3(sp)
-	sd x29, PT_T4(sp)
-	sd x30, PT_T5(sp)
-	sd x31, PT_T6(sp)
-	.endm
-
-	.macro RESTORE_ALL
-	ld x1,  PT_RA(sp)
-	ld x2,  PT_SP(sp)
-	ld x3,  PT_GP(sp)
-	ld x4,  PT_TP(sp)
-	ld x5,  PT_T0(sp)
-	ld x6,  PT_T1(sp)
-	ld x7,  PT_T2(sp)
-	ld x8,  PT_S0(sp)
-	ld x9,  PT_S1(sp)
-	ld x10, PT_A0(sp)
-	ld x11, PT_A1(sp)
-	ld x12, PT_A2(sp)
-	ld x13, PT_A3(sp)
-	ld x14, PT_A4(sp)
-	ld x15, PT_A5(sp)
-	ld x16, PT_A6(sp)
-	ld x17, PT_A7(sp)
-	ld x18, PT_S2(sp)
-	ld x19, PT_S3(sp)
-	ld x20, PT_S4(sp)
-	ld x21, PT_S5(sp)
-	ld x22, PT_S6(sp)
-	ld x23, PT_S7(sp)
-	ld x24, PT_S8(sp)
-	ld x25, PT_S9(sp)
-	ld x26, PT_S10(sp)
-	ld x27, PT_S11(sp)
-	ld x28, PT_T3(sp)
-	ld x29, PT_T4(sp)
-	ld x30, PT_T5(sp)
-	ld x31, PT_T6(sp)
-
-	ld	s0, (PT_SIZE_ON_STACK)(sp)
-	ld	ra, (PT_SIZE_ON_STACK+8)(sp)
-	addi	sp, sp, (PT_SIZE_ON_STACK+16)
-	.endm
-
-	.macro RESTORE_GRAPH_REG_ARGS
-	ld	a0, PT_T0(sp)
-	ld	a1, PT_T1(sp)
-#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
-	ld	a2, PT_T2(sp)
-#endif
-	.endm
-
-/*
- * Most of the contents are the same as ftrace_caller.
- */
 ENTRY(ftrace_regs_caller)
-	/*
-	 * a3: the address of all registers in the stack
-	 */
-	ld	a1, -8(s0)
-	addi	a0, ra, -MCOUNT_INSN_SIZE
-	la	t5, function_trace_op
-	ld	a2, 0(t5)
-	addi	a3, sp, -(PT_SIZE_ON_STACK+16)
-
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	addi	t0, s0, -8
-	mv	t1, a0
-#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
-	ld	t2, -16(s0)
-#endif
-#endif
 	SAVE_ALL
 
+	addi	a0, ra, -FENTRY_RA_OFFSET
+	la	a1, function_trace_op
+	REG_L	a2, 0(a1)
+	REG_L	a1, PT_SIZE_ON_STACK(sp)
+	mv	a3, sp
+
 ftrace_regs_call:
 	.global ftrace_regs_call
 	call	ftrace_stub
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	RESTORE_GRAPH_REG_ARGS
-	call	ftrace_graph_caller
+	addi	a0, sp, PT_RA
+	REG_L	a1, PT_EPC(sp)
+	addi	a1, a1, -FENTRY_RA_OFFSET
+#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
+	mv	a2, s0
+#endif
+ftrace_graph_regs_call:
+	.global ftrace_graph_regs_call
+	call	ftrace_stub
 #endif
 
 	RESTORE_ALL
diff --git a/arch/riscv/kernel/module.c b/arch/riscv/kernel/module.c
index 104fba889..10c8dfcaa 100644
--- a/arch/riscv/kernel/module.c
+++ b/arch/riscv/kernel/module.c
@@ -13,6 +13,19 @@
 #include <linux/pgtable.h>
 #include <asm/sections.h>
 
+/*
+ * The auipc+jalr instruction pair can reach any PC-relative offset
+ * in the range [-2^31 - 2^11, 2^31 - 2^11)
+ */
+static bool riscv_insn_valid_32bit_offset(ptrdiff_t val)
+{
+#ifdef CONFIG_32BIT
+	return true;
+#else
+	return (-(1L << 31) - (1L << 11)) <= val && val < ((1L << 31) - (1L << 11));
+#endif
+}
+
 static int apply_r_riscv_32_rela(struct module *me, u32 *location, Elf_Addr v)
 {
 	if (v != (u32)v) {
@@ -95,7 +108,7 @@ static int apply_r_riscv_pcrel_hi20_rela(struct module *me, u32 *location,
 	ptrdiff_t offset = (void *)v - (void *)location;
 	s32 hi20;
 
-	if (offset != (s32)offset) {
+	if (!riscv_insn_valid_32bit_offset(offset)) {
 		pr_err(
 		  "%s: target %016llx can not be addressed by the 32-bit offset from PC = %p\n",
 		  me->name, (long long)v, location);
@@ -197,10 +210,9 @@ static int apply_r_riscv_call_plt_rela(struct module *me, u32 *location,
 				       Elf_Addr v)
 {
 	ptrdiff_t offset = (void *)v - (void *)location;
-	s32 fill_v = offset;
 	u32 hi20, lo12;
 
-	if (offset != fill_v) {
+	if (!riscv_insn_valid_32bit_offset(offset)) {
 		/* Only emit the plt entry if offset over 32-bit range */
 		if (IS_ENABLED(CONFIG_MODULE_SECTIONS)) {
 			offset = module_emit_plt_entry(me, v);
@@ -224,10 +236,9 @@ static int apply_r_riscv_call_rela(struct module *me, u32 *location,
 				   Elf_Addr v)
 {
 	ptrdiff_t offset = (void *)v - (void *)location;
-	s32 fill_v = offset;
 	u32 hi20, lo12;
 
-	if (offset != fill_v) {
+	if (!riscv_insn_valid_32bit_offset(offset)) {
 		pr_err(
 		  "%s: target %016llx can not be addressed by the 32-bit offset from PC = %p\n",
 		  me->name, (long long)v, location);
@@ -253,7 +264,7 @@ static int apply_r_riscv_align_rela(struct module *me, u32 *location,
 	pr_err(
 	  "%s: The unexpected relocation type 'R_RISCV_ALIGN' from PC = %p\n",
 	  me->name, location);
-	return -EINVAL;
+	return 0; /* Do not return -EINVAL when relocation type is R_RISCV_ALIGN */
 }
 
 static int apply_r_riscv_add32_rela(struct module *me, u32 *location,
diff --git a/arch/riscv/kernel/patch.c b/arch/riscv/kernel/patch.c
index 3fe7a5296..778c5086d 100644
--- a/arch/riscv/kernel/patch.c
+++ b/arch/riscv/kernel/patch.c
@@ -20,7 +20,12 @@ struct patch_insn {
 };
 
 #ifdef CONFIG_MMU
-static void *patch_map(void *addr, int fixmap)
+/*
+ * The fix_to_virt(, idx) needs a const value (not a dynamic variable of
+ * reg-a0) or BUILD_BUG_ON failed with "idx >= __end_of_fixed_addresses".
+ * So use '__always_inline' and 'const unsigned int fixmap' here.
+ */
+static __always_inline void *patch_map(void *addr, const unsigned int fixmap)
 {
 	uintptr_t uintaddr = (uintptr_t) addr;
 	struct page *page;
@@ -37,7 +42,6 @@ static void *patch_map(void *addr, int fixmap)
 	return (void *)set_fixmap_offset(fixmap, page_to_phys(page) +
 					 (uintaddr & ~PAGE_MASK));
 }
-NOKPROBE_SYMBOL(patch_map);
 
 static void patch_unmap(int fixmap)
 {
@@ -56,7 +60,7 @@ static int patch_insn_write(void *addr, const void *insn, size_t len)
 	 * already, so we don't need to give another lock here and could
 	 * ensure that it was safe between each cores.
 	 */
-	lockdep_assert_held(&text_mutex);
+	//lockdep_assert_held(&text_mutex);
 
 	if (across_pages)
 		patch_map(addr + len, FIX_TEXT_POKE1);
diff --git a/arch/riscv/kernel/perf_callchain.c b/arch/riscv/kernel/perf_callchain.c
index ad3001cbd..e0cf246d4 100644
--- a/arch/riscv/kernel/perf_callchain.c
+++ b/arch/riscv/kernel/perf_callchain.c
@@ -19,8 +19,8 @@ static unsigned long user_backtrace(struct perf_callchain_entry_ctx *entry,
 {
 	struct stackframe buftail;
 	unsigned long ra = 0;
-	unsigned long *user_frame_tail =
-			(unsigned long *)(fp - sizeof(struct stackframe));
+	unsigned long __user *user_frame_tail =
+		(unsigned long __user *)(fp - sizeof(struct stackframe));
 
 	/* Check accessibility of one struct frame_tail beyond */
 	if (!access_ok(user_frame_tail, sizeof(buftail)))
@@ -75,13 +75,13 @@ void perf_callchain_user(struct perf_callchain_entry_ctx *entry,
 		fp = user_backtrace(entry, fp, 0);
 }
 
-bool fill_callchain(unsigned long pc, void *entry)
+bool fill_callchain(unsigned long pc, unsigned long regs, void *entry)
 {
-	return perf_callchain_store(entry, pc);
+	return perf_callchain_store(entry, pc) == 0;
 }
 
 void notrace walk_stackframe(struct task_struct *task,
-	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg);
+	struct pt_regs *regs, bool (*fn)(unsigned long, unsigned long, void *), void *arg);
 void perf_callchain_kernel(struct perf_callchain_entry_ctx *entry,
 			   struct pt_regs *regs)
 {
diff --git a/arch/riscv/kernel/probes/Makefile b/arch/riscv/kernel/probes/Makefile
new file mode 100755
index 000000000..7f0840dcc
--- /dev/null
+++ b/arch/riscv/kernel/probes/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_KPROBES)		+= kprobes.o decode-insn.o simulate-insn.o
+obj-$(CONFIG_KPROBES)		+= kprobes_trampoline.o
+obj-$(CONFIG_KPROBES_ON_FTRACE)	+= ftrace.o
+obj-$(CONFIG_UPROBES)		+= uprobes.o decode-insn.o simulate-insn.o
+CFLAGS_REMOVE_simulate-insn.o = $(CC_FLAGS_FTRACE)
diff --git a/arch/riscv/kernel/probes/decode-insn.c b/arch/riscv/kernel/probes/decode-insn.c
new file mode 100755
index 000000000..0876c304c
--- /dev/null
+++ b/arch/riscv/kernel/probes/decode-insn.c
@@ -0,0 +1,48 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#include <linux/kernel.h>
+#include <linux/kprobes.h>
+#include <linux/module.h>
+#include <linux/kallsyms.h>
+#include <asm/sections.h>
+
+#include "decode-insn.h"
+#include "simulate-insn.h"
+
+/* Return:
+ *   INSN_REJECTED     If instruction is one not allowed to kprobe,
+ *   INSN_GOOD_NO_SLOT If instruction is supported but doesn't use its slot.
+ */
+enum probe_insn __kprobes
+riscv_probe_decode_insn(probe_opcode_t *addr, struct arch_probe_insn *api)
+{
+	probe_opcode_t insn = le32_to_cpu(*addr);
+
+	/*
+	 * Reject instructions list:
+	 */
+	RISCV_INSN_REJECTED(system,		insn);
+	RISCV_INSN_REJECTED(fence,		insn);
+
+	/*
+	 * Simulate instructions list:
+	 * TODO: the REJECTED ones below need to be implemented
+	 */
+#ifdef CONFIG_RISCV_ISA_C
+	RISCV_INSN_REJECTED(c_j,		insn);
+	RISCV_INSN_REJECTED(c_jr,		insn);
+	RISCV_INSN_REJECTED(c_jal,		insn);
+	RISCV_INSN_REJECTED(c_jalr,		insn);
+	RISCV_INSN_REJECTED(c_beqz,		insn);
+	RISCV_INSN_REJECTED(c_bnez,		insn);
+	RISCV_INSN_REJECTED(c_ebreak,		insn);
+#endif
+
+	RISCV_INSN_REJECTED(auipc,		insn);
+	RISCV_INSN_REJECTED(branch,		insn);
+
+	RISCV_INSN_SET_SIMULATE(jal,		insn);
+	RISCV_INSN_SET_SIMULATE(jalr,		insn);
+
+	return INSN_GOOD;
+}
diff --git a/arch/riscv/kernel/probes/decode-insn.h b/arch/riscv/kernel/probes/decode-insn.h
new file mode 100755
index 000000000..42269a7d6
--- /dev/null
+++ b/arch/riscv/kernel/probes/decode-insn.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+
+#ifndef _RISCV_KERNEL_KPROBES_DECODE_INSN_H
+#define _RISCV_KERNEL_KPROBES_DECODE_INSN_H
+
+#include <asm/sections.h>
+#include <asm/kprobes.h>
+
+enum probe_insn {
+	INSN_REJECTED,
+	INSN_GOOD_NO_SLOT,
+	INSN_GOOD,
+};
+
+enum probe_insn __kprobes
+riscv_probe_decode_insn(probe_opcode_t *addr, struct arch_probe_insn *asi);
+
+#endif /* _RISCV_KERNEL_KPROBES_DECODE_INSN_H */
diff --git a/arch/riscv/kernel/probes/ftrace.c b/arch/riscv/kernel/probes/ftrace.c
new file mode 100755
index 000000000..c7ccfff5e
--- /dev/null
+++ b/arch/riscv/kernel/probes/ftrace.c
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/kprobes.h>
+
+/* Ftrace callback handler for kprobes -- called under preepmt disabed */
+void kprobe_ftrace_handler(unsigned long ip, unsigned long parent_ip,
+			   struct ftrace_ops *ops, struct pt_regs *regs)
+{
+	struct kprobe *p;
+	struct kprobe_ctlblk *kcb;
+
+	p = get_kprobe((kprobe_opcode_t *)ip);
+	if (unlikely(!p) || kprobe_disabled(p))
+		return;
+
+	kcb = get_kprobe_ctlblk();
+	if (kprobe_running()) {
+		kprobes_inc_nmissed_count(p);
+	} else {
+		unsigned long orig_ip = instruction_pointer(regs);
+
+		instruction_pointer_set(regs, ip);
+
+		__this_cpu_write(current_kprobe, p);
+		kcb->kprobe_status = KPROBE_HIT_ACTIVE;
+		if (!p->pre_handler || !p->pre_handler(p, regs)) {
+			/*
+			 * Emulate singlestep (and also recover regs->pc)
+			 * as if there is a nop
+			 */
+			instruction_pointer_set(regs,
+				(unsigned long)p->addr + MCOUNT_INSN_SIZE);
+			if (unlikely(p->post_handler)) {
+				kcb->kprobe_status = KPROBE_HIT_SSDONE;
+				p->post_handler(p, regs, 0);
+			}
+			instruction_pointer_set(regs, orig_ip);
+		}
+
+		/*
+		 * If pre_handler returns !0, it changes regs->pc. We have to
+		 * skip emulating post_handler.
+		 */
+		__this_cpu_write(current_kprobe, NULL);
+	}
+}
+NOKPROBE_SYMBOL(kprobe_ftrace_handler);
+
+int arch_prepare_kprobe_ftrace(struct kprobe *p)
+{
+	p->ainsn.api.insn = NULL;
+	return 0;
+}
diff --git a/arch/riscv/kernel/probes/kprobes.c b/arch/riscv/kernel/probes/kprobes.c
new file mode 100755
index 000000000..5b3e258e6
--- /dev/null
+++ b/arch/riscv/kernel/probes/kprobes.c
@@ -0,0 +1,416 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#include <linux/kprobes.h>
+#include <linux/extable.h>
+#include <linux/slab.h>
+#include <linux/stop_machine.h>
+#include <asm/ptrace.h>
+#include <linux/uaccess.h>
+#include <asm/sections.h>
+#include <asm/cacheflush.h>
+#include <asm/bug.h>
+#include <asm/patch.h>
+
+#include "decode-insn.h"
+
+DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;
+DEFINE_PER_CPU(struct kprobe_ctlblk, kprobe_ctlblk);
+
+static void __kprobes
+post_kprobe_handler(struct kprobe_ctlblk *, struct pt_regs *);
+
+static void __kprobes arch_prepare_ss_slot(struct kprobe *p)
+{
+	unsigned long offset = GET_INSN_LENGTH(p->opcode);
+
+	p->ainsn.api.restore = (unsigned long)p->addr + offset;
+
+	patch_text(p->ainsn.api.insn, p->opcode);
+	patch_text((void *)((unsigned long)(p->ainsn.api.insn) + offset),
+		   __BUG_INSN_32);
+}
+
+static void __kprobes arch_prepare_simulate(struct kprobe *p)
+{
+	p->ainsn.api.restore = 0;
+}
+
+static void __kprobes arch_simulate_insn(struct kprobe *p, struct pt_regs *regs)
+{
+	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
+
+	if (p->ainsn.api.handler)
+		p->ainsn.api.handler((u32)p->opcode,
+					(unsigned long)p->addr, regs);
+
+	post_kprobe_handler(kcb, regs);
+}
+
+static bool __kprobes arch_check_kprobe(struct kprobe *p)
+{
+	unsigned long tmp  = (unsigned long)p->addr - p->offset;
+	unsigned long addr = (unsigned long)p->addr;
+
+	while (tmp <= addr) {
+		if (tmp == addr)
+			return true;
+
+		tmp += GET_INSN_LENGTH(*(u16 *)tmp);
+	}
+
+	return false;
+}
+
+int __kprobes arch_prepare_kprobe(struct kprobe *p)
+{
+	unsigned long probe_addr = (unsigned long)p->addr;
+
+	if (probe_addr & 0x1) {
+		pr_warn("Address not aligned.\n");
+
+		return -EINVAL;
+	}
+
+	if (!arch_check_kprobe(p))
+		return -EILSEQ;
+
+	/* copy instruction */
+	p->opcode = le32_to_cpu(*p->addr);
+
+	/* decode instruction */
+	switch (riscv_probe_decode_insn(p->addr, &p->ainsn.api)) {
+	case INSN_REJECTED:	/* insn not supported */
+		return -EINVAL;
+
+	case INSN_GOOD_NO_SLOT:	/* insn need simulation */
+		p->ainsn.api.insn = NULL;
+		break;
+
+	case INSN_GOOD:	/* instruction uses slot */
+		p->ainsn.api.insn = get_insn_slot();
+		if (!p->ainsn.api.insn)
+			return -ENOMEM;
+		break;
+	}
+
+	/* prepare the instruction */
+	if (p->ainsn.api.insn)
+		arch_prepare_ss_slot(p);
+	else
+		arch_prepare_simulate(p);
+
+	return 0;
+}
+
+/* install breakpoint in text */
+void __kprobes arch_arm_kprobe(struct kprobe *p)
+{
+	if ((p->opcode & __INSN_LENGTH_MASK) == __INSN_LENGTH_32)
+		patch_text(p->addr, __BUG_INSN_32);
+	else
+		patch_text(p->addr, __BUG_INSN_16);
+}
+
+/* remove breakpoint from text */
+void __kprobes arch_disarm_kprobe(struct kprobe *p)
+{
+	patch_text(p->addr, p->opcode);
+}
+
+void __kprobes arch_remove_kprobe(struct kprobe *p)
+{
+}
+
+static void __kprobes save_previous_kprobe(struct kprobe_ctlblk *kcb)
+{
+	kcb->prev_kprobe.kp = kprobe_running();
+	kcb->prev_kprobe.status = kcb->kprobe_status;
+}
+
+static void __kprobes restore_previous_kprobe(struct kprobe_ctlblk *kcb)
+{
+	__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);
+	kcb->kprobe_status = kcb->prev_kprobe.status;
+}
+
+static void __kprobes set_current_kprobe(struct kprobe *p)
+{
+	__this_cpu_write(current_kprobe, p);
+}
+
+/*
+ * Interrupts need to be disabled before single-step mode is set, and not
+ * reenabled until after single-step mode ends.
+ * Without disabling interrupt on local CPU, there is a chance of
+ * interrupt occurrence in the period of exception return and  start of
+ * out-of-line single-step, that result in wrongly single stepping
+ * into the interrupt handler.
+ */
+static void __kprobes kprobes_save_local_irqflag(struct kprobe_ctlblk *kcb,
+						struct pt_regs *regs)
+{
+	kcb->saved_status = regs->status;
+	regs->status &= ~SR_SPIE;
+}
+
+static void __kprobes kprobes_restore_local_irqflag(struct kprobe_ctlblk *kcb,
+						struct pt_regs *regs)
+{
+	regs->status = kcb->saved_status;
+}
+
+static void __kprobes
+set_ss_context(struct kprobe_ctlblk *kcb, unsigned long addr, struct kprobe *p)
+{
+	unsigned long offset = GET_INSN_LENGTH(p->opcode);
+
+	kcb->ss_ctx.ss_pending = true;
+	kcb->ss_ctx.match_addr = addr + offset;
+}
+
+static void __kprobes clear_ss_context(struct kprobe_ctlblk *kcb)
+{
+	kcb->ss_ctx.ss_pending = false;
+	kcb->ss_ctx.match_addr = 0;
+}
+
+static void __kprobes setup_singlestep(struct kprobe *p,
+				       struct pt_regs *regs,
+				       struct kprobe_ctlblk *kcb, int reenter)
+{
+	unsigned long slot;
+
+	if (reenter) {
+		save_previous_kprobe(kcb);
+		set_current_kprobe(p);
+		kcb->kprobe_status = KPROBE_REENTER;
+	} else {
+		kcb->kprobe_status = KPROBE_HIT_SS;
+	}
+
+	if (p->ainsn.api.insn) {
+		/* prepare for single stepping */
+		slot = (unsigned long)p->ainsn.api.insn;
+
+		set_ss_context(kcb, slot, p);	/* mark pending ss */
+
+		/* IRQs and single stepping do not mix well. */
+		kprobes_save_local_irqflag(kcb, regs);
+
+		instruction_pointer_set(regs, slot);
+	} else {
+		/* insn simulation */
+		arch_simulate_insn(p, regs);
+	}
+}
+
+static int __kprobes reenter_kprobe(struct kprobe *p,
+				    struct pt_regs *regs,
+				    struct kprobe_ctlblk *kcb)
+{
+	switch (kcb->kprobe_status) {
+	case KPROBE_HIT_SSDONE:
+	case KPROBE_HIT_ACTIVE:
+		kprobes_inc_nmissed_count(p);
+		setup_singlestep(p, regs, kcb, 1);
+		break;
+	case KPROBE_HIT_SS:
+	case KPROBE_REENTER:
+		pr_warn("Unrecoverable kprobe detected.\n");
+		dump_kprobe(p);
+		BUG();
+		break;
+	default:
+		WARN_ON(1);
+		return 0;
+	}
+
+	return 1;
+}
+
+static void __kprobes
+post_kprobe_handler(struct kprobe_ctlblk *kcb, struct pt_regs *regs)
+{
+	struct kprobe *cur = kprobe_running();
+
+	if (!cur)
+		return;
+
+	/* return addr restore if non-branching insn */
+	if (cur->ainsn.api.restore != 0)
+		regs->epc = cur->ainsn.api.restore;
+
+	/* restore back original saved kprobe variables and continue */
+	if (kcb->kprobe_status == KPROBE_REENTER) {
+		restore_previous_kprobe(kcb);
+		return;
+	}
+
+	/* call post handler */
+	kcb->kprobe_status = KPROBE_HIT_SSDONE;
+	if (cur->post_handler)	{
+		/* post_handler can hit breakpoint and single step
+		 * again, so we enable D-flag for recursive exception.
+		 */
+		cur->post_handler(cur, regs, 0);
+	}
+
+	reset_current_kprobe();
+}
+
+int __kprobes kprobe_fault_handler(struct pt_regs *regs, unsigned int trapnr)
+{
+	struct kprobe *cur = kprobe_running();
+	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
+
+	switch (kcb->kprobe_status) {
+	case KPROBE_HIT_SS:
+	case KPROBE_REENTER:
+		/*
+		 * We are here because the instruction being single
+		 * stepped caused a page fault. We reset the current
+		 * kprobe and the ip points back to the probe address
+		 * and allow the page fault handler to continue as a
+		 * normal page fault.
+		 */
+		regs->epc = (unsigned long) cur->addr;
+		if (!instruction_pointer(regs))
+			BUG();
+
+		if (kcb->kprobe_status == KPROBE_REENTER)
+			restore_previous_kprobe(kcb);
+		else
+			reset_current_kprobe();
+
+		break;
+	case KPROBE_HIT_ACTIVE:
+	case KPROBE_HIT_SSDONE:
+		/*
+		 * We increment the nmissed count for accounting,
+		 * we can also use npre/npostfault count for accounting
+		 * these specific fault cases.
+		 */
+		kprobes_inc_nmissed_count(cur);
+
+		/*
+		 * We come here because instructions in the pre/post
+		 * handler caused the page_fault, this could happen
+		 * if handler tries to access user space by
+		 * copy_from_user(), get_user() etc. Let the
+		 * user-specified handler try to fix it first.
+		 */
+		if (cur->fault_handler && cur->fault_handler(cur, regs, trapnr))
+			return 1;
+
+		/*
+		 * In case the user-specified fault handler returned
+		 * zero, try to fix up.
+		 */
+		if (fixup_exception(regs))
+			return 1;
+	}
+	return 0;
+}
+
+bool __kprobes
+kprobe_breakpoint_handler(struct pt_regs *regs)
+{
+	struct kprobe *p, *cur_kprobe;
+	struct kprobe_ctlblk *kcb;
+	unsigned long addr = instruction_pointer(regs);
+
+	kcb = get_kprobe_ctlblk();
+	cur_kprobe = kprobe_running();
+
+	p = get_kprobe((kprobe_opcode_t *) addr);
+
+	if (p) {
+		if (cur_kprobe) {
+			if (reenter_kprobe(p, regs, kcb))
+				return true;
+		} else {
+			/* Probe hit */
+			set_current_kprobe(p);
+			kcb->kprobe_status = KPROBE_HIT_ACTIVE;
+
+			/*
+			 * If we have no pre-handler or it returned 0, we
+			 * continue with normal processing.  If we have a
+			 * pre-handler and it returned non-zero, it will
+			 * modify the execution path and no need to single
+			 * stepping. Let's just reset current kprobe and exit.
+			 *
+			 * pre_handler can hit a breakpoint and can step thru
+			 * before return.
+			 */
+			if (!p->pre_handler || !p->pre_handler(p, regs))
+				setup_singlestep(p, regs, kcb, 0);
+			else
+				reset_current_kprobe();
+		}
+		return true;
+	}
+
+	/*
+	 * The breakpoint instruction was removed right
+	 * after we hit it.  Another cpu has removed
+	 * either a probepoint or a debugger breakpoint
+	 * at this address.  In either case, no further
+	 * handling of this interrupt is appropriate.
+	 * Return back to original instruction, and continue.
+	 */
+	return false;
+}
+
+bool __kprobes
+kprobe_single_step_handler(struct pt_regs *regs)
+{
+	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
+
+	if ((kcb->ss_ctx.ss_pending)
+	    && (kcb->ss_ctx.match_addr == instruction_pointer(regs))) {
+		clear_ss_context(kcb);	/* clear pending ss */
+
+		kprobes_restore_local_irqflag(kcb, regs);
+
+		post_kprobe_handler(kcb, regs);
+		return true;
+	}
+	return false;
+}
+
+/*
+ * Provide a blacklist of symbols identifying ranges which cannot be kprobed.
+ * This blacklist is exposed to userspace via debugfs (kprobes/blacklist).
+ */
+int __init arch_populate_kprobe_blacklist(void)
+{
+	int ret;
+
+	ret = kprobe_add_area_blacklist((unsigned long)__irqentry_text_start,
+					(unsigned long)__irqentry_text_end);
+	return ret;
+}
+
+void __kprobes __used *trampoline_probe_handler(struct pt_regs *regs)
+{
+	return (void *)kretprobe_trampoline_handler(regs, &kretprobe_trampoline, NULL);
+}
+
+void __kprobes arch_prepare_kretprobe(struct kretprobe_instance *ri,
+				      struct pt_regs *regs)
+{
+	ri->ret_addr = (kprobe_opcode_t *)regs->ra;
+	ri->fp = NULL;
+	regs->ra = (unsigned long) &kretprobe_trampoline;
+}
+
+int __kprobes arch_trampoline_kprobe(struct kprobe *p)
+{
+	return 0;
+}
+
+int __init arch_init_kprobes(void)
+{
+	return 0;
+}
diff --git a/arch/riscv/kernel/probes/kprobes_trampoline.S b/arch/riscv/kernel/probes/kprobes_trampoline.S
new file mode 100755
index 000000000..6e85d021e
--- /dev/null
+++ b/arch/riscv/kernel/probes/kprobes_trampoline.S
@@ -0,0 +1,93 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Author: Patrick Sthlin <me@packi.ch>
+ */
+#include <linux/linkage.h>
+
+#include <asm/asm.h>
+#include <asm/asm-offsets.h>
+
+	.text
+	.altmacro
+
+	.macro save_all_base_regs
+	REG_S x1,  PT_RA(sp)
+	REG_S x3,  PT_GP(sp)
+	REG_S x4,  PT_TP(sp)
+	REG_S x5,  PT_T0(sp)
+	REG_S x6,  PT_T1(sp)
+	REG_S x7,  PT_T2(sp)
+	REG_S x8,  PT_S0(sp)
+	REG_S x9,  PT_S1(sp)
+	REG_S x10, PT_A0(sp)
+	REG_S x11, PT_A1(sp)
+	REG_S x12, PT_A2(sp)
+	REG_S x13, PT_A3(sp)
+	REG_S x14, PT_A4(sp)
+	REG_S x15, PT_A5(sp)
+	REG_S x16, PT_A6(sp)
+	REG_S x17, PT_A7(sp)
+	REG_S x18, PT_S2(sp)
+	REG_S x19, PT_S3(sp)
+	REG_S x20, PT_S4(sp)
+	REG_S x21, PT_S5(sp)
+	REG_S x22, PT_S6(sp)
+	REG_S x23, PT_S7(sp)
+	REG_S x24, PT_S8(sp)
+	REG_S x25, PT_S9(sp)
+	REG_S x26, PT_S10(sp)
+	REG_S x27, PT_S11(sp)
+	REG_S x28, PT_T3(sp)
+	REG_S x29, PT_T4(sp)
+	REG_S x30, PT_T5(sp)
+	REG_S x31, PT_T6(sp)
+	.endm
+
+	.macro restore_all_base_regs
+	REG_L x3,  PT_GP(sp)
+	REG_L x4,  PT_TP(sp)
+	REG_L x5,  PT_T0(sp)
+	REG_L x6,  PT_T1(sp)
+	REG_L x7,  PT_T2(sp)
+	REG_L x8,  PT_S0(sp)
+	REG_L x9,  PT_S1(sp)
+	REG_L x10, PT_A0(sp)
+	REG_L x11, PT_A1(sp)
+	REG_L x12, PT_A2(sp)
+	REG_L x13, PT_A3(sp)
+	REG_L x14, PT_A4(sp)
+	REG_L x15, PT_A5(sp)
+	REG_L x16, PT_A6(sp)
+	REG_L x17, PT_A7(sp)
+	REG_L x18, PT_S2(sp)
+	REG_L x19, PT_S3(sp)
+	REG_L x20, PT_S4(sp)
+	REG_L x21, PT_S5(sp)
+	REG_L x22, PT_S6(sp)
+	REG_L x23, PT_S7(sp)
+	REG_L x24, PT_S8(sp)
+	REG_L x25, PT_S9(sp)
+	REG_L x26, PT_S10(sp)
+	REG_L x27, PT_S11(sp)
+	REG_L x28, PT_T3(sp)
+	REG_L x29, PT_T4(sp)
+	REG_L x30, PT_T5(sp)
+	REG_L x31, PT_T6(sp)
+	.endm
+
+ENTRY(kretprobe_trampoline)
+	addi sp, sp, -(PT_SIZE_ON_STACK)
+	save_all_base_regs
+
+	move a0, sp /* pt_regs */
+
+	call trampoline_probe_handler
+
+	/* use the result as the return-address */
+	move ra, a0
+
+	restore_all_base_regs
+	addi sp, sp, PT_SIZE_ON_STACK
+
+	ret
+ENDPROC(kretprobe_trampoline)
diff --git a/arch/riscv/kernel/probes/simulate-insn.c b/arch/riscv/kernel/probes/simulate-insn.c
new file mode 100755
index 000000000..d0f3b3fde
--- /dev/null
+++ b/arch/riscv/kernel/probes/simulate-insn.c
@@ -0,0 +1,197 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#include <linux/bitops.h>
+#include <linux/kernel.h>
+#include <linux/kprobes.h>
+
+#include "decode-insn.h"
+#include "simulate-insn.h"
+
+static inline bool rv_insn_reg_get_val(struct pt_regs *regs, u32 index,
+				       unsigned long *ptr)
+{
+	if (index == 0)
+		*ptr = 0;
+	else if (index <= 31)
+		*ptr = *((unsigned long *)regs + index);
+	else
+		return false;
+
+	return true;
+}
+
+static inline bool rv_insn_reg_set_val(struct pt_regs *regs, u32 index,
+				       unsigned long val)
+{
+	if (index == 0)
+		return false;
+	else if (index <= 31)
+		*((unsigned long *)regs + index) = val;
+	else
+		return false;
+
+	return true;
+}
+
+bool __kprobes simulate_jal(u32 opcode, unsigned long addr, struct pt_regs *regs)
+{
+	/*
+	 *     31    30       21    20     19        12 11 7 6      0
+	 * imm [20] | imm[10:1] | imm[11] | imm[19:12] | rd | opcode
+	 *     1         10          1           8       5    JAL/J
+	 */
+	bool ret;
+	u32 imm;
+	u32 index = (opcode >> 7) & 0x1f;
+
+	ret = rv_insn_reg_set_val(regs, index, addr + 4);
+	if (!ret)
+		return ret;
+
+	imm  = ((opcode >> 21) & 0x3ff) << 1;
+	imm |= ((opcode >> 20) & 0x1)   << 11;
+	imm |= ((opcode >> 12) & 0xff)  << 12;
+	imm |= ((opcode >> 31) & 0x1)   << 20;
+
+	instruction_pointer_set(regs, addr + sign_extend32((imm), 20));
+
+	return ret;
+}
+
+bool __kprobes simulate_jalr(u32 opcode, unsigned long addr, struct pt_regs *regs)
+{
+	/*
+	 * 31          20 19 15 14 12 11 7 6      0
+	 *  offset[11:0] | rs1 | 010 | rd | opcode
+	 *      12         5      3    5    JALR/JR
+	 */
+	bool ret;
+	unsigned long base_addr;
+	u32 imm = (opcode >> 20) & 0xfff;
+	u32 rd_index = (opcode >> 7) & 0x1f;
+	u32 rs1_index = (opcode >> 15) & 0x1f;
+
+	ret = rv_insn_reg_set_val(regs, rd_index, addr + 4);
+	if (!ret)
+		return ret;
+
+	ret = rv_insn_reg_get_val(regs, rs1_index, &base_addr);
+	if (!ret)
+		return ret;
+
+	instruction_pointer_set(regs, (base_addr + sign_extend32((imm), 11))&~1);
+
+	return ret;
+}
+
+#define auipc_rd_idx(opcode) \
+	((opcode >> 7) & 0x1f)
+
+#define auipc_imm(opcode) \
+	((((opcode) >> 12) & 0xfffff) << 12)
+
+#if __riscv_xlen == 64
+#define auipc_offset(opcode)	sign_extend64(auipc_imm(opcode), 31)
+#elif __riscv_xlen == 32
+#define auipc_offset(opcode)	auipc_imm(opcode)
+#else
+#error "Unexpected __riscv_xlen"
+#endif
+
+bool __kprobes simulate_auipc(u32 opcode, unsigned long addr, struct pt_regs *regs)
+{
+	/*
+	 * auipc instruction:
+	 *  31        12 11 7 6      0
+	 * | imm[31:12] | rd | opcode |
+	 *        20       5     7
+	 */
+
+	u32 rd_idx = auipc_rd_idx(opcode);
+	unsigned long rd_val = addr + auipc_offset(opcode);
+
+	if (!rv_insn_reg_set_val(regs, rd_idx, rd_val))
+		return false;
+
+	instruction_pointer_set(regs, addr + 4);
+
+	return true;
+}
+
+#define branch_rs1_idx(opcode) \
+	(((opcode) >> 15) & 0x1f)
+
+#define branch_rs2_idx(opcode) \
+	(((opcode) >> 20) & 0x1f)
+
+#define branch_funct3(opcode) \
+	(((opcode) >> 12) & 0x7)
+
+#define branch_imm(opcode) \
+	(((((opcode) >>  8) & 0xf ) <<  1) | \
+	 ((((opcode) >> 25) & 0x3f) <<  5) | \
+	 ((((opcode) >>  7) & 0x1 ) << 11) | \
+	 ((((opcode) >> 31) & 0x1 ) << 12))
+
+#define branch_offset(opcode) \
+	sign_extend32((branch_imm(opcode)), 12)
+
+#define BRANCH_BEQ	0x0
+#define BRANCH_BNE	0x1
+#define BRANCH_BLT	0x4
+#define BRANCH_BGE	0x5
+#define BRANCH_BLTU	0x6
+#define BRANCH_BGEU	0x7
+
+bool __kprobes simulate_branch(u32 opcode, unsigned long addr, struct pt_regs *regs)
+{
+	/*
+	 * branch instructions:
+	 *      31    30       25 24 20 19 15 14    12 11       8    7      6      0
+	 * | imm[12] | imm[10:5] | rs2 | rs1 | funct3 | imm[4:1] | imm[11] | opcode |
+	 *     1           6        5     5      3         4         1         7
+	 *     imm[12|10:5]        rs2   rs1    000       imm[4:1|11]       1100011  BEQ
+	 *     imm[12|10:5]        rs2   rs1    001       imm[4:1|11]       1100011  BNE
+	 *     imm[12|10:5]        rs2   rs1    100       imm[4:1|11]       1100011  BLT
+	 *     imm[12|10:5]        rs2   rs1    101       imm[4:1|11]       1100011  BGE
+	 *     imm[12|10:5]        rs2   rs1    110       imm[4:1|11]       1100011  BLTU
+	 *     imm[12|10:5]        rs2   rs1    111       imm[4:1|11]       1100011  BGEU
+	 */
+
+	s32 offset;
+	s32 offset_tmp;
+	unsigned long rs1_val;
+	unsigned long rs2_val;
+
+	if (!rv_insn_reg_get_val(regs, branch_rs1_idx(opcode), &rs1_val) ||
+	    !rv_insn_reg_get_val(regs, branch_rs2_idx(opcode), &rs2_val))
+		return false;
+
+	offset_tmp = branch_offset(opcode);
+	switch (branch_funct3(opcode)) {
+	case BRANCH_BEQ:
+		offset = (rs1_val == rs2_val) ? offset_tmp : 4;
+		break;
+	case BRANCH_BNE:
+		offset = (rs1_val != rs2_val) ? offset_tmp : 4;
+		break;
+	case BRANCH_BLT:
+		offset = ((long)rs1_val < (long)rs2_val) ? offset_tmp : 4;
+		break;
+	case BRANCH_BGE:
+		offset = ((long)rs1_val >= (long)rs2_val) ? offset_tmp : 4;
+		break;
+	case BRANCH_BLTU:
+		offset = (rs1_val < rs2_val) ? offset_tmp : 4;
+		break;
+	case BRANCH_BGEU:
+		offset = (rs1_val >= rs2_val) ? offset_tmp : 4;
+		break;
+	default:
+		return false;
+	}
+
+	instruction_pointer_set(regs, addr + offset);
+
+	return true;
+}
\ No newline at end of file
diff --git a/arch/riscv/kernel/probes/simulate-insn.h b/arch/riscv/kernel/probes/simulate-insn.h
new file mode 100755
index 000000000..cb6ff7dcc
--- /dev/null
+++ b/arch/riscv/kernel/probes/simulate-insn.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+
+#ifndef _RISCV_KERNEL_PROBES_SIMULATE_INSN_H
+#define _RISCV_KERNEL_PROBES_SIMULATE_INSN_H
+
+#define __RISCV_INSN_FUNCS(name, mask, val)				\
+static __always_inline bool riscv_insn_is_##name(probe_opcode_t code)	\
+{									\
+	BUILD_BUG_ON(~(mask) & (val));					\
+	return (code & (mask)) == (val);				\
+}									\
+bool simulate_##name(u32 opcode, unsigned long addr,			\
+		     struct pt_regs *regs)
+
+#define RISCV_INSN_REJECTED(name, code)					\
+	do {								\
+		if (riscv_insn_is_##name(code)) {			\
+			return INSN_REJECTED;				\
+		}							\
+	} while (0)
+
+__RISCV_INSN_FUNCS(system,	0x7f, 0x73);
+__RISCV_INSN_FUNCS(fence,	0x7f, 0x0f);
+
+#define RISCV_INSN_SET_SIMULATE(name, code)				\
+	do {								\
+		if (riscv_insn_is_##name(code)) {			\
+			api->handler = simulate_##name;			\
+			return INSN_GOOD_NO_SLOT;			\
+		}							\
+	} while (0)
+
+__RISCV_INSN_FUNCS(c_j,		0xe003, 0xa001);
+__RISCV_INSN_FUNCS(c_jr,	0xf007, 0x8002);
+__RISCV_INSN_FUNCS(c_jal,	0xe003, 0x2001);
+__RISCV_INSN_FUNCS(c_jalr,	0xf007, 0x9002);
+__RISCV_INSN_FUNCS(c_beqz,	0xe003, 0xc001);
+__RISCV_INSN_FUNCS(c_bnez,	0xe003, 0xe001);
+__RISCV_INSN_FUNCS(c_ebreak,	0xffff, 0x9002);
+
+__RISCV_INSN_FUNCS(auipc,	0x7f, 0x17);
+__RISCV_INSN_FUNCS(branch,	0x7f, 0x63);
+
+__RISCV_INSN_FUNCS(jal,		0x7f, 0x6f);
+__RISCV_INSN_FUNCS(jalr,	0x707f, 0x67);
+
+#endif /* _RISCV_KERNEL_PROBES_SIMULATE_INSN_H */
diff --git a/arch/riscv/kernel/probes/uprobes.c b/arch/riscv/kernel/probes/uprobes.c
new file mode 100755
index 000000000..7a057b5f0
--- /dev/null
+++ b/arch/riscv/kernel/probes/uprobes.c
@@ -0,0 +1,186 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/highmem.h>
+#include <linux/ptrace.h>
+#include <linux/uprobes.h>
+
+#include "decode-insn.h"
+
+#define UPROBE_TRAP_NR	UINT_MAX
+
+bool is_swbp_insn(uprobe_opcode_t *insn)
+{
+#ifdef CONFIG_RISCV_ISA_C
+	return (*insn & 0xffff) == UPROBE_SWBP_INSN;
+#else
+	return *insn == UPROBE_SWBP_INSN;
+#endif
+}
+
+unsigned long uprobe_get_swbp_addr(struct pt_regs *regs)
+{
+	return instruction_pointer(regs);
+}
+
+int arch_uprobe_analyze_insn(struct arch_uprobe *auprobe, struct mm_struct *mm,
+			     unsigned long addr)
+{
+	probe_opcode_t opcode;
+
+	opcode = *(probe_opcode_t *)(&auprobe->insn[0]);
+
+	auprobe->insn_size = GET_INSN_LENGTH(opcode);
+
+	switch (riscv_probe_decode_insn(&opcode, &auprobe->api)) {
+	case INSN_REJECTED:
+		return -EINVAL;
+
+	case INSN_GOOD_NO_SLOT:
+		auprobe->simulate = true;
+		break;
+
+	case INSN_GOOD:
+		auprobe->simulate = false;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
+{
+	struct uprobe_task *utask = current->utask;
+
+	utask->autask.saved_cause = current->thread.bad_cause;
+	current->thread.bad_cause = UPROBE_TRAP_NR;
+
+	instruction_pointer_set(regs, utask->xol_vaddr);
+
+	regs->status &= ~SR_SPIE;
+
+	return 0;
+}
+
+int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
+{
+	struct uprobe_task *utask = current->utask;
+
+	WARN_ON_ONCE(current->thread.bad_cause != UPROBE_TRAP_NR);
+
+	instruction_pointer_set(regs, utask->vaddr + auprobe->insn_size);
+
+	regs->status |= SR_SPIE;
+
+	return 0;
+}
+
+bool arch_uprobe_xol_was_trapped(struct task_struct *t)
+{
+	if (t->thread.bad_cause != UPROBE_TRAP_NR)
+		return true;
+
+	return false;
+}
+
+bool arch_uprobe_skip_sstep(struct arch_uprobe *auprobe, struct pt_regs *regs)
+{
+	probe_opcode_t insn;
+	unsigned long addr;
+
+	if (!auprobe->simulate)
+		return false;
+
+	insn = *(probe_opcode_t *)(&auprobe->insn[0]);
+	addr = instruction_pointer(regs);
+
+	if (auprobe->api.handler)
+		auprobe->api.handler(insn, addr, regs);
+
+	return true;
+}
+
+void arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
+{
+	struct uprobe_task *utask = current->utask;
+
+	/*
+	 * Task has received a fatal signal, so reset back to probbed
+	 * address.
+	 */
+	instruction_pointer_set(regs, utask->vaddr);
+
+	regs->status &= ~SR_SPIE;
+}
+
+bool arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,
+		struct pt_regs *regs)
+{
+	if (ctx == RP_CHECK_CHAIN_CALL)
+		return regs->sp <= ret->stack;
+	else
+		return regs->sp < ret->stack;
+}
+
+unsigned long
+arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr,
+				  struct pt_regs *regs)
+{
+	unsigned long ra;
+
+	ra = regs->ra;
+
+	regs->ra = trampoline_vaddr;
+
+	return ra;
+}
+
+int arch_uprobe_exception_notify(struct notifier_block *self,
+				 unsigned long val, void *data)
+{
+	return NOTIFY_DONE;
+}
+
+bool uprobe_breakpoint_handler(struct pt_regs *regs)
+{
+	if (uprobe_pre_sstep_notifier(regs))
+		return true;
+
+	return false;
+}
+
+bool uprobe_single_step_handler(struct pt_regs *regs)
+{
+	if (uprobe_post_sstep_notifier(regs))
+		return true;
+
+	return false;
+}
+
+void arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
+			   void *src, unsigned long len)
+{
+	/* Initialize the slot */
+	void *kaddr = kmap_atomic(page);
+	void *dst = kaddr + (vaddr & ~PAGE_MASK);
+
+	memcpy(dst, src, len);
+
+	/* Add ebreak behind opcode to simulate singlestep */
+	if (vaddr) {
+		dst += GET_INSN_LENGTH(*(probe_opcode_t *)src);
+		*(uprobe_opcode_t *)dst = __BUG_INSN_32;
+	}
+
+	kunmap_atomic(kaddr);
+
+	/*
+	 * We probably need flush_icache_user_page() but it needs vma.
+	 * This should work on most of architectures by default. If
+	 * architecture needs to do something different it can define
+	 * its own version of the function.
+	 */
+	flush_dcache_page(page);
+}
diff --git a/arch/riscv/kernel/process.c b/arch/riscv/kernel/process.c
index dd5f985b1..0d6f79dc3 100644
--- a/arch/riscv/kernel/process.c
+++ b/arch/riscv/kernel/process.c
@@ -14,9 +14,11 @@
 #include <linux/tick.h>
 #include <linux/ptrace.h>
 #include <linux/uaccess.h>
+#include <uapi/linux/elf.h>
 
 #include <asm/unistd.h>
 #include <asm/processor.h>
+#include <asm/compat.h>
 #include <asm/csr.h>
 #include <asm/string.h>
 #include <asm/switch_to.h>
@@ -43,6 +45,11 @@ void show_regs(struct pt_regs *regs)
 {
 	show_regs_print_info(KERN_DEFAULT);
 
+	if (!user_mode(regs)) {
+		pr_cont("epc : %pS\n", (void *)regs->epc);
+		pr_cont(" ra : %pS\n", (void *)regs->ra);
+	}
+
 	pr_cont("epc: " REG_FMT " ra : " REG_FMT " sp : " REG_FMT "\n",
 		regs->epc, regs->ra, regs->sp);
 	pr_cont(" gp : " REG_FMT " tp : " REG_FMT " t0 : " REG_FMT "\n",
@@ -82,8 +89,22 @@ void start_thread(struct pt_regs *regs, unsigned long pc,
 		 */
 		fstate_restore(current, regs);
 	}
+
+	if (has_vector) {
+		regs->status |= SR_VS_INITIAL;
+		vstate_restore(current, regs);
+	}
+
 	regs->epc = pc;
 	regs->sp = sp;
+
+#ifdef CONFIG_COMPAT
+	regs->status &= ~SR_UXL;
+	if (is_compat_task())
+		regs->status |= SR_UXL_32;
+	else
+		regs->status |= SR_UXL_64;
+#endif
 }
 
 void flush_thread(void)
diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index 69678ab64..85c81d65f 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -12,6 +12,7 @@
 #include <asm/thread_info.h>
 #include <asm/switch_to.h>
 #include <linux/audit.h>
+#include <linux/compat.h>
 #include <linux/ptrace.h>
 #include <linux/elf.h>
 #include <linux/regset.h>
@@ -27,6 +28,9 @@ enum riscv_regset {
 #ifdef CONFIG_FPU
 	REGSET_F,
 #endif
+#ifdef CONFIG_VECTOR
+	REGSET_V,
+#endif
 };
 
 static int riscv_gpr_get(struct task_struct *target,
@@ -85,6 +89,31 @@ static int riscv_fpr_set(struct task_struct *target,
 }
 #endif
 
+#ifdef CONFIG_VECTOR
+static int riscv_vr_get(struct task_struct *target,
+			 const struct user_regset *regset,
+			 struct membuf to)
+{
+	struct __riscv_v_state *vstate = &target->thread.vstate;
+
+	membuf_write(&to, vstate, offsetof(struct __riscv_v_state, vtype));
+	return membuf_zero(&to, 4);	// explicitly pad
+}
+
+static int riscv_vr_set(struct task_struct *target,
+			 const struct user_regset *regset,
+			 unsigned int pos, unsigned int count,
+			 const void *kbuf, const void __user *ubuf)
+{
+	int ret;
+	struct __riscv_v_state *vstate = &target->thread.vstate;
+
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, vstate, 0,
+				 offsetof(struct __riscv_v_state, vtype));
+	return ret;
+}
+#endif
+
 static const struct user_regset riscv_user_regset[] = {
 	[REGSET_X] = {
 		.core_note_type = NT_PRSTATUS,
@@ -104,6 +133,16 @@ static const struct user_regset riscv_user_regset[] = {
 		.set = riscv_fpr_set,
 	},
 #endif
+#ifdef CONFIG_VECTOR
+	[REGSET_V] = {
+		.core_note_type = NT_RISCV_VECTOR,
+		.n = ELF_NVREG,
+		.size = sizeof(elf_greg_t),
+		.align = sizeof(elf_greg_t),
+		.regset_get = riscv_vr_get,
+		.set = riscv_vr_set,
+	},
+#endif
 };
 
 static const struct user_regset_view riscv_user_native_view = {
@@ -113,9 +152,103 @@ static const struct user_regset_view riscv_user_native_view = {
 	.n = ARRAY_SIZE(riscv_user_regset),
 };
 
-const struct user_regset_view *task_user_regset_view(struct task_struct *task)
+struct pt_regs_offset {
+	const char *name;
+	int offset;
+};
+
+#define REG_OFFSET_NAME(r) {.name = #r, .offset = offsetof(struct pt_regs, r)}
+#define REG_OFFSET_END {.name = NULL, .offset = 0}
+
+static const struct pt_regs_offset regoffset_table[] = {
+	REG_OFFSET_NAME(epc),
+	REG_OFFSET_NAME(ra),
+	REG_OFFSET_NAME(sp),
+	REG_OFFSET_NAME(gp),
+	REG_OFFSET_NAME(tp),
+	REG_OFFSET_NAME(t0),
+	REG_OFFSET_NAME(t1),
+	REG_OFFSET_NAME(t2),
+	REG_OFFSET_NAME(s0),
+	REG_OFFSET_NAME(s1),
+	REG_OFFSET_NAME(a0),
+	REG_OFFSET_NAME(a1),
+	REG_OFFSET_NAME(a2),
+	REG_OFFSET_NAME(a3),
+	REG_OFFSET_NAME(a4),
+	REG_OFFSET_NAME(a5),
+	REG_OFFSET_NAME(a6),
+	REG_OFFSET_NAME(a7),
+	REG_OFFSET_NAME(s2),
+	REG_OFFSET_NAME(s3),
+	REG_OFFSET_NAME(s4),
+	REG_OFFSET_NAME(s5),
+	REG_OFFSET_NAME(s6),
+	REG_OFFSET_NAME(s7),
+	REG_OFFSET_NAME(s8),
+	REG_OFFSET_NAME(s9),
+	REG_OFFSET_NAME(s10),
+	REG_OFFSET_NAME(s11),
+	REG_OFFSET_NAME(t3),
+	REG_OFFSET_NAME(t4),
+	REG_OFFSET_NAME(t5),
+	REG_OFFSET_NAME(t6),
+	REG_OFFSET_NAME(status),
+	REG_OFFSET_NAME(badaddr),
+	REG_OFFSET_NAME(cause),
+	REG_OFFSET_NAME(orig_a0),
+	REG_OFFSET_END,
+};
+
+/**
+ * regs_query_register_offset() - query register offset from its name
+ * @name:	the name of a register
+ *
+ * regs_query_register_offset() returns the offset of a register in struct
+ * pt_regs from its name. If the name is invalid, this returns -EINVAL;
+ */
+int regs_query_register_offset(const char *name)
+{
+	const struct pt_regs_offset *roff;
+
+	for (roff = regoffset_table; roff->name != NULL; roff++)
+		if (!strcmp(roff->name, name))
+			return roff->offset;
+	return -EINVAL;
+}
+
+/**
+ * regs_within_kernel_stack() - check the address in the stack
+ * @regs:      pt_regs which contains kernel stack pointer.
+ * @addr:      address which is checked.
+ *
+ * regs_within_kernel_stack() checks @addr is within the kernel stack page(s).
+ * If @addr is within the kernel stack, it returns true. If not, returns false.
+ */
+static bool regs_within_kernel_stack(struct pt_regs *regs, unsigned long addr)
 {
-	return &riscv_user_native_view;
+	return (addr & ~(THREAD_SIZE - 1))  ==
+		(kernel_stack_pointer(regs) & ~(THREAD_SIZE - 1));
+}
+
+/**
+ * regs_get_kernel_stack_nth() - get Nth entry of the stack
+ * @regs:	pt_regs which contains kernel stack pointer.
+ * @n:		stack entry number.
+ *
+ * regs_get_kernel_stack_nth() returns @n th entry of the kernel stack which
+ * is specified by @regs. If the @n th entry is NOT in the kernel stack,
+ * this returns 0.
+ */
+unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs, unsigned int n)
+{
+	unsigned long *addr = (unsigned long *)kernel_stack_pointer(regs);
+
+	addr += n;
+	if (regs_within_kernel_stack(regs, (unsigned long)addr))
+		return *addr;
+	else
+		return 0;
 }
 
 void ptrace_disable(struct task_struct *child)
@@ -176,3 +309,94 @@ __visible void do_syscall_trace_exit(struct pt_regs *regs)
 		trace_sys_exit(regs, regs_return_value(regs));
 #endif
 }
+
+#ifdef CONFIG_COMPAT
+static int compat_riscv_gpr_get(struct task_struct *target,
+				const struct user_regset *regset,
+				struct membuf to)
+{
+	struct compat_user_regs_struct cregs;
+
+	regs_to_cregs(&cregs, task_pt_regs(target));
+
+	return membuf_write(&to, &cregs,
+			    sizeof(struct compat_user_regs_struct));
+}
+
+static int compat_riscv_gpr_set(struct task_struct *target,
+				const struct user_regset *regset,
+				unsigned int pos, unsigned int count,
+				const void *kbuf, const void __user *ubuf)
+{
+	int ret;
+	struct compat_user_regs_struct cregs;
+
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &cregs, 0, -1);
+
+	cregs_to_regs(&cregs, task_pt_regs(target));
+
+	return ret;
+}
+
+static const struct user_regset compat_riscv_user_regset[] = {
+	[REGSET_X] = {
+		.core_note_type = NT_PRSTATUS,
+		.n = ELF_NGREG,
+		.size = sizeof(compat_elf_greg_t),
+		.align = sizeof(compat_elf_greg_t),
+		.regset_get = compat_riscv_gpr_get,
+		.set = compat_riscv_gpr_set,
+	},
+#ifdef CONFIG_FPU
+	[REGSET_F] = {
+		.core_note_type = NT_PRFPREG,
+		.n = ELF_NFPREG,
+		.size = sizeof(elf_fpreg_t),
+		.align = sizeof(elf_fpreg_t),
+		.regset_get = riscv_fpr_get,
+		.set = riscv_fpr_set,
+	},
+#endif
+#ifdef CONFIG_VECTOR
+	[REGSET_V] = {
+		.core_note_type = NT_RISCV_VECTOR,
+		.n = ELF_NVREG,
+		.size = sizeof(elf_greg_t),
+		.align = sizeof(elf_greg_t),
+		.regset_get = riscv_vr_get,
+		.set = riscv_vr_set,
+	},
+#endif
+};
+
+static const struct user_regset_view compat_riscv_user_native_view = {
+	.name = "riscv",
+	.e_machine = EM_RISCV,
+	.regsets = compat_riscv_user_regset,
+	.n = ARRAY_SIZE(compat_riscv_user_regset),
+};
+
+long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
+			compat_ulong_t caddr, compat_ulong_t cdata)
+{
+	long ret = -EIO;
+
+	switch (request) {
+	default:
+		ret = compat_ptrace_request(child, request, caddr, cdata);
+		break;
+	}
+
+	return ret;
+}
+#endif /* CONFIG_COMPAT */
+
+const struct user_regset_view *task_user_regset_view(struct task_struct *task)
+{
+#ifdef CONFIG_COMPAT
+	if (test_tsk_thread_flag(task, TIF_32BIT))
+		return &compat_riscv_user_native_view;
+	else
+#endif
+		return &riscv_user_native_view;
+}
diff --git a/arch/riscv/kernel/sbi.c b/arch/riscv/kernel/sbi.c
index 226ccce0f..0128a6964 100644
--- a/arch/riscv/kernel/sbi.c
+++ b/arch/riscv/kernel/sbi.c
@@ -98,8 +98,12 @@ EXPORT_SYMBOL(sbi_console_getchar);
  *
  * Return: None
  */
+extern void khv_shutdown(void);
 void sbi_shutdown(void)
 {
+#ifdef CONFIG_VIRTIO_KHV_MMIO
+	khv_shutdown();
+#endif
 	sbi_ecall(SBI_EXT_0_1_SHUTDOWN, 0, 0, 0, 0, 0, 0, 0);
 }
 EXPORT_SYMBOL(sbi_shutdown);
@@ -547,6 +551,21 @@ static inline long sbi_get_firmware_version(void)
 	return __sbi_base_ecall(SBI_EXT_BASE_GET_IMP_VERSION);
 }
 
+long sbi_get_mvendorid(void)
+{
+	return __sbi_base_ecall(SBI_EXT_BASE_GET_MVENDORID);
+}
+
+long sbi_get_marchid(void)
+{
+	return __sbi_base_ecall(SBI_EXT_BASE_GET_MARCHID);
+}
+
+long sbi_get_mimpid(void)
+{
+	return __sbi_base_ecall(SBI_EXT_BASE_GET_MIMPID);
+}
+
 static void sbi_send_cpumask_ipi(const struct cpumask *target)
 {
 	struct cpumask hartid_mask;
diff --git a/arch/riscv/kernel/setup.c b/arch/riscv/kernel/setup.c
index 117f3212a..23f8203b6 100644
--- a/arch/riscv/kernel/setup.c
+++ b/arch/riscv/kernel/setup.c
@@ -4,6 +4,8 @@
  *  Chen Liqin <liqin.chen@sunplusct.com>
  *  Lennox Wu <lennox.wu@sunplusct.com>
  * Copyright (C) 2012 Regents of the University of California
+ * Copyright (C) 2020 FORTH-ICS/CARV
+ *  Nick Kossifidis <mick@ics.forth.gr>
  */
 
 #include <linux/init.h>
@@ -18,6 +20,7 @@
 #include <linux/swiotlb.h>
 #include <linux/smp.h>
 #include <linux/efi.h>
+#include <linux/crash_dump.h>
 
 #include <asm/cpu_ops.h>
 #include <asm/early_ioremap.h>
@@ -51,6 +54,184 @@ atomic_t hart_lottery __section(".sdata");
 unsigned long boot_cpu_hartid;
 static DEFINE_PER_CPU(struct cpu, cpu_devices);
 
+/*
+ * Place kernel memory regions on the resource tree so that
+ * kexec-tools can retrieve them from /proc/iomem. While there
+ * also add "System RAM" regions for compatibility with other
+ * archs, and the rest of the known regions for completeness.
+ */
+static struct resource code_res = { .name = "Kernel code", };
+static struct resource data_res = { .name = "Kernel data", };
+static struct resource rodata_res = { .name = "Kernel rodata", };
+static struct resource bss_res = { .name = "Kernel bss", };
+#ifdef CONFIG_CRASH_DUMP
+static struct resource elfcorehdr_res = { .name = "ELF Core hdr", };
+#endif
+
+static int __init add_resource(struct resource *parent,
+				struct resource *res)
+{
+	int ret = 0;
+
+	ret = insert_resource(parent, res);
+	if (ret < 0) {
+		pr_err("Failed to add a %s resource at %llx\n",
+			res->name, (unsigned long long) res->start);
+		return ret;
+	}
+
+	return 1;
+}
+
+static int __init add_kernel_resources(struct resource *res)
+{
+	int ret = 0;
+
+	/*
+	 * The memory region of the kernel image is continuous and
+	 * was reserved on setup_bootmem, find it here and register
+	 * it as a resource, then register the various segments of
+	 * the image as child nodes
+	 */
+	if (!(res->start <= code_res.start && res->end >= data_res.end))
+		return 0;
+
+	res->name = "Kernel image";
+	res->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+
+	/*
+	 * We removed a part of this region on setup_bootmem so
+	 * we need to expand the resource for the bss to fit in.
+	 */
+	res->end = bss_res.end;
+
+	ret = add_resource(&iomem_resource, res);
+	if (ret < 0)
+		return ret;
+
+	ret = add_resource(res, &code_res);
+	if (ret < 0)
+		return ret;
+
+	ret = add_resource(res, &rodata_res);
+	if (ret < 0)
+		return ret;
+
+	ret = add_resource(res, &data_res);
+	if (ret < 0)
+		return ret;
+
+	ret = add_resource(res, &bss_res);
+
+	return ret;
+}
+
+static void __init init_resources(void)
+{
+	struct memblock_region *region = NULL;
+	struct resource *res = NULL;
+	int ret = 0;
+
+	code_res.start = __pa_symbol(_text);
+	code_res.end = __pa_symbol(_etext) - 1;
+	code_res.flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+
+	rodata_res.start = __pa_symbol(__start_rodata);
+	rodata_res.end = __pa_symbol(__end_rodata) - 1;
+	rodata_res.flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+
+	data_res.start = __pa_symbol(_data);
+	data_res.end = __pa_symbol(_edata) - 1;
+	data_res.flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+
+	bss_res.start = __pa_symbol(__bss_start);
+	bss_res.end = __pa_symbol(__bss_stop) - 1;
+	bss_res.flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+
+	/*
+	 * Start by adding the reserved regions, if they overlap
+	 * with /memory regions, insert_resource later on will take
+	 * care of it.
+	 */
+
+#ifdef CONFIG_KEXEC_CORE
+	if (crashk_res.start != crashk_res.end) {
+		ret = add_resource(&iomem_resource, &crashk_res);
+		if (ret < 0)
+			goto error;
+	}
+#endif
+
+#ifdef CONFIG_CRASH_DUMP
+	if (elfcorehdr_size > 0) {
+		elfcorehdr_res.start = elfcorehdr_addr;
+		elfcorehdr_res.end = elfcorehdr_addr + elfcorehdr_size - 1;
+		elfcorehdr_res.flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+		add_resource(&iomem_resource, &elfcorehdr_res);
+	}
+#endif
+
+	for_each_reserved_mem_region(region) {
+		res = memblock_alloc(sizeof(struct resource), SMP_CACHE_BYTES);
+		if (!res)
+			panic("%s: Failed to allocate %zu bytes\n", __func__,
+			      sizeof(struct resource));
+
+		res->name = "Reserved";
+		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+		res->start = __pfn_to_phys(memblock_region_reserved_base_pfn(region));
+		res->end = __pfn_to_phys(memblock_region_reserved_end_pfn(region)) - 1;
+
+		ret = add_kernel_resources(res);
+		if (ret < 0)
+			goto error;
+		else if (ret)
+			continue;
+
+		/*
+		 * Ignore any other reserved regions within
+		 * system memory.
+		 */
+		if (memblock_is_memory(res->start))
+			continue;
+
+		ret = add_resource(&iomem_resource, res);
+		if (ret < 0)
+			goto error;
+		}
+
+	/* Add /memory regions to the resource tree */
+	for_each_mem_region(region) {
+		res = memblock_alloc(sizeof(struct resource), SMP_CACHE_BYTES);
+		if (!res)
+			panic("%s: Failed to allocate %zu bytes\n", __func__,
+			      sizeof(struct resource));
+
+		if (unlikely(memblock_is_nomap(region))) {
+			res->name = "Reserved";
+			res->flags = IORESOURCE_MEM;
+	} else {
+			res->name = "System RAM";
+			res->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+		}
+
+		res->start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
+		res->end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;
+
+		ret = add_resource(&iomem_resource, res);
+		if (ret < 0)
+			goto error;
+	}
+
+	return;
+
+ error:
+	memblock_free((phys_addr_t) res, sizeof(struct resource));
+	/* Better an empty resource tree than an inconsistent one */
+	release_child_resources(&iomem_resource);
+}
+
+
 static void __init parse_dtb(void)
 {
 	/* Early scan of device tree from init memory */
@@ -99,6 +280,7 @@ void __init setup_arch(char **cmdline_p)
 #endif
 
 #if IS_ENABLED(CONFIG_RISCV_SBI)
+	init_resources();
 	sbi_init();
 #endif
 
diff --git a/arch/riscv/kernel/signal.c b/arch/riscv/kernel/signal.c
index bc6841867..a8d086309 100644
--- a/arch/riscv/kernel/signal.c
+++ b/arch/riscv/kernel/signal.c
@@ -6,6 +6,7 @@
  * Copyright (C) 2012 Regents of the University of California
  */
 
+#include <linux/compat.h>
 #include <linux/signal.h>
 #include <linux/uaccess.h>
 #include <linux/syscalls.h>
@@ -83,6 +84,41 @@ static long save_fp_state(struct pt_regs *regs,
 #define restore_fp_state(task, regs) (0)
 #endif
 
+#ifdef CONFIG_VECTOR
+static long restore_v_state(struct pt_regs *regs,
+			    struct __riscv_v_state *sc_vregs)
+{
+	long err;
+	struct __riscv_v_state __user *state = sc_vregs;
+
+	err = __copy_from_user(&current->thread.vstate, state, sizeof(*state));
+	if (unlikely(err))
+		return err;
+
+	vstate_restore(current, regs);
+
+	return err;
+}
+
+static long save_v_state(struct pt_regs *regs,
+			 struct __riscv_v_state *sc_vregs)
+{
+	long err;
+	struct __riscv_v_state __user *state = sc_vregs;
+
+	vstate_save(current, regs);
+	err = __copy_to_user(state, &current->thread.vstate, sizeof(*state));
+	if (unlikely(err))
+		return err;
+
+	return err;
+}
+#else
+#define save_v_state(task, regs) (0)
+#define restore_v_state(task, regs) (0)
+#endif
+
+
 static long restore_sigcontext(struct pt_regs *regs,
 	struct sigcontext __user *sc)
 {
@@ -92,6 +128,9 @@ static long restore_sigcontext(struct pt_regs *regs,
 	/* Restore the floating-point state. */
 	if (has_fpu)
 		err |= restore_fp_state(regs, &sc->sc_fpregs);
+	/* Restore the vector state. */
+	if (has_vector)
+		err |= restore_v_state(regs, &sc->sc_vregs);
 	return err;
 }
 
@@ -145,6 +184,9 @@ static long setup_sigcontext(struct rt_sigframe __user *frame,
 	/* Save the floating-point state. */
 	if (has_fpu)
 		err |= save_fp_state(regs, &sc->sc_fpregs);
+	/* Save the vector state. */
+	if (has_vector)
+		err |= save_v_state(regs, &sc->sc_vregs);
 	return err;
 }
 
@@ -229,6 +271,11 @@ static int setup_rt_frame(struct ksignal *ksig, sigset_t *set,
 	return 0;
 }
 
+#ifdef CONFIG_COMPAT
+extern int compat_setup_rt_frame(struct ksignal *ksig, sigset_t *set,
+				 struct pt_regs *regs);
+#endif
+
 static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
 {
 	sigset_t *oldset = sigmask_to_save();
@@ -258,7 +305,12 @@ static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
 		}
 	}
 
+#ifdef CONFIG_COMPAT
 	/* Set up the stack frame */
+	if (is_compat_task())
+		ret = compat_setup_rt_frame(ksig, oldset, regs);
+	else
+#endif
 	ret = setup_rt_frame(ksig, oldset, regs);
 
 	signal_setup_done(ret, ksig, 0);
@@ -309,6 +361,9 @@ static void do_signal(struct pt_regs *regs)
 asmlinkage __visible void do_notify_resume(struct pt_regs *regs,
 					   unsigned long thread_info_flags)
 {
+	if (thread_info_flags & _TIF_UPROBE)
+		uprobe_notify_resume(regs);
+
 	/* Handle pending signal delivery */
 	if (thread_info_flags & _TIF_SIGPENDING)
 		do_signal(regs);
diff --git a/arch/riscv/kernel/smp.c b/arch/riscv/kernel/smp.c
index d44567490..b1255f5cb 100644
--- a/arch/riscv/kernel/smp.c
+++ b/arch/riscv/kernel/smp.c
@@ -11,6 +11,7 @@
 #include <linux/cpu.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/kexec.h>
 #include <linux/profile.h>
 #include <linux/smp.h>
 #include <linux/sched.h>
@@ -26,6 +27,7 @@ enum ipi_message_type {
 	IPI_RESCHEDULE,
 	IPI_CALL_FUNC,
 	IPI_CPU_STOP,
+	IPI_CPU_CRASH_STOP,
 	IPI_IRQ_WORK,
 	IPI_MAX
 };
@@ -85,6 +87,22 @@ static void ipi_stop(void)
 		wait_for_interrupt();
 }
 
+#ifdef CONFIG_KEXEC_CORE
+static atomic_t waiting_for_crash_ipi = ATOMIC_INIT(0);
+
+static void ipi_cpu_crash_stop(unsigned int cpu, struct pt_regs *regs)
+{
+	crash_save_cpu(regs, cpu);
+
+	atomic_dec(&waiting_for_crash_ipi);
+
+	local_irq_disable();
+
+	while(1)
+		wait_for_interrupt();
+}
+#endif
+
 static struct riscv_ipi_ops *ipi_ops;
 
 void riscv_set_ipi_ops(struct riscv_ipi_ops *ops)
@@ -138,6 +156,7 @@ void arch_irq_work_raise(void)
 
 void handle_IPI(struct pt_regs *regs)
 {
+	unsigned int cpu = smp_processor_id();
 	struct pt_regs *old_regs = set_irq_regs(regs);
 	unsigned long *pending_ipis = &ipi_data[smp_processor_id()].bits;
 	unsigned long *stats = ipi_data[smp_processor_id()].stats;
@@ -171,6 +190,13 @@ void handle_IPI(struct pt_regs *regs)
 			ipi_stop();
 		}
 
+		if (ops & (1 << IPI_CPU_CRASH_STOP)) {
+#ifdef CONFIG_KEXEC_CORE
+			ipi_cpu_crash_stop(cpu, get_irq_regs());
+#endif
+			unreachable();
+		}
+
 		if (ops & (1 << IPI_IRQ_WORK)) {
 			stats[IPI_IRQ_WORK]++;
 			irq_work_run();
@@ -191,6 +217,7 @@ static const char * const ipi_names[] = {
 	[IPI_RESCHEDULE]	= "Rescheduling interrupts",
 	[IPI_CALL_FUNC]		= "Function call interrupts",
 	[IPI_CPU_STOP]		= "CPU stop interrupts",
+	[IPI_CPU_CRASH_STOP]    = "CPU stop (for crash dump) interrupts",
 	[IPI_IRQ_WORK]		= "IRQ work interrupts",
 };
 
@@ -242,6 +269,64 @@ void smp_send_stop(void)
 			   cpumask_pr_args(cpu_online_mask));
 }
 
+#ifdef CONFIG_KEXEC_CORE
+/*
+ * The number of CPUs online, not counting this CPU (which may not be
+ * fully online and so not counted in num_online_cpus()).
+ */
+static inline unsigned int num_other_online_cpus(void)
+{
+        unsigned int this_cpu_online = cpu_online(smp_processor_id());
+
+        return num_online_cpus() - this_cpu_online;
+}
+
+void crash_smp_send_stop(void)
+{
+        static int cpus_stopped;
+        cpumask_t mask;
+        unsigned long timeout;
+
+        /*
+         * This function can be called twice in panic path, but obviously
+         * we execute this only once.
+         */
+        if (cpus_stopped)
+                return;
+
+        cpus_stopped = 1;
+
+        /*
+         * If this cpu is the only one alive at this point in time, online or
+         * not, there are no stop messages to be sent around, so just back out.
+         */
+        if (num_other_online_cpus() == 0)
+                return;
+
+        cpumask_copy(&mask, cpu_online_mask);
+        cpumask_clear_cpu(smp_processor_id(), &mask);
+
+        atomic_set(&waiting_for_crash_ipi, num_other_online_cpus());
+
+        pr_crit("SMP: stopping secondary CPUs\n");
+        send_ipi_mask(&mask, IPI_CPU_CRASH_STOP);
+
+        /* Wait up to ten seconds for other CPUs to stop */
+        timeout = USEC_PER_SEC * 10;
+        while ((atomic_read(&waiting_for_crash_ipi) > 0) && timeout--)
+                udelay(1);
+
+        if (atomic_read(&waiting_for_crash_ipi) > 0)
+                pr_warn("SMP: failed to stop secondary CPUs %*pbl\n",
+                        cpumask_pr_args(&mask));
+}
+
+bool smp_crash_stop_failed(void)
+{
+        return (atomic_read(&waiting_for_crash_ipi) > 0);
+}
+#endif
+
 void smp_send_reschedule(int cpu)
 {
 	send_ipi_single(cpu, IPI_RESCHEDULE);
diff --git a/arch/riscv/kernel/smpboot.c b/arch/riscv/kernel/smpboot.c
index 0b04e0eae..6c890cbdb 100644
--- a/arch/riscv/kernel/smpboot.c
+++ b/arch/riscv/kernel/smpboot.c
@@ -35,6 +35,7 @@
 #include "head.h"
 
 static DECLARE_COMPLETION(cpu_running);
+static struct cpumask cpu_delay_available_mask = { CPU_BITS_NONE };
 
 void __init smp_prepare_boot_cpu(void)
 {
@@ -87,6 +88,11 @@ void __init setup_smp(void)
 			break;
 		}
 
+		if (!of_device_is_available(dn))
+			pr_info("CPU with hartid=%d is not available\n", hart);
+		else
+			cpumask_set_cpu(cpuid, &cpu_delay_available_mask);
+
 		cpuid_to_hartid_map(cpuid) = hart;
 		cpuid++;
 	}
@@ -118,6 +124,11 @@ int __cpu_up(unsigned int cpu, struct task_struct *tidle)
 	int ret = 0;
 	tidle->thread_info.cpu = cpu;
 
+	if (!cpumask_test_cpu(cpu, &cpu_delay_available_mask)) {
+		cpumask_set_cpu(cpu, &cpu_delay_available_mask);
+		return -EIO;
+	}
+
 	ret = start_secondary_cpu(cpu, tidle);
 	if (!ret) {
 		wait_for_completion_timeout(&cpu_running,
diff --git a/arch/riscv/kernel/soft_vector/Makefile b/arch/riscv/kernel/soft_vector/Makefile
new file mode 100755
index 000000000..d0f8984c8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the RISC-V Linux kernel
+#
+obj-$(CONFIG_VECTOR_EMU)	+= softfloat/
+obj-$(CONFIG_VECTOR_EMU)	+= insns/
+obj-$(CONFIG_VECTOR_EMU)	+= decode.o
+
+clean:
diff --git a/arch/riscv/kernel/soft_vector/arch_riscv_kernel_soft_vector_generate b/arch/riscv/kernel/soft_vector/arch_riscv_kernel_soft_vector_generate
new file mode 100755
index 000000000..f32ebfc8a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/arch_riscv_kernel_soft_vector_generate
@@ -0,0 +1,485 @@
+#!/bin/bash
+function get_opcode() {
+      grep ^DECLARE_INSN.*\\\<$2\\\> $1 | sed 's/DECLARE_INSN(.*,\(.*\),.*)/\1/' | sed 's/ //';
+};
+
+insns=( 'vaadd_vi' \
+    'vaadd_vv' \
+    'vaadd_vx' \
+    'vadc_vim' \
+    'vadc_vvm' \
+    'vadc_vxm' \
+    'vadd_vi' \
+    'vadd_vv' \
+    'vadd_vx' \
+    'vand_vi' \
+    'vand_vv' \
+    'vand_vx' \
+    'vasub_vv' \
+    'vasub_vx' \
+    'vcompress_vm' \
+    'vdiv_vv' \
+    'vdiv_vx' \
+    'vdivu_vv' \
+    'vdivu_vx' \
+    'vdot_vv' \
+    'vdotu_vv' \
+    'vext_x_v' \
+    'vid_v' \
+    'viota_m' \
+    'vmacc_vv' \
+    'vmacc_vx' \
+    'vmadc_vim' \
+    'vmadc_vvm' \
+    'vmadc_vxm' \
+    'vmadd_vv' \
+    'vmadd_vx' \
+    'vmand_mm' \
+    'vmandnot_mm' \
+    'vmax_vv' \
+    'vmax_vx' \
+    'vmaxu_vv' \
+    'vmaxu_vx' \
+    'vmerge_vim' \
+    'vmerge_vvm' \
+    'vmerge_vxm' \
+    'vmfirst_m' \
+    'vmin_vv' \
+    'vmin_vx' \
+    'vminu_vv' \
+    'vminu_vx' \
+    'vmnand_mm' \
+    'vmnor_mm' \
+    'vmor_mm' \
+    'vmornot_mm' \
+    'vmpopc_m' \
+    'vmsbc_vvm' \
+    'vmsbc_vxm' \
+    'vmsbf_m' \
+    'vmseq_vi' \
+    'vmseq_vv' \
+    'vmseq_vx' \
+    'vmsgt_vi' \
+    'vmsgt_vx' \
+    'vmsgtu_vi' \
+    'vmsgtu_vx' \
+    'vmsif_m' \
+    'vmsle_vi' \
+    'vmsle_vv' \
+    'vmsle_vx' \
+    'vmsleu_vi' \
+    'vmsleu_vv' \
+    'vmsleu_vx' \
+    'vmslt_vv' \
+    'vmslt_vx' \
+    'vmsltu_vv' \
+    'vmsltu_vx' \
+    'vmsne_vi' \
+    'vmsne_vv' \
+    'vmsne_vx' \
+    'vmsof_m' \
+    'vmul_vv' \
+    'vmul_vx' \
+    'vmulh_vv' \
+    'vmulh_vx' \
+    'vmulhsu_vv' \
+    'vmulhsu_vx' \
+    'vmulhu_vv' \
+    'vmulhu_vx' \
+    'vmv_s_x' \
+    'vmv_v_i' \
+    'vmv_v_v' \
+    'vmv_v_x' \
+    'vmxnor_mm' \
+    'vmxor_mm' \
+    'vnclip_vi' \
+    'vnclip_vv' \
+    'vnclip_vx' \
+    'vnclipu_vi' \
+    'vnclipu_vv' \
+    'vnclipu_vx' \
+    'vnmsac_vv' \
+    'vnmsac_vx' \
+    'vnmsub_vv' \
+    'vnmsub_vx' \
+    'vnsra_vi' \
+    'vnsra_vv' \
+    'vnsra_vx' \
+    'vnsrl_vi' \
+    'vnsrl_vv' \
+    'vnsrl_vx' \
+    'vor_vi' \
+    'vor_vv' \
+    'vor_vx' \
+    'vredand_vs' \
+    'vredmax_vs' \
+    'vredmaxu_vs' \
+    'vredmin_vs' \
+    'vredminu_vs' \
+    'vredor_vs' \
+    'vredsum_vs' \
+    'vredxor_vs' \
+    'vrem_vv' \
+    'vrem_vx' \
+    'vremu_vv' \
+    'vremu_vx' \
+    'vrgather_vi' \
+    'vrgather_vv' \
+    'vrgather_vx' \
+    'vrsub_vi' \
+    'vrsub_vx' \
+    'vsadd_vi' \
+    'vsadd_vv' \
+    'vsadd_vx' \
+    'vsaddu_vi' \
+    'vsaddu_vv' \
+    'vsaddu_vx' \
+    'vsbc_vvm' \
+    'vsbc_vxm' \
+    'vslide1down_vx' \
+    'vslide1up_vx' \
+    'vslidedown_vi' \
+    'vslidedown_vx' \
+    'vslideup_vi' \
+    'vslideup_vx' \
+    'vsll_vi' \
+    'vsll_vv' \
+    'vsll_vx' \
+    'vsmul_vv' \
+    'vsmul_vx' \
+    'vsra_vi' \
+    'vsra_vv' \
+    'vsra_vx' \
+    'vsrl_vi' \
+    'vsrl_vv' \
+    'vsrl_vx' \
+    'vssra_vi' \
+    'vssra_vv' \
+    'vssra_vx' \
+    'vssrl_vi' \
+    'vssrl_vv' \
+    'vssrl_vx' \
+    'vssub_vv' \
+    'vssub_vx' \
+    'vssubu_vv' \
+    'vssubu_vx' \
+    'vsub_vv' \
+    'vsub_vx' \
+    'vwadd_vv' \
+    'vwadd_vx' \
+    'vwadd_wv' \
+    'vwadd_wx' \
+    'vwaddu_vv' \
+    'vwaddu_vx' \
+    'vwaddu_wv' \
+    'vwaddu_wx' \
+    'vwmacc_vv' \
+    'vwmacc_vx' \
+    'vwmaccsu_vv' \
+    'vwmaccsu_vx' \
+    'vwmaccu_vv' \
+    'vwmaccu_vx' \
+    'vwmaccus_vx' \
+    'vwmul_vv' \
+    'vwmul_vx' \
+    'vwmulsu_vv' \
+    'vwmulsu_vx' \
+    'vwmulu_vv' \
+    'vwmulu_vx' \
+    'vwredsum_vs' \
+    'vwredsumu_vs' \
+    'vwsmacc_vv' \
+    'vwsmacc_vx' \
+    'vwsmaccsu_vv' \
+    'vwsmaccsu_vx' \
+    'vwsmaccu_vv' \
+    'vwsmaccu_vx' \
+    'vwsmaccus_vx' \
+    'vwsub_vv' \
+    'vwsub_vx' \
+    'vwsub_wv' \
+    'vwsub_wx' \
+    'vwsubu_vv' \
+    'vwsubu_vx' \
+    'vwsubu_wv' \
+    'vwsubu_wx' \
+    'vxor_vi' \
+    'vxor_vv' \
+    'vxor_vx' \
+    'vfadd_vf' \
+    'vfadd_vv' \
+    'vfclass_v' \
+    'vfcvt_f_x_v' \
+    'vfcvt_f_xu_v' \
+    'vfcvt_x_f_v' \
+    'vfcvt_xu_f_v' \
+    'vfdiv_vf' \
+    'vfdiv_vv' \
+    'vfdot_vv' \
+    'vfmacc_vf' \
+    'vfmacc_vv' \
+    'vfmadd_vf' \
+    'vfmadd_vv' \
+    'vfmax_vf' \
+    'vfmax_vv' \
+    'vfmerge_vfm' \
+    'vfmin_vf' \
+    'vfmin_vv' \
+    'vfmsac_vf' \
+    'vfmsac_vv' \
+    'vfmsub_vf' \
+    'vfmsub_vv' \
+    'vfmul_vf' \
+    'vfmul_vv' \
+    'vfmv_f_s' \
+    'vfmv_s_f' \
+    'vfmv_v_f' \
+    'vfncvt_f_f_v' \
+    'vfncvt_f_x_v' \
+    'vfncvt_f_xu_v' \
+    'vfncvt_x_f_v' \
+    'vfncvt_xu_f_v' \
+    'vfnmacc_vf' \
+    'vfnmacc_vv' \
+    'vfnmadd_vf' \
+    'vfnmadd_vv' \
+    'vfnmsac_vf' \
+    'vfnmsac_vv' \
+    'vfnmsub_vf' \
+    'vfnmsub_vv' \
+    'vfrdiv_vf' \
+    'vfredmax_vs' \
+    'vfredmin_vs' \
+    'vfredosum_vs' \
+    'vfredsum_vs' \
+    'vfrsub_vf' \
+    'vfsgnj_vf' \
+    'vfsgnj_vv' \
+    'vfsgnjn_vf' \
+    'vfsgnjn_vv' \
+    'vfsgnjx_vf' \
+    'vfsgnjx_vv' \
+    'vfsqrt_v' \
+    'vfsub_vf' \
+    'vfsub_vv' \
+    'vfwadd_vf' \
+    'vfwadd_vv' \
+    'vfwadd_wf' \
+    'vfwadd_wv' \
+    'vfwcvt_f_f_v' \
+    'vfwcvt_f_x_v' \
+    'vfwcvt_f_xu_v' \
+    'vfwcvt_x_f_v' \
+    'vfwcvt_xu_f_v' \
+    'vfwmacc_vf' \
+    'vfwmacc_vv' \
+    'vfwmsac_vf' \
+    'vfwmsac_vv' \
+    'vfwmul_vf' \
+    'vfwmul_vv' \
+    'vfwnmacc_vf' \
+    'vfwnmacc_vv' \
+    'vfwnmsac_vf' \
+    'vfwnmsac_vv' \
+    'vfwredosum_vs' \
+    'vfwredsum_vs' \
+    'vfwsub_vf' \
+    'vfwsub_vv' \
+    'vfwsub_wf' \
+    'vfwsub_wv' \
+    'vmfeq_vf' \
+    'vmfeq_vv' \
+    'vmfge_vf' \
+    'vmfgt_vf' \
+    'vmfle_vf' \
+    'vmfle_vv' \
+    'vmflt_vf' \
+    'vmflt_vv' \
+    'vmfne_vf' \
+    'vmfne_vv' \
+    'vmford_vf' \
+    'vmford_vv' \
+    'vlb_v' \
+    'vlh_v' \
+    'vlw_v' \
+    'vle_v' \
+    'vlbu_v' \
+    'vlhu_v' \
+    'vlwu_v' \
+    'vlsb_v' \
+    'vlsh_v' \
+    'vlsw_v' \
+    'vlse_v' \
+    'vlxb_v' \
+    'vlxh_v' \
+    'vlxw_v' \
+    'vlxe_v' \
+    'vlsbu_v' \
+    'vlshu_v' \
+    'vlswu_v' \
+    'vlxbu_v' \
+    'vlxhu_v' \
+    'vlxwu_v' \
+    'vlbff_v' \
+    'vlhff_v' \
+    'vlwff_v' \
+    'vleff_v' \
+    'vlbuff_v' \
+    'vlhuff_v' \
+    'vlwuff_v' \
+    'vsb_v' \
+    'vsh_v' \
+    'vsw_v' \
+    'vse_v' \
+    'vssb_v' \
+    'vssh_v' \
+    'vssw_v' \
+    'vsse_v' \
+    'vsxb_v' \
+    'vsxh_v' \
+    'vsxw_v' \
+    'vsxe_v' \
+    'vsuxb_v' \
+    'vsuxh_v' \
+    'vsuxw_v' \
+    'vsuxe_v' \
+    'vsetvli' \
+    'vsetvl' \
+    'vamoaddd_v' \
+    'vamoandd_v' \ 
+    'vamomaxd_v' \
+    'vamomaxuw_v' \ 
+    'vamomind_v' \
+    'vamominuw_v' \
+    'vamoord_v' \
+    'vamoswapd_v' \
+    'vamoxord_v' \
+    'vamoaddw_v' \
+    'vamoandw_v' \
+    'vamomaxud_v' \
+    'vamomaxw_v' \
+    'vamominud_v' \
+    'vamominw_v' \
+    'vamoorw_v' \
+    'vamoswapw_v' \
+    'vamoxorw_v' \
+);
+f_insns=( 'fadd_s' \
+    'fclass_s' \
+    'fcvt_l_s' \
+    'fcvt_lu_s' \
+    'fcvt_s_l' \
+    'fcvt_s_lu' \
+    'fcvt_s_w' \
+    'fcvt_s_wu' \
+    'fcvt_w_s' \
+    'fcvt_wu_s' \
+    'fdiv_s' \
+    'feq_s' \
+    'fle_s' \
+    'flt_s' \
+    'flw' \
+    'fmadd_s' \
+    'fmax_s' \
+    'fmin_s' \
+    'fmsub_s' \
+    'fmul_s' \
+    'fmv_w_x' \
+    'fmv_x_w' \
+    'fnmadd_s' \
+    'fnmsub_s' \
+    'fsgnj_s' \
+    'fsgnjn_s' \
+    'fsgnjx_s' \
+    'fsqrt_s' \
+    'fsub_s' \
+    'fsw' \
+    'fadd_d' \
+    'fclass_d' \
+    'fcvt_d_l' \
+    'fcvt_d_lu' \
+    'fcvt_d_q' \
+    'fcvt_d_s' \
+    'fcvt_d_w' \
+    'fcvt_d_wu' \
+    'fcvt_l_d' \
+    'fcvt_lu_d' \
+    'fcvt_s_d' \
+    'fcvt_w_d' \
+    'fcvt_wu_d' \
+    'fdiv_d' \
+    'feq_d' \
+    'fld' \
+    'fle_d' \
+    'flt_d' \
+    'fmadd_d' \
+    'fmax_d' \
+    'fmin_d' \
+    'fmsub_d' \
+    'fmul_d' \
+    'fmv_d_x' \
+    'fmv_x_d' \
+    'fnmadd_d' \
+    'fnmsub_d' \
+    'fsd' \
+    'fsgnj_d' \
+    'fsgnjn_d' \
+    'fsgnjx_d' \
+    'fsqrt_d' \
+    'fsub_d' \
+    'fadd_q' \
+    'fclass_q' \
+    'fcvt_l_q' \
+    'fcvt_lu_q' \
+    'fcvt_q_d' \
+    'fcvt_q_l' \
+    'fcvt_q_lu' \
+    'fcvt_q_s' \
+    'fcvt_q_w' \
+    'fcvt_q_wu' \
+    'fcvt_s_q' \
+    'fcvt_w_q' \
+    'fcvt_wu_q' \
+    'fgidiv_q' \
+    'feq_q' \
+    'fle_q' \
+    'flq' \
+    'flt_q' \
+    'fmadd_q' \
+    'fmax_q' \
+    'fmin_q' \
+    'fmsub_q' \
+    'fmul_q' \
+    'fnmadd_q' \
+    'fnmsub_q' \
+    'fsgnj_q' \
+    'fsgnjn_q' \
+    'fsgnjx_q' \
+    'fsq' \
+    'fsqrt_q' \
+    'fsub_q' \
+);
+
+rm ./insns/*
+echo '/*generated by shell*/' > insn_list.h
+echo '# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the RISC-V Linux kernel
+#
+' > ./insns/Makefile
+for i in ${insns[@]}; do
+        if [ -f ./insns_func/$i.h ] ; then
+             match=$(get_opcode ./encoding.h $i)
+             #echo $i,'s/NAME/'$i'/g', $match,. 's/OPCODE/'$match'/', ./insns/$i.c
+             touch ./insns/$i.c
+             sed 's/NAME/'$i'/g' ./insn_template.c | sed 's/OPCODE/'$match'/g' >&./insns/$i.c
+             echo 'DEFINE_INSN('$i')' >> insn_list.h 
+             echo 'obj-$(CONFIG_VECTOR_EMU)    += '$i.o >> ./insns/Makefile
+        else
+        	echo 'not find', $i
+        fi
+done
+
+if [ -f ./insns/.c ]; then
+    rm ./insns/.c
+fi
diff --git a/arch/riscv/kernel/soft_vector/arith.h b/arch/riscv/kernel/soft_vector/arith.h
new file mode 100755
index 000000000..02b2c7de4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/arith.h
@@ -0,0 +1,75 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#ifndef _RISCV_ARITH_H
+#define _RISCV_ARITH_H
+
+inline uint64_t mulhu(uint64_t a, uint64_t b);
+
+inline int64_t mulh(int64_t a, int64_t b);
+
+inline int64_t mulhsu(int64_t a, uint64_t b);
+
+//ref:  https://locklessinc.com/articles/sat_arithmetic/
+#define sat_add(T, UT) \
+inline T sat_add_##T##_##UT(T x, T y, bool *sat);
+
+sat_add(int8_t, uint8_t)
+sat_add(int16_t, uint16_t)
+sat_add(int32_t, uint32_t)
+sat_add(int64_t, uint64_t)
+#undef sat_add
+
+#define sat_sub(T, UT) \
+inline T sat_sub_##T##_##UT(T x, T y, bool *sat);
+
+sat_sub(int8_t, uint8_t)
+sat_sub(int16_t, uint16_t)
+sat_sub(int32_t, uint32_t)
+sat_sub(int64_t, uint64_t)
+#undef sat_sub
+
+#define sat_addu(T) \
+T sat_addu_##T(T x, T y, bool *sat);
+
+sat_addu(uint8_t)
+sat_addu(uint16_t)
+sat_addu(uint32_t)
+sat_addu(uint64_t)
+#undef sat_addu
+
+#define sat_subu(T) \
+T sat_subu_##T(T x, T y, bool *sat);
+
+sat_subu(uint8_t)
+sat_subu(uint16_t)
+sat_subu(uint32_t)
+sat_subu(uint64_t)
+#undef sat_subu
+#endif
diff --git a/arch/riscv/kernel/soft_vector/decode.c b/arch/riscv/kernel/soft_vector/decode.c
new file mode 100755
index 000000000..f0a4f44d3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/decode.c
@@ -0,0 +1,601 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include <linux/uaccess.h>
+#include <asm/switch_to.h>
+#include <asm/csr.h>
+#include "riscv_decode.h"
+#include "arith.h"
+#define vector_elt(type) \
+        type * vector_elt_##type(vector_state* vector, reg_t vReg, reg_t n){ \
+          reg_t elts_per_reg;\
+          type *regStart;\
+          require(vector->vsew != 0); \
+          require((vector->VLEN >> 3)/sizeof(type) > 0); \
+          elts_per_reg = (vector->VLEN >> 3) / (sizeof(type)); \
+          vReg += n / elts_per_reg; \
+          n = n % elts_per_reg; \
+          regStart = (type*)((char*)vector->regs + vReg * (vector->VLEN >> 3)); \
+          return &regStart[n]; \
+        } \
+
+vector_elt(float32_t)
+vector_elt(float64_t)
+vector_elt(int8_t)
+vector_elt(int16_t)
+vector_elt(int32_t)
+vector_elt(int64_t)
+vector_elt(uint8_t)
+vector_elt(uint16_t)
+vector_elt(uint32_t)
+vector_elt(uint64_t)
+
+#define load_store(type) \
+      type##_t load_##type(reg_t addr) { \
+          type##_t tmp; \
+          type##_t __user *in; \
+          long err; \
+          in = (type##_t __user *)addr; \
+          err = __copy_from_user(&tmp, in , sizeof(type##_t)); \
+	      if (unlikely(err)) \
+		      panic("load memory error\n"); \
+          return tmp; \
+      } \
+      \
+      void store_##type(reg_t addr, type##_t val) { \
+          type##_t __user *out; \
+          long err; \
+          out = (type##_t __user *)addr; \
+          err = __copy_to_user(out, &val, sizeof(type##_t)); \
+	      if (unlikely(err)) \
+		      panic("store memory error\n"); \
+          return; \
+      } \
+      
+load_store(uint8)
+load_store(uint16)
+load_store(uint32)
+load_store(uint64)
+
+load_store(int8)
+load_store(int16)
+load_store(int32)
+load_store(int64)
+
+inline uint64_t x(insn_t b, int lo, int len) { return (b >> lo) & (((insn_bits_t)1 << len)-1); }
+inline uint64_t xs(insn_t b, int lo, int len) { return (int64_t)b << (64-lo-len) >> (64-len); }
+inline uint64_t imm_sign(insn_t b) { return xs(b, 63, 1); }
+inline int length(insn_t b) { return insn_length(b); }
+inline int64_t i_imm(insn_t b) { return (int64_t)b >> 20; }
+inline int64_t shamt(insn_t b) { return x(b, 20, 6); }
+inline int64_t s_imm(insn_t b) { return x(b, 7, 5) + (xs(b, 25, 7) << 5); }
+inline int64_t sb_imm(insn_t b) { return (x(b, 8, 4) << 1) + (x(b, 25,6) << 5) + (x(b, 7,1) << 11) + (imm_sign(b) << 12); }
+inline int64_t u_imm(insn_t b) { return (int64_t)b >> 12 << 12; }
+inline int64_t uj_imm(insn_t b) { return (x(b, 21, 10) << 1) + (x(b, 20, 1) << 11) + (x(b, 12, 8) << 12) + (imm_sign(b) << 20); }
+inline uint64_t rd(insn_t b) { return x(b, 7, 5); }
+inline uint64_t insn_rs1(insn_t b) { return x(b, 15, 5); }
+inline uint64_t rs2(insn_t b) { return x(b, 20, 5); }
+inline uint64_t rs3(insn_t b) { return x(b, 27, 5); }
+inline uint64_t rm(insn_t b) { return x(b, 12, 3); }
+inline uint64_t csr(insn_t b) { return x(b, 20, 12); }
+
+inline uint64_t v_vm(insn_t b) { return x(b, 25, 1); }
+inline uint64_t v_wd(insn_t b) { return x(b, 26, 1); }
+inline uint64_t v_nf(insn_t b) { return x(b, 29, 3); }
+inline uint64_t v_simm5(insn_t b) { return xs(b, 15, 5); }
+inline uint64_t v_zimm5(insn_t b) { return x(b, 15, 5); }
+inline uint64_t v_zimm11(insn_t b) { return x(b, 20, 11); }
+inline uint64_t v_lmul(insn_t b) { return 1 << x(b, 20, 2); }
+inline uint64_t v_sew(insn_t b) { return 1 << (x(b, 22, 3) + 3); }
+
+extern unsigned long elf_hwcap;
+bool supports_extension(processor_t * state, unsigned char ext) {
+  if (ext >= 'A' && ext <= 'Z')
+    return ((elf_hwcap >> (ext - 'A')) & 1);
+  return false;
+}
+
+int get_flen(processor_t * state) {
+    return supports_extension(state, 'Q') ? 128 :
+           supports_extension(state, 'D') ? 64 :
+           supports_extension(state, 'F') ? 32 : 0;
+}
+
+inline float128_t defaultNaNF128(void)
+{
+  float128_t nan;
+  nan.v[1] = defaultNaNF128UI64;
+  nan.v[0] = defaultNaNF128UI0;
+  return nan;
+}
+inline freg_t fsgnj128(freg_t a, freg_t b, bool n, bool x)
+{
+  a.v[1] = (a.v[1] & ~F64_SIGN) | (((x ? a.v[1] : n ? F64_SIGN : 0) ^ b.v[1]) & F64_SIGN);
+  return a;
+}
+inline freg_t f128_negate(freg_t a)
+{
+  a.v[1] ^= F64_SIGN;
+  return a;
+}
+
+inline float32_t f32(uint32_t v) { return (float32_t){v}; }
+inline float64_t f64(uint64_t v) { return (float64_t){v}; }
+inline float32_t f32_f(freg_t r) { return f32(unboxF32(r)); }
+inline float64_t f64_f(freg_t r) { return f64(unboxF64(r)); }
+inline float128_t f128(freg_t r) { return r; }
+inline freg_t freg32(float32_t f) { return (float128_t){{((uint64_t)-1 << 32) | f.v, (uint64_t)-1}};}
+inline freg_t freg64(float64_t f) { return (float128_t){{f.v, (uint64_t)-1}};}
+inline freg_t freg128(float128_t f) { return f; }
+
+inline int max_internal(int a, int b) {return a > b? a : b;}
+inline int min_internal(int a, int b) {return a > b? b : a;}
+
+inline bool is_overlaped(const int astart, const int asize,
+                                const int bstart, const int bsize)
+{
+  const int aend = astart + asize;
+  const int bend = bstart + bsize;
+  return max_internal(aend, bend) - min_internal(astart, bstart) < asize + bsize;
+}
+
+reg_t set_vl(vector_state *vector, uint64_t regId, reg_t reqVL, reg_t newType){
+  if (vector->vtype != newType){
+    vector->vtype = newType;
+    vector->vsew = 1 << (BITS(newType, 4, 2) + 3);
+    vector->vlmul = 1 << BITS(newType, 1, 0);
+    vector->vediv = 1 << BITS(newType, 6, 5);
+    vector->vlmax = vector->VLEN/vector->vsew * vector->vlmul;
+    vector->vmlen = vector->vsew / vector->vlmul;
+    vector->reg_mask = (NVPR-1) & ~(vector->vlmul-1);
+    vector->vill = false;
+  }
+  vector->vl = reqVL <= vector->vlmax ? (regId == 0)? vector->vlmax: reqVL : vector->vlmax;
+  vector->vstart = 0;
+  return vector->vl;
+}
+
+inline uint64_t mulhu(uint64_t a, uint64_t b)
+{
+  uint64_t t, a0, b0, a1, b1;
+  uint32_t y1, y2, y3;
+  a0 = (uint32_t)a;
+  a1 = a >> 32;
+  b0 = (uint32_t)b;
+  b1 = b >> 32;
+
+  t = a1*b0 + ((a0*b0) >> 32);
+  y1 = t;
+  y2 = t >> 32;
+
+  t = a0*b1 + y1;
+  y1 = t;
+
+  t = a1*b1 + y2 + (t >> 32);
+  y2 = t;
+  y3 = t >> 32;
+
+  return ((uint64_t)y3 << 32) | y2;
+}
+
+inline int64_t mulh(int64_t a, int64_t b)
+{
+  int negate;
+  uint64_t res;
+  negate  = (a < 0) != (b < 0);
+  res = mulhu(a < 0 ? -a : a, b < 0 ? -b : b);
+  return negate ? ~res + (a * b == 0) : res;
+}
+
+inline int64_t mulhsu(int64_t a, uint64_t b)
+{
+  int negate;
+  uint64_t res;
+  negate = a < 0;
+  res = mulhu(a < 0 ? -a : a, b);
+  return negate ? ~res + (a * b == 0) : res;
+}
+
+//ref:  https://locklessinc.com/articles/sat_arithmetic/
+#define sat_add(T, UT) \
+inline T sat_add_##T##_##UT(T x, T y, bool *sat) \
+{ \
+  UT ux, uy, res;\
+  int sh; \
+  ux = x; \
+  uy = y; \
+  res = ux + uy; \
+  *sat = false; \
+  sh = sizeof(T) * 8 - 1; \
+  \
+  /* Calculate overflowed result. (Don't change the sign bit of ux) */ \
+  ux = (ux >> sh) + (((UT)0x1 << sh) - 1); \
+  \
+  /* Force compiler to use cmovns instruction */ \
+  if ((T) ((ux ^ uy) | ~(uy ^ res)) >= 0) { \
+    res = ux; \
+    *sat = true; \
+  } \
+  \
+  return res; \
+}
+
+sat_add(int8_t, uint8_t)
+sat_add(int16_t, uint16_t)
+sat_add(int32_t, uint32_t)
+sat_add(int64_t, uint64_t)
+#undef sat_add
+
+#define sat_sub(T, UT) \
+inline T sat_sub_##T##_##UT(T x, T y, bool *sat) { \
+  UT ux, uy, res; \
+  int sh; \
+  ux = x; \
+  uy = y; \
+  res = ux - uy; \
+  *sat = false; \
+  sh  = sizeof(T) * 8 - 1; \
+  \
+  /* Calculate overflowed result. (Don't change the sign bit of ux) */ \
+  ux = (ux >> sh) + (((UT)0x1 << sh) - 1); \
+  \
+  /* Force compiler to use cmovns instruction */ \
+  if ((T) ((ux ^ uy) & (ux ^ res)) < 0) { \
+    res = ux; \
+    *sat = true; \
+  } \
+  \
+  return res; \
+}
+
+sat_sub(int8_t, uint8_t)
+sat_sub(int16_t, uint16_t)
+sat_sub(int32_t, uint32_t)
+sat_sub(int64_t, uint64_t)
+#undef sat_sub
+
+#define sat_addu(T) \
+T sat_addu_##T(T x, T y, bool *sat) { \
+  T res; \
+  res = x + y; \
+  *sat = false; \
+  \
+  *sat = res < x; \
+  res |= -(res < x); \
+  \
+  return res; \
+}
+
+sat_addu(uint8_t)
+sat_addu(uint16_t)
+sat_addu(uint32_t)
+sat_addu(uint64_t)
+#undef sat_addu
+
+#define sat_subu(T) \
+T sat_subu_##T(T x, T y, bool *sat) { \
+  T res; \
+  res = x - y; \
+  *sat = false; \
+  \
+  *sat = !(res <= x); \
+  res &= -(res <= x); \
+  \
+  return res; \
+}
+
+sat_subu(uint8_t)
+sat_subu(uint16_t)
+sat_subu(uint32_t)
+sat_subu(uint64_t)
+#undef sat_subu
+
+inline int get_xlen(void)
+{
+   return 64;// to fix
+}
+
+inline int get_max_xlen(void)
+{
+   return 64;//to fix
+}
+
+typedef reg_t (*insn_func_t)(processor_t* p, insn_t insn);
+typedef struct
+{
+  insn_bits_t match;
+  insn_bits_t mask;
+  insn_func_t rv32;
+  insn_func_t rv64;
+} insn_desc_t;
+#ifndef INSN_REG
+#define DECLARE_INSN(name, match, mask) \
+		{match, mask, rv32_##name, rv64_##name},
+insn_desc_t insts[] = {
+	#include "encoding.h"
+	{0,0, NULL, NULL}
+};
+#undef DECLARE_INSN
+#else
+insn_desc_t insts[1000];
+static int idx = 0;
+
+void register_insn( insn_bits_t match, insn_bits_t mask, insn_func_t rv32, insn_func_t rv64)
+{
+  insts[idx].match = match;
+  insts[idx].mask = mask;
+  insts[idx].rv32 = rv32;
+  insts[idx].rv64 = rv64;
+  idx++;
+}
+
+#define REGISTER_INSN(name, match, mask) \
+  register_insn(match, mask, rv32_##name, rv64_##name);
+
+void register_base_instructions(void)
+{
+  pr_info("register base %x, %d\n", insts, sizeof(insn_desc_t));
+  #define DECLARE_INSN(name, match, mask) \
+    insn_bits_t name##_match , name##_mask; \
+    name##_match = (match); \
+    name##_mask = (mask);
+  #include "encoding.h"
+  #undef DECLARE_INSN
+
+  #define DEFINE_INSN(name) \
+    REGISTER_INSN(name, name##_match, name##_mask)
+  #include "insn_list.h"
+  #undef DEFINE_INSN
+
+  register_insn(0, 0, NULL, NULL);
+  pr_info("idx: %d\n", idx);
+}
+#endif
+#define MAX_SEARCH_INSNS 100
+#define GCC_SUPPORT_VSETVL
+//#define GCC_SUPPORT_VSETVL
+//#define DEBUG_SOFT_VECTER
+int back_search_vsetvl(struct pt_regs *regs, processor_t *state, insn_t vinsn) {
+#ifdef GCC_SUPPORT_VSETVL
+    uint32_t insn;
+    uint32_t __user *in;
+    processor_t *p = state;
+    reg_t addr;
+	long err;
+	if (vinsn != 0x32002057) { //vmv.x.s	zero,v0
+		set_vl(VECTOR, current->thread.vsetvl_state.regid, current->thread.vsetvl_state.vl, current->thread.vsetvl_state.vtype);
+		return 1;
+	} else {
+		addr = regs->epc - 4;
+		in = (uint32_t __user *)addr;
+		err = __copy_from_user(&insn, in , sizeof(uint32_t));
+		if (unlikely(err)) { // cannot fetch insns
+			printk("cannot fetch vsetvl insn, default:use last vsetvl info\n");
+			set_vl(VECTOR, current->thread.vsetvl_state.regid, current->thread.vsetvl_state.vl, current->thread.vsetvl_state.vtype);
+			return 1;
+		}
+		if ((insn & MASK_VSETVLI) == MATCH_VSETVLI) {
+			WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, v_zimm11(insn)));
+			current->thread.vsetvl_state.last_vector_pc = regs->epc;
+			current->thread.vsetvl_state.regid = insn_rs1(insn);
+			current->thread.vsetvl_state.vl = VECTOR->vl;
+			current->thread.vsetvl_state.vtype = VECTOR->vtype;
+			return 1;
+		} else if((insn & MASK_VSETVL) == MATCH_VSETVL) {
+			WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, RS2));
+			current->thread.vsetvl_state.last_vector_pc = regs->epc;
+			current->thread.vsetvl_state.regid = insn_rs1(insn);
+			current->thread.vsetvl_state.vl = VECTOR->vl;
+			current->thread.vsetvl_state.vtype = VECTOR->vtype;
+			return 1;
+		} else {// possible c-ext insns
+			printk("cannot find vsetvl insn, default:use last vsetvl info\n");
+			set_vl(VECTOR, current->thread.vsetvl_state.regid, current->thread.vsetvl_state.vl, current->thread.vsetvl_state.vtype);
+			return 1;
+		}
+	}
+
+#else
+	reg_t addr;
+	uint8_t match = 0;
+	reg_t pos_list[MAX_SEARCH_INSNS];
+	uint8_t pos_list_insn[MAX_SEARCH_INSNS];
+	uint8_t pos_num;
+	uint8_t insn_count = 0;
+    uint32_t insn;
+    uint32_t __user *in;
+	long err;
+	processor_t* p = state;
+    pos_list[0] = regs->epc - 4;
+    pos_list_insn[0] = 0;
+    pos_num = 1;
+	do {
+		addr = pos_list[--pos_num];
+		insn_count = pos_list_insn[pos_num];
+		do { // search one insn per loop
+			if (addr == current->thread.vsetvl_state.last_vector_pc) {// match last setvl
+				set_vl(VECTOR, current->thread.vsetvl_state.regid, current->thread.vsetvl_state.vl, current->thread.vsetvl_state.vtype);
+				current->thread.vsetvl_state.last_vector_pc = regs->epc;
+				match = 1;
+				break;
+			}
+			in = (uint32_t __user *)addr;
+			err = __copy_from_user(&insn, in , sizeof(uint32_t));
+			if (unlikely(err)) // cannot fetch insns
+				break;
+			if((insn & 0x3) == 3) { // possible 32-bit insn
+				if ((insn & MASK_VSETVLI) == MATCH_VSETVLI) {
+					WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, v_zimm11(insn)));
+					current->thread.vsetvl_state.last_vector_pc = regs->epc;
+					current->thread.vsetvl_state.regid = insn_rs1(insn);
+					current->thread.vsetvl_state.vl = VECTOR->vl;
+					current->thread.vsetvl_state.vtype = VECTOR->vtype;
+					match = 1;
+					break;
+				} else if((insn & MASK_VSETVL) == MATCH_VSETVL) {
+					WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, RS2));
+					current->thread.vsetvl_state.last_vector_pc = regs->epc;
+					current->thread.vsetvl_state.regid = insn_rs1(insn);
+					current->thread.vsetvl_state.vl = VECTOR->vl;
+					current->thread.vsetvl_state.vtype = VECTOR->vtype;
+					match = 1;
+					break;
+				} else if (((insn >> 16) & 0x3) != 3) {// possible c-ext insns
+					pos_list[pos_num] =  addr - 4;
+					pos_list_insn[pos_num++] = insn_count + 1;
+					addr = addr - 2;
+					insn_count++;
+					continue;
+				}
+				insn_count++;
+				addr = addr - 4;
+			} else if (((insn >> 16) & 0x3) != 3) { // c-ext insn
+				addr = addr - 2;
+				insn_count++;
+				continue;
+			} else //illegal insn
+				break;
+		} while (insn_count < MAX_SEARCH_INSNS); //search 100 insns at most
+		if (match) {
+			break;
+		}
+	} while(pos_num > 0);
+	return match;
+#endif
+}
+
+int get_processor_state(struct pt_regs *regs, processor_t * state, insn_t insn) {
+  int i;
+#ifdef DEBUG_SOFT_VECTER
+  unsigned long *origin = (unsigned long *)&(regs->epc);
+#endif
+  state->pc = regs->epc;
+  state->XPR[0] = 0;
+  memcpy (&(state->XPR[1]), &(regs->ra), 31 * sizeof(unsigned long));
+  state->saved_a0 = state->XPR[10];
+  state->XPR[10] = regs->orig_a0;
+  state->mstatus = regs->status;
+  if (has_fpu) {
+	fstate_save(current, regs);
+    for (i = 0; i < 32; i++) {
+      state->FPR[i] = freg64(f64(current->thread.fstate.f[i]));
+      state->frm = (current->thread.fstate.fcsr >> 5) & 0x7;
+      state->fflags = (current->thread.fstate.fcsr & 0x1f);
+    }
+  }
+  if (has_vector) {
+	vstate_save(current, regs);
+    state->vector.VLEN = 128; //to fix
+    state->vector.ELEN = 64;  //to fix
+    state->vector.SLEN = 128;  //to fix
+    {
+		for (i = 0; i < 32; i++) {
+		  state->vector.regs[i] = current->thread.vstate.v[i];
+		}
+    }
+    state->vector.vstart = current->thread.vstate.vstart;
+    state->vector.vxrm = current->thread.vstate.vxrm;
+    state->vector.vxsat = current->thread.vstate.vxsat;
+	state->vector.vl = current->thread.vstate.vl;
+    state->vector.vtype = current->thread.vstate.vtype;
+    state->vector.vill = BITS(state->vector.vtype, (get_xlen() - 1), (get_xlen() - 1));
+    if (state->vector.vill != 0) {
+    	if (back_search_vsetvl(regs, state, insn) != 1) {
+    		printk("ERROR: cannot find related vsetvl\n");
+    		return 1;
+    	}
+    } else {
+		state->vector.vsew = 1 << (BITS(state->vector.vtype, 4, 2) + 3);
+		state->vector.vlmul = 1 << BITS(state->vector.vtype, 1, 0);
+		state->vector.vediv = 1 << BITS(state->vector.vtype, 6, 5);
+		state->vector.vlmax = state->vector.VLEN/state->vector.vsew * state->vector.vlmul;
+		state->vector.vmlen = state->vector.vsew / state->vector.vlmul;
+		state->vector.reg_mask = (NVPR-1) & ~(state->vector.vlmul-1);
+    }
+  }
+  return 0;
+}
+
+void restore_processor_state(struct pt_regs *regs, processor_t * state) {
+	int i;
+	memcpy (&(regs->ra), &(state->XPR[1]), 31 * sizeof(unsigned long));
+	if (state->XPR[10] == regs->orig_a0)
+		regs->a0 = state->saved_a0;
+	regs->status = state->mstatus;
+	if (has_fpu) {
+		for (i = 0; i < 32; i++) {
+			current->thread.fstate.f[i] = state->FPR[i].v[0];
+		}
+		current->thread.fstate.fcsr = (state->frm << 5) | state->fflags;
+		fstate_restore(current, regs);
+	}
+	if (has_vector) {
+		for (i = 0; i < 32; i++) {
+		   current->thread.vstate.v[i] = state->vector.regs[i];
+		}
+		current->thread.vstate.vstart = state->vector.vstart;
+		current->thread.vstate.vxrm = state->vector.vxrm;
+		current->thread.vstate.vxsat = state->vector.vxsat;
+		current->thread.vstate.vl = state->vector.vl;
+		current->thread.vstate.vtype = state->vector.vtype;
+	}
+	regs->epc = state->pc;
+	vstate_restore(current, regs);
+}
+
+bool decode_exec_insn(struct pt_regs *regs, insn_t insn)
+{
+	processor_t state;
+	insn_desc_t *p;
+	reg_t len;
+#ifdef INSN_REG
+	if (idx == 0) register_base_instructions();
+#endif
+	p = & insts[0];
+    if (get_processor_state(regs, &state, insn))
+    	return false;
+    if (insn == 0x32002057) {
+		state.pc += 4;
+		restore_processor_state(regs, &state);
+		return true;
+    }
+    while (p->rv64 && ((insn & p->mask) != p->match))
+    	p++;
+    if (p->rv64) {
+    	if ((len = p->rv64(&state, insn))) {
+    		state.pc += len;
+    		restore_processor_state(regs, &state);
+    		return true;
+    	}
+    	pr_info("exec insn fail %llx %lx\n", insn, regs->epc);
+   } else
+	    pr_info("decode insn %llx %lx fail\n", insn, regs->epc);
+
+   return false;
+}
diff --git a/arch/riscv/kernel/soft_vector/encoding.h b/arch/riscv/kernel/soft_vector/encoding.h
new file mode 100755
index 000000000..23bbe38eb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/encoding.h
@@ -0,0 +1,1451 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#ifndef RISCV_CSR_ENCODING_H
+#define RISCV_CSR_ENCODING_H
+
+#define MSTATUS_UIE         0x00000001
+#define MSTATUS_SIE         0x00000002
+#define MSTATUS_HIE         0x00000004
+#define MSTATUS_MIE         0x00000008
+#define MSTATUS_UPIE        0x00000010
+#define MSTATUS_SPIE        0x00000020
+#define MSTATUS_HPIE        0x00000040
+#define MSTATUS_MPIE        0x00000080
+#define MSTATUS_SPP         0x00000100
+#define MSTATUS_HPP         0x00000600
+#define MSTATUS_MPP         0x00001800
+#define MSTATUS_FS          0x00006000
+#define MSTATUS_XS          0x00018000
+#define MSTATUS_MPRV        0x00020000
+#define MSTATUS_SUM         0x00040000
+#define MSTATUS_MXR         0x00080000
+#define MSTATUS_TVM         0x00100000
+#define MSTATUS_TW          0x00200000
+#define MSTATUS_TSR         0x00400000
+#define MSTATUS32_SD        0x80000000
+#define MSTATUS_UXL         0x0000000300000000
+#define MSTATUS_SXL         0x0000000C00000000
+#define MSTATUS64_SD        0x8000000000000000
+
+#define SSTATUS_UIE         0x00000001
+#define SSTATUS_SIE         0x00000002
+#define SSTATUS_UPIE        0x00000010
+#define SSTATUS_SPIE        0x00000020
+#define SSTATUS_SPP         0x00000100
+#define SSTATUS_FS          0x00006000
+#define SSTATUS_XS          0x00018000
+#define SSTATUS_SUM         0x00040000
+#define SSTATUS_MXR         0x00080000
+#define SSTATUS32_SD        0x80000000
+#define SSTATUS_UXL         0x0000000300000000
+#define SSTATUS64_SD        0x8000000000000000
+#endif
+/* Automatically generated by parse-opcodes.  */
+#ifndef RISCV_ENCODING_H
+#define RISCV_ENCODING_H
+#define MATCH_VSETVLI 0x7057
+#define MASK_VSETVLI  0x8000707f
+#define MATCH_VSETVL 0x80007057
+#define MASK_VSETVL  0xfe00707f
+#define MATCH_VLB_V 0x10000007
+#define MASK_VLB_V  0x1df0707f
+#define MATCH_VLH_V 0x10005007
+#define MASK_VLH_V  0x1df0707f
+#define MATCH_VLW_V 0x10006007
+#define MASK_VLW_V  0x1df0707f
+#define MATCH_VLE_V 0x7007
+#define MASK_VLE_V  0x1df0707f
+#define MATCH_VLBU_V 0x7
+#define MASK_VLBU_V  0x1df0707f
+#define MATCH_VLHU_V 0x5007
+#define MASK_VLHU_V  0x1df0707f
+#define MATCH_VLWU_V 0x6007
+#define MASK_VLWU_V  0x1df0707f
+#define MATCH_VSB_V 0x27
+#define MASK_VSB_V  0x1df0707f
+#define MATCH_VSH_V 0x5027
+#define MASK_VSH_V  0x1df0707f
+#define MATCH_VSW_V 0x6027
+#define MASK_VSW_V  0x1df0707f
+#define MATCH_VSE_V 0x7027
+#define MASK_VSE_V  0x1df0707f
+#define MATCH_VLSB_V 0x18000007
+#define MASK_VLSB_V  0x1c00707f
+#define MATCH_VLSH_V 0x18005007
+#define MASK_VLSH_V  0x1c00707f
+#define MATCH_VLSW_V 0x18006007
+#define MASK_VLSW_V  0x1c00707f
+#define MATCH_VLSE_V 0x8007007
+#define MASK_VLSE_V  0x1c00707f
+#define MATCH_VLSBU_V 0x8000007
+#define MASK_VLSBU_V  0x1c00707f
+#define MATCH_VLSHU_V 0x8005007
+#define MASK_VLSHU_V  0x1c00707f
+#define MATCH_VLSWU_V 0x8006007
+#define MASK_VLSWU_V  0x1c00707f
+#define MATCH_VSSB_V 0x8000027
+#define MASK_VSSB_V  0x1c00707f
+#define MATCH_VSSH_V 0x8005027
+#define MASK_VSSH_V  0x1c00707f
+#define MATCH_VSSW_V 0x8006027
+#define MASK_VSSW_V  0x1c00707f
+#define MATCH_VSSE_V 0x8007027
+#define MASK_VSSE_V  0x1c00707f
+#define MATCH_VLXB_V 0x1c000007
+#define MASK_VLXB_V  0x1c00707f
+#define MATCH_VLXH_V 0x1c005007
+#define MASK_VLXH_V  0x1c00707f
+#define MATCH_VLXW_V 0x1c006007
+#define MASK_VLXW_V  0x1c00707f
+#define MATCH_VLXE_V 0xc007007
+#define MASK_VLXE_V  0x1c00707f
+#define MATCH_VLXBU_V 0xc000007
+#define MASK_VLXBU_V  0x1c00707f
+#define MATCH_VLXHU_V 0xc005007
+#define MASK_VLXHU_V  0x1c00707f
+#define MATCH_VLXWU_V 0xc006007
+#define MASK_VLXWU_V  0x1c00707f
+#define MATCH_VSXB_V 0xc000027
+#define MASK_VSXB_V  0x1c00707f
+#define MATCH_VSXH_V 0xc005027
+#define MASK_VSXH_V  0x1c00707f
+#define MATCH_VSXW_V 0xc006027
+#define MASK_VSXW_V  0x1c00707f
+#define MATCH_VSXE_V 0xc007027
+#define MASK_VSXE_V  0x1c00707f
+#define MATCH_VSUXB_V 0x1c000027
+#define MASK_VSUXB_V  0xfc00707f
+#define MATCH_VSUXH_V 0x1c005027
+#define MASK_VSUXH_V  0xfc00707f
+#define MATCH_VSUXW_V 0x1c006027
+#define MASK_VSUXW_V  0xfc00707f
+#define MATCH_VSUXE_V 0x1c007027
+#define MASK_VSUXE_V  0xfc00707f
+#define MATCH_VLBFF_V 0x11000007
+#define MASK_VLBFF_V  0x1df0707f
+#define MATCH_VLHFF_V 0x11005007
+#define MASK_VLHFF_V  0x1df0707f
+#define MATCH_VLWFF_V 0x11006007
+#define MASK_VLWFF_V  0x1df0707f
+#define MATCH_VLEFF_V 0x1007007
+#define MASK_VLEFF_V  0x1df0707f
+#define MATCH_VLBUFF_V 0x1000007
+#define MASK_VLBUFF_V  0x1df0707f
+#define MATCH_VLHUFF_V 0x1005007
+#define MASK_VLHUFF_V  0x1df0707f
+#define MATCH_VLWUFF_V 0x1006007
+#define MASK_VLWUFF_V  0x1df0707f
+#define MATCH_VFADD_VF 0x5057
+#define MASK_VFADD_VF  0xfc00707f
+#define MATCH_VFSUB_VF 0x8005057
+#define MASK_VFSUB_VF  0xfc00707f
+#define MATCH_VFMIN_VF 0x10005057
+#define MASK_VFMIN_VF  0xfc00707f
+#define MATCH_VFMAX_VF 0x18005057
+#define MASK_VFMAX_VF  0xfc00707f
+#define MATCH_VFSGNJ_VF 0x20005057
+#define MASK_VFSGNJ_VF  0xfc00707f
+#define MATCH_VFSGNJN_VF 0x24005057
+#define MASK_VFSGNJN_VF  0xfc00707f
+#define MATCH_VFSGNJX_VF 0x28005057
+#define MASK_VFSGNJX_VF  0xfc00707f
+#define MATCH_VFMV_S_F 0x36005057
+#define MASK_VFMV_S_F  0xfff0707f
+#define MATCH_VFMERGE_VFM 0x5c005057
+#define MASK_VFMERGE_VFM  0xfe00707f
+#define MATCH_VFMV_V_F 0x5e005057
+#define MASK_VFMV_V_F  0xfff0707f
+#define MATCH_VMFEQ_VF 0x60005057
+#define MASK_VMFEQ_VF  0xfc00707f
+#define MATCH_VMFLE_VF 0x64005057
+#define MASK_VMFLE_VF  0xfc00707f
+#define MATCH_VMFORD_VF 0x68005057
+#define MASK_VMFORD_VF  0xfc00707f
+#define MATCH_VMFLT_VF 0x6c005057
+#define MASK_VMFLT_VF  0xfc00707f
+#define MATCH_VMFNE_VF 0x70005057
+#define MASK_VMFNE_VF  0xfc00707f
+#define MATCH_VMFGT_VF 0x74005057
+#define MASK_VMFGT_VF  0xfc00707f
+#define MATCH_VMFGE_VF 0x7c005057
+#define MASK_VMFGE_VF  0xfc00707f
+#define MATCH_VFDIV_VF 0x80005057
+#define MASK_VFDIV_VF  0xfc00707f
+#define MATCH_VFRDIV_VF 0x84005057
+#define MASK_VFRDIV_VF  0xfc00707f
+#define MATCH_VFMUL_VF 0x90005057
+#define MASK_VFMUL_VF  0xfc00707f
+#define MATCH_VFRSUB_VF 0x9c005057
+#define MASK_VFRSUB_VF  0xfc00707f
+#define MATCH_VFMADD_VF 0xa0005057
+#define MASK_VFMADD_VF  0xfc00707f
+#define MATCH_VFNMADD_VF 0xa4005057
+#define MASK_VFNMADD_VF  0xfc00707f
+#define MATCH_VFMSUB_VF 0xa8005057
+#define MASK_VFMSUB_VF  0xfc00707f
+#define MATCH_VFNMSUB_VF 0xac005057
+#define MASK_VFNMSUB_VF  0xfc00707f
+#define MATCH_VFMACC_VF 0xb0005057
+#define MASK_VFMACC_VF  0xfc00707f
+#define MATCH_VFNMACC_VF 0xb4005057
+#define MASK_VFNMACC_VF  0xfc00707f
+#define MATCH_VFMSAC_VF 0xb8005057
+#define MASK_VFMSAC_VF  0xfc00707f
+#define MATCH_VFNMSAC_VF 0xbc005057
+#define MASK_VFNMSAC_VF  0xfc00707f
+#define MATCH_VFWADD_VF 0xc0005057
+#define MASK_VFWADD_VF  0xfc00707f
+#define MATCH_VFWSUB_VF 0xc8005057
+#define MASK_VFWSUB_VF  0xfc00707f
+#define MATCH_VFWADD_WF 0xd0005057
+#define MASK_VFWADD_WF  0xfc00707f
+#define MATCH_VFWSUB_WF 0xd8005057
+#define MASK_VFWSUB_WF  0xfc00707f
+#define MATCH_VFWMUL_VF 0xe0005057
+#define MASK_VFWMUL_VF  0xfc00707f
+#define MATCH_VFWMACC_VF 0xf0005057
+#define MASK_VFWMACC_VF  0xfc00707f
+#define MATCH_VFWNMACC_VF 0xf4005057
+#define MASK_VFWNMACC_VF  0xfc00707f
+#define MATCH_VFWMSAC_VF 0xf8005057
+#define MASK_VFWMSAC_VF  0xfc00707f
+#define MATCH_VFWNMSAC_VF 0xfc005057
+#define MASK_VFWNMSAC_VF  0xfc00707f
+#define MATCH_VFADD_VV 0x1057
+#define MASK_VFADD_VV  0xfc00707f
+#define MATCH_VFREDSUM_VS 0x4001057
+#define MASK_VFREDSUM_VS  0xfc00707f
+#define MATCH_VFSUB_VV 0x8001057
+#define MASK_VFSUB_VV  0xfc00707f
+#define MATCH_VFREDOSUM_VS 0xc001057
+#define MASK_VFREDOSUM_VS  0xfc00707f
+#define MATCH_VFMIN_VV 0x10001057
+#define MASK_VFMIN_VV  0xfc00707f
+#define MATCH_VFREDMIN_VS 0x14001057
+#define MASK_VFREDMIN_VS  0xfc00707f
+#define MATCH_VFMAX_VV 0x18001057
+#define MASK_VFMAX_VV  0xfc00707f
+#define MATCH_VFREDMAX_VS 0x1c001057
+#define MASK_VFREDMAX_VS  0xfc00707f
+#define MATCH_VFSGNJ_VV 0x20001057
+#define MASK_VFSGNJ_VV  0xfc00707f
+#define MATCH_VFSGNJN_VV 0x24001057
+#define MASK_VFSGNJN_VV  0xfc00707f
+#define MATCH_VFSGNJX_VV 0x28001057
+#define MASK_VFSGNJX_VV  0xfc00707f
+#define MATCH_VFMV_F_S 0x32001057
+#define MASK_VFMV_F_S  0xfe0ff07f
+#define MATCH_VMFEQ_VV 0x60001057
+#define MASK_VMFEQ_VV  0xfc00707f
+#define MATCH_VMFLE_VV 0x64001057
+#define MASK_VMFLE_VV  0xfc00707f
+#define MATCH_VMFORD_VV 0x68001057
+#define MASK_VMFORD_VV  0xfc00707f
+#define MATCH_VMFLT_VV 0x6c001057
+#define MASK_VMFLT_VV  0xfc00707f
+#define MATCH_VMFNE_VV 0x70001057
+#define MASK_VMFNE_VV  0xfc00707f
+#define MATCH_VFDIV_VV 0x80001057
+#define MASK_VFDIV_VV  0xfc00707f
+#define MATCH_VFMUL_VV 0x90001057
+#define MASK_VFMUL_VV  0xfc00707f
+#define MATCH_VFMADD_VV 0xa0001057
+#define MASK_VFMADD_VV  0xfc00707f
+#define MATCH_VFNMADD_VV 0xa4001057
+#define MASK_VFNMADD_VV  0xfc00707f
+#define MATCH_VFMSUB_VV 0xa8001057
+#define MASK_VFMSUB_VV  0xfc00707f
+#define MATCH_VFNMSUB_VV 0xac001057
+#define MASK_VFNMSUB_VV  0xfc00707f
+#define MATCH_VFMACC_VV 0xb0001057
+#define MASK_VFMACC_VV  0xfc00707f
+#define MATCH_VFNMACC_VV 0xb4001057
+#define MASK_VFNMACC_VV  0xfc00707f
+#define MATCH_VFMSAC_VV 0xb8001057
+#define MASK_VFMSAC_VV  0xfc00707f
+#define MATCH_VFNMSAC_VV 0xbc001057
+#define MASK_VFNMSAC_VV  0xfc00707f
+#define MATCH_VFCVT_XU_F_V 0x88001057
+#define MASK_VFCVT_XU_F_V  0xfc0ff07f
+#define MATCH_VFCVT_X_F_V 0x88009057
+#define MASK_VFCVT_X_F_V  0xfc0ff07f
+#define MATCH_VFCVT_F_XU_V 0x88011057
+#define MASK_VFCVT_F_XU_V  0xfc0ff07f
+#define MATCH_VFCVT_F_X_V 0x88019057
+#define MASK_VFCVT_F_X_V  0xfc0ff07f
+#define MATCH_VFWCVT_XU_F_V 0x88041057
+#define MASK_VFWCVT_XU_F_V  0xfc0ff07f
+#define MATCH_VFWCVT_X_F_V 0x88049057
+#define MASK_VFWCVT_X_F_V  0xfc0ff07f
+#define MATCH_VFWCVT_F_XU_V 0x88051057
+#define MASK_VFWCVT_F_XU_V  0xfc0ff07f
+#define MATCH_VFWCVT_F_X_V 0x88059057
+#define MASK_VFWCVT_F_X_V  0xfc0ff07f
+#define MATCH_VFWCVT_F_F_V 0x88061057
+#define MASK_VFWCVT_F_F_V  0xfc0ff07f
+#define MATCH_VFNCVT_XU_F_V 0x88081057
+#define MASK_VFNCVT_XU_F_V  0xfc0ff07f
+#define MATCH_VFNCVT_X_F_V 0x88089057
+#define MASK_VFNCVT_X_F_V  0xfc0ff07f
+#define MATCH_VFNCVT_F_XU_V 0x88091057
+#define MASK_VFNCVT_F_XU_V  0xfc0ff07f
+#define MATCH_VFNCVT_F_X_V 0x88099057
+#define MASK_VFNCVT_F_X_V  0xfc0ff07f
+#define MATCH_VFNCVT_F_F_V 0x880a1057
+#define MASK_VFNCVT_F_F_V  0xfc0ff07f
+#define MATCH_VFSQRT_V 0x8c001057
+#define MASK_VFSQRT_V  0xfc0ff07f
+#define MATCH_VFCLASS_V 0x8c081057
+#define MASK_VFCLASS_V  0xfc0ff07f
+#define MATCH_VFWADD_VV 0xc0001057
+#define MASK_VFWADD_VV  0xfc00707f
+#define MATCH_VFWREDSUM_VS 0xc4001057
+#define MASK_VFWREDSUM_VS  0xfc00707f
+#define MATCH_VFWSUB_VV 0xc8001057
+#define MASK_VFWSUB_VV  0xfc00707f
+#define MATCH_VFWREDOSUM_VS 0xcc001057
+#define MASK_VFWREDOSUM_VS  0xfc00707f
+#define MATCH_VFWADD_WV 0xd0001057
+#define MASK_VFWADD_WV  0xfc00707f
+#define MATCH_VFWSUB_WV 0xd8001057
+#define MASK_VFWSUB_WV  0xfc00707f
+#define MATCH_VFWMUL_VV 0xe0001057
+#define MASK_VFWMUL_VV  0xfc00707f
+#define MATCH_VFDOT_VV 0xe4001057
+#define MASK_VFDOT_VV  0xfc00707f
+#define MATCH_VFWMACC_VV 0xf0001057
+#define MASK_VFWMACC_VV  0xfc00707f
+#define MATCH_VFWNMACC_VV 0xf4001057
+#define MASK_VFWNMACC_VV  0xfc00707f
+#define MATCH_VFWMSAC_VV 0xf8001057
+#define MASK_VFWMSAC_VV  0xfc00707f
+#define MATCH_VFWNMSAC_VV 0xfc001057
+#define MASK_VFWNMSAC_VV  0xfc00707f
+#define MATCH_VADD_VX 0x4057
+#define MASK_VADD_VX  0xfc00707f
+#define MATCH_VSUB_VX 0x8004057
+#define MASK_VSUB_VX  0xfc00707f
+#define MATCH_VRSUB_VX 0xc004057
+#define MASK_VRSUB_VX  0xfc00707f
+#define MATCH_VMINU_VX 0x10004057
+#define MASK_VMINU_VX  0xfc00707f
+#define MATCH_VMIN_VX 0x14004057
+#define MASK_VMIN_VX  0xfc00707f
+#define MATCH_VMAXU_VX 0x18004057
+#define MASK_VMAXU_VX  0xfc00707f
+#define MATCH_VMAX_VX 0x1c004057
+#define MASK_VMAX_VX  0xfc00707f
+#define MATCH_VAND_VX 0x24004057
+#define MASK_VAND_VX  0xfc00707f
+#define MATCH_VOR_VX 0x28004057
+#define MASK_VOR_VX  0xfc00707f
+#define MATCH_VXOR_VX 0x2c004057
+#define MASK_VXOR_VX  0xfc00707f
+#define MATCH_VRGATHER_VX 0x30004057
+#define MASK_VRGATHER_VX  0xfc00707f
+#define MATCH_VSLIDEUP_VX 0x38004057
+#define MASK_VSLIDEUP_VX  0xfc00707f
+#define MATCH_VSLIDEDOWN_VX 0x3c004057
+#define MASK_VSLIDEDOWN_VX  0xfc00707f
+#define MATCH_VADC_VXM 0x42004057
+#define MASK_VADC_VXM  0xfe00707f
+#define MATCH_VMADC_VXM 0x46004057
+#define MASK_VMADC_VXM  0xfe00707f
+#define MATCH_VSBC_VXM 0x4a004057
+#define MASK_VSBC_VXM  0xfe00707f
+#define MATCH_VMSBC_VXM 0x4e004057
+#define MASK_VMSBC_VXM  0xfe00707f
+#define MATCH_VMERGE_VXM 0x5c004057
+#define MASK_VMERGE_VXM  0xfe00707f
+#define MATCH_VMV_V_X 0x5e004057
+#define MASK_VMV_V_X  0xfff0707f
+#define MATCH_VMSEQ_VX 0x60004057
+#define MASK_VMSEQ_VX  0xfc00707f
+#define MATCH_VMSNE_VX 0x64004057
+#define MASK_VMSNE_VX  0xfc00707f
+#define MATCH_VMSLTU_VX 0x68004057
+#define MASK_VMSLTU_VX  0xfc00707f
+#define MATCH_VMSLT_VX 0x6c004057
+#define MASK_VMSLT_VX  0xfc00707f
+#define MATCH_VMSLEU_VX 0x70004057
+#define MASK_VMSLEU_VX  0xfc00707f
+#define MATCH_VMSLE_VX 0x74004057
+#define MASK_VMSLE_VX  0xfc00707f
+#define MATCH_VMSGTU_VX 0x78004057
+#define MASK_VMSGTU_VX  0xfc00707f
+#define MATCH_VMSGT_VX 0x7c004057
+#define MASK_VMSGT_VX  0xfc00707f
+#define MATCH_VSADDU_VX 0x80004057
+#define MASK_VSADDU_VX  0xfc00707f
+#define MATCH_VSADD_VX 0x84004057
+#define MASK_VSADD_VX  0xfc00707f
+#define MATCH_VSSUBU_VX 0x88004057
+#define MASK_VSSUBU_VX  0xfc00707f
+#define MATCH_VSSUB_VX 0x8c004057
+#define MASK_VSSUB_VX  0xfc00707f
+#define MATCH_VAADD_VX 0x90004057
+#define MASK_VAADD_VX  0xfc00707f
+#define MATCH_VSLL_VX 0x94004057
+#define MASK_VSLL_VX  0xfc00707f
+#define MATCH_VASUB_VX 0x98004057
+#define MASK_VASUB_VX  0xfc00707f
+#define MATCH_VSMUL_VX 0x9c004057
+#define MASK_VSMUL_VX  0xfc00707f
+#define MATCH_VSRL_VX 0xa0004057
+#define MASK_VSRL_VX  0xfc00707f
+#define MATCH_VSRA_VX 0xa4004057
+#define MASK_VSRA_VX  0xfc00707f
+#define MATCH_VSSRL_VX 0xa8004057
+#define MASK_VSSRL_VX  0xfc00707f
+#define MATCH_VSSRA_VX 0xac004057
+#define MASK_VSSRA_VX  0xfc00707f
+#define MATCH_VNSRL_VX 0xb0004057
+#define MASK_VNSRL_VX  0xfc00707f
+#define MATCH_VNSRA_VX 0xb4004057
+#define MASK_VNSRA_VX  0xfc00707f
+#define MATCH_VNCLIPU_VX 0xb8004057
+#define MASK_VNCLIPU_VX  0xfc00707f
+#define MATCH_VNCLIP_VX 0xbc004057
+#define MASK_VNCLIP_VX  0xfc00707f
+#define MATCH_VWSMACCU_VX 0xf0004057
+#define MASK_VWSMACCU_VX  0xfc00707f
+#define MATCH_VWSMACC_VX 0xf4004057
+#define MASK_VWSMACC_VX  0xfc00707f
+#define MATCH_VWSMACCSU_VX 0xf8004057
+#define MASK_VWSMACCSU_VX  0xfc00707f
+#define MATCH_VWSMACCUS_VX 0xfc004057
+#define MASK_VWSMACCUS_VX  0xfc00707f
+#define MATCH_VADD_VV 0x57
+#define MASK_VADD_VV  0xfc00707f
+#define MATCH_VSUB_VV 0x8000057
+#define MASK_VSUB_VV  0xfc00707f
+#define MATCH_VMINU_VV 0x10000057
+#define MASK_VMINU_VV  0xfc00707f
+#define MATCH_VMIN_VV 0x14000057
+#define MASK_VMIN_VV  0xfc00707f
+#define MATCH_VMAXU_VV 0x18000057
+#define MASK_VMAXU_VV  0xfc00707f
+#define MATCH_VMAX_VV 0x1c000057
+#define MASK_VMAX_VV  0xfc00707f
+#define MATCH_VAND_VV 0x24000057
+#define MASK_VAND_VV  0xfc00707f
+#define MATCH_VOR_VV 0x28000057
+#define MASK_VOR_VV  0xfc00707f
+#define MATCH_VXOR_VV 0x2c000057
+#define MASK_VXOR_VV  0xfc00707f
+#define MATCH_VRGATHER_VV 0x30000057
+#define MASK_VRGATHER_VV  0xfc00707f
+#define MATCH_VADC_VVM 0x42000057
+#define MASK_VADC_VVM  0xfe00707f
+#define MATCH_VMADC_VVM 0x46000057
+#define MASK_VMADC_VVM  0xfe00707f
+#define MATCH_VSBC_VVM 0x4a000057
+#define MASK_VSBC_VVM  0xfe00707f
+#define MATCH_VMSBC_VVM 0x4e000057
+#define MASK_VMSBC_VVM  0xfe00707f
+#define MATCH_VMERGE_VVM 0x5c000057
+#define MASK_VMERGE_VVM  0xfe00707f
+#define MATCH_VMV_V_V 0x5e000057
+#define MASK_VMV_V_V  0xfff0707f
+#define MATCH_VMSEQ_VV 0x60000057
+#define MASK_VMSEQ_VV  0xfc00707f
+#define MATCH_VMSNE_VV 0x64000057
+#define MASK_VMSNE_VV  0xfc00707f
+#define MATCH_VMSLTU_VV 0x68000057
+#define MASK_VMSLTU_VV  0xfc00707f
+#define MATCH_VMSLT_VV 0x6c000057
+#define MASK_VMSLT_VV  0xfc00707f
+#define MATCH_VMSLEU_VV 0x70000057
+#define MASK_VMSLEU_VV  0xfc00707f
+#define MATCH_VMSLE_VV 0x74000057
+#define MASK_VMSLE_VV  0xfc00707f
+#define MATCH_VSADDU_VV 0x80000057
+#define MASK_VSADDU_VV  0xfc00707f
+#define MATCH_VSADD_VV 0x84000057
+#define MASK_VSADD_VV  0xfc00707f
+#define MATCH_VSSUBU_VV 0x88000057
+#define MASK_VSSUBU_VV  0xfc00707f
+#define MATCH_VSSUB_VV 0x8c000057
+#define MASK_VSSUB_VV  0xfc00707f
+#define MATCH_VAADD_VV 0x90000057
+#define MASK_VAADD_VV  0xfc00707f
+#define MATCH_VSLL_VV 0x94000057
+#define MASK_VSLL_VV  0xfc00707f
+#define MATCH_VASUB_VV 0x98000057
+#define MASK_VASUB_VV  0xfc00707f
+#define MATCH_VSMUL_VV 0x9c000057
+#define MASK_VSMUL_VV  0xfc00707f
+#define MATCH_VSRL_VV 0xa0000057
+#define MASK_VSRL_VV  0xfc00707f
+#define MATCH_VSRA_VV 0xa4000057
+#define MASK_VSRA_VV  0xfc00707f
+#define MATCH_VSSRL_VV 0xa8000057
+#define MASK_VSSRL_VV  0xfc00707f
+#define MATCH_VSSRA_VV 0xac000057
+#define MASK_VSSRA_VV  0xfc00707f
+#define MATCH_VNSRL_VV 0xb0000057
+#define MASK_VNSRL_VV  0xfc00707f
+#define MATCH_VNSRA_VV 0xb4000057
+#define MASK_VNSRA_VV  0xfc00707f
+#define MATCH_VNCLIPU_VV 0xb8000057
+#define MASK_VNCLIPU_VV  0xfc00707f
+#define MATCH_VNCLIP_VV 0xbc000057
+#define MASK_VNCLIP_VV  0xfc00707f
+#define MATCH_VWREDSUMU_VS 0xc0000057
+#define MASK_VWREDSUMU_VS  0xfc00707f
+#define MATCH_VWREDSUM_VS 0xc4000057
+#define MASK_VWREDSUM_VS  0xfc00707f
+#define MATCH_VDOTU_VV 0xe0000057
+#define MASK_VDOTU_VV  0xfc00707f
+#define MATCH_VDOT_VV 0xe4000057
+#define MASK_VDOT_VV  0xfc00707f
+#define MATCH_VWSMACCU_VV 0xf0000057
+#define MASK_VWSMACCU_VV  0xfc00707f
+#define MATCH_VWSMACC_VV 0xf4000057
+#define MASK_VWSMACC_VV  0xfc00707f
+#define MATCH_VWSMACCSU_VV 0xf8000057
+#define MASK_VWSMACCSU_VV  0xfc00707f
+#define MATCH_VADD_VI 0x3057
+#define MASK_VADD_VI  0xfc00707f
+#define MATCH_VRSUB_VI 0xc003057
+#define MASK_VRSUB_VI  0xfc00707f
+#define MATCH_VAND_VI 0x24003057
+#define MASK_VAND_VI  0xfc00707f
+#define MATCH_VOR_VI 0x28003057
+#define MASK_VOR_VI  0xfc00707f
+#define MATCH_VXOR_VI 0x2c003057
+#define MASK_VXOR_VI  0xfc00707f
+#define MATCH_VRGATHER_VI 0x30003057
+#define MASK_VRGATHER_VI  0xfc00707f
+#define MATCH_VSLIDEUP_VI 0x38003057
+#define MASK_VSLIDEUP_VI  0xfc00707f
+#define MATCH_VSLIDEDOWN_VI 0x3c003057
+#define MASK_VSLIDEDOWN_VI  0xfc00707f
+#define MATCH_VADC_VIM 0x42003057
+#define MASK_VADC_VIM  0xfe00707f
+#define MATCH_VMADC_VIM 0x46003057
+#define MASK_VMADC_VIM  0xfe00707f
+#define MATCH_VMERGE_VIM 0x5c003057
+#define MASK_VMERGE_VIM  0xfe00707f
+#define MATCH_VMV_V_I 0x5e003057
+#define MASK_VMV_V_I  0xfff0707f
+#define MATCH_VMSEQ_VI 0x60003057
+#define MASK_VMSEQ_VI  0xfc00707f
+#define MATCH_VMSNE_VI 0x64003057
+#define MASK_VMSNE_VI  0xfc00707f
+#define MATCH_VMSLEU_VI 0x70003057
+#define MASK_VMSLEU_VI  0xfc00707f
+#define MATCH_VMSLE_VI 0x74003057
+#define MASK_VMSLE_VI  0xfc00707f
+#define MATCH_VMSGTU_VI 0x78003057
+#define MASK_VMSGTU_VI  0xfc00707f
+#define MATCH_VMSGT_VI 0x7c003057
+#define MASK_VMSGT_VI  0xfc00707f
+#define MATCH_VSADDU_VI 0x80003057
+#define MASK_VSADDU_VI  0xfc00707f
+#define MATCH_VSADD_VI 0x84003057
+#define MASK_VSADD_VI  0xfc00707f
+#define MATCH_VAADD_VI 0x90003057
+#define MASK_VAADD_VI  0xfc00707f
+#define MATCH_VSLL_VI 0x94003057
+#define MASK_VSLL_VI  0xfc00707f
+#define MATCH_VSRL_VI 0xa0003057
+#define MASK_VSRL_VI  0xfc00707f
+#define MATCH_VSRA_VI 0xa4003057
+#define MASK_VSRA_VI  0xfc00707f
+#define MATCH_VSSRL_VI 0xa8003057
+#define MASK_VSSRL_VI  0xfc00707f
+#define MATCH_VSSRA_VI 0xac003057
+#define MASK_VSSRA_VI  0xfc00707f
+#define MATCH_VNSRL_VI 0xb0003057
+#define MASK_VNSRL_VI  0xfc00707f
+#define MATCH_VNSRA_VI 0xb4003057
+#define MASK_VNSRA_VI  0xfc00707f
+#define MATCH_VNCLIPU_VI 0xb8003057
+#define MASK_VNCLIPU_VI  0xfc00707f
+#define MATCH_VNCLIP_VI 0xbc003057
+#define MASK_VNCLIP_VI  0xfc00707f
+#define MATCH_VREDSUM_VS 0x2057
+#define MASK_VREDSUM_VS  0xfc00707f
+#define MATCH_VREDAND_VS 0x4002057
+#define MASK_VREDAND_VS  0xfc00707f
+#define MATCH_VREDOR_VS 0x8002057
+#define MASK_VREDOR_VS  0xfc00707f
+#define MATCH_VREDXOR_VS 0xc002057
+#define MASK_VREDXOR_VS  0xfc00707f
+#define MATCH_VREDMINU_VS 0x10002057
+#define MASK_VREDMINU_VS  0xfc00707f
+#define MATCH_VREDMIN_VS 0x14002057
+#define MASK_VREDMIN_VS  0xfc00707f
+#define MATCH_VREDMAXU_VS 0x18002057
+#define MASK_VREDMAXU_VS  0xfc00707f
+#define MATCH_VREDMAX_VS 0x1c002057
+#define MASK_VREDMAX_VS  0xfc00707f
+#define MATCH_VEXT_X_V 0x32002057
+#define MASK_VEXT_X_V  0xfe00707f
+#define MATCH_VMPOPC_M 0x50002057
+#define MASK_VMPOPC_M  0xfc00707f
+#define MATCH_VMFIRST_M 0x54002057
+#define MASK_VMFIRST_M  0xfc00707f
+#define MATCH_VCOMPRESS_VM 0x5c002057
+#define MASK_VCOMPRESS_VM  0xfc00707f
+#define MATCH_VMANDNOT_MM 0x60002057
+#define MASK_VMANDNOT_MM  0xfc00707f
+#define MATCH_VMAND_MM 0x64002057
+#define MASK_VMAND_MM  0xfc00707f
+#define MATCH_VMOR_MM 0x68002057
+#define MASK_VMOR_MM  0xfc00707f
+#define MATCH_VMXOR_MM 0x6c002057
+#define MASK_VMXOR_MM  0xfc00707f
+#define MATCH_VMORNOT_MM 0x70002057
+#define MASK_VMORNOT_MM  0xfc00707f
+#define MATCH_VMNAND_MM 0x74002057
+#define MASK_VMNAND_MM  0xfc00707f
+#define MATCH_VMNOR_MM 0x78002057
+#define MASK_VMNOR_MM  0xfc00707f
+#define MATCH_VMXNOR_MM 0x7c002057
+#define MASK_VMXNOR_MM  0xfc00707f
+#define MATCH_VMSBF_M 0x5800a057
+#define MASK_VMSBF_M  0xfc0ff07f
+#define MATCH_VMSOF_M 0x58012057
+#define MASK_VMSOF_M  0xfc0ff07f
+#define MATCH_VMSIF_M 0x5801a057
+#define MASK_VMSIF_M  0xfc0ff07f
+#define MATCH_VIOTA_M 0x58082057
+#define MASK_VIOTA_M  0xfc0ff07f
+#define MATCH_VID_V 0x5808a057
+#define MASK_VID_V  0xfdfff07f
+#define MATCH_VDIVU_VV 0x80002057
+#define MASK_VDIVU_VV  0xfc00707f
+#define MATCH_VDIV_VV 0x84002057
+#define MASK_VDIV_VV  0xfc00707f
+#define MATCH_VREMU_VV 0x88002057
+#define MASK_VREMU_VV  0xfc00707f
+#define MATCH_VREM_VV 0x8c002057
+#define MASK_VREM_VV  0xfc00707f
+#define MATCH_VMULHU_VV 0x90002057
+#define MASK_VMULHU_VV  0xfc00707f
+#define MATCH_VMUL_VV 0x94002057
+#define MASK_VMUL_VV  0xfc00707f
+#define MATCH_VMULHSU_VV 0x98002057
+#define MASK_VMULHSU_VV  0xfc00707f
+#define MATCH_VMULH_VV 0x9c002057
+#define MASK_VMULH_VV  0xfc00707f
+#define MATCH_VMADD_VV 0xa4002057
+#define MASK_VMADD_VV  0xfc00707f
+#define MATCH_VNMSUB_VV 0xac002057
+#define MASK_VNMSUB_VV  0xfc00707f
+#define MATCH_VMACC_VV 0xb4002057
+#define MASK_VMACC_VV  0xfc00707f
+#define MATCH_VNMSAC_VV 0xbc002057
+#define MASK_VNMSAC_VV  0xfc00707f
+#define MATCH_VWADDU_VV 0xc0002057
+#define MASK_VWADDU_VV  0xfc00707f
+#define MATCH_VWADD_VV 0xc4002057
+#define MASK_VWADD_VV  0xfc00707f
+#define MATCH_VWSUBU_VV 0xc8002057
+#define MASK_VWSUBU_VV  0xfc00707f
+#define MATCH_VWSUB_VV 0xcc002057
+#define MASK_VWSUB_VV  0xfc00707f
+#define MATCH_VWADDU_WV 0xd0002057
+#define MASK_VWADDU_WV  0xfc00707f
+#define MATCH_VWADD_WV 0xd4002057
+#define MASK_VWADD_WV  0xfc00707f
+#define MATCH_VWSUBU_WV 0xd8002057
+#define MASK_VWSUBU_WV  0xfc00707f
+#define MATCH_VWSUB_WV 0xdc002057
+#define MASK_VWSUB_WV  0xfc00707f
+#define MATCH_VWMULU_VV 0xe0002057
+#define MASK_VWMULU_VV  0xfc00707f
+#define MATCH_VWMULSU_VV 0xe8002057
+#define MASK_VWMULSU_VV  0xfc00707f
+#define MATCH_VWMUL_VV 0xec002057
+#define MASK_VWMUL_VV  0xfc00707f
+#define MATCH_VWMACCU_VV 0xf0002057
+#define MASK_VWMACCU_VV  0xfc00707f
+#define MATCH_VWMACC_VV 0xf4002057
+#define MASK_VWMACC_VV  0xfc00707f
+#define MATCH_VWMACCSU_VV 0xf8002057
+#define MASK_VWMACCSU_VV  0xfc00707f
+#define MATCH_VMV_S_X 0x36006057
+#define MASK_VMV_S_X  0xfff0707f
+#define MATCH_VSLIDE1UP_VX 0x38006057
+#define MASK_VSLIDE1UP_VX  0xfc00707f
+#define MATCH_VSLIDE1DOWN_VX 0x3c006057
+#define MASK_VSLIDE1DOWN_VX  0xfc00707f
+#define MATCH_VDIVU_VX 0x80006057
+#define MASK_VDIVU_VX  0xfc00707f
+#define MATCH_VDIV_VX 0x84006057
+#define MASK_VDIV_VX  0xfc00707f
+#define MATCH_VREMU_VX 0x88006057
+#define MASK_VREMU_VX  0xfc00707f
+#define MATCH_VREM_VX 0x8c006057
+#define MASK_VREM_VX  0xfc00707f
+#define MATCH_VMULHU_VX 0x90006057
+#define MASK_VMULHU_VX  0xfc00707f
+#define MATCH_VMUL_VX 0x94006057
+#define MASK_VMUL_VX  0xfc00707f
+#define MATCH_VMULHSU_VX 0x98006057
+#define MASK_VMULHSU_VX  0xfc00707f
+#define MATCH_VMULH_VX 0x9c006057
+#define MASK_VMULH_VX  0xfc00707f
+#define MATCH_VMADD_VX 0xa4006057
+#define MASK_VMADD_VX  0xfc00707f
+#define MATCH_VNMSUB_VX 0xac006057
+#define MASK_VNMSUB_VX  0xfc00707f
+#define MATCH_VMACC_VX 0xb4006057
+#define MASK_VMACC_VX  0xfc00707f
+#define MATCH_VNMSAC_VX 0xbc006057
+#define MASK_VNMSAC_VX  0xfc00707f
+#define MATCH_VWADDU_VX 0xc0006057
+#define MASK_VWADDU_VX  0xfc00707f
+#define MATCH_VWADD_VX 0xc4006057
+#define MASK_VWADD_VX  0xfc00707f
+#define MATCH_VWSUBU_VX 0xc8006057
+#define MASK_VWSUBU_VX  0xfc00707f
+#define MATCH_VWSUB_VX 0xcc006057
+#define MASK_VWSUB_VX  0xfc00707f
+#define MATCH_VWADDU_WX 0xd0006057
+#define MASK_VWADDU_WX  0xfc00707f
+#define MATCH_VWADD_WX 0xd4006057
+#define MASK_VWADD_WX  0xfc00707f
+#define MATCH_VWSUBU_WX 0xd8006057
+#define MASK_VWSUBU_WX  0xfc00707f
+#define MATCH_VWSUB_WX 0xdc006057
+#define MASK_VWSUB_WX  0xfc00707f
+#define MATCH_VWMULU_VX 0xe0006057
+#define MASK_VWMULU_VX  0xfc00707f
+#define MATCH_VWMULSU_VX 0xe8006057
+#define MASK_VWMULSU_VX  0xfc00707f
+#define MATCH_VWMUL_VX 0xec006057
+#define MASK_VWMUL_VX  0xfc00707f
+#define MATCH_VWMACCU_VX 0xf0006057
+#define MASK_VWMACCU_VX  0xfc00707f
+#define MATCH_VWMACC_VX 0xf4006057
+#define MASK_VWMACC_VX  0xfc00707f
+#define MATCH_VWMACCSU_VX 0xf8006057
+#define MASK_VWMACCSU_VX  0xfc00707f
+#define MATCH_VWMACCUS_VX 0xfc006057
+#define MASK_VWMACCUS_VX  0xfc00707f
+#define MATCH_VAMOSWAPW_V 0x800602f
+#define MASK_VAMOSWAPW_V  0xf800707f
+#define MATCH_VAMOADDW_V 0x602f
+#define MASK_VAMOADDW_V  0xf800707f
+#define MATCH_VAMOXORW_V 0x2000602f
+#define MASK_VAMOXORW_V  0xf800707f
+#define MATCH_VAMOANDW_V 0x6000602f
+#define MASK_VAMOANDW_V  0xf800707f
+#define MATCH_VAMOORW_V 0x4000602f
+#define MASK_VAMOORW_V  0xf800707f
+#define MATCH_VAMOMINW_V 0x8000602f
+#define MASK_VAMOMINW_V  0xf800707f
+#define MATCH_VAMOMAXW_V 0xa000602f
+#define MASK_VAMOMAXW_V  0xf800707f
+#define MATCH_VAMOMINUW_V 0xc000602f
+#define MASK_VAMOMINUW_V  0xf800707f
+#define MATCH_VAMOMAXUW_V 0xe000602f
+#define MASK_VAMOMAXUW_V  0xf800707f
+#define MATCH_VAMOSWAPD_V 0x800702f
+#define MASK_VAMOSWAPD_V  0xf800707f
+#define MATCH_VAMOADDD_V 0x702f
+#define MASK_VAMOADDD_V  0xf800707f
+#define MATCH_VAMOXORD_V 0x2000702f
+#define MASK_VAMOXORD_V  0xf800707f
+#define MATCH_VAMOANDD_V 0x6000702f
+#define MASK_VAMOANDD_V  0xf800707f
+#define MATCH_VAMOORD_V 0x4000702f
+#define MASK_VAMOORD_V  0xf800707f
+#define MATCH_VAMOMIND_V 0x8000702f
+#define MASK_VAMOMIND_V  0xf800707f
+#define MATCH_VAMOMAXD_V 0xa000702f
+#define MASK_VAMOMAXD_V  0xf800707f
+#define MATCH_VAMOMINUD_V 0xc000702f
+#define MASK_VAMOMINUD_V  0xf800707f
+#define MATCH_VAMOMAXUD_V 0xe000702f
+#define MASK_VAMOMAXUD_V  0xf800707f
+#define MATCH_VAMOSWAPQ_V 0x800002f
+#define MASK_VAMOSWAPQ_V  0xf800707f
+#define MATCH_VAMOADDQ_V 0x2f
+#define MASK_VAMOADDQ_V  0xf800707f
+#define MATCH_VAMOXORQ_V 0x2000002f
+#define MASK_VAMOXORQ_V  0xf800707f
+#define MATCH_VAMOANDQ_V 0x6000002f
+#define MASK_VAMOANDQ_V  0xf800707f
+#define MATCH_VAMOORQ_V 0x4000002f
+#define MASK_VAMOORQ_V  0xf800707f
+#define MATCH_VAMOMINQ_V 0x8000002f
+#define MASK_VAMOMINQ_V  0xf800707f
+#define MATCH_VAMOMAXQ_V 0xa000002f
+#define MASK_VAMOMAXQ_V  0xf800707f
+#define MATCH_VAMOMINUQ_V 0xc000002f
+#define MASK_VAMOMINUQ_V  0xf800707f
+#define MATCH_VAMOMAXUQ_V 0xe000002f
+#define MASK_VAMOMAXUQ_V  0xf800707f
+#define CSR_FFLAGS 0x1
+#define CSR_FRM 0x2
+#define CSR_FCSR 0x3
+#define CSR_USTATUS 0x0
+#define CSR_UIE 0x4
+#define CSR_UTVEC 0x5
+#define CSR_VSTART 0x8
+#define CSR_VXSAT 0x9
+#define CSR_VXRM 0xa
+#define CSR_USCRATCH 0x40
+#define CSR_UEPC 0x41
+#define CSR_UCAUSE 0x42
+#define CSR_UTVAL 0x43
+#define CSR_UIP 0x44
+#define CSR_CYCLE 0xc00
+#define CSR_TIME 0xc01
+#define CSR_INSTRET 0xc02
+#define CSR_HPMCOUNTER3 0xc03
+#define CSR_HPMCOUNTER4 0xc04
+#define CSR_HPMCOUNTER5 0xc05
+#define CSR_HPMCOUNTER6 0xc06
+#define CSR_HPMCOUNTER7 0xc07
+#define CSR_HPMCOUNTER8 0xc08
+#define CSR_HPMCOUNTER9 0xc09
+#define CSR_HPMCOUNTER10 0xc0a
+#define CSR_HPMCOUNTER11 0xc0b
+#define CSR_HPMCOUNTER12 0xc0c
+#define CSR_HPMCOUNTER13 0xc0d
+#define CSR_HPMCOUNTER14 0xc0e
+#define CSR_HPMCOUNTER15 0xc0f
+#define CSR_HPMCOUNTER16 0xc10
+#define CSR_HPMCOUNTER17 0xc11
+#define CSR_HPMCOUNTER18 0xc12
+#define CSR_HPMCOUNTER19 0xc13
+#define CSR_HPMCOUNTER20 0xc14
+#define CSR_HPMCOUNTER21 0xc15
+#define CSR_HPMCOUNTER22 0xc16
+#define CSR_HPMCOUNTER23 0xc17
+#define CSR_HPMCOUNTER24 0xc18
+#define CSR_HPMCOUNTER25 0xc19
+#define CSR_HPMCOUNTER26 0xc1a
+#define CSR_HPMCOUNTER27 0xc1b
+#define CSR_HPMCOUNTER28 0xc1c
+#define CSR_HPMCOUNTER29 0xc1d
+#define CSR_HPMCOUNTER30 0xc1e
+#define CSR_HPMCOUNTER31 0xc1f
+#define CSR_VL 0xc20
+#define CSR_VTYPE 0xc21
+#define CSR_SSTATUS 0x100
+#define CSR_SIE 0x104
+#define CSR_STVEC 0x105
+#define CSR_SCOUNTEREN 0x106
+#define CSR_SSCRATCH 0x140
+#define CSR_SEPC 0x141
+#define CSR_SCAUSE 0x142
+#define CSR_STVAL 0x143
+#define CSR_SIP 0x144
+#define CSR_SATP 0x180
+#define CSR_BSSTATUS 0x200
+#define CSR_BSIE 0x204
+#define CSR_BSTVEC 0x205
+#define CSR_BSSCRATCH 0x240
+#define CSR_BSEPC 0x241
+#define CSR_BSCAUSE 0x242
+#define CSR_BSTVAL 0x243
+#define CSR_BSIP 0x244
+#define CSR_BSATP 0x280
+#define CSR_HSTATUS 0xa00
+#define CSR_HEDELEG 0xa02
+#define CSR_HIDELEG 0xa03
+#define CSR_HGATP 0xa80
+#define CSR_UTVT 0x7
+#define CSR_UNXTI 0x45
+#define CSR_UINTSTATUS 0x46
+#define CSR_USCRATCHCSW 0x48
+#define CSR_USCRATCHCSWL 0x49
+#define CSR_STVT 0x107
+#define CSR_SNXTI 0x145
+#define CSR_SINTSTATUS 0x146
+#define CSR_SSCRATCHCSW 0x148
+#define CSR_SSCRATCHCSWL 0x149
+#define CSR_MTVT 0x307
+#define CSR_MNXTI 0x345
+#define CSR_MINTSTATUS 0x346
+#define CSR_MSCRATCHCSW 0x348
+#define CSR_MSCRATCHCSWL 0x349
+#define CSR_MSTATUS 0x300
+#define CSR_MISA 0x301
+#define CSR_MEDELEG 0x302
+#define CSR_MIDELEG 0x303
+#define CSR_MIE 0x304
+#define CSR_MTVEC 0x305
+#define CSR_MCOUNTEREN 0x306
+#define CSR_MSCRATCH 0x340
+#define CSR_MEPC 0x341
+#define CSR_MCAUSE 0x342
+#define CSR_MTVAL 0x343
+#define CSR_MIP 0x344
+#define CSR_PMPCFG0 0x3a0
+#define CSR_PMPCFG1 0x3a1
+#define CSR_PMPCFG2 0x3a2
+#define CSR_PMPCFG3 0x3a3
+#define CSR_PMPADDR0 0x3b0
+#define CSR_PMPADDR1 0x3b1
+#define CSR_PMPADDR2 0x3b2
+#define CSR_PMPADDR3 0x3b3
+#define CSR_PMPADDR4 0x3b4
+#define CSR_PMPADDR5 0x3b5
+#define CSR_PMPADDR6 0x3b6
+#define CSR_PMPADDR7 0x3b7
+#define CSR_PMPADDR8 0x3b8
+#define CSR_PMPADDR9 0x3b9
+#define CSR_PMPADDR10 0x3ba
+#define CSR_PMPADDR11 0x3bb
+#define CSR_PMPADDR12 0x3bc
+#define CSR_PMPADDR13 0x3bd
+#define CSR_PMPADDR14 0x3be
+#define CSR_PMPADDR15 0x3bf
+#define CSR_TSELECT 0x7a0
+#define CSR_TDATA1 0x7a1
+#define CSR_TDATA2 0x7a2
+#define CSR_TDATA3 0x7a3
+#define CSR_DCSR 0x7b0
+#define CSR_DPC 0x7b1
+#define CSR_DSCRATCH 0x7b2
+#define CSR_MCYCLE 0xb00
+#define CSR_MINSTRET 0xb02
+#define CSR_MHPMCOUNTER3 0xb03
+#define CSR_MHPMCOUNTER4 0xb04
+#define CSR_MHPMCOUNTER5 0xb05
+#define CSR_MHPMCOUNTER6 0xb06
+#define CSR_MHPMCOUNTER7 0xb07
+#define CSR_MHPMCOUNTER8 0xb08
+#define CSR_MHPMCOUNTER9 0xb09
+#define CSR_MHPMCOUNTER10 0xb0a
+#define CSR_MHPMCOUNTER11 0xb0b
+#define CSR_MHPMCOUNTER12 0xb0c
+#define CSR_MHPMCOUNTER13 0xb0d
+#define CSR_MHPMCOUNTER14 0xb0e
+#define CSR_MHPMCOUNTER15 0xb0f
+#define CSR_MHPMCOUNTER16 0xb10
+#define CSR_MHPMCOUNTER17 0xb11
+#define CSR_MHPMCOUNTER18 0xb12
+#define CSR_MHPMCOUNTER19 0xb13
+#define CSR_MHPMCOUNTER20 0xb14
+#define CSR_MHPMCOUNTER21 0xb15
+#define CSR_MHPMCOUNTER22 0xb16
+#define CSR_MHPMCOUNTER23 0xb17
+#define CSR_MHPMCOUNTER24 0xb18
+#define CSR_MHPMCOUNTER25 0xb19
+#define CSR_MHPMCOUNTER26 0xb1a
+#define CSR_MHPMCOUNTER27 0xb1b
+#define CSR_MHPMCOUNTER28 0xb1c
+#define CSR_MHPMCOUNTER29 0xb1d
+#define CSR_MHPMCOUNTER30 0xb1e
+#define CSR_MHPMCOUNTER31 0xb1f
+#define CSR_MHPMEVENT3 0x323
+#define CSR_MHPMEVENT4 0x324
+#define CSR_MHPMEVENT5 0x325
+#define CSR_MHPMEVENT6 0x326
+#define CSR_MHPMEVENT7 0x327
+#define CSR_MHPMEVENT8 0x328
+#define CSR_MHPMEVENT9 0x329
+#define CSR_MHPMEVENT10 0x32a
+#define CSR_MHPMEVENT11 0x32b
+#define CSR_MHPMEVENT12 0x32c
+#define CSR_MHPMEVENT13 0x32d
+#define CSR_MHPMEVENT14 0x32e
+#define CSR_MHPMEVENT15 0x32f
+#define CSR_MHPMEVENT16 0x330
+#define CSR_MHPMEVENT17 0x331
+#define CSR_MHPMEVENT18 0x332
+#define CSR_MHPMEVENT19 0x333
+#define CSR_MHPMEVENT20 0x334
+#define CSR_MHPMEVENT21 0x335
+#define CSR_MHPMEVENT22 0x336
+#define CSR_MHPMEVENT23 0x337
+#define CSR_MHPMEVENT24 0x338
+#define CSR_MHPMEVENT25 0x339
+#define CSR_MHPMEVENT26 0x33a
+#define CSR_MHPMEVENT27 0x33b
+#define CSR_MHPMEVENT28 0x33c
+#define CSR_MHPMEVENT29 0x33d
+#define CSR_MHPMEVENT30 0x33e
+#define CSR_MHPMEVENT31 0x33f
+#define CSR_MVENDORID 0xf11
+#define CSR_MARCHID 0xf12
+#define CSR_MIMPID 0xf13
+#define CSR_MHARTID 0xf14
+#define CSR_CYCLEH 0xc80
+#define CSR_TIMEH 0xc81
+#define CSR_INSTRETH 0xc82
+#define CSR_HPMCOUNTER3H 0xc83
+#define CSR_HPMCOUNTER4H 0xc84
+#define CSR_HPMCOUNTER5H 0xc85
+#define CSR_HPMCOUNTER6H 0xc86
+#define CSR_HPMCOUNTER7H 0xc87
+#define CSR_HPMCOUNTER8H 0xc88
+#define CSR_HPMCOUNTER9H 0xc89
+#define CSR_HPMCOUNTER10H 0xc8a
+#define CSR_HPMCOUNTER11H 0xc8b
+#define CSR_HPMCOUNTER12H 0xc8c
+#define CSR_HPMCOUNTER13H 0xc8d
+#define CSR_HPMCOUNTER14H 0xc8e
+#define CSR_HPMCOUNTER15H 0xc8f
+#define CSR_HPMCOUNTER16H 0xc90
+#define CSR_HPMCOUNTER17H 0xc91
+#define CSR_HPMCOUNTER18H 0xc92
+#define CSR_HPMCOUNTER19H 0xc93
+#define CSR_HPMCOUNTER20H 0xc94
+#define CSR_HPMCOUNTER21H 0xc95
+#define CSR_HPMCOUNTER22H 0xc96
+#define CSR_HPMCOUNTER23H 0xc97
+#define CSR_HPMCOUNTER24H 0xc98
+#define CSR_HPMCOUNTER25H 0xc99
+#define CSR_HPMCOUNTER26H 0xc9a
+#define CSR_HPMCOUNTER27H 0xc9b
+#define CSR_HPMCOUNTER28H 0xc9c
+#define CSR_HPMCOUNTER29H 0xc9d
+#define CSR_HPMCOUNTER30H 0xc9e
+#define CSR_HPMCOUNTER31H 0xc9f
+#define CSR_MCYCLEH 0xb80
+#define CSR_MINSTRETH 0xb82
+#define CSR_MHPMCOUNTER3H 0xb83
+#define CSR_MHPMCOUNTER4H 0xb84
+#define CSR_MHPMCOUNTER5H 0xb85
+#define CSR_MHPMCOUNTER6H 0xb86
+#define CSR_MHPMCOUNTER7H 0xb87
+#define CSR_MHPMCOUNTER8H 0xb88
+#define CSR_MHPMCOUNTER9H 0xb89
+#define CSR_MHPMCOUNTER10H 0xb8a
+#define CSR_MHPMCOUNTER11H 0xb8b
+#define CSR_MHPMCOUNTER12H 0xb8c
+#define CSR_MHPMCOUNTER13H 0xb8d
+#define CSR_MHPMCOUNTER14H 0xb8e
+#define CSR_MHPMCOUNTER15H 0xb8f
+#define CSR_MHPMCOUNTER16H 0xb90
+#define CSR_MHPMCOUNTER17H 0xb91
+#define CSR_MHPMCOUNTER18H 0xb92
+#define CSR_MHPMCOUNTER19H 0xb93
+#define CSR_MHPMCOUNTER20H 0xb94
+#define CSR_MHPMCOUNTER21H 0xb95
+#define CSR_MHPMCOUNTER22H 0xb96
+#define CSR_MHPMCOUNTER23H 0xb97
+#define CSR_MHPMCOUNTER24H 0xb98
+#define CSR_MHPMCOUNTER25H 0xb99
+#define CSR_MHPMCOUNTER26H 0xb9a
+#define CSR_MHPMCOUNTER27H 0xb9b
+#define CSR_MHPMCOUNTER28H 0xb9c
+#define CSR_MHPMCOUNTER29H 0xb9d
+#define CSR_MHPMCOUNTER30H 0xb9e
+#define CSR_MHPMCOUNTER31H 0xb9f
+#define CAUSE_MISALIGNED_FETCH 0x0
+#define CAUSE_FETCH_ACCESS 0x1
+#define CAUSE_ILLEGAL_INSTRUCTION 0x2
+#define CAUSE_BREAKPOINT 0x3
+#define CAUSE_MISALIGNED_LOAD 0x4
+#define CAUSE_LOAD_ACCESS 0x5
+#define CAUSE_MISALIGNED_STORE 0x6
+#define CAUSE_STORE_ACCESS 0x7
+#define CAUSE_USER_ECALL 0x8
+#define CAUSE_SUPERVISOR_ECALL 0x9
+#define CAUSE_HYPERVISOR_ECALL 0xa
+#define CAUSE_MACHINE_ECALL 0xb
+#define CAUSE_FETCH_PAGE_FAULT 0xc
+#define CAUSE_LOAD_PAGE_FAULT 0xd
+#define CAUSE_STORE_PAGE_FAULT 0xf
+#endif
+#ifdef DECLARE_INSN
+DECLARE_INSN(vsetvli, MATCH_VSETVLI, MASK_VSETVLI)
+DECLARE_INSN(vsetvl, MATCH_VSETVL, MASK_VSETVL)
+DECLARE_INSN(vlb_v, MATCH_VLB_V, MASK_VLB_V)
+DECLARE_INSN(vlh_v, MATCH_VLH_V, MASK_VLH_V)
+DECLARE_INSN(vlw_v, MATCH_VLW_V, MASK_VLW_V)
+DECLARE_INSN(vle_v, MATCH_VLE_V, MASK_VLE_V)
+DECLARE_INSN(vlbu_v, MATCH_VLBU_V, MASK_VLBU_V)
+DECLARE_INSN(vlhu_v, MATCH_VLHU_V, MASK_VLHU_V)
+DECLARE_INSN(vlwu_v, MATCH_VLWU_V, MASK_VLWU_V)
+DECLARE_INSN(vsb_v, MATCH_VSB_V, MASK_VSB_V)
+DECLARE_INSN(vsh_v, MATCH_VSH_V, MASK_VSH_V)
+DECLARE_INSN(vsw_v, MATCH_VSW_V, MASK_VSW_V)
+DECLARE_INSN(vse_v, MATCH_VSE_V, MASK_VSE_V)
+DECLARE_INSN(vlsb_v, MATCH_VLSB_V, MASK_VLSB_V)
+DECLARE_INSN(vlsh_v, MATCH_VLSH_V, MASK_VLSH_V)
+DECLARE_INSN(vlsw_v, MATCH_VLSW_V, MASK_VLSW_V)
+DECLARE_INSN(vlse_v, MATCH_VLSE_V, MASK_VLSE_V)
+DECLARE_INSN(vlsbu_v, MATCH_VLSBU_V, MASK_VLSBU_V)
+DECLARE_INSN(vlshu_v, MATCH_VLSHU_V, MASK_VLSHU_V)
+DECLARE_INSN(vlswu_v, MATCH_VLSWU_V, MASK_VLSWU_V)
+DECLARE_INSN(vssb_v, MATCH_VSSB_V, MASK_VSSB_V)
+DECLARE_INSN(vssh_v, MATCH_VSSH_V, MASK_VSSH_V)
+DECLARE_INSN(vssw_v, MATCH_VSSW_V, MASK_VSSW_V)
+DECLARE_INSN(vsse_v, MATCH_VSSE_V, MASK_VSSE_V)
+DECLARE_INSN(vlxb_v, MATCH_VLXB_V, MASK_VLXB_V)
+DECLARE_INSN(vlxh_v, MATCH_VLXH_V, MASK_VLXH_V)
+DECLARE_INSN(vlxw_v, MATCH_VLXW_V, MASK_VLXW_V)
+DECLARE_INSN(vlxe_v, MATCH_VLXE_V, MASK_VLXE_V)
+DECLARE_INSN(vlxbu_v, MATCH_VLXBU_V, MASK_VLXBU_V)
+DECLARE_INSN(vlxhu_v, MATCH_VLXHU_V, MASK_VLXHU_V)
+DECLARE_INSN(vlxwu_v, MATCH_VLXWU_V, MASK_VLXWU_V)
+DECLARE_INSN(vsxb_v, MATCH_VSXB_V, MASK_VSXB_V)
+DECLARE_INSN(vsxh_v, MATCH_VSXH_V, MASK_VSXH_V)
+DECLARE_INSN(vsxw_v, MATCH_VSXW_V, MASK_VSXW_V)
+DECLARE_INSN(vsxe_v, MATCH_VSXE_V, MASK_VSXE_V)
+DECLARE_INSN(vsuxb_v, MATCH_VSUXB_V, MASK_VSUXB_V)
+DECLARE_INSN(vsuxh_v, MATCH_VSUXH_V, MASK_VSUXH_V)
+DECLARE_INSN(vsuxw_v, MATCH_VSUXW_V, MASK_VSUXW_V)
+DECLARE_INSN(vsuxe_v, MATCH_VSUXE_V, MASK_VSUXE_V)
+DECLARE_INSN(vlbff_v, MATCH_VLBFF_V, MASK_VLBFF_V)
+DECLARE_INSN(vlhff_v, MATCH_VLHFF_V, MASK_VLHFF_V)
+DECLARE_INSN(vlwff_v, MATCH_VLWFF_V, MASK_VLWFF_V)
+DECLARE_INSN(vleff_v, MATCH_VLEFF_V, MASK_VLEFF_V)
+DECLARE_INSN(vlbuff_v, MATCH_VLBUFF_V, MASK_VLBUFF_V)
+DECLARE_INSN(vlhuff_v, MATCH_VLHUFF_V, MASK_VLHUFF_V)
+DECLARE_INSN(vlwuff_v, MATCH_VLWUFF_V, MASK_VLWUFF_V)
+DECLARE_INSN(vfadd_vf, MATCH_VFADD_VF, MASK_VFADD_VF)
+DECLARE_INSN(vfsub_vf, MATCH_VFSUB_VF, MASK_VFSUB_VF)
+DECLARE_INSN(vfmin_vf, MATCH_VFMIN_VF, MASK_VFMIN_VF)
+DECLARE_INSN(vfmax_vf, MATCH_VFMAX_VF, MASK_VFMAX_VF)
+DECLARE_INSN(vfsgnj_vf, MATCH_VFSGNJ_VF, MASK_VFSGNJ_VF)
+DECLARE_INSN(vfsgnjn_vf, MATCH_VFSGNJN_VF, MASK_VFSGNJN_VF)
+DECLARE_INSN(vfsgnjx_vf, MATCH_VFSGNJX_VF, MASK_VFSGNJX_VF)
+DECLARE_INSN(vfmv_s_f, MATCH_VFMV_S_F, MASK_VFMV_S_F)
+DECLARE_INSN(vfmerge_vfm, MATCH_VFMERGE_VFM, MASK_VFMERGE_VFM)
+DECLARE_INSN(vfmv_v_f, MATCH_VFMV_V_F, MASK_VFMV_V_F)
+DECLARE_INSN(vmfeq_vf, MATCH_VMFEQ_VF, MASK_VMFEQ_VF)
+DECLARE_INSN(vmfle_vf, MATCH_VMFLE_VF, MASK_VMFLE_VF)
+DECLARE_INSN(vmford_vf, MATCH_VMFORD_VF, MASK_VMFORD_VF)
+DECLARE_INSN(vmflt_vf, MATCH_VMFLT_VF, MASK_VMFLT_VF)
+DECLARE_INSN(vmfne_vf, MATCH_VMFNE_VF, MASK_VMFNE_VF)
+DECLARE_INSN(vmfgt_vf, MATCH_VMFGT_VF, MASK_VMFGT_VF)
+DECLARE_INSN(vmfge_vf, MATCH_VMFGE_VF, MASK_VMFGE_VF)
+DECLARE_INSN(vfdiv_vf, MATCH_VFDIV_VF, MASK_VFDIV_VF)
+DECLARE_INSN(vfrdiv_vf, MATCH_VFRDIV_VF, MASK_VFRDIV_VF)
+DECLARE_INSN(vfmul_vf, MATCH_VFMUL_VF, MASK_VFMUL_VF)
+DECLARE_INSN(vfrsub_vf, MATCH_VFRSUB_VF, MASK_VFRSUB_VF)
+DECLARE_INSN(vfmadd_vf, MATCH_VFMADD_VF, MASK_VFMADD_VF)
+DECLARE_INSN(vfnmadd_vf, MATCH_VFNMADD_VF, MASK_VFNMADD_VF)
+DECLARE_INSN(vfmsub_vf, MATCH_VFMSUB_VF, MASK_VFMSUB_VF)
+DECLARE_INSN(vfnmsub_vf, MATCH_VFNMSUB_VF, MASK_VFNMSUB_VF)
+DECLARE_INSN(vfmacc_vf, MATCH_VFMACC_VF, MASK_VFMACC_VF)
+DECLARE_INSN(vfnmacc_vf, MATCH_VFNMACC_VF, MASK_VFNMACC_VF)
+DECLARE_INSN(vfmsac_vf, MATCH_VFMSAC_VF, MASK_VFMSAC_VF)
+DECLARE_INSN(vfnmsac_vf, MATCH_VFNMSAC_VF, MASK_VFNMSAC_VF)
+DECLARE_INSN(vfwadd_vf, MATCH_VFWADD_VF, MASK_VFWADD_VF)
+DECLARE_INSN(vfwsub_vf, MATCH_VFWSUB_VF, MASK_VFWSUB_VF)
+DECLARE_INSN(vfwadd_wf, MATCH_VFWADD_WF, MASK_VFWADD_WF)
+DECLARE_INSN(vfwsub_wf, MATCH_VFWSUB_WF, MASK_VFWSUB_WF)
+DECLARE_INSN(vfwmul_vf, MATCH_VFWMUL_VF, MASK_VFWMUL_VF)
+DECLARE_INSN(vfwmacc_vf, MATCH_VFWMACC_VF, MASK_VFWMACC_VF)
+DECLARE_INSN(vfwnmacc_vf, MATCH_VFWNMACC_VF, MASK_VFWNMACC_VF)
+DECLARE_INSN(vfwmsac_vf, MATCH_VFWMSAC_VF, MASK_VFWMSAC_VF)
+DECLARE_INSN(vfwnmsac_vf, MATCH_VFWNMSAC_VF, MASK_VFWNMSAC_VF)
+DECLARE_INSN(vfadd_vv, MATCH_VFADD_VV, MASK_VFADD_VV)
+DECLARE_INSN(vfredsum_vs, MATCH_VFREDSUM_VS, MASK_VFREDSUM_VS)
+DECLARE_INSN(vfsub_vv, MATCH_VFSUB_VV, MASK_VFSUB_VV)
+DECLARE_INSN(vfredosum_vs, MATCH_VFREDOSUM_VS, MASK_VFREDOSUM_VS)
+DECLARE_INSN(vfmin_vv, MATCH_VFMIN_VV, MASK_VFMIN_VV)
+DECLARE_INSN(vfredmin_vs, MATCH_VFREDMIN_VS, MASK_VFREDMIN_VS)
+DECLARE_INSN(vfmax_vv, MATCH_VFMAX_VV, MASK_VFMAX_VV)
+DECLARE_INSN(vfredmax_vs, MATCH_VFREDMAX_VS, MASK_VFREDMAX_VS)
+DECLARE_INSN(vfsgnj_vv, MATCH_VFSGNJ_VV, MASK_VFSGNJ_VV)
+DECLARE_INSN(vfsgnjn_vv, MATCH_VFSGNJN_VV, MASK_VFSGNJN_VV)
+DECLARE_INSN(vfsgnjx_vv, MATCH_VFSGNJX_VV, MASK_VFSGNJX_VV)
+DECLARE_INSN(vfmv_f_s, MATCH_VFMV_F_S, MASK_VFMV_F_S)
+DECLARE_INSN(vmfeq_vv, MATCH_VMFEQ_VV, MASK_VMFEQ_VV)
+DECLARE_INSN(vmfle_vv, MATCH_VMFLE_VV, MASK_VMFLE_VV)
+DECLARE_INSN(vmford_vv, MATCH_VMFORD_VV, MASK_VMFORD_VV)
+DECLARE_INSN(vmflt_vv, MATCH_VMFLT_VV, MASK_VMFLT_VV)
+DECLARE_INSN(vmfne_vv, MATCH_VMFNE_VV, MASK_VMFNE_VV)
+DECLARE_INSN(vfdiv_vv, MATCH_VFDIV_VV, MASK_VFDIV_VV)
+DECLARE_INSN(vfmul_vv, MATCH_VFMUL_VV, MASK_VFMUL_VV)
+DECLARE_INSN(vfmadd_vv, MATCH_VFMADD_VV, MASK_VFMADD_VV)
+DECLARE_INSN(vfnmadd_vv, MATCH_VFNMADD_VV, MASK_VFNMADD_VV)
+DECLARE_INSN(vfmsub_vv, MATCH_VFMSUB_VV, MASK_VFMSUB_VV)
+DECLARE_INSN(vfnmsub_vv, MATCH_VFNMSUB_VV, MASK_VFNMSUB_VV)
+DECLARE_INSN(vfmacc_vv, MATCH_VFMACC_VV, MASK_VFMACC_VV)
+DECLARE_INSN(vfnmacc_vv, MATCH_VFNMACC_VV, MASK_VFNMACC_VV)
+DECLARE_INSN(vfmsac_vv, MATCH_VFMSAC_VV, MASK_VFMSAC_VV)
+DECLARE_INSN(vfnmsac_vv, MATCH_VFNMSAC_VV, MASK_VFNMSAC_VV)
+DECLARE_INSN(vfcvt_xu_f_v, MATCH_VFCVT_XU_F_V, MASK_VFCVT_XU_F_V)
+DECLARE_INSN(vfcvt_x_f_v, MATCH_VFCVT_X_F_V, MASK_VFCVT_X_F_V)
+DECLARE_INSN(vfcvt_f_xu_v, MATCH_VFCVT_F_XU_V, MASK_VFCVT_F_XU_V)
+DECLARE_INSN(vfcvt_f_x_v, MATCH_VFCVT_F_X_V, MASK_VFCVT_F_X_V)
+DECLARE_INSN(vfwcvt_xu_f_v, MATCH_VFWCVT_XU_F_V, MASK_VFWCVT_XU_F_V)
+DECLARE_INSN(vfwcvt_x_f_v, MATCH_VFWCVT_X_F_V, MASK_VFWCVT_X_F_V)
+DECLARE_INSN(vfwcvt_f_xu_v, MATCH_VFWCVT_F_XU_V, MASK_VFWCVT_F_XU_V)
+DECLARE_INSN(vfwcvt_f_x_v, MATCH_VFWCVT_F_X_V, MASK_VFWCVT_F_X_V)
+DECLARE_INSN(vfwcvt_f_f_v, MATCH_VFWCVT_F_F_V, MASK_VFWCVT_F_F_V)
+DECLARE_INSN(vfncvt_xu_f_v, MATCH_VFNCVT_XU_F_V, MASK_VFNCVT_XU_F_V)
+DECLARE_INSN(vfncvt_x_f_v, MATCH_VFNCVT_X_F_V, MASK_VFNCVT_X_F_V)
+DECLARE_INSN(vfncvt_f_xu_v, MATCH_VFNCVT_F_XU_V, MASK_VFNCVT_F_XU_V)
+DECLARE_INSN(vfncvt_f_x_v, MATCH_VFNCVT_F_X_V, MASK_VFNCVT_F_X_V)
+DECLARE_INSN(vfncvt_f_f_v, MATCH_VFNCVT_F_F_V, MASK_VFNCVT_F_F_V)
+DECLARE_INSN(vfsqrt_v, MATCH_VFSQRT_V, MASK_VFSQRT_V)
+DECLARE_INSN(vfclass_v, MATCH_VFCLASS_V, MASK_VFCLASS_V)
+DECLARE_INSN(vfwadd_vv, MATCH_VFWADD_VV, MASK_VFWADD_VV)
+DECLARE_INSN(vfwredsum_vs, MATCH_VFWREDSUM_VS, MASK_VFWREDSUM_VS)
+DECLARE_INSN(vfwsub_vv, MATCH_VFWSUB_VV, MASK_VFWSUB_VV)
+DECLARE_INSN(vfwredosum_vs, MATCH_VFWREDOSUM_VS, MASK_VFWREDOSUM_VS)
+DECLARE_INSN(vfwadd_wv, MATCH_VFWADD_WV, MASK_VFWADD_WV)
+DECLARE_INSN(vfwsub_wv, MATCH_VFWSUB_WV, MASK_VFWSUB_WV)
+DECLARE_INSN(vfwmul_vv, MATCH_VFWMUL_VV, MASK_VFWMUL_VV)
+DECLARE_INSN(vfdot_vv, MATCH_VFDOT_VV, MASK_VFDOT_VV)
+DECLARE_INSN(vfwmacc_vv, MATCH_VFWMACC_VV, MASK_VFWMACC_VV)
+DECLARE_INSN(vfwnmacc_vv, MATCH_VFWNMACC_VV, MASK_VFWNMACC_VV)
+DECLARE_INSN(vfwmsac_vv, MATCH_VFWMSAC_VV, MASK_VFWMSAC_VV)
+DECLARE_INSN(vfwnmsac_vv, MATCH_VFWNMSAC_VV, MASK_VFWNMSAC_VV)
+DECLARE_INSN(vadd_vx, MATCH_VADD_VX, MASK_VADD_VX)
+DECLARE_INSN(vsub_vx, MATCH_VSUB_VX, MASK_VSUB_VX)
+DECLARE_INSN(vrsub_vx, MATCH_VRSUB_VX, MASK_VRSUB_VX)
+DECLARE_INSN(vminu_vx, MATCH_VMINU_VX, MASK_VMINU_VX)
+DECLARE_INSN(vmin_vx, MATCH_VMIN_VX, MASK_VMIN_VX)
+DECLARE_INSN(vmaxu_vx, MATCH_VMAXU_VX, MASK_VMAXU_VX)
+DECLARE_INSN(vmax_vx, MATCH_VMAX_VX, MASK_VMAX_VX)
+DECLARE_INSN(vand_vx, MATCH_VAND_VX, MASK_VAND_VX)
+DECLARE_INSN(vor_vx, MATCH_VOR_VX, MASK_VOR_VX)
+DECLARE_INSN(vxor_vx, MATCH_VXOR_VX, MASK_VXOR_VX)
+DECLARE_INSN(vrgather_vx, MATCH_VRGATHER_VX, MASK_VRGATHER_VX)
+DECLARE_INSN(vslideup_vx, MATCH_VSLIDEUP_VX, MASK_VSLIDEUP_VX)
+DECLARE_INSN(vslidedown_vx, MATCH_VSLIDEDOWN_VX, MASK_VSLIDEDOWN_VX)
+DECLARE_INSN(vadc_vxm, MATCH_VADC_VXM, MASK_VADC_VXM)
+DECLARE_INSN(vmadc_vxm, MATCH_VMADC_VXM, MASK_VMADC_VXM)
+DECLARE_INSN(vsbc_vxm, MATCH_VSBC_VXM, MASK_VSBC_VXM)
+DECLARE_INSN(vmsbc_vxm, MATCH_VMSBC_VXM, MASK_VMSBC_VXM)
+DECLARE_INSN(vmerge_vxm, MATCH_VMERGE_VXM, MASK_VMERGE_VXM)
+DECLARE_INSN(vmv_v_x, MATCH_VMV_V_X, MASK_VMV_V_X)
+DECLARE_INSN(vmseq_vx, MATCH_VMSEQ_VX, MASK_VMSEQ_VX)
+DECLARE_INSN(vmsne_vx, MATCH_VMSNE_VX, MASK_VMSNE_VX)
+DECLARE_INSN(vmsltu_vx, MATCH_VMSLTU_VX, MASK_VMSLTU_VX)
+DECLARE_INSN(vmslt_vx, MATCH_VMSLT_VX, MASK_VMSLT_VX)
+DECLARE_INSN(vmsleu_vx, MATCH_VMSLEU_VX, MASK_VMSLEU_VX)
+DECLARE_INSN(vmsle_vx, MATCH_VMSLE_VX, MASK_VMSLE_VX)
+DECLARE_INSN(vmsgtu_vx, MATCH_VMSGTU_VX, MASK_VMSGTU_VX)
+DECLARE_INSN(vmsgt_vx, MATCH_VMSGT_VX, MASK_VMSGT_VX)
+DECLARE_INSN(vsaddu_vx, MATCH_VSADDU_VX, MASK_VSADDU_VX)
+DECLARE_INSN(vsadd_vx, MATCH_VSADD_VX, MASK_VSADD_VX)
+DECLARE_INSN(vssubu_vx, MATCH_VSSUBU_VX, MASK_VSSUBU_VX)
+DECLARE_INSN(vssub_vx, MATCH_VSSUB_VX, MASK_VSSUB_VX)
+DECLARE_INSN(vaadd_vx, MATCH_VAADD_VX, MASK_VAADD_VX)
+DECLARE_INSN(vsll_vx, MATCH_VSLL_VX, MASK_VSLL_VX)
+DECLARE_INSN(vasub_vx, MATCH_VASUB_VX, MASK_VASUB_VX)
+DECLARE_INSN(vsmul_vx, MATCH_VSMUL_VX, MASK_VSMUL_VX)
+DECLARE_INSN(vsrl_vx, MATCH_VSRL_VX, MASK_VSRL_VX)
+DECLARE_INSN(vsra_vx, MATCH_VSRA_VX, MASK_VSRA_VX)
+DECLARE_INSN(vssrl_vx, MATCH_VSSRL_VX, MASK_VSSRL_VX)
+DECLARE_INSN(vssra_vx, MATCH_VSSRA_VX, MASK_VSSRA_VX)
+DECLARE_INSN(vnsrl_vx, MATCH_VNSRL_VX, MASK_VNSRL_VX)
+DECLARE_INSN(vnsra_vx, MATCH_VNSRA_VX, MASK_VNSRA_VX)
+DECLARE_INSN(vnclipu_vx, MATCH_VNCLIPU_VX, MASK_VNCLIPU_VX)
+DECLARE_INSN(vnclip_vx, MATCH_VNCLIP_VX, MASK_VNCLIP_VX)
+DECLARE_INSN(vwsmaccu_vx, MATCH_VWSMACCU_VX, MASK_VWSMACCU_VX)
+DECLARE_INSN(vwsmacc_vx, MATCH_VWSMACC_VX, MASK_VWSMACC_VX)
+DECLARE_INSN(vwsmaccsu_vx, MATCH_VWSMACCSU_VX, MASK_VWSMACCSU_VX)
+DECLARE_INSN(vwsmaccus_vx, MATCH_VWSMACCUS_VX, MASK_VWSMACCUS_VX)
+DECLARE_INSN(vadd_vv, MATCH_VADD_VV, MASK_VADD_VV)
+DECLARE_INSN(vsub_vv, MATCH_VSUB_VV, MASK_VSUB_VV)
+DECLARE_INSN(vminu_vv, MATCH_VMINU_VV, MASK_VMINU_VV)
+DECLARE_INSN(vmin_vv, MATCH_VMIN_VV, MASK_VMIN_VV)
+DECLARE_INSN(vmaxu_vv, MATCH_VMAXU_VV, MASK_VMAXU_VV)
+DECLARE_INSN(vmax_vv, MATCH_VMAX_VV, MASK_VMAX_VV)
+DECLARE_INSN(vand_vv, MATCH_VAND_VV, MASK_VAND_VV)
+DECLARE_INSN(vor_vv, MATCH_VOR_VV, MASK_VOR_VV)
+DECLARE_INSN(vxor_vv, MATCH_VXOR_VV, MASK_VXOR_VV)
+DECLARE_INSN(vrgather_vv, MATCH_VRGATHER_VV, MASK_VRGATHER_VV)
+DECLARE_INSN(vadc_vvm, MATCH_VADC_VVM, MASK_VADC_VVM)
+DECLARE_INSN(vmadc_vvm, MATCH_VMADC_VVM, MASK_VMADC_VVM)
+DECLARE_INSN(vsbc_vvm, MATCH_VSBC_VVM, MASK_VSBC_VVM)
+DECLARE_INSN(vmsbc_vvm, MATCH_VMSBC_VVM, MASK_VMSBC_VVM)
+DECLARE_INSN(vmerge_vvm, MATCH_VMERGE_VVM, MASK_VMERGE_VVM)
+DECLARE_INSN(vmv_v_v, MATCH_VMV_V_V, MASK_VMV_V_V)
+DECLARE_INSN(vmseq_vv, MATCH_VMSEQ_VV, MASK_VMSEQ_VV)
+DECLARE_INSN(vmsne_vv, MATCH_VMSNE_VV, MASK_VMSNE_VV)
+DECLARE_INSN(vmsltu_vv, MATCH_VMSLTU_VV, MASK_VMSLTU_VV)
+DECLARE_INSN(vmslt_vv, MATCH_VMSLT_VV, MASK_VMSLT_VV)
+DECLARE_INSN(vmsleu_vv, MATCH_VMSLEU_VV, MASK_VMSLEU_VV)
+DECLARE_INSN(vmsle_vv, MATCH_VMSLE_VV, MASK_VMSLE_VV)
+DECLARE_INSN(vsaddu_vv, MATCH_VSADDU_VV, MASK_VSADDU_VV)
+DECLARE_INSN(vsadd_vv, MATCH_VSADD_VV, MASK_VSADD_VV)
+DECLARE_INSN(vssubu_vv, MATCH_VSSUBU_VV, MASK_VSSUBU_VV)
+DECLARE_INSN(vssub_vv, MATCH_VSSUB_VV, MASK_VSSUB_VV)
+DECLARE_INSN(vaadd_vv, MATCH_VAADD_VV, MASK_VAADD_VV)
+DECLARE_INSN(vsll_vv, MATCH_VSLL_VV, MASK_VSLL_VV)
+DECLARE_INSN(vasub_vv, MATCH_VASUB_VV, MASK_VASUB_VV)
+DECLARE_INSN(vsmul_vv, MATCH_VSMUL_VV, MASK_VSMUL_VV)
+DECLARE_INSN(vsrl_vv, MATCH_VSRL_VV, MASK_VSRL_VV)
+DECLARE_INSN(vsra_vv, MATCH_VSRA_VV, MASK_VSRA_VV)
+DECLARE_INSN(vssrl_vv, MATCH_VSSRL_VV, MASK_VSSRL_VV)
+DECLARE_INSN(vssra_vv, MATCH_VSSRA_VV, MASK_VSSRA_VV)
+DECLARE_INSN(vnsrl_vv, MATCH_VNSRL_VV, MASK_VNSRL_VV)
+DECLARE_INSN(vnsra_vv, MATCH_VNSRA_VV, MASK_VNSRA_VV)
+DECLARE_INSN(vnclipu_vv, MATCH_VNCLIPU_VV, MASK_VNCLIPU_VV)
+DECLARE_INSN(vnclip_vv, MATCH_VNCLIP_VV, MASK_VNCLIP_VV)
+DECLARE_INSN(vwredsumu_vs, MATCH_VWREDSUMU_VS, MASK_VWREDSUMU_VS)
+DECLARE_INSN(vwredsum_vs, MATCH_VWREDSUM_VS, MASK_VWREDSUM_VS)
+DECLARE_INSN(vdotu_vv, MATCH_VDOTU_VV, MASK_VDOTU_VV)
+DECLARE_INSN(vdot_vv, MATCH_VDOT_VV, MASK_VDOT_VV)
+DECLARE_INSN(vwsmaccu_vv, MATCH_VWSMACCU_VV, MASK_VWSMACCU_VV)
+DECLARE_INSN(vwsmacc_vv, MATCH_VWSMACC_VV, MASK_VWSMACC_VV)
+DECLARE_INSN(vwsmaccsu_vv, MATCH_VWSMACCSU_VV, MASK_VWSMACCSU_VV)
+DECLARE_INSN(vadd_vi, MATCH_VADD_VI, MASK_VADD_VI)
+DECLARE_INSN(vrsub_vi, MATCH_VRSUB_VI, MASK_VRSUB_VI)
+DECLARE_INSN(vand_vi, MATCH_VAND_VI, MASK_VAND_VI)
+DECLARE_INSN(vor_vi, MATCH_VOR_VI, MASK_VOR_VI)
+DECLARE_INSN(vxor_vi, MATCH_VXOR_VI, MASK_VXOR_VI)
+DECLARE_INSN(vrgather_vi, MATCH_VRGATHER_VI, MASK_VRGATHER_VI)
+DECLARE_INSN(vslideup_vi, MATCH_VSLIDEUP_VI, MASK_VSLIDEUP_VI)
+DECLARE_INSN(vslidedown_vi, MATCH_VSLIDEDOWN_VI, MASK_VSLIDEDOWN_VI)
+DECLARE_INSN(vadc_vim, MATCH_VADC_VIM, MASK_VADC_VIM)
+DECLARE_INSN(vmadc_vim, MATCH_VMADC_VIM, MASK_VMADC_VIM)
+DECLARE_INSN(vmerge_vim, MATCH_VMERGE_VIM, MASK_VMERGE_VIM)
+DECLARE_INSN(vmv_v_i, MATCH_VMV_V_I, MASK_VMV_V_I)
+DECLARE_INSN(vmseq_vi, MATCH_VMSEQ_VI, MASK_VMSEQ_VI)
+DECLARE_INSN(vmsne_vi, MATCH_VMSNE_VI, MASK_VMSNE_VI)
+DECLARE_INSN(vmsleu_vi, MATCH_VMSLEU_VI, MASK_VMSLEU_VI)
+DECLARE_INSN(vmsle_vi, MATCH_VMSLE_VI, MASK_VMSLE_VI)
+DECLARE_INSN(vmsgtu_vi, MATCH_VMSGTU_VI, MASK_VMSGTU_VI)
+DECLARE_INSN(vmsgt_vi, MATCH_VMSGT_VI, MASK_VMSGT_VI)
+DECLARE_INSN(vsaddu_vi, MATCH_VSADDU_VI, MASK_VSADDU_VI)
+DECLARE_INSN(vsadd_vi, MATCH_VSADD_VI, MASK_VSADD_VI)
+DECLARE_INSN(vaadd_vi, MATCH_VAADD_VI, MASK_VAADD_VI)
+DECLARE_INSN(vsll_vi, MATCH_VSLL_VI, MASK_VSLL_VI)
+DECLARE_INSN(vsrl_vi, MATCH_VSRL_VI, MASK_VSRL_VI)
+DECLARE_INSN(vsra_vi, MATCH_VSRA_VI, MASK_VSRA_VI)
+DECLARE_INSN(vssrl_vi, MATCH_VSSRL_VI, MASK_VSSRL_VI)
+DECLARE_INSN(vssra_vi, MATCH_VSSRA_VI, MASK_VSSRA_VI)
+DECLARE_INSN(vnsrl_vi, MATCH_VNSRL_VI, MASK_VNSRL_VI)
+DECLARE_INSN(vnsra_vi, MATCH_VNSRA_VI, MASK_VNSRA_VI)
+DECLARE_INSN(vnclipu_vi, MATCH_VNCLIPU_VI, MASK_VNCLIPU_VI)
+DECLARE_INSN(vnclip_vi, MATCH_VNCLIP_VI, MASK_VNCLIP_VI)
+DECLARE_INSN(vredsum_vs, MATCH_VREDSUM_VS, MASK_VREDSUM_VS)
+DECLARE_INSN(vredand_vs, MATCH_VREDAND_VS, MASK_VREDAND_VS)
+DECLARE_INSN(vredor_vs, MATCH_VREDOR_VS, MASK_VREDOR_VS)
+DECLARE_INSN(vredxor_vs, MATCH_VREDXOR_VS, MASK_VREDXOR_VS)
+DECLARE_INSN(vredminu_vs, MATCH_VREDMINU_VS, MASK_VREDMINU_VS)
+DECLARE_INSN(vredmin_vs, MATCH_VREDMIN_VS, MASK_VREDMIN_VS)
+DECLARE_INSN(vredmaxu_vs, MATCH_VREDMAXU_VS, MASK_VREDMAXU_VS)
+DECLARE_INSN(vredmax_vs, MATCH_VREDMAX_VS, MASK_VREDMAX_VS)
+DECLARE_INSN(vext_x_v, MATCH_VEXT_X_V, MASK_VEXT_X_V)
+DECLARE_INSN(vmpopc_m, MATCH_VMPOPC_M, MASK_VMPOPC_M)
+DECLARE_INSN(vmfirst_m, MATCH_VMFIRST_M, MASK_VMFIRST_M)
+DECLARE_INSN(vcompress_vm, MATCH_VCOMPRESS_VM, MASK_VCOMPRESS_VM)
+DECLARE_INSN(vmandnot_mm, MATCH_VMANDNOT_MM, MASK_VMANDNOT_MM)
+DECLARE_INSN(vmand_mm, MATCH_VMAND_MM, MASK_VMAND_MM)
+DECLARE_INSN(vmor_mm, MATCH_VMOR_MM, MASK_VMOR_MM)
+DECLARE_INSN(vmxor_mm, MATCH_VMXOR_MM, MASK_VMXOR_MM)
+DECLARE_INSN(vmornot_mm, MATCH_VMORNOT_MM, MASK_VMORNOT_MM)
+DECLARE_INSN(vmnand_mm, MATCH_VMNAND_MM, MASK_VMNAND_MM)
+DECLARE_INSN(vmnor_mm, MATCH_VMNOR_MM, MASK_VMNOR_MM)
+DECLARE_INSN(vmxnor_mm, MATCH_VMXNOR_MM, MASK_VMXNOR_MM)
+DECLARE_INSN(vmsbf_m, MATCH_VMSBF_M, MASK_VMSBF_M)
+DECLARE_INSN(vmsof_m, MATCH_VMSOF_M, MASK_VMSOF_M)
+DECLARE_INSN(vmsif_m, MATCH_VMSIF_M, MASK_VMSIF_M)
+DECLARE_INSN(viota_m, MATCH_VIOTA_M, MASK_VIOTA_M)
+DECLARE_INSN(vid_v, MATCH_VID_V, MASK_VID_V)
+DECLARE_INSN(vdivu_vv, MATCH_VDIVU_VV, MASK_VDIVU_VV)
+DECLARE_INSN(vdiv_vv, MATCH_VDIV_VV, MASK_VDIV_VV)
+DECLARE_INSN(vremu_vv, MATCH_VREMU_VV, MASK_VREMU_VV)
+DECLARE_INSN(vrem_vv, MATCH_VREM_VV, MASK_VREM_VV)
+DECLARE_INSN(vmulhu_vv, MATCH_VMULHU_VV, MASK_VMULHU_VV)
+DECLARE_INSN(vmul_vv, MATCH_VMUL_VV, MASK_VMUL_VV)
+DECLARE_INSN(vmulhsu_vv, MATCH_VMULHSU_VV, MASK_VMULHSU_VV)
+DECLARE_INSN(vmulh_vv, MATCH_VMULH_VV, MASK_VMULH_VV)
+DECLARE_INSN(vmadd_vv, MATCH_VMADD_VV, MASK_VMADD_VV)
+DECLARE_INSN(vnmsub_vv, MATCH_VNMSUB_VV, MASK_VNMSUB_VV)
+DECLARE_INSN(vmacc_vv, MATCH_VMACC_VV, MASK_VMACC_VV)
+DECLARE_INSN(vnmsac_vv, MATCH_VNMSAC_VV, MASK_VNMSAC_VV)
+DECLARE_INSN(vwaddu_vv, MATCH_VWADDU_VV, MASK_VWADDU_VV)
+DECLARE_INSN(vwadd_vv, MATCH_VWADD_VV, MASK_VWADD_VV)
+DECLARE_INSN(vwsubu_vv, MATCH_VWSUBU_VV, MASK_VWSUBU_VV)
+DECLARE_INSN(vwsub_vv, MATCH_VWSUB_VV, MASK_VWSUB_VV)
+DECLARE_INSN(vwaddu_wv, MATCH_VWADDU_WV, MASK_VWADDU_WV)
+DECLARE_INSN(vwadd_wv, MATCH_VWADD_WV, MASK_VWADD_WV)
+DECLARE_INSN(vwsubu_wv, MATCH_VWSUBU_WV, MASK_VWSUBU_WV)
+DECLARE_INSN(vwsub_wv, MATCH_VWSUB_WV, MASK_VWSUB_WV)
+DECLARE_INSN(vwmulu_vv, MATCH_VWMULU_VV, MASK_VWMULU_VV)
+DECLARE_INSN(vwmulsu_vv, MATCH_VWMULSU_VV, MASK_VWMULSU_VV)
+DECLARE_INSN(vwmul_vv, MATCH_VWMUL_VV, MASK_VWMUL_VV)
+DECLARE_INSN(vwmaccu_vv, MATCH_VWMACCU_VV, MASK_VWMACCU_VV)
+DECLARE_INSN(vwmacc_vv, MATCH_VWMACC_VV, MASK_VWMACC_VV)
+DECLARE_INSN(vwmaccsu_vv, MATCH_VWMACCSU_VV, MASK_VWMACCSU_VV)
+DECLARE_INSN(vmv_s_x, MATCH_VMV_S_X, MASK_VMV_S_X)
+DECLARE_INSN(vslide1up_vx, MATCH_VSLIDE1UP_VX, MASK_VSLIDE1UP_VX)
+DECLARE_INSN(vslide1down_vx, MATCH_VSLIDE1DOWN_VX, MASK_VSLIDE1DOWN_VX)
+DECLARE_INSN(vdivu_vx, MATCH_VDIVU_VX, MASK_VDIVU_VX)
+DECLARE_INSN(vdiv_vx, MATCH_VDIV_VX, MASK_VDIV_VX)
+DECLARE_INSN(vremu_vx, MATCH_VREMU_VX, MASK_VREMU_VX)
+DECLARE_INSN(vrem_vx, MATCH_VREM_VX, MASK_VREM_VX)
+DECLARE_INSN(vmulhu_vx, MATCH_VMULHU_VX, MASK_VMULHU_VX)
+DECLARE_INSN(vmul_vx, MATCH_VMUL_VX, MASK_VMUL_VX)
+DECLARE_INSN(vmulhsu_vx, MATCH_VMULHSU_VX, MASK_VMULHSU_VX)
+DECLARE_INSN(vmulh_vx, MATCH_VMULH_VX, MASK_VMULH_VX)
+DECLARE_INSN(vmadd_vx, MATCH_VMADD_VX, MASK_VMADD_VX)
+DECLARE_INSN(vnmsub_vx, MATCH_VNMSUB_VX, MASK_VNMSUB_VX)
+DECLARE_INSN(vmacc_vx, MATCH_VMACC_VX, MASK_VMACC_VX)
+DECLARE_INSN(vnmsac_vx, MATCH_VNMSAC_VX, MASK_VNMSAC_VX)
+DECLARE_INSN(vwaddu_vx, MATCH_VWADDU_VX, MASK_VWADDU_VX)
+DECLARE_INSN(vwadd_vx, MATCH_VWADD_VX, MASK_VWADD_VX)
+DECLARE_INSN(vwsubu_vx, MATCH_VWSUBU_VX, MASK_VWSUBU_VX)
+DECLARE_INSN(vwsub_vx, MATCH_VWSUB_VX, MASK_VWSUB_VX)
+DECLARE_INSN(vwaddu_wx, MATCH_VWADDU_WX, MASK_VWADDU_WX)
+DECLARE_INSN(vwadd_wx, MATCH_VWADD_WX, MASK_VWADD_WX)
+DECLARE_INSN(vwsubu_wx, MATCH_VWSUBU_WX, MASK_VWSUBU_WX)
+DECLARE_INSN(vwsub_wx, MATCH_VWSUB_WX, MASK_VWSUB_WX)
+DECLARE_INSN(vwmulu_vx, MATCH_VWMULU_VX, MASK_VWMULU_VX)
+DECLARE_INSN(vwmulsu_vx, MATCH_VWMULSU_VX, MASK_VWMULSU_VX)
+DECLARE_INSN(vwmul_vx, MATCH_VWMUL_VX, MASK_VWMUL_VX)
+DECLARE_INSN(vwmaccu_vx, MATCH_VWMACCU_VX, MASK_VWMACCU_VX)
+DECLARE_INSN(vwmacc_vx, MATCH_VWMACC_VX, MASK_VWMACC_VX)
+DECLARE_INSN(vwmaccsu_vx, MATCH_VWMACCSU_VX, MASK_VWMACCSU_VX)
+DECLARE_INSN(vwmaccus_vx, MATCH_VWMACCUS_VX, MASK_VWMACCUS_VX)
+DECLARE_INSN(vamoswapw_v, MATCH_VAMOSWAPW_V, MASK_VAMOSWAPW_V)
+DECLARE_INSN(vamoaddw_v, MATCH_VAMOADDW_V, MASK_VAMOADDW_V)
+DECLARE_INSN(vamoxorw_v, MATCH_VAMOXORW_V, MASK_VAMOXORW_V)
+DECLARE_INSN(vamoandw_v, MATCH_VAMOANDW_V, MASK_VAMOANDW_V)
+DECLARE_INSN(vamoorw_v, MATCH_VAMOORW_V, MASK_VAMOORW_V)
+DECLARE_INSN(vamominw_v, MATCH_VAMOMINW_V, MASK_VAMOMINW_V)
+DECLARE_INSN(vamomaxw_v, MATCH_VAMOMAXW_V, MASK_VAMOMAXW_V)
+DECLARE_INSN(vamominuw_v, MATCH_VAMOMINUW_V, MASK_VAMOMINUW_V)
+DECLARE_INSN(vamomaxuw_v, MATCH_VAMOMAXUW_V, MASK_VAMOMAXUW_V)
+DECLARE_INSN(vamoswapd_v, MATCH_VAMOSWAPD_V, MASK_VAMOSWAPD_V)
+DECLARE_INSN(vamoaddd_v, MATCH_VAMOADDD_V, MASK_VAMOADDD_V)
+DECLARE_INSN(vamoxord_v, MATCH_VAMOXORD_V, MASK_VAMOXORD_V)
+DECLARE_INSN(vamoandd_v, MATCH_VAMOANDD_V, MASK_VAMOANDD_V)
+DECLARE_INSN(vamoord_v, MATCH_VAMOORD_V, MASK_VAMOORD_V)
+DECLARE_INSN(vamomind_v, MATCH_VAMOMIND_V, MASK_VAMOMIND_V)
+DECLARE_INSN(vamomaxd_v, MATCH_VAMOMAXD_V, MASK_VAMOMAXD_V)
+DECLARE_INSN(vamominud_v, MATCH_VAMOMINUD_V, MASK_VAMOMINUD_V)
+DECLARE_INSN(vamomaxud_v, MATCH_VAMOMAXUD_V, MASK_VAMOMAXUD_V)
+#ifdef ZVAMO
+DECLARE_INSN(vamoswapq_v, MATCH_VAMOSWAPQ_V, MASK_VAMOSWAPQ_V)
+DECLARE_INSN(vamoaddq_v, MATCH_VAMOADDQ_V, MASK_VAMOADDQ_V)
+DECLARE_INSN(vamoxorq_v, MATCH_VAMOXORQ_V, MASK_VAMOXORQ_V)
+DECLARE_INSN(vamoandq_v, MATCH_VAMOANDQ_V, MASK_VAMOANDQ_V)
+DECLARE_INSN(vamoorq_v, MATCH_VAMOORQ_V, MASK_VAMOORQ_V)
+DECLARE_INSN(vamominq_v, MATCH_VAMOMINQ_V, MASK_VAMOMINQ_V)
+DECLARE_INSN(vamomaxq_v, MATCH_VAMOMAXQ_V, MASK_VAMOMAXQ_V)
+DECLARE_INSN(vamominuq_v, MATCH_VAMOMINUQ_V, MASK_VAMOMINUQ_V)
+DECLARE_INSN(vamomaxuq_v, MATCH_VAMOMAXUQ_V, MASK_VAMOMAXUQ_V)
+#endif
+#endif
diff --git a/arch/riscv/kernel/soft_vector/insn_list.h b/arch/riscv/kernel/soft_vector/insn_list.h
new file mode 100755
index 000000000..173203e3b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insn_list.h
@@ -0,0 +1,361 @@
+/*generated by shell*/
+DEFINE_INSN(vaadd_vi)
+DEFINE_INSN(vaadd_vv)
+DEFINE_INSN(vaadd_vx)
+DEFINE_INSN(vadc_vim)
+DEFINE_INSN(vadc_vvm)
+DEFINE_INSN(vadc_vxm)
+DEFINE_INSN(vadd_vi)
+DEFINE_INSN(vadd_vv)
+DEFINE_INSN(vadd_vx)
+DEFINE_INSN(vand_vi)
+DEFINE_INSN(vand_vv)
+DEFINE_INSN(vand_vx)
+DEFINE_INSN(vasub_vv)
+DEFINE_INSN(vasub_vx)
+DEFINE_INSN(vcompress_vm)
+DEFINE_INSN(vdiv_vv)
+DEFINE_INSN(vdiv_vx)
+DEFINE_INSN(vdivu_vv)
+DEFINE_INSN(vdivu_vx)
+DEFINE_INSN(vdot_vv)
+DEFINE_INSN(vdotu_vv)
+DEFINE_INSN(vext_x_v)
+DEFINE_INSN(vid_v)
+DEFINE_INSN(viota_m)
+DEFINE_INSN(vmacc_vv)
+DEFINE_INSN(vmacc_vx)
+DEFINE_INSN(vmadc_vim)
+DEFINE_INSN(vmadc_vvm)
+DEFINE_INSN(vmadc_vxm)
+DEFINE_INSN(vmadd_vv)
+DEFINE_INSN(vmadd_vx)
+DEFINE_INSN(vmand_mm)
+DEFINE_INSN(vmandnot_mm)
+DEFINE_INSN(vmax_vv)
+DEFINE_INSN(vmax_vx)
+DEFINE_INSN(vmaxu_vv)
+DEFINE_INSN(vmaxu_vx)
+DEFINE_INSN(vmerge_vim)
+DEFINE_INSN(vmerge_vvm)
+DEFINE_INSN(vmerge_vxm)
+DEFINE_INSN(vmfirst_m)
+DEFINE_INSN(vmin_vv)
+DEFINE_INSN(vmin_vx)
+DEFINE_INSN(vminu_vv)
+DEFINE_INSN(vminu_vx)
+DEFINE_INSN(vmnand_mm)
+DEFINE_INSN(vmnor_mm)
+DEFINE_INSN(vmor_mm)
+DEFINE_INSN(vmornot_mm)
+DEFINE_INSN(vmpopc_m)
+DEFINE_INSN(vmsbc_vvm)
+DEFINE_INSN(vmsbc_vxm)
+DEFINE_INSN(vmsbf_m)
+DEFINE_INSN(vmseq_vi)
+DEFINE_INSN(vmseq_vv)
+DEFINE_INSN(vmseq_vx)
+DEFINE_INSN(vmsgt_vi)
+DEFINE_INSN(vmsgt_vx)
+DEFINE_INSN(vmsgtu_vi)
+DEFINE_INSN(vmsgtu_vx)
+DEFINE_INSN(vmsif_m)
+DEFINE_INSN(vmsle_vi)
+DEFINE_INSN(vmsle_vv)
+DEFINE_INSN(vmsle_vx)
+DEFINE_INSN(vmsleu_vi)
+DEFINE_INSN(vmsleu_vv)
+DEFINE_INSN(vmsleu_vx)
+DEFINE_INSN(vmslt_vv)
+DEFINE_INSN(vmslt_vx)
+DEFINE_INSN(vmsltu_vv)
+DEFINE_INSN(vmsltu_vx)
+DEFINE_INSN(vmsne_vi)
+DEFINE_INSN(vmsne_vv)
+DEFINE_INSN(vmsne_vx)
+DEFINE_INSN(vmsof_m)
+DEFINE_INSN(vmul_vv)
+DEFINE_INSN(vmul_vx)
+DEFINE_INSN(vmulh_vv)
+DEFINE_INSN(vmulh_vx)
+DEFINE_INSN(vmulhsu_vv)
+DEFINE_INSN(vmulhsu_vx)
+DEFINE_INSN(vmulhu_vv)
+DEFINE_INSN(vmulhu_vx)
+DEFINE_INSN(vmv_s_x)
+DEFINE_INSN(vmv_v_i)
+DEFINE_INSN(vmv_v_v)
+DEFINE_INSN(vmv_v_x)
+DEFINE_INSN(vmxnor_mm)
+DEFINE_INSN(vmxor_mm)
+DEFINE_INSN(vnclip_vi)
+DEFINE_INSN(vnclip_vv)
+DEFINE_INSN(vnclip_vx)
+DEFINE_INSN(vnclipu_vi)
+DEFINE_INSN(vnclipu_vv)
+DEFINE_INSN(vnclipu_vx)
+DEFINE_INSN(vnmsac_vv)
+DEFINE_INSN(vnmsac_vx)
+DEFINE_INSN(vnmsub_vv)
+DEFINE_INSN(vnmsub_vx)
+DEFINE_INSN(vnsra_vi)
+DEFINE_INSN(vnsra_vv)
+DEFINE_INSN(vnsra_vx)
+DEFINE_INSN(vnsrl_vi)
+DEFINE_INSN(vnsrl_vv)
+DEFINE_INSN(vnsrl_vx)
+DEFINE_INSN(vor_vi)
+DEFINE_INSN(vor_vv)
+DEFINE_INSN(vor_vx)
+DEFINE_INSN(vredand_vs)
+DEFINE_INSN(vredmax_vs)
+DEFINE_INSN(vredmaxu_vs)
+DEFINE_INSN(vredmin_vs)
+DEFINE_INSN(vredminu_vs)
+DEFINE_INSN(vredor_vs)
+DEFINE_INSN(vredsum_vs)
+DEFINE_INSN(vredxor_vs)
+DEFINE_INSN(vrem_vv)
+DEFINE_INSN(vrem_vx)
+DEFINE_INSN(vremu_vv)
+DEFINE_INSN(vremu_vx)
+DEFINE_INSN(vrgather_vi)
+DEFINE_INSN(vrgather_vv)
+DEFINE_INSN(vrgather_vx)
+DEFINE_INSN(vrsub_vi)
+DEFINE_INSN(vrsub_vx)
+DEFINE_INSN(vsadd_vi)
+DEFINE_INSN(vsadd_vv)
+DEFINE_INSN(vsadd_vx)
+DEFINE_INSN(vsaddu_vi)
+DEFINE_INSN(vsaddu_vv)
+DEFINE_INSN(vsaddu_vx)
+DEFINE_INSN(vsbc_vvm)
+DEFINE_INSN(vsbc_vxm)
+DEFINE_INSN(vslide1down_vx)
+DEFINE_INSN(vslide1up_vx)
+DEFINE_INSN(vslidedown_vi)
+DEFINE_INSN(vslidedown_vx)
+DEFINE_INSN(vslideup_vi)
+DEFINE_INSN(vslideup_vx)
+DEFINE_INSN(vsll_vi)
+DEFINE_INSN(vsll_vv)
+DEFINE_INSN(vsll_vx)
+DEFINE_INSN(vsmul_vv)
+DEFINE_INSN(vsmul_vx)
+DEFINE_INSN(vsra_vi)
+DEFINE_INSN(vsra_vv)
+DEFINE_INSN(vsra_vx)
+DEFINE_INSN(vsrl_vi)
+DEFINE_INSN(vsrl_vv)
+DEFINE_INSN(vsrl_vx)
+DEFINE_INSN(vssra_vi)
+DEFINE_INSN(vssra_vv)
+DEFINE_INSN(vssra_vx)
+DEFINE_INSN(vssrl_vi)
+DEFINE_INSN(vssrl_vv)
+DEFINE_INSN(vssrl_vx)
+DEFINE_INSN(vssub_vv)
+DEFINE_INSN(vssub_vx)
+DEFINE_INSN(vssubu_vv)
+DEFINE_INSN(vssubu_vx)
+DEFINE_INSN(vsub_vv)
+DEFINE_INSN(vsub_vx)
+DEFINE_INSN(vwadd_vv)
+DEFINE_INSN(vwadd_vx)
+DEFINE_INSN(vwadd_wv)
+DEFINE_INSN(vwadd_wx)
+DEFINE_INSN(vwaddu_vv)
+DEFINE_INSN(vwaddu_vx)
+DEFINE_INSN(vwaddu_wv)
+DEFINE_INSN(vwaddu_wx)
+DEFINE_INSN(vwmacc_vv)
+DEFINE_INSN(vwmacc_vx)
+DEFINE_INSN(vwmaccsu_vv)
+DEFINE_INSN(vwmaccsu_vx)
+DEFINE_INSN(vwmaccu_vv)
+DEFINE_INSN(vwmaccu_vx)
+DEFINE_INSN(vwmaccus_vx)
+DEFINE_INSN(vwmul_vv)
+DEFINE_INSN(vwmul_vx)
+DEFINE_INSN(vwmulsu_vv)
+DEFINE_INSN(vwmulsu_vx)
+DEFINE_INSN(vwmulu_vv)
+DEFINE_INSN(vwmulu_vx)
+DEFINE_INSN(vwredsum_vs)
+DEFINE_INSN(vwredsumu_vs)
+DEFINE_INSN(vwsmacc_vv)
+DEFINE_INSN(vwsmacc_vx)
+DEFINE_INSN(vwsmaccsu_vv)
+DEFINE_INSN(vwsmaccsu_vx)
+DEFINE_INSN(vwsmaccu_vv)
+DEFINE_INSN(vwsmaccu_vx)
+DEFINE_INSN(vwsmaccus_vx)
+DEFINE_INSN(vwsub_vv)
+DEFINE_INSN(vwsub_vx)
+DEFINE_INSN(vwsub_wv)
+DEFINE_INSN(vwsub_wx)
+DEFINE_INSN(vwsubu_vv)
+DEFINE_INSN(vwsubu_vx)
+DEFINE_INSN(vwsubu_wv)
+DEFINE_INSN(vwsubu_wx)
+DEFINE_INSN(vxor_vi)
+DEFINE_INSN(vxor_vv)
+DEFINE_INSN(vxor_vx)
+DEFINE_INSN(vfadd_vf)
+DEFINE_INSN(vfadd_vv)
+DEFINE_INSN(vfclass_v)
+DEFINE_INSN(vfcvt_f_x_v)
+DEFINE_INSN(vfcvt_f_xu_v)
+DEFINE_INSN(vfcvt_x_f_v)
+DEFINE_INSN(vfcvt_xu_f_v)
+DEFINE_INSN(vfdiv_vf)
+DEFINE_INSN(vfdiv_vv)
+DEFINE_INSN(vfdot_vv)
+DEFINE_INSN(vfmacc_vf)
+DEFINE_INSN(vfmacc_vv)
+DEFINE_INSN(vfmadd_vf)
+DEFINE_INSN(vfmadd_vv)
+DEFINE_INSN(vfmax_vf)
+DEFINE_INSN(vfmax_vv)
+DEFINE_INSN(vfmerge_vfm)
+DEFINE_INSN(vfmin_vf)
+DEFINE_INSN(vfmin_vv)
+DEFINE_INSN(vfmsac_vf)
+DEFINE_INSN(vfmsac_vv)
+DEFINE_INSN(vfmsub_vf)
+DEFINE_INSN(vfmsub_vv)
+DEFINE_INSN(vfmul_vf)
+DEFINE_INSN(vfmul_vv)
+DEFINE_INSN(vfmv_f_s)
+DEFINE_INSN(vfmv_s_f)
+DEFINE_INSN(vfmv_v_f)
+DEFINE_INSN(vfncvt_f_f_v)
+DEFINE_INSN(vfncvt_f_x_v)
+DEFINE_INSN(vfncvt_f_xu_v)
+DEFINE_INSN(vfncvt_x_f_v)
+DEFINE_INSN(vfncvt_xu_f_v)
+DEFINE_INSN(vfnmacc_vf)
+DEFINE_INSN(vfnmacc_vv)
+DEFINE_INSN(vfnmadd_vf)
+DEFINE_INSN(vfnmadd_vv)
+DEFINE_INSN(vfnmsac_vf)
+DEFINE_INSN(vfnmsac_vv)
+DEFINE_INSN(vfnmsub_vf)
+DEFINE_INSN(vfnmsub_vv)
+DEFINE_INSN(vfrdiv_vf)
+DEFINE_INSN(vfredmax_vs)
+DEFINE_INSN(vfredmin_vs)
+DEFINE_INSN(vfredosum_vs)
+DEFINE_INSN(vfredsum_vs)
+DEFINE_INSN(vfrsub_vf)
+DEFINE_INSN(vfsgnj_vf)
+DEFINE_INSN(vfsgnj_vv)
+DEFINE_INSN(vfsgnjn_vf)
+DEFINE_INSN(vfsgnjn_vv)
+DEFINE_INSN(vfsgnjx_vf)
+DEFINE_INSN(vfsgnjx_vv)
+DEFINE_INSN(vfsqrt_v)
+DEFINE_INSN(vfsub_vf)
+DEFINE_INSN(vfsub_vv)
+DEFINE_INSN(vfwadd_vf)
+DEFINE_INSN(vfwadd_vv)
+DEFINE_INSN(vfwadd_wf)
+DEFINE_INSN(vfwadd_wv)
+DEFINE_INSN(vfwcvt_f_f_v)
+DEFINE_INSN(vfwcvt_f_x_v)
+DEFINE_INSN(vfwcvt_f_xu_v)
+DEFINE_INSN(vfwcvt_x_f_v)
+DEFINE_INSN(vfwcvt_xu_f_v)
+DEFINE_INSN(vfwmacc_vf)
+DEFINE_INSN(vfwmacc_vv)
+DEFINE_INSN(vfwmsac_vf)
+DEFINE_INSN(vfwmsac_vv)
+DEFINE_INSN(vfwmul_vf)
+DEFINE_INSN(vfwmul_vv)
+DEFINE_INSN(vfwnmacc_vf)
+DEFINE_INSN(vfwnmacc_vv)
+DEFINE_INSN(vfwnmsac_vf)
+DEFINE_INSN(vfwnmsac_vv)
+DEFINE_INSN(vfwredosum_vs)
+DEFINE_INSN(vfwredsum_vs)
+DEFINE_INSN(vfwsub_vf)
+DEFINE_INSN(vfwsub_vv)
+DEFINE_INSN(vfwsub_wf)
+DEFINE_INSN(vfwsub_wv)
+DEFINE_INSN(vmfeq_vf)
+DEFINE_INSN(vmfeq_vv)
+DEFINE_INSN(vmfge_vf)
+DEFINE_INSN(vmfgt_vf)
+DEFINE_INSN(vmfle_vf)
+DEFINE_INSN(vmfle_vv)
+DEFINE_INSN(vmflt_vf)
+DEFINE_INSN(vmflt_vv)
+DEFINE_INSN(vmfne_vf)
+DEFINE_INSN(vmfne_vv)
+DEFINE_INSN(vmford_vf)
+DEFINE_INSN(vmford_vv)
+DEFINE_INSN(vlb_v)
+DEFINE_INSN(vlh_v)
+DEFINE_INSN(vlw_v)
+DEFINE_INSN(vle_v)
+DEFINE_INSN(vlbu_v)
+DEFINE_INSN(vlhu_v)
+DEFINE_INSN(vlwu_v)
+DEFINE_INSN(vlsb_v)
+DEFINE_INSN(vlsh_v)
+DEFINE_INSN(vlsw_v)
+DEFINE_INSN(vlse_v)
+DEFINE_INSN(vlxb_v)
+DEFINE_INSN(vlxh_v)
+DEFINE_INSN(vlxw_v)
+DEFINE_INSN(vlxe_v)
+DEFINE_INSN(vlsbu_v)
+DEFINE_INSN(vlshu_v)
+DEFINE_INSN(vlswu_v)
+DEFINE_INSN(vlxbu_v)
+DEFINE_INSN(vlxhu_v)
+DEFINE_INSN(vlxwu_v)
+DEFINE_INSN(vlbff_v)
+DEFINE_INSN(vlhff_v)
+DEFINE_INSN(vlwff_v)
+DEFINE_INSN(vleff_v)
+DEFINE_INSN(vlbuff_v)
+DEFINE_INSN(vlhuff_v)
+DEFINE_INSN(vlwuff_v)
+DEFINE_INSN(vsb_v)
+DEFINE_INSN(vsh_v)
+DEFINE_INSN(vsw_v)
+DEFINE_INSN(vse_v)
+DEFINE_INSN(vssb_v)
+DEFINE_INSN(vssh_v)
+DEFINE_INSN(vssw_v)
+DEFINE_INSN(vsse_v)
+DEFINE_INSN(vsxb_v)
+DEFINE_INSN(vsxh_v)
+DEFINE_INSN(vsxw_v)
+DEFINE_INSN(vsxe_v)
+DEFINE_INSN(vsuxb_v)
+DEFINE_INSN(vsuxh_v)
+DEFINE_INSN(vsuxw_v)
+DEFINE_INSN(vsuxe_v)
+DEFINE_INSN(vsetvli)
+DEFINE_INSN(vsetvl)
+DEFINE_INSN(vamoaddd_v)
+DEFINE_INSN(vamoandd_v)
+DEFINE_INSN(vamomaxd_v)
+DEFINE_INSN(vamomaxuw_v)
+DEFINE_INSN(vamomind_v)
+DEFINE_INSN(vamominuw_v)
+DEFINE_INSN(vamoord_v)
+DEFINE_INSN(vamoswapd_v)
+DEFINE_INSN(vamoxord_v)
+DEFINE_INSN(vamoaddw_v)
+DEFINE_INSN(vamoandw_v)
+DEFINE_INSN(vamomaxud_v)
+DEFINE_INSN(vamomaxw_v)
+DEFINE_INSN(vamominud_v)
+DEFINE_INSN(vamominw_v)
+DEFINE_INSN(vamoorw_v)
+DEFINE_INSN(vamoswapw_v)
+DEFINE_INSN(vamoxorw_v)
diff --git a/arch/riscv/kernel/soft_vector/insn_template.c b/arch/riscv/kernel/soft_vector/insn_template.c
new file mode 100755
index 000000000..b79f1ddaf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insn_template.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_NAME(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(OPCODE);
+  #include "../insns_func/NAME.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_NAME(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(OPCODE);
+  #include "../insns_func/NAME.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insn_template.h b/arch/riscv/kernel/soft_vector/insn_template.h
new file mode 100755
index 000000000..a6830627d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insn_template.h
@@ -0,0 +1,34 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "riscv_decode.h"
+#include "softfloat/softfloat.h"
+#include "softfloat/internals.h"
+#include "softfloat/specialize.h"
+#include <linux/printk.h>
diff --git a/arch/riscv/kernel/soft_vector/insns/Makefile b/arch/riscv/kernel/soft_vector/insns/Makefile
new file mode 100755
index 000000000..d6cecbe9b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/Makefile
@@ -0,0 +1,365 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the RISC-V Linux kernel
+#
+
+obj-$(CONFIG_VECTOR_EMU)    += vaadd_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vaadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vaadd_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vadc_vim.o
+obj-$(CONFIG_VECTOR_EMU)    += vadc_vvm.o
+obj-$(CONFIG_VECTOR_EMU)    += vadc_vxm.o
+obj-$(CONFIG_VECTOR_EMU)    += vadd_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vadd_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vand_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vand_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vand_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vasub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vasub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vcompress_vm.o
+obj-$(CONFIG_VECTOR_EMU)    += vdiv_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vdiv_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vdivu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vdivu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vdot_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vdotu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vext_x_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vid_v.o
+obj-$(CONFIG_VECTOR_EMU)    += viota_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmacc_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmadc_vim.o
+obj-$(CONFIG_VECTOR_EMU)    += vmadc_vvm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmadc_vxm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmadd_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmand_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmandnot_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmax_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmax_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmaxu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmaxu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmerge_vim.o
+obj-$(CONFIG_VECTOR_EMU)    += vmerge_vvm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmerge_vxm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfirst_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmin_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmin_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vminu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vminu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmnand_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmnor_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmor_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmornot_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmpopc_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsbc_vvm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsbc_vxm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsbf_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmseq_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmseq_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmseq_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsgt_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsgt_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsgtu_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsgtu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsif_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsle_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsle_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsle_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsleu_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsleu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsleu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmslt_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmslt_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsltu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsltu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsne_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsne_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsne_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsof_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmul_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmul_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulh_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulh_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulhsu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulhsu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulhu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulhu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmv_s_x.o
+obj-$(CONFIG_VECTOR_EMU)    += vmv_v_i.o
+obj-$(CONFIG_VECTOR_EMU)    += vmv_v_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vmv_v_x.o
+obj-$(CONFIG_VECTOR_EMU)    += vmxnor_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmxor_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclip_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclip_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclip_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclipu_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclipu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclipu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vnmsac_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnmsac_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vnmsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnmsub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsra_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsra_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsra_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsrl_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsrl_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsrl_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vor_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vor_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vor_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vredand_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredmax_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredmaxu_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredmin_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredminu_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredor_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredsum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredxor_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vrem_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vrem_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vremu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vremu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vrgather_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vrgather_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vrgather_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vrsub_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vrsub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsadd_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vsadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsadd_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsaddu_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vsaddu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsaddu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsbc_vvm.o
+obj-$(CONFIG_VECTOR_EMU)    += vsbc_vxm.o
+obj-$(CONFIG_VECTOR_EMU)    += vslide1down_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vslide1up_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vslidedown_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vslidedown_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vslideup_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vslideup_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsll_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vsll_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsll_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsmul_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsmul_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsra_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vsra_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsra_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsrl_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vsrl_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsrl_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vssra_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vssra_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vssra_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vssrl_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vssrl_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vssrl_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vssub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vssub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vssubu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vssubu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwadd_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwadd_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwadd_wx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwaddu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwaddu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwaddu_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwaddu_wx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmacc_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmaccsu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmaccsu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmaccu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmaccu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmaccus_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmul_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmul_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmulsu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmulsu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmulu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmulu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwredsum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vwredsumu_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmacc_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmaccsu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmaccsu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmaccu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmaccu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmaccus_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsub_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsub_wx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsubu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsubu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsubu_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsubu_wx.o
+obj-$(CONFIG_VECTOR_EMU)    += vxor_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vxor_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vxor_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vfadd_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfclass_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfcvt_f_x_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfcvt_f_xu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfcvt_x_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfcvt_xu_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfdiv_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfdiv_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfdot_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmacc_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmadd_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmax_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmax_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmerge_vfm.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmin_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmin_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmsac_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmsac_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmsub_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmul_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmul_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmv_f_s.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmv_s_f.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmv_v_f.o
+obj-$(CONFIG_VECTOR_EMU)    += vfncvt_f_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfncvt_f_x_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfncvt_f_xu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfncvt_x_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfncvt_xu_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmacc_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmadd_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmsac_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmsac_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmsub_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfrdiv_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfredmax_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfredmin_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfredosum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfredsum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfrsub_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnj_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnj_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnjn_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnjn_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnjx_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnjx_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsqrt_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsub_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwadd_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwadd_wf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwadd_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwcvt_f_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwcvt_f_x_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwcvt_f_xu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwcvt_x_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwcvt_xu_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmacc_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmsac_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmsac_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmul_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmul_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwnmacc_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwnmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwnmsac_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwnmsac_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwredosum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwredsum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwsub_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwsub_wf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwsub_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfeq_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfeq_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfge_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfgt_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfle_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfle_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmflt_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmflt_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfne_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfne_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmford_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmford_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vlb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vle_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlbu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlhu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlwu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlsb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlsh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlsw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlse_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxe_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlsbu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlshu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlswu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxbu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxhu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxwu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlbff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlhff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlwff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vleff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlbuff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlhuff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlwuff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vse_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vssb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vssh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vssw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsse_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsxb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsxh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsxw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsxe_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsuxb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsuxh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsuxw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsuxe_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsetvli.o
+obj-$(CONFIG_VECTOR_EMU)    += vsetvl.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoaddd_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoandd_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamomaxd_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamomaxuw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamomind_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamominuw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoord_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoswapd_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoxord_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoaddw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoandw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamomaxud_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamomaxw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamominud_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamominw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoorw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoswapw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoxorw_v.o
diff --git a/arch/riscv/kernel/soft_vector/insns/vaadd_vi.c b/arch/riscv/kernel/soft_vector/insns/vaadd_vi.c
new file mode 100755
index 000000000..c904163d3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vaadd_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vaadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAADD_VI);
+  #include "../insns_func/vaadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vaadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAADD_VI);
+  #include "../insns_func/vaadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vaadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vaadd_vv.c
new file mode 100755
index 000000000..3a9cb2a56
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vaadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vaadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAADD_VV);
+  #include "../insns_func/vaadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vaadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAADD_VV);
+  #include "../insns_func/vaadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vaadd_vx.c b/arch/riscv/kernel/soft_vector/insns/vaadd_vx.c
new file mode 100755
index 000000000..ebed76c6b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vaadd_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vaadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAADD_VX);
+  #include "../insns_func/vaadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vaadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAADD_VX);
+  #include "../insns_func/vaadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadc_vim.c b/arch/riscv/kernel/soft_vector/insns/vadc_vim.c
new file mode 100755
index 000000000..d96bcba23
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadc_vim.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadc_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADC_VIM);
+  #include "../insns_func/vadc_vim.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadc_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADC_VIM);
+  #include "../insns_func/vadc_vim.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadc_vvm.c b/arch/riscv/kernel/soft_vector/insns/vadc_vvm.c
new file mode 100755
index 000000000..bcbbf90b9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadc_vvm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADC_VVM);
+  #include "../insns_func/vadc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADC_VVM);
+  #include "../insns_func/vadc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadc_vxm.c b/arch/riscv/kernel/soft_vector/insns/vadc_vxm.c
new file mode 100755
index 000000000..eaf3fd62b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadc_vxm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADC_VXM);
+  #include "../insns_func/vadc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADC_VXM);
+  #include "../insns_func/vadc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadd_vi.c b/arch/riscv/kernel/soft_vector/insns/vadd_vi.c
new file mode 100755
index 000000000..0f047471f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadd_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADD_VI);
+  #include "../insns_func/vadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADD_VI);
+  #include "../insns_func/vadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vadd_vv.c
new file mode 100755
index 000000000..6a66b619a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADD_VV);
+  #include "../insns_func/vadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADD_VV);
+  #include "../insns_func/vadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadd_vx.c b/arch/riscv/kernel/soft_vector/insns/vadd_vx.c
new file mode 100755
index 000000000..b9d82ec9b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadd_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADD_VX);
+  #include "../insns_func/vadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADD_VX);
+  #include "../insns_func/vadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoaddd_v.c b/arch/riscv/kernel/soft_vector/insns/vamoaddd_v.c
new file mode 100755
index 000000000..56546cfbf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoaddd_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoaddd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOADDD_V);
+  #include "../insns_func/vamoaddd_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoaddd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOADDD_V);
+  #include "../insns_func/vamoaddd_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoaddw_v.c b/arch/riscv/kernel/soft_vector/insns/vamoaddw_v.c
new file mode 100755
index 000000000..e744705ce
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoaddw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoaddw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOADDW_V);
+  #include "../insns_func/vamoaddw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoaddw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOADDW_V);
+  #include "../insns_func/vamoaddw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoandd_v.c b/arch/riscv/kernel/soft_vector/insns/vamoandd_v.c
new file mode 100755
index 000000000..c48c4b951
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoandd_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoandd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOANDD_V);
+  #include "../insns_func/vamoandd_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoandd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOANDD_V);
+  #include "../insns_func/vamoandd_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoandw_v.c b/arch/riscv/kernel/soft_vector/insns/vamoandw_v.c
new file mode 100755
index 000000000..892b61c56
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoandw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoandw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOANDW_V);
+  #include "../insns_func/vamoandw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoandw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOANDW_V);
+  #include "../insns_func/vamoandw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamomaxd_v.c b/arch/riscv/kernel/soft_vector/insns/vamomaxd_v.c
new file mode 100755
index 000000000..bb862afd2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamomaxd_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamomaxd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMAXD_V);
+  #include "../insns_func/vamomaxd_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamomaxd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMAXD_V);
+  #include "../insns_func/vamomaxd_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamomaxud_v.c b/arch/riscv/kernel/soft_vector/insns/vamomaxud_v.c
new file mode 100755
index 000000000..31032e940
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamomaxud_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamomaxud_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMAXUD_V);
+  #include "../insns_func/vamomaxud_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamomaxud_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMAXUD_V);
+  #include "../insns_func/vamomaxud_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamomaxuw_v.c b/arch/riscv/kernel/soft_vector/insns/vamomaxuw_v.c
new file mode 100755
index 000000000..919351ab2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamomaxuw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamomaxuw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMAXUW_V);
+  #include "../insns_func/vamomaxuw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamomaxuw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMAXUW_V);
+  #include "../insns_func/vamomaxuw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamomaxw_v.c b/arch/riscv/kernel/soft_vector/insns/vamomaxw_v.c
new file mode 100755
index 000000000..ff434a403
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamomaxw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamomaxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMAXW_V);
+  #include "../insns_func/vamomaxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamomaxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMAXW_V);
+  #include "../insns_func/vamomaxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamomind_v.c b/arch/riscv/kernel/soft_vector/insns/vamomind_v.c
new file mode 100755
index 000000000..6b95c1ba2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamomind_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamomind_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMIND_V);
+  #include "../insns_func/vamomind_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamomind_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMIND_V);
+  #include "../insns_func/vamomind_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamominud_v.c b/arch/riscv/kernel/soft_vector/insns/vamominud_v.c
new file mode 100755
index 000000000..1f3eb428c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamominud_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamominud_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMINUD_V);
+  #include "../insns_func/vamominud_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamominud_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMINUD_V);
+  #include "../insns_func/vamominud_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamominuw_v.c b/arch/riscv/kernel/soft_vector/insns/vamominuw_v.c
new file mode 100755
index 000000000..cb3ae8e2a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamominuw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamominuw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMINUW_V);
+  #include "../insns_func/vamominuw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamominuw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMINUW_V);
+  #include "../insns_func/vamominuw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamominw_v.c b/arch/riscv/kernel/soft_vector/insns/vamominw_v.c
new file mode 100755
index 000000000..cc303d423
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamominw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamominw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMINW_V);
+  #include "../insns_func/vamominw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamominw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMINW_V);
+  #include "../insns_func/vamominw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoord_v.c b/arch/riscv/kernel/soft_vector/insns/vamoord_v.c
new file mode 100755
index 000000000..35f840094
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoord_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoord_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOORD_V);
+  #include "../insns_func/vamoord_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoord_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOORD_V);
+  #include "../insns_func/vamoord_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoorw_v.c b/arch/riscv/kernel/soft_vector/insns/vamoorw_v.c
new file mode 100755
index 000000000..c3c87e18f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoorw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoorw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOORW_V);
+  #include "../insns_func/vamoorw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoorw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOORW_V);
+  #include "../insns_func/vamoorw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoswapd_v.c b/arch/riscv/kernel/soft_vector/insns/vamoswapd_v.c
new file mode 100755
index 000000000..237fbfdb9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoswapd_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoswapd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOSWAPD_V);
+  #include "../insns_func/vamoswapd_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoswapd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOSWAPD_V);
+  #include "../insns_func/vamoswapd_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoswapw_v.c b/arch/riscv/kernel/soft_vector/insns/vamoswapw_v.c
new file mode 100755
index 000000000..667514a40
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoswapw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoswapw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOSWAPW_V);
+  #include "../insns_func/vamoswapw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoswapw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOSWAPW_V);
+  #include "../insns_func/vamoswapw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoxord_v.c b/arch/riscv/kernel/soft_vector/insns/vamoxord_v.c
new file mode 100755
index 000000000..3d3b137e0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoxord_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoxord_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOXORD_V);
+  #include "../insns_func/vamoxord_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoxord_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOXORD_V);
+  #include "../insns_func/vamoxord_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoxorw_v.c b/arch/riscv/kernel/soft_vector/insns/vamoxorw_v.c
new file mode 100755
index 000000000..65a0fc060
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoxorw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoxorw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOXORW_V);
+  #include "../insns_func/vamoxorw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoxorw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOXORW_V);
+  #include "../insns_func/vamoxorw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vand_vi.c b/arch/riscv/kernel/soft_vector/insns/vand_vi.c
new file mode 100755
index 000000000..b49d61678
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vand_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vand_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAND_VI);
+  #include "../insns_func/vand_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vand_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAND_VI);
+  #include "../insns_func/vand_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vand_vv.c b/arch/riscv/kernel/soft_vector/insns/vand_vv.c
new file mode 100755
index 000000000..5ddd363e4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vand_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vand_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAND_VV);
+  #include "../insns_func/vand_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vand_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAND_VV);
+  #include "../insns_func/vand_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vand_vx.c b/arch/riscv/kernel/soft_vector/insns/vand_vx.c
new file mode 100755
index 000000000..6faffd079
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vand_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vand_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAND_VX);
+  #include "../insns_func/vand_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vand_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAND_VX);
+  #include "../insns_func/vand_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vasub_vv.c b/arch/riscv/kernel/soft_vector/insns/vasub_vv.c
new file mode 100755
index 000000000..658969351
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vasub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vasub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VASUB_VV);
+  #include "../insns_func/vasub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vasub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VASUB_VV);
+  #include "../insns_func/vasub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vasub_vx.c b/arch/riscv/kernel/soft_vector/insns/vasub_vx.c
new file mode 100755
index 000000000..7ba745e4f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vasub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vasub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VASUB_VX);
+  #include "../insns_func/vasub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vasub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VASUB_VX);
+  #include "../insns_func/vasub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vcompress_vm.c b/arch/riscv/kernel/soft_vector/insns/vcompress_vm.c
new file mode 100755
index 000000000..b4364063f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vcompress_vm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vcompress_vm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VCOMPRESS_VM);
+  #include "../insns_func/vcompress_vm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vcompress_vm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VCOMPRESS_VM);
+  #include "../insns_func/vcompress_vm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdiv_vv.c b/arch/riscv/kernel/soft_vector/insns/vdiv_vv.c
new file mode 100755
index 000000000..53fb597b7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdiv_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdiv_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDIV_VV);
+  #include "../insns_func/vdiv_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdiv_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDIV_VV);
+  #include "../insns_func/vdiv_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdiv_vx.c b/arch/riscv/kernel/soft_vector/insns/vdiv_vx.c
new file mode 100755
index 000000000..6483d857d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdiv_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdiv_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDIV_VX);
+  #include "../insns_func/vdiv_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdiv_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDIV_VX);
+  #include "../insns_func/vdiv_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdivu_vv.c b/arch/riscv/kernel/soft_vector/insns/vdivu_vv.c
new file mode 100755
index 000000000..ed42933a5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdivu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdivu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDIVU_VV);
+  #include "../insns_func/vdivu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdivu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDIVU_VV);
+  #include "../insns_func/vdivu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdivu_vx.c b/arch/riscv/kernel/soft_vector/insns/vdivu_vx.c
new file mode 100755
index 000000000..d502b5e51
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdivu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdivu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDIVU_VX);
+  #include "../insns_func/vdivu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdivu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDIVU_VX);
+  #include "../insns_func/vdivu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdot_vv.c b/arch/riscv/kernel/soft_vector/insns/vdot_vv.c
new file mode 100755
index 000000000..cb67d3f3f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdot_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdot_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDOT_VV);
+  #include "../insns_func/vdot_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdot_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDOT_VV);
+  #include "../insns_func/vdot_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdotu_vv.c b/arch/riscv/kernel/soft_vector/insns/vdotu_vv.c
new file mode 100755
index 000000000..87eba04f0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdotu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdotu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDOTU_VV);
+  #include "../insns_func/vdotu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdotu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDOTU_VV);
+  #include "../insns_func/vdotu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vext_x_v.c b/arch/riscv/kernel/soft_vector/insns/vext_x_v.c
new file mode 100755
index 000000000..98b37e4b7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vext_x_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vext_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VEXT_X_V);
+  #include "../insns_func/vext_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vext_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VEXT_X_V);
+  #include "../insns_func/vext_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfadd_vf.c b/arch/riscv/kernel/soft_vector/insns/vfadd_vf.c
new file mode 100755
index 000000000..ca1ee97fe
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfadd_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFADD_VF);
+  #include "../insns_func/vfadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFADD_VF);
+  #include "../insns_func/vfadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vfadd_vv.c
new file mode 100755
index 000000000..31ccee558
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFADD_VV);
+  #include "../insns_func/vfadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFADD_VV);
+  #include "../insns_func/vfadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfclass_v.c b/arch/riscv/kernel/soft_vector/insns/vfclass_v.c
new file mode 100755
index 000000000..1b6dff824
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfclass_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfclass_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFCLASS_V);
+  #include "../insns_func/vfclass_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfclass_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFCLASS_V);
+  #include "../insns_func/vfclass_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfcvt_f_x_v.c b/arch/riscv/kernel/soft_vector/insns/vfcvt_f_x_v.c
new file mode 100755
index 000000000..7893b6985
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfcvt_f_x_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfcvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFCVT_F_X_V);
+  #include "../insns_func/vfcvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfcvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFCVT_F_X_V);
+  #include "../insns_func/vfcvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfcvt_f_xu_v.c b/arch/riscv/kernel/soft_vector/insns/vfcvt_f_xu_v.c
new file mode 100755
index 000000000..9bc200d13
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfcvt_f_xu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfcvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFCVT_F_XU_V);
+  #include "../insns_func/vfcvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfcvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFCVT_F_XU_V);
+  #include "../insns_func/vfcvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfcvt_x_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfcvt_x_f_v.c
new file mode 100755
index 000000000..7e63c105a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfcvt_x_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfcvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFCVT_X_F_V);
+  #include "../insns_func/vfcvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfcvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFCVT_X_F_V);
+  #include "../insns_func/vfcvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfcvt_xu_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfcvt_xu_f_v.c
new file mode 100755
index 000000000..17a129e24
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfcvt_xu_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfcvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFCVT_XU_F_V);
+  #include "../insns_func/vfcvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfcvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFCVT_XU_F_V);
+  #include "../insns_func/vfcvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfdiv_vf.c b/arch/riscv/kernel/soft_vector/insns/vfdiv_vf.c
new file mode 100755
index 000000000..30c36a3f1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfdiv_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfdiv_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFDIV_VF);
+  #include "../insns_func/vfdiv_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfdiv_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFDIV_VF);
+  #include "../insns_func/vfdiv_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfdiv_vv.c b/arch/riscv/kernel/soft_vector/insns/vfdiv_vv.c
new file mode 100755
index 000000000..0fc6172db
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfdiv_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfdiv_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFDIV_VV);
+  #include "../insns_func/vfdiv_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfdiv_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFDIV_VV);
+  #include "../insns_func/vfdiv_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfdot_vv.c b/arch/riscv/kernel/soft_vector/insns/vfdot_vv.c
new file mode 100755
index 000000000..e2f474e35
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfdot_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfdot_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFDOT_VV);
+  #include "../insns_func/vfdot_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfdot_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFDOT_VV);
+  #include "../insns_func/vfdot_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmacc_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmacc_vf.c
new file mode 100755
index 000000000..dccc0f401
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmacc_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMACC_VF);
+  #include "../insns_func/vfmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMACC_VF);
+  #include "../insns_func/vfmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmacc_vv.c
new file mode 100755
index 000000000..8d168ecd7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMACC_VV);
+  #include "../insns_func/vfmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMACC_VV);
+  #include "../insns_func/vfmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmadd_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmadd_vf.c
new file mode 100755
index 000000000..92f2688d9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmadd_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMADD_VF);
+  #include "../insns_func/vfmadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMADD_VF);
+  #include "../insns_func/vfmadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmadd_vv.c
new file mode 100755
index 000000000..bc3b9fa28
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMADD_VV);
+  #include "../insns_func/vfmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMADD_VV);
+  #include "../insns_func/vfmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmax_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmax_vf.c
new file mode 100755
index 000000000..d12f99cd7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmax_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmax_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMAX_VF);
+  #include "../insns_func/vfmax_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmax_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMAX_VF);
+  #include "../insns_func/vfmax_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmax_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmax_vv.c
new file mode 100755
index 000000000..15e4c976d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmax_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmax_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMAX_VV);
+  #include "../insns_func/vfmax_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmax_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMAX_VV);
+  #include "../insns_func/vfmax_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmerge_vfm.c b/arch/riscv/kernel/soft_vector/insns/vfmerge_vfm.c
new file mode 100755
index 000000000..f2399c61d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmerge_vfm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmerge_vfm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMERGE_VFM);
+  #include "../insns_func/vfmerge_vfm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmerge_vfm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMERGE_VFM);
+  #include "../insns_func/vfmerge_vfm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmin_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmin_vf.c
new file mode 100755
index 000000000..ca2766f98
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmin_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmin_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMIN_VF);
+  #include "../insns_func/vfmin_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmin_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMIN_VF);
+  #include "../insns_func/vfmin_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmin_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmin_vv.c
new file mode 100755
index 000000000..e2d26aa74
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmin_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmin_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMIN_VV);
+  #include "../insns_func/vfmin_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmin_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMIN_VV);
+  #include "../insns_func/vfmin_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmsac_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmsac_vf.c
new file mode 100755
index 000000000..822ac1403
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmsac_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMSAC_VF);
+  #include "../insns_func/vfmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMSAC_VF);
+  #include "../insns_func/vfmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmsac_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmsac_vv.c
new file mode 100755
index 000000000..c8b90d0cb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmsac_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMSAC_VV);
+  #include "../insns_func/vfmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMSAC_VV);
+  #include "../insns_func/vfmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmsub_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmsub_vf.c
new file mode 100755
index 000000000..5e07cef89
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmsub_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMSUB_VF);
+  #include "../insns_func/vfmsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMSUB_VF);
+  #include "../insns_func/vfmsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmsub_vv.c
new file mode 100755
index 000000000..de079023e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMSUB_VV);
+  #include "../insns_func/vfmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMSUB_VV);
+  #include "../insns_func/vfmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmul_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmul_vf.c
new file mode 100755
index 000000000..a4cd5ef03
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmul_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmul_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMUL_VF);
+  #include "../insns_func/vfmul_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmul_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMUL_VF);
+  #include "../insns_func/vfmul_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmul_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmul_vv.c
new file mode 100755
index 000000000..d02dc07e6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmul_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMUL_VV);
+  #include "../insns_func/vfmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMUL_VV);
+  #include "../insns_func/vfmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmv_f_s.c b/arch/riscv/kernel/soft_vector/insns/vfmv_f_s.c
new file mode 100755
index 000000000..359515895
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmv_f_s.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmv_f_s(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMV_F_S);
+  #include "../insns_func/vfmv_f_s.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmv_f_s(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMV_F_S);
+  #include "../insns_func/vfmv_f_s.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmv_s_f.c b/arch/riscv/kernel/soft_vector/insns/vfmv_s_f.c
new file mode 100755
index 000000000..c0b23e319
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmv_s_f.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmv_s_f(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMV_S_F);
+  #include "../insns_func/vfmv_s_f.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmv_s_f(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMV_S_F);
+  #include "../insns_func/vfmv_s_f.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmv_v_f.c b/arch/riscv/kernel/soft_vector/insns/vfmv_v_f.c
new file mode 100755
index 000000000..7cd7537fe
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmv_v_f.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmv_v_f(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMV_V_F);
+  #include "../insns_func/vfmv_v_f.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmv_v_f(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMV_V_F);
+  #include "../insns_func/vfmv_v_f.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfncvt_f_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_f_v.c
new file mode 100755
index 000000000..3e49f7862
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfncvt_f_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_F_V);
+  #include "../insns_func/vfncvt_f_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfncvt_f_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_F_V);
+  #include "../insns_func/vfncvt_f_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfncvt_f_x_v.c b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_x_v.c
new file mode 100755
index 000000000..0b421e8bb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_x_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfncvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_X_V);
+  #include "../insns_func/vfncvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfncvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_X_V);
+  #include "../insns_func/vfncvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfncvt_f_xu_v.c b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_xu_v.c
new file mode 100755
index 000000000..6d4f412a6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_xu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfncvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_XU_V);
+  #include "../insns_func/vfncvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfncvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_XU_V);
+  #include "../insns_func/vfncvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfncvt_x_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfncvt_x_f_v.c
new file mode 100755
index 000000000..5d1f6ee2c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfncvt_x_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfncvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNCVT_X_F_V);
+  #include "../insns_func/vfncvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfncvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNCVT_X_F_V);
+  #include "../insns_func/vfncvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfncvt_xu_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfncvt_xu_f_v.c
new file mode 100755
index 000000000..897518b08
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfncvt_xu_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfncvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNCVT_XU_F_V);
+  #include "../insns_func/vfncvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfncvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNCVT_XU_F_V);
+  #include "../insns_func/vfncvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmacc_vf.c b/arch/riscv/kernel/soft_vector/insns/vfnmacc_vf.c
new file mode 100755
index 000000000..d678cd2bf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmacc_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMACC_VF);
+  #include "../insns_func/vfnmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMACC_VF);
+  #include "../insns_func/vfnmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vfnmacc_vv.c
new file mode 100755
index 000000000..550a9e015
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMACC_VV);
+  #include "../insns_func/vfnmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMACC_VV);
+  #include "../insns_func/vfnmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmadd_vf.c b/arch/riscv/kernel/soft_vector/insns/vfnmadd_vf.c
new file mode 100755
index 000000000..b76308859
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmadd_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMADD_VF);
+  #include "../insns_func/vfnmadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMADD_VF);
+  #include "../insns_func/vfnmadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vfnmadd_vv.c
new file mode 100755
index 000000000..0bdd694ea
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMADD_VV);
+  #include "../insns_func/vfnmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMADD_VV);
+  #include "../insns_func/vfnmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmsac_vf.c b/arch/riscv/kernel/soft_vector/insns/vfnmsac_vf.c
new file mode 100755
index 000000000..727ffe4f4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmsac_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMSAC_VF);
+  #include "../insns_func/vfnmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMSAC_VF);
+  #include "../insns_func/vfnmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmsac_vv.c b/arch/riscv/kernel/soft_vector/insns/vfnmsac_vv.c
new file mode 100755
index 000000000..b67f67e57
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmsac_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMSAC_VV);
+  #include "../insns_func/vfnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMSAC_VV);
+  #include "../insns_func/vfnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmsub_vf.c b/arch/riscv/kernel/soft_vector/insns/vfnmsub_vf.c
new file mode 100755
index 000000000..54b27a819
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmsub_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMSUB_VF);
+  #include "../insns_func/vfnmsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMSUB_VF);
+  #include "../insns_func/vfnmsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vfnmsub_vv.c
new file mode 100755
index 000000000..c20ceddef
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMSUB_VV);
+  #include "../insns_func/vfnmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMSUB_VV);
+  #include "../insns_func/vfnmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfrdiv_vf.c b/arch/riscv/kernel/soft_vector/insns/vfrdiv_vf.c
new file mode 100755
index 000000000..ec1b12f5d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfrdiv_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfrdiv_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFRDIV_VF);
+  #include "../insns_func/vfrdiv_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfrdiv_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFRDIV_VF);
+  #include "../insns_func/vfrdiv_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfredmax_vs.c b/arch/riscv/kernel/soft_vector/insns/vfredmax_vs.c
new file mode 100755
index 000000000..2a75b6c41
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfredmax_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfredmax_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFREDMAX_VS);
+  #include "../insns_func/vfredmax_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfredmax_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFREDMAX_VS);
+  #include "../insns_func/vfredmax_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfredmin_vs.c b/arch/riscv/kernel/soft_vector/insns/vfredmin_vs.c
new file mode 100755
index 000000000..91d1cbe5d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfredmin_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfredmin_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFREDMIN_VS);
+  #include "../insns_func/vfredmin_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfredmin_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFREDMIN_VS);
+  #include "../insns_func/vfredmin_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfredosum_vs.c b/arch/riscv/kernel/soft_vector/insns/vfredosum_vs.c
new file mode 100755
index 000000000..013f54e2c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfredosum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfredosum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFREDOSUM_VS);
+  #include "../insns_func/vfredosum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfredosum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFREDOSUM_VS);
+  #include "../insns_func/vfredosum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfredsum_vs.c b/arch/riscv/kernel/soft_vector/insns/vfredsum_vs.c
new file mode 100755
index 000000000..45fa3217d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfredsum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFREDSUM_VS);
+  #include "../insns_func/vfredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFREDSUM_VS);
+  #include "../insns_func/vfredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfrsub_vf.c b/arch/riscv/kernel/soft_vector/insns/vfrsub_vf.c
new file mode 100755
index 000000000..396549126
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfrsub_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfrsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFRSUB_VF);
+  #include "../insns_func/vfrsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfrsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFRSUB_VF);
+  #include "../insns_func/vfrsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnj_vf.c b/arch/riscv/kernel/soft_vector/insns/vfsgnj_vf.c
new file mode 100755
index 000000000..2c0ea1950
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnj_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnj_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJ_VF);
+  #include "../insns_func/vfsgnj_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnj_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJ_VF);
+  #include "../insns_func/vfsgnj_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnj_vv.c b/arch/riscv/kernel/soft_vector/insns/vfsgnj_vv.c
new file mode 100755
index 000000000..f6347e8b5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnj_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnj_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJ_VV);
+  #include "../insns_func/vfsgnj_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnj_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJ_VV);
+  #include "../insns_func/vfsgnj_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vf.c b/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vf.c
new file mode 100755
index 000000000..1f816fdbb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnjn_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJN_VF);
+  #include "../insns_func/vfsgnjn_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnjn_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJN_VF);
+  #include "../insns_func/vfsgnjn_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vv.c b/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vv.c
new file mode 100755
index 000000000..9de19b2fa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnjn_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJN_VV);
+  #include "../insns_func/vfsgnjn_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnjn_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJN_VV);
+  #include "../insns_func/vfsgnjn_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vf.c b/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vf.c
new file mode 100755
index 000000000..7abac2f38
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnjx_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJX_VF);
+  #include "../insns_func/vfsgnjx_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnjx_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJX_VF);
+  #include "../insns_func/vfsgnjx_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vv.c b/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vv.c
new file mode 100755
index 000000000..f305989e2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnjx_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJX_VV);
+  #include "../insns_func/vfsgnjx_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnjx_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJX_VV);
+  #include "../insns_func/vfsgnjx_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsqrt_v.c b/arch/riscv/kernel/soft_vector/insns/vfsqrt_v.c
new file mode 100755
index 000000000..260558203
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsqrt_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsqrt_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSQRT_V);
+  #include "../insns_func/vfsqrt_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsqrt_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSQRT_V);
+  #include "../insns_func/vfsqrt_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsub_vf.c b/arch/riscv/kernel/soft_vector/insns/vfsub_vf.c
new file mode 100755
index 000000000..398284534
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsub_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSUB_VF);
+  #include "../insns_func/vfsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSUB_VF);
+  #include "../insns_func/vfsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vfsub_vv.c
new file mode 100755
index 000000000..325c26051
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSUB_VV);
+  #include "../insns_func/vfsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSUB_VV);
+  #include "../insns_func/vfsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwadd_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwadd_vf.c
new file mode 100755
index 000000000..e2892d93e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwadd_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWADD_VF);
+  #include "../insns_func/vfwadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWADD_VF);
+  #include "../insns_func/vfwadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwadd_vv.c
new file mode 100755
index 000000000..250c236d4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWADD_VV);
+  #include "../insns_func/vfwadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWADD_VV);
+  #include "../insns_func/vfwadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwadd_wf.c b/arch/riscv/kernel/soft_vector/insns/vfwadd_wf.c
new file mode 100755
index 000000000..61ce79389
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwadd_wf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwadd_wf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWADD_WF);
+  #include "../insns_func/vfwadd_wf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwadd_wf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWADD_WF);
+  #include "../insns_func/vfwadd_wf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwadd_wv.c b/arch/riscv/kernel/soft_vector/insns/vfwadd_wv.c
new file mode 100755
index 000000000..f19583c51
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwadd_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwadd_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWADD_WV);
+  #include "../insns_func/vfwadd_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwadd_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWADD_WV);
+  #include "../insns_func/vfwadd_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_f_v.c
new file mode 100755
index 000000000..0bd1e699f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwcvt_f_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_F_V);
+  #include "../insns_func/vfwcvt_f_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwcvt_f_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_F_V);
+  #include "../insns_func/vfwcvt_f_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_x_v.c b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_x_v.c
new file mode 100755
index 000000000..bc2569ef7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_x_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwcvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_X_V);
+  #include "../insns_func/vfwcvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwcvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_X_V);
+  #include "../insns_func/vfwcvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_xu_v.c b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_xu_v.c
new file mode 100755
index 000000000..cb0c96b60
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_xu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwcvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_XU_V);
+  #include "../insns_func/vfwcvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwcvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_XU_V);
+  #include "../insns_func/vfwcvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwcvt_x_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfwcvt_x_f_v.c
new file mode 100755
index 000000000..590d84ab7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwcvt_x_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwcvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWCVT_X_F_V);
+  #include "../insns_func/vfwcvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwcvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWCVT_X_F_V);
+  #include "../insns_func/vfwcvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwcvt_xu_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfwcvt_xu_f_v.c
new file mode 100755
index 000000000..95215748b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwcvt_xu_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwcvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWCVT_XU_F_V);
+  #include "../insns_func/vfwcvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwcvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWCVT_XU_F_V);
+  #include "../insns_func/vfwcvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmacc_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwmacc_vf.c
new file mode 100755
index 000000000..9052a5689
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmacc_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMACC_VF);
+  #include "../insns_func/vfwmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMACC_VF);
+  #include "../insns_func/vfwmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwmacc_vv.c
new file mode 100755
index 000000000..acdd26f56
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMACC_VV);
+  #include "../insns_func/vfwmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMACC_VV);
+  #include "../insns_func/vfwmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmsac_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwmsac_vf.c
new file mode 100755
index 000000000..366a355fb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmsac_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMSAC_VF);
+  #include "../insns_func/vfwmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMSAC_VF);
+  #include "../insns_func/vfwmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmsac_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwmsac_vv.c
new file mode 100755
index 000000000..928c0c3bd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmsac_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMSAC_VV);
+  #include "../insns_func/vfwmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMSAC_VV);
+  #include "../insns_func/vfwmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmul_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwmul_vf.c
new file mode 100755
index 000000000..79606eced
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmul_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmul_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMUL_VF);
+  #include "../insns_func/vfwmul_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmul_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMUL_VF);
+  #include "../insns_func/vfwmul_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmul_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwmul_vv.c
new file mode 100755
index 000000000..1d8aa5b9a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmul_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMUL_VV);
+  #include "../insns_func/vfwmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMUL_VV);
+  #include "../insns_func/vfwmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vf.c
new file mode 100755
index 000000000..76be04454
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwnmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWNMACC_VF);
+  #include "../insns_func/vfwnmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwnmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWNMACC_VF);
+  #include "../insns_func/vfwnmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vv.c
new file mode 100755
index 000000000..3c78ef646
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwnmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWNMACC_VV);
+  #include "../insns_func/vfwnmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwnmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWNMACC_VV);
+  #include "../insns_func/vfwnmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vf.c
new file mode 100755
index 000000000..85f8e28c8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwnmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWNMSAC_VF);
+  #include "../insns_func/vfwnmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwnmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWNMSAC_VF);
+  #include "../insns_func/vfwnmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vv.c
new file mode 100755
index 000000000..c357fc8df
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWNMSAC_VV);
+  #include "../insns_func/vfwnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWNMSAC_VV);
+  #include "../insns_func/vfwnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwredosum_vs.c b/arch/riscv/kernel/soft_vector/insns/vfwredosum_vs.c
new file mode 100755
index 000000000..376490d20
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwredosum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwredosum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWREDOSUM_VS);
+  #include "../insns_func/vfwredosum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwredosum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWREDOSUM_VS);
+  #include "../insns_func/vfwredosum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwredsum_vs.c b/arch/riscv/kernel/soft_vector/insns/vfwredsum_vs.c
new file mode 100755
index 000000000..a07babc1e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwredsum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWREDSUM_VS);
+  #include "../insns_func/vfwredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWREDSUM_VS);
+  #include "../insns_func/vfwredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwsub_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwsub_vf.c
new file mode 100755
index 000000000..41465bdbc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwsub_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWSUB_VF);
+  #include "../insns_func/vfwsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWSUB_VF);
+  #include "../insns_func/vfwsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwsub_vv.c
new file mode 100755
index 000000000..2202acd7f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWSUB_VV);
+  #include "../insns_func/vfwsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWSUB_VV);
+  #include "../insns_func/vfwsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwsub_wf.c b/arch/riscv/kernel/soft_vector/insns/vfwsub_wf.c
new file mode 100755
index 000000000..5b3b56b9b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwsub_wf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwsub_wf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWSUB_WF);
+  #include "../insns_func/vfwsub_wf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwsub_wf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWSUB_WF);
+  #include "../insns_func/vfwsub_wf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwsub_wv.c b/arch/riscv/kernel/soft_vector/insns/vfwsub_wv.c
new file mode 100755
index 000000000..c78d2e220
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwsub_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwsub_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWSUB_WV);
+  #include "../insns_func/vfwsub_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwsub_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWSUB_WV);
+  #include "../insns_func/vfwsub_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vid_v.c b/arch/riscv/kernel/soft_vector/insns/vid_v.c
new file mode 100755
index 000000000..854988b81
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vid_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vid_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VID_V);
+  #include "../insns_func/vid_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vid_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VID_V);
+  #include "../insns_func/vid_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/viota_m.c b/arch/riscv/kernel/soft_vector/insns/viota_m.c
new file mode 100755
index 000000000..d18d30a51
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/viota_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_viota_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VIOTA_M);
+  #include "../insns_func/viota_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_viota_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VIOTA_M);
+  #include "../insns_func/viota_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlb_v.c b/arch/riscv/kernel/soft_vector/insns/vlb_v.c
new file mode 100755
index 000000000..ce9776c6e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLB_V);
+  #include "../insns_func/vlb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLB_V);
+  #include "../insns_func/vlb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlbff_v.c b/arch/riscv/kernel/soft_vector/insns/vlbff_v.c
new file mode 100755
index 000000000..4242ab3d8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlbff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlbff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLBFF_V);
+  #include "../insns_func/vlbff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlbff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLBFF_V);
+  #include "../insns_func/vlbff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlbu_v.c b/arch/riscv/kernel/soft_vector/insns/vlbu_v.c
new file mode 100755
index 000000000..b5b91d0bf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlbu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLBU_V);
+  #include "../insns_func/vlbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLBU_V);
+  #include "../insns_func/vlbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlbuff_v.c b/arch/riscv/kernel/soft_vector/insns/vlbuff_v.c
new file mode 100755
index 000000000..b959b6643
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlbuff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlbuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLBUFF_V);
+  #include "../insns_func/vlbuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlbuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLBUFF_V);
+  #include "../insns_func/vlbuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vle_v.c b/arch/riscv/kernel/soft_vector/insns/vle_v.c
new file mode 100755
index 000000000..2cfe3a2d3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vle_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vle_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLE_V);
+  #include "../insns_func/vle_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vle_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLE_V);
+  #include "../insns_func/vle_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vleff_v.c b/arch/riscv/kernel/soft_vector/insns/vleff_v.c
new file mode 100755
index 000000000..ecb868e02
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vleff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vleff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLEFF_V);
+  #include "../insns_func/vleff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vleff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLEFF_V);
+  #include "../insns_func/vleff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlh_v.c b/arch/riscv/kernel/soft_vector/insns/vlh_v.c
new file mode 100755
index 000000000..022abcf2b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLH_V);
+  #include "../insns_func/vlh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLH_V);
+  #include "../insns_func/vlh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlhff_v.c b/arch/riscv/kernel/soft_vector/insns/vlhff_v.c
new file mode 100755
index 000000000..f3defab3c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlhff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlhff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLHFF_V);
+  #include "../insns_func/vlhff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlhff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLHFF_V);
+  #include "../insns_func/vlhff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlhu_v.c b/arch/riscv/kernel/soft_vector/insns/vlhu_v.c
new file mode 100755
index 000000000..8459f2220
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlhu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlhu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLHU_V);
+  #include "../insns_func/vlhu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlhu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLHU_V);
+  #include "../insns_func/vlhu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlhuff_v.c b/arch/riscv/kernel/soft_vector/insns/vlhuff_v.c
new file mode 100755
index 000000000..7f376eb59
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlhuff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlhuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLHUFF_V);
+  #include "../insns_func/vlhuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlhuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLHUFF_V);
+  #include "../insns_func/vlhuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlsb_v.c b/arch/riscv/kernel/soft_vector/insns/vlsb_v.c
new file mode 100755
index 000000000..003645e6b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlsb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlsb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSB_V);
+  #include "../insns_func/vlsb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlsb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSB_V);
+  #include "../insns_func/vlsb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlsbu_v.c b/arch/riscv/kernel/soft_vector/insns/vlsbu_v.c
new file mode 100755
index 000000000..565a18e8b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlsbu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlsbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSBU_V);
+  #include "../insns_func/vlsbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlsbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSBU_V);
+  #include "../insns_func/vlsbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlse_v.c b/arch/riscv/kernel/soft_vector/insns/vlse_v.c
new file mode 100755
index 000000000..1966162bf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlse_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSE_V);
+  #include "../insns_func/vlse_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSE_V);
+  #include "../insns_func/vlse_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlsh_v.c b/arch/riscv/kernel/soft_vector/insns/vlsh_v.c
new file mode 100755
index 000000000..e2897236f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlsh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlsh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSH_V);
+  #include "../insns_func/vlsh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlsh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSH_V);
+  #include "../insns_func/vlsh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlshu_v.c b/arch/riscv/kernel/soft_vector/insns/vlshu_v.c
new file mode 100755
index 000000000..dcb86faab
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlshu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlshu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSHU_V);
+  #include "../insns_func/vlshu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlshu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSHU_V);
+  #include "../insns_func/vlshu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlsw_v.c b/arch/riscv/kernel/soft_vector/insns/vlsw_v.c
new file mode 100755
index 000000000..4c98914cb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlsw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlsw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSW_V);
+  #include "../insns_func/vlsw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlsw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSW_V);
+  #include "../insns_func/vlsw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlswu_v.c b/arch/riscv/kernel/soft_vector/insns/vlswu_v.c
new file mode 100755
index 000000000..26751462f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlswu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlswu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSWU_V);
+  #include "../insns_func/vlswu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlswu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSWU_V);
+  #include "../insns_func/vlswu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlw_v.c b/arch/riscv/kernel/soft_vector/insns/vlw_v.c
new file mode 100755
index 000000000..b86ce2dd5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLW_V);
+  #include "../insns_func/vlw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLW_V);
+  #include "../insns_func/vlw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlwff_v.c b/arch/riscv/kernel/soft_vector/insns/vlwff_v.c
new file mode 100755
index 000000000..8c5fb41f6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlwff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlwff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLWFF_V);
+  #include "../insns_func/vlwff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlwff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLWFF_V);
+  #include "../insns_func/vlwff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlwu_v.c b/arch/riscv/kernel/soft_vector/insns/vlwu_v.c
new file mode 100755
index 000000000..aa7151aac
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlwu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlwu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLWU_V);
+  #include "../insns_func/vlwu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlwu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLWU_V);
+  #include "../insns_func/vlwu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlwuff_v.c b/arch/riscv/kernel/soft_vector/insns/vlwuff_v.c
new file mode 100755
index 000000000..c9de1b7e7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlwuff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlwuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLWUFF_V);
+  #include "../insns_func/vlwuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlwuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLWUFF_V);
+  #include "../insns_func/vlwuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxb_v.c b/arch/riscv/kernel/soft_vector/insns/vlxb_v.c
new file mode 100755
index 000000000..2cb11bf9f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXB_V);
+  #include "../insns_func/vlxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXB_V);
+  #include "../insns_func/vlxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxbu_v.c b/arch/riscv/kernel/soft_vector/insns/vlxbu_v.c
new file mode 100755
index 000000000..508e97bd3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxbu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXBU_V);
+  #include "../insns_func/vlxbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXBU_V);
+  #include "../insns_func/vlxbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxe_v.c b/arch/riscv/kernel/soft_vector/insns/vlxe_v.c
new file mode 100755
index 000000000..bbea62df3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxe_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXE_V);
+  #include "../insns_func/vlxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXE_V);
+  #include "../insns_func/vlxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxh_v.c b/arch/riscv/kernel/soft_vector/insns/vlxh_v.c
new file mode 100755
index 000000000..fbdc04d80
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXH_V);
+  #include "../insns_func/vlxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXH_V);
+  #include "../insns_func/vlxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxhu_v.c b/arch/riscv/kernel/soft_vector/insns/vlxhu_v.c
new file mode 100755
index 000000000..574c43ccc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxhu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxhu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXHU_V);
+  #include "../insns_func/vlxhu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxhu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXHU_V);
+  #include "../insns_func/vlxhu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxw_v.c b/arch/riscv/kernel/soft_vector/insns/vlxw_v.c
new file mode 100755
index 000000000..bfb117c91
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXW_V);
+  #include "../insns_func/vlxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXW_V);
+  #include "../insns_func/vlxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxwu_v.c b/arch/riscv/kernel/soft_vector/insns/vlxwu_v.c
new file mode 100755
index 000000000..789774a7f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxwu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxwu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXWU_V);
+  #include "../insns_func/vlxwu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxwu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXWU_V);
+  #include "../insns_func/vlxwu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vmacc_vv.c
new file mode 100755
index 000000000..6b1872b2f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMACC_VV);
+  #include "../insns_func/vmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMACC_VV);
+  #include "../insns_func/vmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmacc_vx.c b/arch/riscv/kernel/soft_vector/insns/vmacc_vx.c
new file mode 100755
index 000000000..5b101f453
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmacc_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMACC_VX);
+  #include "../insns_func/vmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMACC_VX);
+  #include "../insns_func/vmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmadc_vim.c b/arch/riscv/kernel/soft_vector/insns/vmadc_vim.c
new file mode 100755
index 000000000..504b700ab
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmadc_vim.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmadc_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMADC_VIM);
+  #include "../insns_func/vmadc_vim.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmadc_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMADC_VIM);
+  #include "../insns_func/vmadc_vim.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmadc_vvm.c b/arch/riscv/kernel/soft_vector/insns/vmadc_vvm.c
new file mode 100755
index 000000000..fb38afc54
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmadc_vvm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmadc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMADC_VVM);
+  #include "../insns_func/vmadc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmadc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMADC_VVM);
+  #include "../insns_func/vmadc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmadc_vxm.c b/arch/riscv/kernel/soft_vector/insns/vmadc_vxm.c
new file mode 100755
index 000000000..62e98fc3d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmadc_vxm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmadc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMADC_VXM);
+  #include "../insns_func/vmadc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmadc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMADC_VXM);
+  #include "../insns_func/vmadc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vmadd_vv.c
new file mode 100755
index 000000000..143db556d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMADD_VV);
+  #include "../insns_func/vmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMADD_VV);
+  #include "../insns_func/vmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmadd_vx.c b/arch/riscv/kernel/soft_vector/insns/vmadd_vx.c
new file mode 100755
index 000000000..93c137593
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmadd_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMADD_VX);
+  #include "../insns_func/vmadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMADD_VX);
+  #include "../insns_func/vmadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmand_mm.c b/arch/riscv/kernel/soft_vector/insns/vmand_mm.c
new file mode 100755
index 000000000..cf3441b5c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmand_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmand_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMAND_MM);
+  #include "../insns_func/vmand_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmand_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMAND_MM);
+  #include "../insns_func/vmand_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmandnot_mm.c b/arch/riscv/kernel/soft_vector/insns/vmandnot_mm.c
new file mode 100755
index 000000000..004b1da46
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmandnot_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmandnot_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMANDNOT_MM);
+  #include "../insns_func/vmandnot_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmandnot_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMANDNOT_MM);
+  #include "../insns_func/vmandnot_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmax_vv.c b/arch/riscv/kernel/soft_vector/insns/vmax_vv.c
new file mode 100755
index 000000000..e4ce31f46
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmax_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmax_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMAX_VV);
+  #include "../insns_func/vmax_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmax_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMAX_VV);
+  #include "../insns_func/vmax_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmax_vx.c b/arch/riscv/kernel/soft_vector/insns/vmax_vx.c
new file mode 100755
index 000000000..9c5a23855
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmax_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmax_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMAX_VX);
+  #include "../insns_func/vmax_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmax_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMAX_VX);
+  #include "../insns_func/vmax_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmaxu_vv.c b/arch/riscv/kernel/soft_vector/insns/vmaxu_vv.c
new file mode 100755
index 000000000..70884689c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmaxu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmaxu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMAXU_VV);
+  #include "../insns_func/vmaxu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmaxu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMAXU_VV);
+  #include "../insns_func/vmaxu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmaxu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmaxu_vx.c
new file mode 100755
index 000000000..b3b662b5f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmaxu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmaxu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMAXU_VX);
+  #include "../insns_func/vmaxu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmaxu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMAXU_VX);
+  #include "../insns_func/vmaxu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmerge_vim.c b/arch/riscv/kernel/soft_vector/insns/vmerge_vim.c
new file mode 100755
index 000000000..84b019567
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmerge_vim.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmerge_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMERGE_VIM);
+  #include "../insns_func/vmerge_vim.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmerge_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMERGE_VIM);
+  #include "../insns_func/vmerge_vim.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmerge_vvm.c b/arch/riscv/kernel/soft_vector/insns/vmerge_vvm.c
new file mode 100755
index 000000000..a72ba4bf7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmerge_vvm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmerge_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMERGE_VVM);
+  #include "../insns_func/vmerge_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmerge_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMERGE_VVM);
+  #include "../insns_func/vmerge_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmerge_vxm.c b/arch/riscv/kernel/soft_vector/insns/vmerge_vxm.c
new file mode 100755
index 000000000..9d02f30b2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmerge_vxm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmerge_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMERGE_VXM);
+  #include "../insns_func/vmerge_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmerge_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMERGE_VXM);
+  #include "../insns_func/vmerge_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfeq_vf.c b/arch/riscv/kernel/soft_vector/insns/vmfeq_vf.c
new file mode 100755
index 000000000..4a76d6fc7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfeq_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfeq_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFEQ_VF);
+  #include "../insns_func/vmfeq_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfeq_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFEQ_VF);
+  #include "../insns_func/vmfeq_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfeq_vv.c b/arch/riscv/kernel/soft_vector/insns/vmfeq_vv.c
new file mode 100755
index 000000000..d648c390d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfeq_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfeq_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFEQ_VV);
+  #include "../insns_func/vmfeq_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfeq_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFEQ_VV);
+  #include "../insns_func/vmfeq_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfge_vf.c b/arch/riscv/kernel/soft_vector/insns/vmfge_vf.c
new file mode 100755
index 000000000..52f585c9e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfge_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfge_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFGE_VF);
+  #include "../insns_func/vmfge_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfge_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFGE_VF);
+  #include "../insns_func/vmfge_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfgt_vf.c b/arch/riscv/kernel/soft_vector/insns/vmfgt_vf.c
new file mode 100755
index 000000000..489b35234
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfgt_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfgt_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFGT_VF);
+  #include "../insns_func/vmfgt_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfgt_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFGT_VF);
+  #include "../insns_func/vmfgt_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfirst_m.c b/arch/riscv/kernel/soft_vector/insns/vmfirst_m.c
new file mode 100755
index 000000000..b4ca73a90
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfirst_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfirst_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFIRST_M);
+  #include "../insns_func/vmfirst_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfirst_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFIRST_M);
+  #include "../insns_func/vmfirst_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfle_vf.c b/arch/riscv/kernel/soft_vector/insns/vmfle_vf.c
new file mode 100755
index 000000000..ff31d3d72
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfle_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfle_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFLE_VF);
+  #include "../insns_func/vmfle_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfle_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFLE_VF);
+  #include "../insns_func/vmfle_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfle_vv.c b/arch/riscv/kernel/soft_vector/insns/vmfle_vv.c
new file mode 100755
index 000000000..732b20fbb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfle_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfle_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFLE_VV);
+  #include "../insns_func/vmfle_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfle_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFLE_VV);
+  #include "../insns_func/vmfle_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmflt_vf.c b/arch/riscv/kernel/soft_vector/insns/vmflt_vf.c
new file mode 100755
index 000000000..8470f2e8c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmflt_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmflt_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFLT_VF);
+  #include "../insns_func/vmflt_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmflt_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFLT_VF);
+  #include "../insns_func/vmflt_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmflt_vv.c b/arch/riscv/kernel/soft_vector/insns/vmflt_vv.c
new file mode 100755
index 000000000..9efde0c38
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmflt_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmflt_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFLT_VV);
+  #include "../insns_func/vmflt_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmflt_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFLT_VV);
+  #include "../insns_func/vmflt_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfne_vf.c b/arch/riscv/kernel/soft_vector/insns/vmfne_vf.c
new file mode 100755
index 000000000..7f2a497f6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfne_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfne_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFNE_VF);
+  #include "../insns_func/vmfne_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfne_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFNE_VF);
+  #include "../insns_func/vmfne_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfne_vv.c b/arch/riscv/kernel/soft_vector/insns/vmfne_vv.c
new file mode 100755
index 000000000..9e1f826ce
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfne_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfne_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFNE_VV);
+  #include "../insns_func/vmfne_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfne_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFNE_VV);
+  #include "../insns_func/vmfne_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmford_vf.c b/arch/riscv/kernel/soft_vector/insns/vmford_vf.c
new file mode 100755
index 000000000..f8e1a8f29
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmford_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmford_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFORD_VF);
+  #include "../insns_func/vmford_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmford_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFORD_VF);
+  #include "../insns_func/vmford_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmford_vv.c b/arch/riscv/kernel/soft_vector/insns/vmford_vv.c
new file mode 100755
index 000000000..0f8de741e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmford_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmford_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFORD_VV);
+  #include "../insns_func/vmford_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmford_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFORD_VV);
+  #include "../insns_func/vmford_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmin_vv.c b/arch/riscv/kernel/soft_vector/insns/vmin_vv.c
new file mode 100755
index 000000000..d93b6e91c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmin_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmin_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMIN_VV);
+  #include "../insns_func/vmin_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmin_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMIN_VV);
+  #include "../insns_func/vmin_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmin_vx.c b/arch/riscv/kernel/soft_vector/insns/vmin_vx.c
new file mode 100755
index 000000000..9c0c2d2c6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmin_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmin_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMIN_VX);
+  #include "../insns_func/vmin_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmin_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMIN_VX);
+  #include "../insns_func/vmin_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vminu_vv.c b/arch/riscv/kernel/soft_vector/insns/vminu_vv.c
new file mode 100755
index 000000000..ce2499f4a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vminu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vminu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMINU_VV);
+  #include "../insns_func/vminu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vminu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMINU_VV);
+  #include "../insns_func/vminu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vminu_vx.c b/arch/riscv/kernel/soft_vector/insns/vminu_vx.c
new file mode 100755
index 000000000..6a074ac24
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vminu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vminu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMINU_VX);
+  #include "../insns_func/vminu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vminu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMINU_VX);
+  #include "../insns_func/vminu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmnand_mm.c b/arch/riscv/kernel/soft_vector/insns/vmnand_mm.c
new file mode 100755
index 000000000..844a9f38a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmnand_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmnand_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMNAND_MM);
+  #include "../insns_func/vmnand_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmnand_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMNAND_MM);
+  #include "../insns_func/vmnand_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmnor_mm.c b/arch/riscv/kernel/soft_vector/insns/vmnor_mm.c
new file mode 100755
index 000000000..d106daf72
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmnor_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmnor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMNOR_MM);
+  #include "../insns_func/vmnor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmnor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMNOR_MM);
+  #include "../insns_func/vmnor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmor_mm.c b/arch/riscv/kernel/soft_vector/insns/vmor_mm.c
new file mode 100755
index 000000000..c7e31a9d0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmor_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMOR_MM);
+  #include "../insns_func/vmor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMOR_MM);
+  #include "../insns_func/vmor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmornot_mm.c b/arch/riscv/kernel/soft_vector/insns/vmornot_mm.c
new file mode 100755
index 000000000..ed4323524
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmornot_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmornot_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMORNOT_MM);
+  #include "../insns_func/vmornot_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmornot_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMORNOT_MM);
+  #include "../insns_func/vmornot_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmpopc_m.c b/arch/riscv/kernel/soft_vector/insns/vmpopc_m.c
new file mode 100755
index 000000000..74eff3d98
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmpopc_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmpopc_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMPOPC_M);
+  #include "../insns_func/vmpopc_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmpopc_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMPOPC_M);
+  #include "../insns_func/vmpopc_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsbc_vvm.c b/arch/riscv/kernel/soft_vector/insns/vmsbc_vvm.c
new file mode 100755
index 000000000..e64e16171
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsbc_vvm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsbc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSBC_VVM);
+  #include "../insns_func/vmsbc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsbc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSBC_VVM);
+  #include "../insns_func/vmsbc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsbc_vxm.c b/arch/riscv/kernel/soft_vector/insns/vmsbc_vxm.c
new file mode 100755
index 000000000..2fcf72a7b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsbc_vxm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsbc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSBC_VXM);
+  #include "../insns_func/vmsbc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsbc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSBC_VXM);
+  #include "../insns_func/vmsbc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsbf_m.c b/arch/riscv/kernel/soft_vector/insns/vmsbf_m.c
new file mode 100755
index 000000000..1900dba9e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsbf_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsbf_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSBF_M);
+  #include "../insns_func/vmsbf_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsbf_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSBF_M);
+  #include "../insns_func/vmsbf_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmseq_vi.c b/arch/riscv/kernel/soft_vector/insns/vmseq_vi.c
new file mode 100755
index 000000000..ebe43137a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmseq_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmseq_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSEQ_VI);
+  #include "../insns_func/vmseq_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmseq_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSEQ_VI);
+  #include "../insns_func/vmseq_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmseq_vv.c b/arch/riscv/kernel/soft_vector/insns/vmseq_vv.c
new file mode 100755
index 000000000..c910cd329
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmseq_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmseq_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSEQ_VV);
+  #include "../insns_func/vmseq_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmseq_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSEQ_VV);
+  #include "../insns_func/vmseq_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmseq_vx.c b/arch/riscv/kernel/soft_vector/insns/vmseq_vx.c
new file mode 100755
index 000000000..8271a1927
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmseq_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmseq_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSEQ_VX);
+  #include "../insns_func/vmseq_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmseq_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSEQ_VX);
+  #include "../insns_func/vmseq_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsgt_vi.c b/arch/riscv/kernel/soft_vector/insns/vmsgt_vi.c
new file mode 100755
index 000000000..9a7ce33a9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsgt_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsgt_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSGT_VI);
+  #include "../insns_func/vmsgt_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsgt_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSGT_VI);
+  #include "../insns_func/vmsgt_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsgt_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsgt_vx.c
new file mode 100755
index 000000000..4757ddba7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsgt_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsgt_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSGT_VX);
+  #include "../insns_func/vmsgt_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsgt_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSGT_VX);
+  #include "../insns_func/vmsgt_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsgtu_vi.c b/arch/riscv/kernel/soft_vector/insns/vmsgtu_vi.c
new file mode 100755
index 000000000..883867575
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsgtu_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsgtu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSGTU_VI);
+  #include "../insns_func/vmsgtu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsgtu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSGTU_VI);
+  #include "../insns_func/vmsgtu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsgtu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsgtu_vx.c
new file mode 100755
index 000000000..b6e9814fa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsgtu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsgtu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSGTU_VX);
+  #include "../insns_func/vmsgtu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsgtu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSGTU_VX);
+  #include "../insns_func/vmsgtu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsif_m.c b/arch/riscv/kernel/soft_vector/insns/vmsif_m.c
new file mode 100755
index 000000000..2406bc901
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsif_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsif_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSIF_M);
+  #include "../insns_func/vmsif_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsif_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSIF_M);
+  #include "../insns_func/vmsif_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsle_vi.c b/arch/riscv/kernel/soft_vector/insns/vmsle_vi.c
new file mode 100755
index 000000000..365f948c7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsle_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsle_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLE_VI);
+  #include "../insns_func/vmsle_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsle_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLE_VI);
+  #include "../insns_func/vmsle_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsle_vv.c b/arch/riscv/kernel/soft_vector/insns/vmsle_vv.c
new file mode 100755
index 000000000..414e4d87f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsle_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsle_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLE_VV);
+  #include "../insns_func/vmsle_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsle_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLE_VV);
+  #include "../insns_func/vmsle_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsle_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsle_vx.c
new file mode 100755
index 000000000..b84151d31
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsle_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsle_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLE_VX);
+  #include "../insns_func/vmsle_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsle_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLE_VX);
+  #include "../insns_func/vmsle_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsleu_vi.c b/arch/riscv/kernel/soft_vector/insns/vmsleu_vi.c
new file mode 100755
index 000000000..d3fd9f246
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsleu_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsleu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLEU_VI);
+  #include "../insns_func/vmsleu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsleu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLEU_VI);
+  #include "../insns_func/vmsleu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsleu_vv.c b/arch/riscv/kernel/soft_vector/insns/vmsleu_vv.c
new file mode 100755
index 000000000..e4eb56abe
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsleu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsleu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLEU_VV);
+  #include "../insns_func/vmsleu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsleu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLEU_VV);
+  #include "../insns_func/vmsleu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsleu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsleu_vx.c
new file mode 100755
index 000000000..47877380a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsleu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsleu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLEU_VX);
+  #include "../insns_func/vmsleu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsleu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLEU_VX);
+  #include "../insns_func/vmsleu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmslt_vv.c b/arch/riscv/kernel/soft_vector/insns/vmslt_vv.c
new file mode 100755
index 000000000..433730bb2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmslt_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmslt_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLT_VV);
+  #include "../insns_func/vmslt_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmslt_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLT_VV);
+  #include "../insns_func/vmslt_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmslt_vx.c b/arch/riscv/kernel/soft_vector/insns/vmslt_vx.c
new file mode 100755
index 000000000..03d23d856
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmslt_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmslt_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLT_VX);
+  #include "../insns_func/vmslt_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmslt_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLT_VX);
+  #include "../insns_func/vmslt_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsltu_vv.c b/arch/riscv/kernel/soft_vector/insns/vmsltu_vv.c
new file mode 100755
index 000000000..ab1493fc6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsltu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsltu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLTU_VV);
+  #include "../insns_func/vmsltu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsltu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLTU_VV);
+  #include "../insns_func/vmsltu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsltu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsltu_vx.c
new file mode 100755
index 000000000..addd3ecc6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsltu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsltu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLTU_VX);
+  #include "../insns_func/vmsltu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsltu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLTU_VX);
+  #include "../insns_func/vmsltu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsne_vi.c b/arch/riscv/kernel/soft_vector/insns/vmsne_vi.c
new file mode 100755
index 000000000..96516a7aa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsne_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsne_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSNE_VI);
+  #include "../insns_func/vmsne_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsne_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSNE_VI);
+  #include "../insns_func/vmsne_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsne_vv.c b/arch/riscv/kernel/soft_vector/insns/vmsne_vv.c
new file mode 100755
index 000000000..a0c852b3d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsne_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsne_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSNE_VV);
+  #include "../insns_func/vmsne_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsne_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSNE_VV);
+  #include "../insns_func/vmsne_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsne_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsne_vx.c
new file mode 100755
index 000000000..6d0b93b16
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsne_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsne_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSNE_VX);
+  #include "../insns_func/vmsne_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsne_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSNE_VX);
+  #include "../insns_func/vmsne_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsof_m.c b/arch/riscv/kernel/soft_vector/insns/vmsof_m.c
new file mode 100755
index 000000000..0bae2b795
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsof_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsof_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSOF_M);
+  #include "../insns_func/vmsof_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsof_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSOF_M);
+  #include "../insns_func/vmsof_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmul_vv.c b/arch/riscv/kernel/soft_vector/insns/vmul_vv.c
new file mode 100755
index 000000000..6cff5c881
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmul_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMUL_VV);
+  #include "../insns_func/vmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMUL_VV);
+  #include "../insns_func/vmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmul_vx.c b/arch/riscv/kernel/soft_vector/insns/vmul_vx.c
new file mode 100755
index 000000000..46860112b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmul_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMUL_VX);
+  #include "../insns_func/vmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMUL_VX);
+  #include "../insns_func/vmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulh_vv.c b/arch/riscv/kernel/soft_vector/insns/vmulh_vv.c
new file mode 100755
index 000000000..75334c0bb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulh_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulh_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULH_VV);
+  #include "../insns_func/vmulh_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulh_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULH_VV);
+  #include "../insns_func/vmulh_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulh_vx.c b/arch/riscv/kernel/soft_vector/insns/vmulh_vx.c
new file mode 100755
index 000000000..6e1ee9d4e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulh_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulh_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULH_VX);
+  #include "../insns_func/vmulh_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulh_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULH_VX);
+  #include "../insns_func/vmulh_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulhsu_vv.c b/arch/riscv/kernel/soft_vector/insns/vmulhsu_vv.c
new file mode 100755
index 000000000..4b87d6e8f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulhsu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulhsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULHSU_VV);
+  #include "../insns_func/vmulhsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulhsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULHSU_VV);
+  #include "../insns_func/vmulhsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulhsu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmulhsu_vx.c
new file mode 100755
index 000000000..506bd0cb9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulhsu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulhsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULHSU_VX);
+  #include "../insns_func/vmulhsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulhsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULHSU_VX);
+  #include "../insns_func/vmulhsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulhu_vv.c b/arch/riscv/kernel/soft_vector/insns/vmulhu_vv.c
new file mode 100755
index 000000000..d440613f8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulhu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulhu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULHU_VV);
+  #include "../insns_func/vmulhu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulhu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULHU_VV);
+  #include "../insns_func/vmulhu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulhu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmulhu_vx.c
new file mode 100755
index 000000000..c9f01b024
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulhu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulhu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULHU_VX);
+  #include "../insns_func/vmulhu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulhu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULHU_VX);
+  #include "../insns_func/vmulhu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmv_s_x.c b/arch/riscv/kernel/soft_vector/insns/vmv_s_x.c
new file mode 100755
index 000000000..e322a2c87
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmv_s_x.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmv_s_x(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMV_S_X);
+  #include "../insns_func/vmv_s_x.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmv_s_x(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMV_S_X);
+  #include "../insns_func/vmv_s_x.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmv_v_i.c b/arch/riscv/kernel/soft_vector/insns/vmv_v_i.c
new file mode 100755
index 000000000..b70715037
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmv_v_i.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmv_v_i(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMV_V_I);
+  #include "../insns_func/vmv_v_i.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmv_v_i(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMV_V_I);
+  #include "../insns_func/vmv_v_i.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmv_v_v.c b/arch/riscv/kernel/soft_vector/insns/vmv_v_v.c
new file mode 100755
index 000000000..e6808297e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmv_v_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmv_v_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMV_V_V);
+  #include "../insns_func/vmv_v_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmv_v_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMV_V_V);
+  #include "../insns_func/vmv_v_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmv_v_x.c b/arch/riscv/kernel/soft_vector/insns/vmv_v_x.c
new file mode 100755
index 000000000..19c99057d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmv_v_x.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmv_v_x(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMV_V_X);
+  #include "../insns_func/vmv_v_x.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmv_v_x(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMV_V_X);
+  #include "../insns_func/vmv_v_x.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmxnor_mm.c b/arch/riscv/kernel/soft_vector/insns/vmxnor_mm.c
new file mode 100755
index 000000000..2d4161d9f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmxnor_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmxnor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMXNOR_MM);
+  #include "../insns_func/vmxnor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmxnor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMXNOR_MM);
+  #include "../insns_func/vmxnor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmxor_mm.c b/arch/riscv/kernel/soft_vector/insns/vmxor_mm.c
new file mode 100755
index 000000000..d1de833f4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmxor_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmxor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMXOR_MM);
+  #include "../insns_func/vmxor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmxor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMXOR_MM);
+  #include "../insns_func/vmxor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclip_vi.c b/arch/riscv/kernel/soft_vector/insns/vnclip_vi.c
new file mode 100755
index 000000000..c77909e8c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclip_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclip_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIP_VI);
+  #include "../insns_func/vnclip_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclip_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIP_VI);
+  #include "../insns_func/vnclip_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclip_vv.c b/arch/riscv/kernel/soft_vector/insns/vnclip_vv.c
new file mode 100755
index 000000000..8f19fb9ef
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclip_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclip_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIP_VV);
+  #include "../insns_func/vnclip_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclip_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIP_VV);
+  #include "../insns_func/vnclip_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclip_vx.c b/arch/riscv/kernel/soft_vector/insns/vnclip_vx.c
new file mode 100755
index 000000000..74be2cc29
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclip_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclip_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIP_VX);
+  #include "../insns_func/vnclip_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclip_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIP_VX);
+  #include "../insns_func/vnclip_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclipu_vi.c b/arch/riscv/kernel/soft_vector/insns/vnclipu_vi.c
new file mode 100755
index 000000000..240ff439b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclipu_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclipu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VI);
+  #include "../insns_func/vnclipu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclipu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VI);
+  #include "../insns_func/vnclipu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclipu_vv.c b/arch/riscv/kernel/soft_vector/insns/vnclipu_vv.c
new file mode 100755
index 000000000..a1127eab7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclipu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclipu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VV);
+  #include "../insns_func/vnclipu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclipu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VV);
+  #include "../insns_func/vnclipu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclipu_vx.c b/arch/riscv/kernel/soft_vector/insns/vnclipu_vx.c
new file mode 100755
index 000000000..2a2ea2a2a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclipu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclipu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VX);
+  #include "../insns_func/vnclipu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclipu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VX);
+  #include "../insns_func/vnclipu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnmsac_vv.c b/arch/riscv/kernel/soft_vector/insns/vnmsac_vv.c
new file mode 100755
index 000000000..dff71a748
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnmsac_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNMSAC_VV);
+  #include "../insns_func/vnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNMSAC_VV);
+  #include "../insns_func/vnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnmsac_vx.c b/arch/riscv/kernel/soft_vector/insns/vnmsac_vx.c
new file mode 100755
index 000000000..9d25188cf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnmsac_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnmsac_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNMSAC_VX);
+  #include "../insns_func/vnmsac_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnmsac_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNMSAC_VX);
+  #include "../insns_func/vnmsac_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnmsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vnmsub_vv.c
new file mode 100755
index 000000000..47edf3cde
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnmsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNMSUB_VV);
+  #include "../insns_func/vnmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNMSUB_VV);
+  #include "../insns_func/vnmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnmsub_vx.c b/arch/riscv/kernel/soft_vector/insns/vnmsub_vx.c
new file mode 100755
index 000000000..4e4664f6d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnmsub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnmsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNMSUB_VX);
+  #include "../insns_func/vnmsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnmsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNMSUB_VX);
+  #include "../insns_func/vnmsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsra_vi.c b/arch/riscv/kernel/soft_vector/insns/vnsra_vi.c
new file mode 100755
index 000000000..8d67a3d06
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsra_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRA_VI);
+  #include "../insns_func/vnsra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRA_VI);
+  #include "../insns_func/vnsra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsra_vv.c b/arch/riscv/kernel/soft_vector/insns/vnsra_vv.c
new file mode 100755
index 000000000..719f08102
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsra_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRA_VV);
+  #include "../insns_func/vnsra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRA_VV);
+  #include "../insns_func/vnsra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsra_vx.c b/arch/riscv/kernel/soft_vector/insns/vnsra_vx.c
new file mode 100755
index 000000000..f5c114908
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsra_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRA_VX);
+  #include "../insns_func/vnsra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRA_VX);
+  #include "../insns_func/vnsra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsrl_vi.c b/arch/riscv/kernel/soft_vector/insns/vnsrl_vi.c
new file mode 100755
index 000000000..613c32d5e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsrl_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRL_VI);
+  #include "../insns_func/vnsrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRL_VI);
+  #include "../insns_func/vnsrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsrl_vv.c b/arch/riscv/kernel/soft_vector/insns/vnsrl_vv.c
new file mode 100755
index 000000000..a71137dee
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsrl_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRL_VV);
+  #include "../insns_func/vnsrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRL_VV);
+  #include "../insns_func/vnsrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsrl_vx.c b/arch/riscv/kernel/soft_vector/insns/vnsrl_vx.c
new file mode 100755
index 000000000..51057f152
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsrl_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRL_VX);
+  #include "../insns_func/vnsrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRL_VX);
+  #include "../insns_func/vnsrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vor_vi.c b/arch/riscv/kernel/soft_vector/insns/vor_vi.c
new file mode 100755
index 000000000..964ec9624
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vor_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vor_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VOR_VI);
+  #include "../insns_func/vor_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vor_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VOR_VI);
+  #include "../insns_func/vor_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vor_vv.c b/arch/riscv/kernel/soft_vector/insns/vor_vv.c
new file mode 100755
index 000000000..1a63b7eab
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vor_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vor_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VOR_VV);
+  #include "../insns_func/vor_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vor_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VOR_VV);
+  #include "../insns_func/vor_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vor_vx.c b/arch/riscv/kernel/soft_vector/insns/vor_vx.c
new file mode 100755
index 000000000..4d30b5200
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vor_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vor_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VOR_VX);
+  #include "../insns_func/vor_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vor_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VOR_VX);
+  #include "../insns_func/vor_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredand_vs.c b/arch/riscv/kernel/soft_vector/insns/vredand_vs.c
new file mode 100755
index 000000000..5109ce25f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredand_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredand_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDAND_VS);
+  #include "../insns_func/vredand_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredand_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDAND_VS);
+  #include "../insns_func/vredand_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredmax_vs.c b/arch/riscv/kernel/soft_vector/insns/vredmax_vs.c
new file mode 100755
index 000000000..5990ffeda
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredmax_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredmax_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDMAX_VS);
+  #include "../insns_func/vredmax_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredmax_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDMAX_VS);
+  #include "../insns_func/vredmax_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredmaxu_vs.c b/arch/riscv/kernel/soft_vector/insns/vredmaxu_vs.c
new file mode 100755
index 000000000..1d6507f72
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredmaxu_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredmaxu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDMAXU_VS);
+  #include "../insns_func/vredmaxu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredmaxu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDMAXU_VS);
+  #include "../insns_func/vredmaxu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredmin_vs.c b/arch/riscv/kernel/soft_vector/insns/vredmin_vs.c
new file mode 100755
index 000000000..3fc5b2485
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredmin_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredmin_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDMIN_VS);
+  #include "../insns_func/vredmin_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredmin_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDMIN_VS);
+  #include "../insns_func/vredmin_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredminu_vs.c b/arch/riscv/kernel/soft_vector/insns/vredminu_vs.c
new file mode 100755
index 000000000..0646ba453
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredminu_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredminu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDMINU_VS);
+  #include "../insns_func/vredminu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredminu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDMINU_VS);
+  #include "../insns_func/vredminu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredor_vs.c b/arch/riscv/kernel/soft_vector/insns/vredor_vs.c
new file mode 100755
index 000000000..85469f39e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredor_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredor_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDOR_VS);
+  #include "../insns_func/vredor_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredor_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDOR_VS);
+  #include "../insns_func/vredor_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredsum_vs.c b/arch/riscv/kernel/soft_vector/insns/vredsum_vs.c
new file mode 100755
index 000000000..21557895a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredsum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDSUM_VS);
+  #include "../insns_func/vredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDSUM_VS);
+  #include "../insns_func/vredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredxor_vs.c b/arch/riscv/kernel/soft_vector/insns/vredxor_vs.c
new file mode 100755
index 000000000..add3322c0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredxor_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredxor_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDXOR_VS);
+  #include "../insns_func/vredxor_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredxor_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDXOR_VS);
+  #include "../insns_func/vredxor_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrem_vv.c b/arch/riscv/kernel/soft_vector/insns/vrem_vv.c
new file mode 100755
index 000000000..b2c023043
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrem_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrem_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREM_VV);
+  #include "../insns_func/vrem_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrem_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREM_VV);
+  #include "../insns_func/vrem_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrem_vx.c b/arch/riscv/kernel/soft_vector/insns/vrem_vx.c
new file mode 100755
index 000000000..f7a6fa28c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrem_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrem_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREM_VX);
+  #include "../insns_func/vrem_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrem_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREM_VX);
+  #include "../insns_func/vrem_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vremu_vv.c b/arch/riscv/kernel/soft_vector/insns/vremu_vv.c
new file mode 100755
index 000000000..66fca3e66
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vremu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vremu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREMU_VV);
+  #include "../insns_func/vremu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vremu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREMU_VV);
+  #include "../insns_func/vremu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vremu_vx.c b/arch/riscv/kernel/soft_vector/insns/vremu_vx.c
new file mode 100755
index 000000000..efaa37cd2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vremu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vremu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREMU_VX);
+  #include "../insns_func/vremu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vremu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREMU_VX);
+  #include "../insns_func/vremu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrgather_vi.c b/arch/riscv/kernel/soft_vector/insns/vrgather_vi.c
new file mode 100755
index 000000000..e025d62bd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrgather_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrgather_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VRGATHER_VI);
+  #include "../insns_func/vrgather_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrgather_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VRGATHER_VI);
+  #include "../insns_func/vrgather_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrgather_vv.c b/arch/riscv/kernel/soft_vector/insns/vrgather_vv.c
new file mode 100755
index 000000000..c7ccb3c19
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrgather_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrgather_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VRGATHER_VV);
+  #include "../insns_func/vrgather_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrgather_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VRGATHER_VV);
+  #include "../insns_func/vrgather_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrgather_vx.c b/arch/riscv/kernel/soft_vector/insns/vrgather_vx.c
new file mode 100755
index 000000000..d7c4c9ecc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrgather_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrgather_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VRGATHER_VX);
+  #include "../insns_func/vrgather_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrgather_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VRGATHER_VX);
+  #include "../insns_func/vrgather_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrsub_vi.c b/arch/riscv/kernel/soft_vector/insns/vrsub_vi.c
new file mode 100755
index 000000000..11e8338d7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrsub_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrsub_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VRSUB_VI);
+  #include "../insns_func/vrsub_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrsub_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VRSUB_VI);
+  #include "../insns_func/vrsub_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrsub_vx.c b/arch/riscv/kernel/soft_vector/insns/vrsub_vx.c
new file mode 100755
index 000000000..4a4277941
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrsub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VRSUB_VX);
+  #include "../insns_func/vrsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VRSUB_VX);
+  #include "../insns_func/vrsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsadd_vi.c b/arch/riscv/kernel/soft_vector/insns/vsadd_vi.c
new file mode 100755
index 000000000..9534d00a5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsadd_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADD_VI);
+  #include "../insns_func/vsadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADD_VI);
+  #include "../insns_func/vsadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vsadd_vv.c
new file mode 100755
index 000000000..fa754a1c0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADD_VV);
+  #include "../insns_func/vsadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADD_VV);
+  #include "../insns_func/vsadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsadd_vx.c b/arch/riscv/kernel/soft_vector/insns/vsadd_vx.c
new file mode 100755
index 000000000..5f64d4e59
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsadd_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADD_VX);
+  #include "../insns_func/vsadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADD_VX);
+  #include "../insns_func/vsadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsaddu_vi.c b/arch/riscv/kernel/soft_vector/insns/vsaddu_vi.c
new file mode 100755
index 000000000..10db78130
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsaddu_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsaddu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADDU_VI);
+  #include "../insns_func/vsaddu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsaddu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADDU_VI);
+  #include "../insns_func/vsaddu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsaddu_vv.c b/arch/riscv/kernel/soft_vector/insns/vsaddu_vv.c
new file mode 100755
index 000000000..a3400f69d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsaddu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsaddu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADDU_VV);
+  #include "../insns_func/vsaddu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsaddu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADDU_VV);
+  #include "../insns_func/vsaddu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsaddu_vx.c b/arch/riscv/kernel/soft_vector/insns/vsaddu_vx.c
new file mode 100755
index 000000000..0b5eace61
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsaddu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsaddu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADDU_VX);
+  #include "../insns_func/vsaddu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsaddu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADDU_VX);
+  #include "../insns_func/vsaddu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsb_v.c b/arch/riscv/kernel/soft_vector/insns/vsb_v.c
new file mode 100755
index 000000000..74d633726
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSB_V);
+  #include "../insns_func/vsb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSB_V);
+  #include "../insns_func/vsb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsbc_vvm.c b/arch/riscv/kernel/soft_vector/insns/vsbc_vvm.c
new file mode 100755
index 000000000..cd64a5e53
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsbc_vvm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsbc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSBC_VVM);
+  #include "../insns_func/vsbc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsbc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSBC_VVM);
+  #include "../insns_func/vsbc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsbc_vxm.c b/arch/riscv/kernel/soft_vector/insns/vsbc_vxm.c
new file mode 100755
index 000000000..61754d1bc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsbc_vxm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsbc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSBC_VXM);
+  #include "../insns_func/vsbc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsbc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSBC_VXM);
+  #include "../insns_func/vsbc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vse_v.c b/arch/riscv/kernel/soft_vector/insns/vse_v.c
new file mode 100755
index 000000000..f1f7f91f8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vse_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSE_V);
+  #include "../insns_func/vse_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSE_V);
+  #include "../insns_func/vse_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsetvl.c b/arch/riscv/kernel/soft_vector/insns/vsetvl.c
new file mode 100755
index 000000000..c3073779a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsetvl.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsetvl(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSETVL);
+  #include "../insns_func/vsetvl.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsetvl(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSETVL);
+  #include "../insns_func/vsetvl.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsetvli.c b/arch/riscv/kernel/soft_vector/insns/vsetvli.c
new file mode 100755
index 000000000..f4f9d6da2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsetvli.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsetvli(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSETVLI);
+  #include "../insns_func/vsetvli.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsetvli(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSETVLI);
+  #include "../insns_func/vsetvli.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsh_v.c b/arch/riscv/kernel/soft_vector/insns/vsh_v.c
new file mode 100755
index 000000000..fb4b832fb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSH_V);
+  #include "../insns_func/vsh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSH_V);
+  #include "../insns_func/vsh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslide1down_vx.c b/arch/riscv/kernel/soft_vector/insns/vslide1down_vx.c
new file mode 100755
index 000000000..a8a45488e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslide1down_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslide1down_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDE1DOWN_VX);
+  #include "../insns_func/vslide1down_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslide1down_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDE1DOWN_VX);
+  #include "../insns_func/vslide1down_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslide1up_vx.c b/arch/riscv/kernel/soft_vector/insns/vslide1up_vx.c
new file mode 100755
index 000000000..066d5d0d4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslide1up_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslide1up_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDE1UP_VX);
+  #include "../insns_func/vslide1up_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslide1up_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDE1UP_VX);
+  #include "../insns_func/vslide1up_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslidedown_vi.c b/arch/riscv/kernel/soft_vector/insns/vslidedown_vi.c
new file mode 100755
index 000000000..0646d7deb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslidedown_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslidedown_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDEDOWN_VI);
+  #include "../insns_func/vslidedown_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslidedown_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDEDOWN_VI);
+  #include "../insns_func/vslidedown_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslidedown_vx.c b/arch/riscv/kernel/soft_vector/insns/vslidedown_vx.c
new file mode 100755
index 000000000..d53609f59
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslidedown_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslidedown_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDEDOWN_VX);
+  #include "../insns_func/vslidedown_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslidedown_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDEDOWN_VX);
+  #include "../insns_func/vslidedown_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslideup_vi.c b/arch/riscv/kernel/soft_vector/insns/vslideup_vi.c
new file mode 100755
index 000000000..29b673e46
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslideup_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslideup_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDEUP_VI);
+  #include "../insns_func/vslideup_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslideup_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDEUP_VI);
+  #include "../insns_func/vslideup_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslideup_vx.c b/arch/riscv/kernel/soft_vector/insns/vslideup_vx.c
new file mode 100755
index 000000000..612afd688
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslideup_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslideup_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDEUP_VX);
+  #include "../insns_func/vslideup_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslideup_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDEUP_VX);
+  #include "../insns_func/vslideup_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsll_vi.c b/arch/riscv/kernel/soft_vector/insns/vsll_vi.c
new file mode 100755
index 000000000..211e331dd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsll_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsll_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLL_VI);
+  #include "../insns_func/vsll_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsll_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLL_VI);
+  #include "../insns_func/vsll_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsll_vv.c b/arch/riscv/kernel/soft_vector/insns/vsll_vv.c
new file mode 100755
index 000000000..3541c425c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsll_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsll_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLL_VV);
+  #include "../insns_func/vsll_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsll_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLL_VV);
+  #include "../insns_func/vsll_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsll_vx.c b/arch/riscv/kernel/soft_vector/insns/vsll_vx.c
new file mode 100755
index 000000000..3f4352099
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsll_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsll_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLL_VX);
+  #include "../insns_func/vsll_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsll_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLL_VX);
+  #include "../insns_func/vsll_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsmul_vv.c b/arch/riscv/kernel/soft_vector/insns/vsmul_vv.c
new file mode 100755
index 000000000..13e91dab1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsmul_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSMUL_VV);
+  #include "../insns_func/vsmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSMUL_VV);
+  #include "../insns_func/vsmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsmul_vx.c b/arch/riscv/kernel/soft_vector/insns/vsmul_vx.c
new file mode 100755
index 000000000..b119dfe9a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsmul_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSMUL_VX);
+  #include "../insns_func/vsmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSMUL_VX);
+  #include "../insns_func/vsmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsra_vi.c b/arch/riscv/kernel/soft_vector/insns/vsra_vi.c
new file mode 100755
index 000000000..b01eb734b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsra_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRA_VI);
+  #include "../insns_func/vsra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRA_VI);
+  #include "../insns_func/vsra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsra_vv.c b/arch/riscv/kernel/soft_vector/insns/vsra_vv.c
new file mode 100755
index 000000000..c7ded9ee8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsra_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRA_VV);
+  #include "../insns_func/vsra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRA_VV);
+  #include "../insns_func/vsra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsra_vx.c b/arch/riscv/kernel/soft_vector/insns/vsra_vx.c
new file mode 100755
index 000000000..508832ee7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsra_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRA_VX);
+  #include "../insns_func/vsra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRA_VX);
+  #include "../insns_func/vsra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsrl_vi.c b/arch/riscv/kernel/soft_vector/insns/vsrl_vi.c
new file mode 100755
index 000000000..3542fa853
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsrl_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRL_VI);
+  #include "../insns_func/vsrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRL_VI);
+  #include "../insns_func/vsrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsrl_vv.c b/arch/riscv/kernel/soft_vector/insns/vsrl_vv.c
new file mode 100755
index 000000000..579aa1920
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsrl_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRL_VV);
+  #include "../insns_func/vsrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRL_VV);
+  #include "../insns_func/vsrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsrl_vx.c b/arch/riscv/kernel/soft_vector/insns/vsrl_vx.c
new file mode 100755
index 000000000..7d83b7884
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsrl_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRL_VX);
+  #include "../insns_func/vsrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRL_VX);
+  #include "../insns_func/vsrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssb_v.c b/arch/riscv/kernel/soft_vector/insns/vssb_v.c
new file mode 100755
index 000000000..e91cad1e0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSB_V);
+  #include "../insns_func/vssb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSB_V);
+  #include "../insns_func/vssb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsse_v.c b/arch/riscv/kernel/soft_vector/insns/vsse_v.c
new file mode 100755
index 000000000..dcd4fb19f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsse_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSE_V);
+  #include "../insns_func/vsse_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSE_V);
+  #include "../insns_func/vsse_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssh_v.c b/arch/riscv/kernel/soft_vector/insns/vssh_v.c
new file mode 100755
index 000000000..abeb9fcb3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSH_V);
+  #include "../insns_func/vssh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSH_V);
+  #include "../insns_func/vssh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssra_vi.c b/arch/riscv/kernel/soft_vector/insns/vssra_vi.c
new file mode 100755
index 000000000..5695e58e2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssra_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRA_VI);
+  #include "../insns_func/vssra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRA_VI);
+  #include "../insns_func/vssra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssra_vv.c b/arch/riscv/kernel/soft_vector/insns/vssra_vv.c
new file mode 100755
index 000000000..a190e6500
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssra_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRA_VV);
+  #include "../insns_func/vssra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRA_VV);
+  #include "../insns_func/vssra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssra_vx.c b/arch/riscv/kernel/soft_vector/insns/vssra_vx.c
new file mode 100755
index 000000000..05fee81aa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssra_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRA_VX);
+  #include "../insns_func/vssra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRA_VX);
+  #include "../insns_func/vssra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssrl_vi.c b/arch/riscv/kernel/soft_vector/insns/vssrl_vi.c
new file mode 100755
index 000000000..1d47d0081
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssrl_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRL_VI);
+  #include "../insns_func/vssrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRL_VI);
+  #include "../insns_func/vssrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssrl_vv.c b/arch/riscv/kernel/soft_vector/insns/vssrl_vv.c
new file mode 100755
index 000000000..6d4b6e2ea
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssrl_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRL_VV);
+  #include "../insns_func/vssrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRL_VV);
+  #include "../insns_func/vssrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssrl_vx.c b/arch/riscv/kernel/soft_vector/insns/vssrl_vx.c
new file mode 100755
index 000000000..c1cb90622
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssrl_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRL_VX);
+  #include "../insns_func/vssrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRL_VX);
+  #include "../insns_func/vssrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssub_vv.c b/arch/riscv/kernel/soft_vector/insns/vssub_vv.c
new file mode 100755
index 000000000..eb15318ba
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSUB_VV);
+  #include "../insns_func/vssub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSUB_VV);
+  #include "../insns_func/vssub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssub_vx.c b/arch/riscv/kernel/soft_vector/insns/vssub_vx.c
new file mode 100755
index 000000000..3af83aac4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSUB_VX);
+  #include "../insns_func/vssub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSUB_VX);
+  #include "../insns_func/vssub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssubu_vv.c b/arch/riscv/kernel/soft_vector/insns/vssubu_vv.c
new file mode 100755
index 000000000..28c20583e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssubu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssubu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSUBU_VV);
+  #include "../insns_func/vssubu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssubu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSUBU_VV);
+  #include "../insns_func/vssubu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssubu_vx.c b/arch/riscv/kernel/soft_vector/insns/vssubu_vx.c
new file mode 100755
index 000000000..5b0d3e071
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssubu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssubu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSUBU_VX);
+  #include "../insns_func/vssubu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssubu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSUBU_VX);
+  #include "../insns_func/vssubu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssw_v.c b/arch/riscv/kernel/soft_vector/insns/vssw_v.c
new file mode 100755
index 000000000..90c3243ad
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSW_V);
+  #include "../insns_func/vssw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSW_V);
+  #include "../insns_func/vssw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vsub_vv.c
new file mode 100755
index 000000000..9b290fde3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUB_VV);
+  #include "../insns_func/vsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUB_VV);
+  #include "../insns_func/vsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsub_vx.c b/arch/riscv/kernel/soft_vector/insns/vsub_vx.c
new file mode 100755
index 000000000..5876fbf08
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUB_VX);
+  #include "../insns_func/vsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUB_VX);
+  #include "../insns_func/vsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsuxb_v.c b/arch/riscv/kernel/soft_vector/insns/vsuxb_v.c
new file mode 100755
index 000000000..77f32bd84
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsuxb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsuxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUXB_V);
+  #include "../insns_func/vsuxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsuxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUXB_V);
+  #include "../insns_func/vsuxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsuxe_v.c b/arch/riscv/kernel/soft_vector/insns/vsuxe_v.c
new file mode 100755
index 000000000..134d7a17c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsuxe_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsuxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUXE_V);
+  #include "../insns_func/vsuxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsuxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUXE_V);
+  #include "../insns_func/vsuxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsuxh_v.c b/arch/riscv/kernel/soft_vector/insns/vsuxh_v.c
new file mode 100755
index 000000000..d66119864
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsuxh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsuxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUXH_V);
+  #include "../insns_func/vsuxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsuxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUXH_V);
+  #include "../insns_func/vsuxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsuxw_v.c b/arch/riscv/kernel/soft_vector/insns/vsuxw_v.c
new file mode 100755
index 000000000..e774c9fb0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsuxw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsuxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUXW_V);
+  #include "../insns_func/vsuxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsuxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUXW_V);
+  #include "../insns_func/vsuxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsw_v.c b/arch/riscv/kernel/soft_vector/insns/vsw_v.c
new file mode 100755
index 000000000..bc8c83e6b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSW_V);
+  #include "../insns_func/vsw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSW_V);
+  #include "../insns_func/vsw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsxb_v.c b/arch/riscv/kernel/soft_vector/insns/vsxb_v.c
new file mode 100755
index 000000000..0be0652ec
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsxb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSXB_V);
+  #include "../insns_func/vsxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSXB_V);
+  #include "../insns_func/vsxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsxe_v.c b/arch/riscv/kernel/soft_vector/insns/vsxe_v.c
new file mode 100755
index 000000000..78359bf49
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsxe_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSXE_V);
+  #include "../insns_func/vsxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSXE_V);
+  #include "../insns_func/vsxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsxh_v.c b/arch/riscv/kernel/soft_vector/insns/vsxh_v.c
new file mode 100755
index 000000000..1fd137b79
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsxh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSXH_V);
+  #include "../insns_func/vsxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSXH_V);
+  #include "../insns_func/vsxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsxw_v.c b/arch/riscv/kernel/soft_vector/insns/vsxw_v.c
new file mode 100755
index 000000000..110d99012
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsxw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSXW_V);
+  #include "../insns_func/vsxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSXW_V);
+  #include "../insns_func/vsxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vwadd_vv.c
new file mode 100755
index 000000000..8693958e0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADD_VV);
+  #include "../insns_func/vwadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADD_VV);
+  #include "../insns_func/vwadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwadd_vx.c b/arch/riscv/kernel/soft_vector/insns/vwadd_vx.c
new file mode 100755
index 000000000..44eb79160
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwadd_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADD_VX);
+  #include "../insns_func/vwadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADD_VX);
+  #include "../insns_func/vwadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwadd_wv.c b/arch/riscv/kernel/soft_vector/insns/vwadd_wv.c
new file mode 100755
index 000000000..148f24bd9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwadd_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwadd_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADD_WV);
+  #include "../insns_func/vwadd_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwadd_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADD_WV);
+  #include "../insns_func/vwadd_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwadd_wx.c b/arch/riscv/kernel/soft_vector/insns/vwadd_wx.c
new file mode 100755
index 000000000..abe840fb0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwadd_wx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwadd_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADD_WX);
+  #include "../insns_func/vwadd_wx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwadd_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADD_WX);
+  #include "../insns_func/vwadd_wx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwaddu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwaddu_vv.c
new file mode 100755
index 000000000..934147bbc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwaddu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwaddu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADDU_VV);
+  #include "../insns_func/vwaddu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwaddu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADDU_VV);
+  #include "../insns_func/vwaddu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwaddu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwaddu_vx.c
new file mode 100755
index 000000000..89cf4add0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwaddu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwaddu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADDU_VX);
+  #include "../insns_func/vwaddu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwaddu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADDU_VX);
+  #include "../insns_func/vwaddu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwaddu_wv.c b/arch/riscv/kernel/soft_vector/insns/vwaddu_wv.c
new file mode 100755
index 000000000..a7aa3f049
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwaddu_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwaddu_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADDU_WV);
+  #include "../insns_func/vwaddu_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwaddu_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADDU_WV);
+  #include "../insns_func/vwaddu_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwaddu_wx.c b/arch/riscv/kernel/soft_vector/insns/vwaddu_wx.c
new file mode 100755
index 000000000..a3b27e55e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwaddu_wx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwaddu_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADDU_WX);
+  #include "../insns_func/vwaddu_wx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwaddu_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADDU_WX);
+  #include "../insns_func/vwaddu_wx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmacc_vv.c
new file mode 100755
index 000000000..1787b0b35
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACC_VV);
+  #include "../insns_func/vwmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACC_VV);
+  #include "../insns_func/vwmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmacc_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmacc_vx.c
new file mode 100755
index 000000000..7e1b1a219
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmacc_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACC_VX);
+  #include "../insns_func/vwmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACC_VX);
+  #include "../insns_func/vwmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vv.c
new file mode 100755
index 000000000..8ef59be97
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmaccsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACCSU_VV);
+  #include "../insns_func/vwmaccsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmaccsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACCSU_VV);
+  #include "../insns_func/vwmaccsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vx.c
new file mode 100755
index 000000000..4fe95db85
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmaccsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACCSU_VX);
+  #include "../insns_func/vwmaccsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmaccsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACCSU_VX);
+  #include "../insns_func/vwmaccsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmaccu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmaccu_vv.c
new file mode 100755
index 000000000..2384eae09
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmaccu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmaccu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACCU_VV);
+  #include "../insns_func/vwmaccu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmaccu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACCU_VV);
+  #include "../insns_func/vwmaccu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmaccu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmaccu_vx.c
new file mode 100755
index 000000000..7f62d36ab
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmaccu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmaccu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACCU_VX);
+  #include "../insns_func/vwmaccu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmaccu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACCU_VX);
+  #include "../insns_func/vwmaccu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmaccus_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmaccus_vx.c
new file mode 100755
index 000000000..3b586482c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmaccus_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmaccus_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACCUS_VX);
+  #include "../insns_func/vwmaccus_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmaccus_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACCUS_VX);
+  #include "../insns_func/vwmaccus_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmul_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmul_vv.c
new file mode 100755
index 000000000..8e59408e0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmul_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMUL_VV);
+  #include "../insns_func/vwmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMUL_VV);
+  #include "../insns_func/vwmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmul_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmul_vx.c
new file mode 100755
index 000000000..38f9bd0f0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmul_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMUL_VX);
+  #include "../insns_func/vwmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMUL_VX);
+  #include "../insns_func/vwmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmulsu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmulsu_vv.c
new file mode 100755
index 000000000..eb6a05a73
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmulsu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmulsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMULSU_VV);
+  #include "../insns_func/vwmulsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmulsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMULSU_VV);
+  #include "../insns_func/vwmulsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmulsu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmulsu_vx.c
new file mode 100755
index 000000000..8a327e27a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmulsu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmulsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMULSU_VX);
+  #include "../insns_func/vwmulsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmulsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMULSU_VX);
+  #include "../insns_func/vwmulsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmulu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmulu_vv.c
new file mode 100755
index 000000000..4b5c933c1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmulu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmulu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMULU_VV);
+  #include "../insns_func/vwmulu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmulu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMULU_VV);
+  #include "../insns_func/vwmulu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmulu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmulu_vx.c
new file mode 100755
index 000000000..4fb562165
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmulu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmulu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMULU_VX);
+  #include "../insns_func/vwmulu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmulu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMULU_VX);
+  #include "../insns_func/vwmulu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwredsum_vs.c b/arch/riscv/kernel/soft_vector/insns/vwredsum_vs.c
new file mode 100755
index 000000000..6706f6c55
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwredsum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWREDSUM_VS);
+  #include "../insns_func/vwredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWREDSUM_VS);
+  #include "../insns_func/vwredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwredsumu_vs.c b/arch/riscv/kernel/soft_vector/insns/vwredsumu_vs.c
new file mode 100755
index 000000000..6f2d87d3d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwredsumu_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwredsumu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWREDSUMU_VS);
+  #include "../insns_func/vwredsumu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwredsumu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWREDSUMU_VS);
+  #include "../insns_func/vwredsumu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vwsmacc_vv.c
new file mode 100755
index 000000000..4df4c08b0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACC_VV);
+  #include "../insns_func/vwsmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACC_VV);
+  #include "../insns_func/vwsmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmacc_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsmacc_vx.c
new file mode 100755
index 000000000..b8ab47715
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmacc_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACC_VX);
+  #include "../insns_func/vwsmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACC_VX);
+  #include "../insns_func/vwsmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vv.c
new file mode 100755
index 000000000..053a9b1f3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmaccsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACCSU_VV);
+  #include "../insns_func/vwsmaccsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmaccsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACCSU_VV);
+  #include "../insns_func/vwsmaccsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vx.c
new file mode 100755
index 000000000..89bba0be5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmaccsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACCSU_VX);
+  #include "../insns_func/vwsmaccsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmaccsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACCSU_VX);
+  #include "../insns_func/vwsmaccsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vv.c
new file mode 100755
index 000000000..b68aaa29a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmaccu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACCU_VV);
+  #include "../insns_func/vwsmaccu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmaccu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACCU_VV);
+  #include "../insns_func/vwsmaccu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vx.c
new file mode 100755
index 000000000..96620aafd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmaccu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACCU_VX);
+  #include "../insns_func/vwsmaccu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmaccu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACCU_VX);
+  #include "../insns_func/vwsmaccu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmaccus_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsmaccus_vx.c
new file mode 100755
index 000000000..21ee05b5a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmaccus_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmaccus_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACCUS_VX);
+  #include "../insns_func/vwsmaccus_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmaccus_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACCUS_VX);
+  #include "../insns_func/vwsmaccus_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vwsub_vv.c
new file mode 100755
index 000000000..dd07ae4e7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUB_VV);
+  #include "../insns_func/vwsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUB_VV);
+  #include "../insns_func/vwsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsub_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsub_vx.c
new file mode 100755
index 000000000..427278b27
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUB_VX);
+  #include "../insns_func/vwsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUB_VX);
+  #include "../insns_func/vwsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsub_wv.c b/arch/riscv/kernel/soft_vector/insns/vwsub_wv.c
new file mode 100755
index 000000000..d8c8e10fc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsub_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsub_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUB_WV);
+  #include "../insns_func/vwsub_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsub_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUB_WV);
+  #include "../insns_func/vwsub_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsub_wx.c b/arch/riscv/kernel/soft_vector/insns/vwsub_wx.c
new file mode 100755
index 000000000..8240cdbe8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsub_wx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsub_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUB_WX);
+  #include "../insns_func/vwsub_wx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsub_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUB_WX);
+  #include "../insns_func/vwsub_wx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsubu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwsubu_vv.c
new file mode 100755
index 000000000..6e3b61426
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsubu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsubu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUBU_VV);
+  #include "../insns_func/vwsubu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsubu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUBU_VV);
+  #include "../insns_func/vwsubu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsubu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsubu_vx.c
new file mode 100755
index 000000000..5216c41b0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsubu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsubu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUBU_VX);
+  #include "../insns_func/vwsubu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsubu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUBU_VX);
+  #include "../insns_func/vwsubu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsubu_wv.c b/arch/riscv/kernel/soft_vector/insns/vwsubu_wv.c
new file mode 100755
index 000000000..da2343972
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsubu_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsubu_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUBU_WV);
+  #include "../insns_func/vwsubu_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsubu_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUBU_WV);
+  #include "../insns_func/vwsubu_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsubu_wx.c b/arch/riscv/kernel/soft_vector/insns/vwsubu_wx.c
new file mode 100755
index 000000000..48657a736
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsubu_wx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsubu_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUBU_WX);
+  #include "../insns_func/vwsubu_wx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsubu_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUBU_WX);
+  #include "../insns_func/vwsubu_wx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vxor_vi.c b/arch/riscv/kernel/soft_vector/insns/vxor_vi.c
new file mode 100755
index 000000000..371bdcb89
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vxor_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vxor_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VXOR_VI);
+  #include "../insns_func/vxor_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vxor_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VXOR_VI);
+  #include "../insns_func/vxor_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vxor_vv.c b/arch/riscv/kernel/soft_vector/insns/vxor_vv.c
new file mode 100755
index 000000000..170f68759
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vxor_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vxor_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VXOR_VV);
+  #include "../insns_func/vxor_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vxor_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VXOR_VV);
+  #include "../insns_func/vxor_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vxor_vx.c b/arch/riscv/kernel/soft_vector/insns/vxor_vx.c
new file mode 100755
index 000000000..ea54a83dc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vxor_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vxor_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VXOR_VX);
+  #include "../insns_func/vxor_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vxor_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VXOR_VX);
+  #include "../insns_func/vxor_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vaadd_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vi.h
new file mode 100755
index 000000000..e1823ffd9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vi.h
@@ -0,0 +1,9 @@
+// vaadd: Averaging adds of integers
+VRM xrm = VECTOR->vxrm;
+VI_VI_LOOP
+({
+  int64_t result = simm5 + vs2;
+  INT_ROUNDING(result, xrm, 1);
+  result = vzext(result >> 1, sew);
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vaadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vv.h
new file mode 100755
index 000000000..26c4011b5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vv.h
@@ -0,0 +1,2 @@
+// vaadd.vv *vd, vs2, vs1
+VI_VVX_LOOP_AVG(vs1, +);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vaadd_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vx.h
new file mode 100755
index 000000000..f418b9736
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vx.h
@@ -0,0 +1,2 @@
+// vaadd.vx *vd, vs2, rs1
+VI_VVX_LOOP_AVG(rs1, +);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadc_vim.h b/arch/riscv/kernel/soft_vector/insns_func/vadc_vim.h
new file mode 100755
index 000000000..b3db303f7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadc_vim.h
@@ -0,0 +1,11 @@
+// vadc.vim *vd, vs2, simm5
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+VI_VI_LOOP
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & simm5) + (op_mask & vs2) + carry;
+  *vd =res;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadc_vvm.h b/arch/riscv/kernel/soft_vector/insns_func/vadc_vvm.h
new file mode 100755
index 000000000..d594dc9cc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadc_vvm.h
@@ -0,0 +1,11 @@
+// vadc.vvm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+VI_VV_LOOP
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs1) + (op_mask & vs2) + carry;
+  *vd =res;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadc_vxm.h b/arch/riscv/kernel/soft_vector/insns_func/vadc_vxm.h
new file mode 100755
index 000000000..06d2048ee
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadc_vxm.h
@@ -0,0 +1,11 @@
+// vadc.vxm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+VI_VX_LOOP
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & rs1) + (op_mask & vs2) + carry;
+  *vd =res;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadd_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vadd_vi.h
new file mode 100755
index 000000000..92cc91251
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadd_vi.h
@@ -0,0 +1,5 @@
+// vadd.vi *vd, simm5, vs2, vm
+VI_VI_LOOP
+({
+  *vd =simm5 + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vadd_vv.h
new file mode 100755
index 000000000..a88ee781a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadd_vv.h
@@ -0,0 +1,5 @@
+// vadd.vv *vd, vs1, vs2, vm
+VI_VV_LOOP
+({
+  *vd =vs1 + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadd_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vadd_vx.h
new file mode 100755
index 000000000..538d5d471
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadd_vx.h
@@ -0,0 +1,5 @@
+// vadd.vx *vd, rs1, vs2, vm
+VI_VX_LOOP
+({
+  *vd =rs1 + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoaddd_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoaddd_v.h
new file mode 100755
index 000000000..53b0aa74f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoaddd_v.h
@@ -0,0 +1,2 @@
+//vamoaddd.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs + vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoaddw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoaddw_v.h
new file mode 100755
index 000000000..0a94a8670
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoaddw_v.h
@@ -0,0 +1,2 @@
+//vamoaddw.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs + vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoandd_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoandd_v.h
new file mode 100755
index 000000000..8834d131a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoandd_v.h
@@ -0,0 +1,2 @@
+//vamoandd.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs & vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoandw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoandw_v.h
new file mode 100755
index 000000000..11162036a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoandw_v.h
@@ -0,0 +1,2 @@
+//vamoandw.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs & vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamomaxd_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamomaxd_v.h
new file mode 100755
index 000000000..ad6f5d7da
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamomaxd_v.h
@@ -0,0 +1,2 @@
+//vamomaxd.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs >= vs3 ? lhs : vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamomaxud_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamomaxud_v.h
new file mode 100755
index 000000000..8a46f3d00
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamomaxud_v.h
@@ -0,0 +1,2 @@
+//vamomaxud.v vd, (rs1), vs2, vd
+VI_AMO({ val = (uint64_t)lhs >= (uint64_t)vs3 ? lhs : vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamomaxuw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamomaxuw_v.h
new file mode 100755
index 000000000..18d63e40b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamomaxuw_v.h
@@ -0,0 +1,2 @@
+//vamomaxuw.v vd, (rs1), vs2, vd
+VI_AMO({ val = (uint64_t)lhs >= (uint64_t)vs3 ? lhs : vs3;}, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamomaxw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamomaxw_v.h
new file mode 100755
index 000000000..2b9a83af4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamomaxw_v.h
@@ -0,0 +1,2 @@
+//vamomaxw.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs >= vs3 ? lhs : vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamomind_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamomind_v.h
new file mode 100755
index 000000000..9bcdd867f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamomind_v.h
@@ -0,0 +1,2 @@
+//vamomind.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs < vs3 ? lhs : vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamominud_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamominud_v.h
new file mode 100755
index 000000000..848d68262
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamominud_v.h
@@ -0,0 +1,2 @@
+//vamominue.v vd, (rs1), vs2, vd
+VI_AMO({ val = (uint64_t)lhs < (uint64_t)vs3 ? lhs : vs3;}, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamominuw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamominuw_v.h
new file mode 100755
index 000000000..6818caed2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamominuw_v.h
@@ -0,0 +1,2 @@
+//vamominuw.v vd, (rs1), vs2, vd
+VI_AMO({ val = (uint64_t)lhs < (uint64_t)vs3 ? lhs : vs3;; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamominw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamominw_v.h
new file mode 100755
index 000000000..f583790bc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamominw_v.h
@@ -0,0 +1,2 @@
+//vamomine.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs < vs3 ? lhs : vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoord_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoord_v.h
new file mode 100755
index 000000000..fd15529e8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoord_v.h
@@ -0,0 +1,2 @@
+//vamoord.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs | vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoorw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoorw_v.h
new file mode 100755
index 000000000..050c110a6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoorw_v.h
@@ -0,0 +1,2 @@
+//vamoorw.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs | vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoswapd_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoswapd_v.h
new file mode 100755
index 000000000..1ef371b6b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoswapd_v.h
@@ -0,0 +1,2 @@
+//vamoswapd.v vd, (rs1), vs2, vd
+VI_AMO({ val = vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoswapw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoswapw_v.h
new file mode 100755
index 000000000..ede53890b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoswapw_v.h
@@ -0,0 +1,2 @@
+//vamoswapw.v vd, (rs1), vs2, vd
+VI_AMO({ val = vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoxord_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoxord_v.h
new file mode 100755
index 000000000..fdf5f7a51
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoxord_v.h
@@ -0,0 +1,2 @@
+//vamoord.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs ^ vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoxorw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoxorw_v.h
new file mode 100755
index 000000000..48a302a84
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoxorw_v.h
@@ -0,0 +1,2 @@
+//vamoxorw.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs ^ vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vand_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vand_vi.h
new file mode 100755
index 000000000..f3a8ef1c3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vand_vi.h
@@ -0,0 +1,5 @@
+// vand.vi *vd, simm5, vs2, vm
+VI_VI_LOOP
+({
+  *vd =simm5 & vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vand_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vand_vv.h
new file mode 100755
index 000000000..e026eab9f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vand_vv.h
@@ -0,0 +1,5 @@
+// vand.vv *vd, vs1, vs2, vm
+VI_VV_LOOP
+({
+  *vd =vs1 & vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vand_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vand_vx.h
new file mode 100755
index 000000000..294d6a14b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vand_vx.h
@@ -0,0 +1,5 @@
+// vand.vx *vd, rs1, vs2, vm
+VI_VX_LOOP
+({
+  *vd =rs1 & vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vasub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vasub_vv.h
new file mode 100755
index 000000000..97c0b4d1a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vasub_vv.h
@@ -0,0 +1,2 @@
+// vasub.vv *vd, vs2, vs1
+VI_VVX_LOOP_AVG(vs1, -);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vasub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vasub_vx.h
new file mode 100755
index 000000000..f1597ee43
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vasub_vx.h
@@ -0,0 +1,2 @@
+// vasub.vx *vd, vs2, rs1
+VI_VVX_LOOP_AVG(rs1, -);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vcompress_vm.h b/arch/riscv/kernel/soft_vector/insns_func/vcompress_vm.h
new file mode 100755
index 000000000..1b85ab5e0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vcompress_vm.h
@@ -0,0 +1,44 @@
+// vcompress *vd, vs2, vs1
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+require(VECTOR->vstart == 0);
+{
+reg_t sew = VECTOR->vsew;
+reg_t vl = VECTOR->vl;
+reg_t rd_num = rd(insn);
+reg_t rs1_num = insn_rs1(insn);
+reg_t rs2_num = rs2(insn);
+reg_t pos = 0;
+reg_t i;
+for (i = VECTOR->vstart ; i < vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+
+  bool do_mask = (*vector_elt_uint64_t(VECTOR, rs1_num, midx) >> mpos) & 0x1;
+  if (do_mask) {
+    switch (sew) {
+    case e8:
+      *vector_elt_uint8_t(VECTOR, rd_num, pos) = *vector_elt_uint8_t(VECTOR, rs2_num, i);
+      break;
+    case e16:
+      *vector_elt_uint16_t(VECTOR, rd_num, pos) = *vector_elt_uint16_t(VECTOR, rs2_num, i);
+      break;
+    case e32:
+      *vector_elt_uint32_t(VECTOR, rd_num, pos) = *vector_elt_uint32_t(VECTOR, rs2_num, i);
+      break;
+    default:
+      *vector_elt_uint64_t(VECTOR, rd_num, pos) = *vector_elt_uint64_t(VECTOR, rs2_num, i);
+      break;
+    }
+
+    ++pos;
+  }
+}
+
+if (vl > 0 && TAIL_ZEROING) {
+  uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, pos * ((sew >> 3) * 1));
+  memset(tail, 0, (VECTOR->vlmax - pos) * ((sew >> 3) * 1));
+}
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdiv_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vdiv_vv.h
new file mode 100755
index 000000000..ee8eab44f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdiv_vv.h
@@ -0,0 +1,10 @@
+// *vdiv.vv *vd, vs2, vs1
+VI_VV_LOOP
+({
+  if (vs1 == 0)
+    *vd =-1;
+  else if (vs2 == -(1 << (sew - 1)) && vs1 == -1)
+    *vd =vs2;
+  else
+    *vd =vs2 / vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdiv_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vdiv_vx.h
new file mode 100755
index 000000000..338b5e720
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdiv_vx.h
@@ -0,0 +1,10 @@
+// *vdiv.vx *vd, vs2, rs1
+VI_VX_LOOP
+({
+  if(rs1 == 0)
+    *vd =-1;
+  else if(vs2 == -(1 << (sew - 1)) && rs1 == -1)
+    *vd =vs2;
+  else
+    *vd =vs2 / rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdivu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vdivu_vv.h
new file mode 100755
index 000000000..ad0e4dac8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdivu_vv.h
@@ -0,0 +1,8 @@
+// *vdivu.vv *vd, vs2, vs1
+VI_VV_ULOOP
+({
+  if(vs1 == 0)
+    *vd =-1;
+  else
+    *vd =vs2 / vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdivu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vdivu_vx.h
new file mode 100755
index 000000000..16f4c9d41
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdivu_vx.h
@@ -0,0 +1,8 @@
+// *vdivu.vx *vd, vs2, rs1
+VI_VX_ULOOP
+({
+  if(rs1 == 0)
+    *vd =-1;
+  else
+    *vd =vs2 / rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdot_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vdot_vv.h
new file mode 100755
index 000000000..3af6b1779
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdot_vv.h
@@ -0,0 +1,5 @@
+// *vdot *vd, vs2, vs1
+VI_VV_LOOP
+({
+  *vd += vs2 * vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdotu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vdotu_vv.h
new file mode 100755
index 000000000..b02d8d9e8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdotu_vv.h
@@ -0,0 +1,5 @@
+// *vdotu *vd, vs2, vs1
+VI_VV_ULOOP
+({
+  *vd += vs2 * vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vext_x_v.h b/arch/riscv/kernel/soft_vector/insns_func/vext_x_v.h
new file mode 100755
index 000000000..5f7d61958
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vext_x_v.h
@@ -0,0 +1,32 @@
+// vext_x_v: rd = vs2[rs1]
+require(v_vm(insn) == 1);
+{
+uint64_t xmask = UINT64_MAX >> (64 - get_max_xlen());
+reg_t rs1 = RS1;
+VI_LOOP_BASE
+VI_LOOP_END_NO_TAIL_ZERO
+if (!(rs1 >= 0 && rs1 < (VECTOR->VLEN/sew))) {
+  WRITE_RD(0);
+} else {
+  switch(sew) {
+  case e8:
+    WRITE_RD(*vector_elt_uint8_t(VECTOR, rs2_num, rs1));
+    break;
+  case e16:
+    WRITE_RD(*vector_elt_uint16_t(VECTOR, rs2_num, rs1));
+    break;
+  case e32:
+    if (get_max_xlen() == 32)
+      WRITE_RD(*vector_elt_int32_t(VECTOR, rs2_num, rs1));
+    else
+      WRITE_RD(*vector_elt_uint32_t(VECTOR, rs2_num, rs1));
+    break;
+  case e64:
+    if (get_max_xlen() <= sew)
+      WRITE_RD(*vector_elt_uint64_t(VECTOR, rs2_num, rs1) & xmask);
+    else
+      WRITE_RD(*vector_elt_uint64_t(VECTOR, rs2_num, rs1));
+    break;
+  }
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfadd_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfadd_vf.h
new file mode 100755
index 000000000..345b33575
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfadd_vf.h
@@ -0,0 +1,8 @@
+// vfadd.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP
+({
+    *vd =f32_add(rs1, vs2);
+},
+{
+    *vd =f64_add(rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfadd_vv.h
new file mode 100755
index 000000000..f5cd57f12
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfadd_vv.h
@@ -0,0 +1,8 @@
+// vfadd.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP
+({
+  *vd =f32_add(vs1, vs2);
+},
+{
+  *vd =f64_add(vs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfclass_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfclass_v.h
new file mode 100755
index 000000000..fc1153eea
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfclass_v.h
@@ -0,0 +1,8 @@
+// vfclass.v *vd, vs2, vm
+VI_VFP_VV_LOOP
+({
+  vd->v = f32_classify(vs2);
+},
+{
+  vd->v = f64_classify(vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_x_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_x_v.h
new file mode 100755
index 000000000..ead30589b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_x_v.h
@@ -0,0 +1,10 @@
+// vfcvt.f.x.v *vd, *vd2, vm
+VI_VFP_VV_LOOP
+({
+  int32_t vs2_i = *vector_elt_int32_t(VECTOR, rs2_num, i);
+  *vd =i32_to_f32(vs2_i);
+},
+{
+  int64_t vs2_i = *vector_elt_int64_t(VECTOR, rs2_num, i);
+  *vd =i64_to_f64(vs2_i);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_xu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_xu_v.h
new file mode 100755
index 000000000..36d6a2354
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_xu_v.h
@@ -0,0 +1,10 @@
+// vfcvt.f.xu.v *vd, *vd2, vm
+VI_VFP_VV_LOOP
+({
+  uint32_t vs2_u = *vector_elt_uint32_t(VECTOR, rs2_num, i);
+  *vd =ui32_to_f32(vs2_u);
+},
+{
+  uint64_t vs2_u = *vector_elt_uint64_t(VECTOR, rs2_num, i);
+  *vd =ui64_to_f64(vs2_u);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfcvt_x_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_x_f_v.h
new file mode 100755
index 000000000..6f481e5bb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_x_f_v.h
@@ -0,0 +1,7 @@
+// vfcvt.x.f.v *vd, *vd2, vm
+VI_VFP_VV_LOOP
+({
+  *vector_elt_int32_t(VECTOR, rd_num, i) = f32_to_i32(vs2, STATE.frm, true);
+},{
+  *vector_elt_int64_t(VECTOR, rd_num, i) = f64_to_i64(vs2, STATE.frm, true);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfcvt_xu_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_xu_f_v.h
new file mode 100755
index 000000000..938ddd555
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_xu_f_v.h
@@ -0,0 +1,8 @@
+// vfcvt.xu.f.v *vd, *vd2, vm
+VI_VFP_VV_LOOP
+({
+  *vector_elt_uint32_t(VECTOR, rd_num, i) = f32_to_ui32(vs2, STATE.frm, true);
+},
+{
+  *vector_elt_uint64_t(VECTOR, rd_num, i) = f64_to_ui64(vs2, STATE.frm, true);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vf.h
new file mode 100755
index 000000000..8666d5f6a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vf.h
@@ -0,0 +1,8 @@
+// vfdiv.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP
+({
+  *vd =f32_div(vs2, rs1);
+},
+{
+  *vd =f64_div(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vv.h
new file mode 100755
index 000000000..9da9a00da
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vv.h
@@ -0,0 +1,8 @@
+// vfdiv.vv  *vd, vs2, vs1
+VI_VFP_VV_LOOP
+({
+  *vd =f32_div(vs2, vs1);
+},
+{
+  *vd =f64_div(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfdot_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfdot_vv.h
new file mode 100755
index 000000000..7736994d4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfdot_vv.h
@@ -0,0 +1,8 @@
+// vfdot.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP
+({
+  *vd =f32_add(*vd, f32_mul(vs2, vs1));
+},
+{
+  *vd =f64_add(*vd, f64_mul(vs2, vs1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vf.h
new file mode 100755
index 000000000..86790ab6f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vf.h
@@ -0,0 +1,8 @@
+// vfmacc.vf *vd, rs1, vs2, vm    # *vd[i] = +(vs2[i] * x[rs1]) + *vd[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(rs1, vs2, *vd);
+},
+{
+  *vd =f64_mulAdd(rs1, vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vv.h
new file mode 100755
index 000000000..e2c38451a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vv.h
@@ -0,0 +1,8 @@
+// vfmacc.vv *vd, rs1, vs2, vm    # *vd[i] = +(vs2[i] * vs1[i]) + *vd[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(vs1, vs2, *vd);
+},
+{
+  *vd =f64_mulAdd(vs1, vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vf.h
new file mode 100755
index 000000000..8109d0fac
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vf.h
@@ -0,0 +1,8 @@
+// vfmadd: *vd[i] = +(*vd[i] * f[rs1]) + vs2[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(*vd, rs1, vs2);
+},
+{
+  *vd =f64_mulAdd(*vd, rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vv.h
new file mode 100755
index 000000000..0a17bbe29
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vv.h
@@ -0,0 +1,8 @@
+// vfmadd: *vd[i] = +(*vd[i] * vs1[i]) + vs2[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(*vd, vs1, vs2);
+},
+{
+  *vd =f64_mulAdd(*vd, vs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmax_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmax_vf.h
new file mode 100755
index 000000000..71f851c95
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmax_vf.h
@@ -0,0 +1,8 @@
+// vfmax
+VI_VFP_VF_LOOP
+({
+  *vd =f32_max(vs2, rs1);
+},
+{
+  *vd =f64_max(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmax_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmax_vv.h
new file mode 100755
index 000000000..4d63da38e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmax_vv.h
@@ -0,0 +1,8 @@
+// vfmax
+VI_VFP_VV_LOOP
+({
+  *vd =f32_max(vs2, vs1);
+},
+{
+  *vd =f64_max(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmerge_vfm.h b/arch/riscv/kernel/soft_vector/insns_func/vfmerge_vfm.h
new file mode 100755
index 000000000..e104fdfd3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmerge_vfm.h
@@ -0,0 +1,21 @@
+// vfmerge_vf *vd, vs2, vs1, vm
+VI_VFP_COMMON;
+{
+reg_t sew = VECTOR->vsew;
+reg_t i;
+for (i=VECTOR->vstart; i<vl; ++i) {
+  float64_t *vd =vector_elt_float64_t(VECTOR, rd_num, i);
+  float64_t rs1 = f64_f(READ_FREG(rs1_num));
+  float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i);
+
+  int midx = (VECTOR->vmlen * i) / 64;
+  int mpos = (VECTOR->vmlen * i) % 64;
+  bool use_first = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+
+  *vd =use_first ? rs1 : vs2;
+}
+
+VI_TAIL_ZERO(1);
+}
+VECTOR->vstart = 0;
+set_fp_exceptions;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmin_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmin_vf.h
new file mode 100755
index 000000000..2682e5c86
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmin_vf.h
@@ -0,0 +1,8 @@
+// vfmin *vd, vs2, rs1
+VI_VFP_VF_LOOP
+({
+  *vd =f32_min(vs2, rs1);
+},
+{
+  *vd =f64_min(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmin_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmin_vv.h
new file mode 100755
index 000000000..57e75fa22
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmin_vv.h
@@ -0,0 +1,8 @@
+// vfmin *vd, vs2, vs1
+VI_VFP_VV_LOOP
+({
+  *vd =f32_min(vs2, vs1);
+},
+{
+  *vd =f64_min(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vf.h
new file mode 100755
index 000000000..9f40071f8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vf.h
@@ -0,0 +1,8 @@
+// vfmsac: *vd[i] = +(f[rs1] * vs2[i]) - *vd[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(rs1, vs2, f32(vd->v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(rs1, vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vv.h
new file mode 100755
index 000000000..e6af0f47e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vv.h
@@ -0,0 +1,8 @@
+// vfmsac: *vd[i] = +(vs1[i] * vs2[i]) - *vd[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(vs1, vs2, f32(vd->v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(vs1, vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vf.h
new file mode 100755
index 000000000..be64d9a4c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vf.h
@@ -0,0 +1,8 @@
+// vfmsub: *vd[i] = +(*vd[i] * f[rs1]) - vs2[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(*vd, rs1, f32(vs2.v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(*vd, rs1, f64(vs2.v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vv.h
new file mode 100755
index 000000000..4d454df20
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vv.h
@@ -0,0 +1,8 @@
+// vfmsub: *vd[i] = +(*vd[i] * vs1[i]) - vs2[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(*vd, vs1, f32(vs2.v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(*vd, vs1, f64(vs2.v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmul_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmul_vf.h
new file mode 100755
index 000000000..bea3c046d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmul_vf.h
@@ -0,0 +1,8 @@
+// vfmul.vf *vd, vs2, rs1, vm
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mul(vs2, rs1);
+},
+{
+  *vd =f64_mul(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmul_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmul_vv.h
new file mode 100755
index 000000000..94e81e190
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmul_vv.h
@@ -0,0 +1,8 @@
+// vfmul.vv *vd, vs1, vs2, vm
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mul(vs1, vs2);
+},
+{
+  *vd =f64_mul(vs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmv_f_s.h b/arch/riscv/kernel/soft_vector/insns_func/vfmv_f_s.h
new file mode 100755
index 000000000..bf75fa977
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmv_f_s.h
@@ -0,0 +1,35 @@
+// vfmv_f_s: rd = vs2[0] (rs1=0)
+require(v_vm(insn) == 1);
+require_fp;
+require(VECTOR->vsew == e8 || VECTOR->vsew == e16 || VECTOR->vsew == e32 || VECTOR->vsew == e64);
+
+{
+reg_t rs2_num = rs2(insn);
+uint64_t vs2_0 = 0;
+const reg_t sew = VECTOR->vsew;
+switch(sew) {
+case e8:
+  vs2_0 = *vector_elt_uint8_t(VECTOR, rs2_num, 0);
+  break;
+case e16:
+  vs2_0 = *vector_elt_uint16_t(VECTOR, rs2_num, 0);
+  break;
+case e32:
+  vs2_0 = *vector_elt_uint32_t(VECTOR, rs2_num, 0);
+  break;
+default:
+  vs2_0 = *vector_elt_uint64_t(VECTOR, rs2_num, 0);
+  break;
+}
+
+// nan_extened
+if (FLEN > sew) {
+  vs2_0 = vs2_0 | ~((1ul << sew) - 1);
+}
+
+if (FLEN == 64) {
+  WRITE_FRD(f64(vs2_0), 64);
+} else {
+  WRITE_FRD(f32(vs2_0), 32);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmv_s_f.h b/arch/riscv/kernel/soft_vector/insns_func/vfmv_s_f.h
new file mode 100755
index 000000000..c9c1152e1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmv_s_f.h
@@ -0,0 +1,29 @@
+// vfmv_s_f: *vd[0] = rs1 (vs2=0)
+reg_t vl = VECTOR->vl;
+require(v_vm(insn) == 1);
+require_fp;
+
+if (vl > 0) {
+  reg_t i;
+  reg_t rd_num = rd(insn);
+  reg_t sew = VECTOR->vsew;
+
+  if (FLEN == 64)
+    *vector_elt_uint64_t(VECTOR, rd_num, 0) = f64_f(FRS1).v;
+  else
+    *vector_elt_uint64_t(VECTOR, rd_num, 0) = f32_f(FRS1).v;
+  {
+  const reg_t max_len = VECTOR->VLEN / sew;
+  for (i = 1; i < max_len; ++i) {
+    switch(sew) {
+    case e64:
+      *vector_elt_uint64_t(VECTOR, rd_num, i) = 0;
+      break;
+    default:
+      require(false);
+      break;
+    }
+  }
+  }
+  vl = 0;
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmv_v_f.h b/arch/riscv/kernel/soft_vector/insns_func/vfmv_v_f.h
new file mode 100755
index 000000000..1d824d767
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmv_v_f.h
@@ -0,0 +1,16 @@
+// vfmerge_vf *vd, vs2, vs1, vm
+VI_VFP_COMMON;
+{
+reg_t sew = VECTOR->vsew;
+reg_t i;
+for (i=VECTOR->vstart; i<vl; ++i) {
+  float64_t *vd =vector_elt_float64_t(VECTOR, rd_num, i);
+  float64_t rs1 = f64_f(READ_FREG(rs1_num));
+
+  *vd =rs1;
+}
+
+VI_TAIL_ZERO(1);
+}
+VECTOR->vstart = 0;
+set_fp_exceptions;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_f_v.h
new file mode 100755
index 000000000..9d2065ced
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_f_v.h
@@ -0,0 +1,8 @@
+// vfncvt.f.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_SD;
+  {
+  float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i);
+  *vector_elt_float32_t(VECTOR, rd_num, i) = f64_to_f32(vs2);
+  }
+VI_VFP_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_x_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_x_v.h
new file mode 100755
index 000000000..25679d3d8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_x_v.h
@@ -0,0 +1,8 @@
+// vfncvt.f.x.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_SD;
+{
+  int64_t vs2 = *vector_elt_int64_t(VECTOR, rs2_num, i);
+  *vector_elt_float32_t(VECTOR, rd_num, i) = i64_to_f32(vs2);
+}
+VI_VFP_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_xu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_xu_v.h
new file mode 100755
index 000000000..8b44de855
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_xu_v.h
@@ -0,0 +1,8 @@
+// vfncvt.f.xu.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_SD;
+{
+  uint64_t vs2 = *vector_elt_uint64_t(VECTOR, rs2_num, i);
+  *vector_elt_float32_t(VECTOR, rd_num, i) = ui64_to_f32(vs2);
+}
+VI_VFP_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfncvt_x_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_x_f_v.h
new file mode 100755
index 000000000..e08c7b0a9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_x_f_v.h
@@ -0,0 +1,8 @@
+// vfncvt.x.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_SD;
+{
+  float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i);
+  *vector_elt_int32_t(VECTOR, rd_num, i) = f64_to_i32(vs2, STATE.frm, true);
+}
+VI_VFP_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfncvt_xu_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_xu_f_v.h
new file mode 100755
index 000000000..88c9f35f2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_xu_f_v.h
@@ -0,0 +1,8 @@
+// vfncvt.xu.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_SD;
+{
+  float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i);
+  *vector_elt_uint32_t(VECTOR, rd_num, i) = f64_to_ui32(vs2, STATE.frm, true);
+}
+VI_VFP_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vf.h
new file mode 100755
index 000000000..97082b71f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vf.h
@@ -0,0 +1,8 @@
+// vfnmacc: *vd[i] = -(f[rs1] * vs2[i]) - *vd[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(rs1, f32(vs2.v ^ F32_SIGN), f32(vd->v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(rs1, f64(vs2.v ^ F64_SIGN), f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vv.h
new file mode 100755
index 000000000..2749b66db
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vv.h
@@ -0,0 +1,8 @@
+// vfnmacc: *vd[i] = -(vs1[i] * vs2[i]) - *vd[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(f32(vs2.v ^ F32_SIGN), vs1, f32(vd->v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(f64(vs2.v ^ F64_SIGN), vs1, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vf.h
new file mode 100755
index 000000000..e9a88e8c9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vf.h
@@ -0,0 +1,8 @@
+// vfnmadd: *vd[i] = -(*vd[i] * f[rs1]) - vs2[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(f32(vd->v ^ F32_SIGN), rs1, f32(vs2.v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(f64(vd->v ^ F64_SIGN), rs1, f64(vs2.v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vv.h
new file mode 100755
index 000000000..40e0632f2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vv.h
@@ -0,0 +1,8 @@
+// vfnmadd: *vd[i] = -(*vd[i] * vs1[i]) - vs2[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(f32(vd->v ^ F32_SIGN), vs1, f32(vs2.v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(f64(vd->v ^ F64_SIGN), vs1, f64(vs2.v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vf.h
new file mode 100755
index 000000000..cfd7fd159
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vf.h
@@ -0,0 +1,8 @@
+// vfnmsac: *vd[i] = -(f[rs1] * vs2[i]) + *vd[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(rs1, f32(vs2.v ^ F32_SIGN), *vd);
+},
+{
+  *vd =f64_mulAdd(rs1, f64(vs2.v ^ F64_SIGN), *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vv.h
new file mode 100755
index 000000000..b1c457ba0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vv.h
@@ -0,0 +1,8 @@
+// vfnmsac.vv *vd, vs1, vs2, vm   # *vd[i] = -(vs2[i] * vs1[i]) + *vd[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(f32(vs1.v ^ F32_SIGN), vs2, *vd);
+},
+{
+  *vd =f64_mulAdd(f64(vs1.v ^ F64_SIGN), vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vf.h
new file mode 100755
index 000000000..e64189039
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vf.h
@@ -0,0 +1,8 @@
+// vfnmsub: *vd[i] = -(*vd[i] * f[rs1]) + vs2[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(f32(vd->v ^ F32_SIGN), rs1, vs2);
+},
+{
+  *vd =f64_mulAdd(f64(vd->v ^ F64_SIGN), rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vv.h
new file mode 100755
index 000000000..6bab3f417
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vv.h
@@ -0,0 +1,8 @@
+// vfnmsub: *vd[i] = -(*vd[i] * vs1[i]) + vs2[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(f32(vd->v ^ F32_SIGN), vs1, vs2);
+},
+{
+  *vd =f64_mulAdd(f64(vd->v ^ F64_SIGN), vs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfrdiv_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfrdiv_vf.h
new file mode 100755
index 000000000..c6296d550
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfrdiv_vf.h
@@ -0,0 +1,8 @@
+// vfrdiv.vf *vd, vs2, rs1, vm  # scalar-vector, *vd[i] = f[rs1]/vs2[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_div(rs1, vs2);
+},
+{
+  *vd =f64_div(rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfredmax_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfredmax_vs.h
new file mode 100755
index 000000000..7aeb773e2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfredmax_vs.h
@@ -0,0 +1,5 @@
+// vfredmax *vd, vs2, vs1
+VI_VFP_VV_LOOP_REDUCTION
+({
+  vd_0 = f64_max(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfredmin_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfredmin_vs.h
new file mode 100755
index 000000000..5eecefe1e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfredmin_vs.h
@@ -0,0 +1,5 @@
+// vfredmin *vd, vs2, vs1
+VI_VFP_VV_LOOP_REDUCTION
+({
+  vd_0 = f64_min(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfredosum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfredosum_vs.h
new file mode 100755
index 000000000..6eeb7b5e2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfredosum_vs.h
@@ -0,0 +1,5 @@
+// vfredosum: *vd[0] =  sum( vs2[*] , vs1[0] )
+VI_VFP_VV_LOOP_REDUCTION
+({
+  vd_0 = f64_add(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfredsum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfredsum_vs.h
new file mode 100755
index 000000000..189b4d211
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfredsum_vs.h
@@ -0,0 +1,5 @@
+// vfredsum: *vd[0] =  sum( vs2[*] , vs1[0] )
+VI_VFP_VV_LOOP_REDUCTION
+({
+  vd_0 = f64_add(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfrsub_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfrsub_vf.h
new file mode 100755
index 000000000..03d25bd41
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfrsub_vf.h
@@ -0,0 +1,8 @@
+// vfsub.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP
+({
+  *vd =f32_sub(rs1, vs2);
+},
+{
+  *vd =f64_sub(rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vf.h
new file mode 100755
index 000000000..5bb49ecf2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vf.h
@@ -0,0 +1,8 @@
+// vfsgnj *vd, vs2, vs1
+VI_VFP_VF_LOOP
+({
+  *vd =fsgnj32(vs2.v, rs1.v, false, false);
+},
+{
+  *vd =fsgnj64(vs2.v, rs1.v, false, false);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vv.h
new file mode 100755
index 000000000..8a6565d30
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vv.h
@@ -0,0 +1,8 @@
+// vfsgnj
+VI_VFP_VV_LOOP
+({
+  *vd =fsgnj32(vs2.v, vs1.v, false, false);
+},
+{
+  *vd =fsgnj64(vs2.v, vs1.v, false, false);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vf.h
new file mode 100755
index 000000000..9843748cb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vf.h
@@ -0,0 +1,8 @@
+// vfsgnn
+VI_VFP_VF_LOOP
+({
+  *vd =fsgnj32(vs2.v, rs1.v, true, false);
+},
+{
+  *vd =fsgnj64(vs2.v, rs1.v, true, false);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vv.h
new file mode 100755
index 000000000..4b2189087
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vv.h
@@ -0,0 +1,8 @@
+// vfsgnn
+VI_VFP_VV_LOOP
+({
+  *vd =fsgnj32(vs2.v, vs1.v, true, false);
+},
+{
+  *vd =fsgnj64(vs2.v, vs1.v, true, false);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vf.h
new file mode 100755
index 000000000..ad5466bf1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vf.h
@@ -0,0 +1,8 @@
+// vfsgnx
+VI_VFP_VF_LOOP
+({
+  *vd =fsgnj32(vs2.v, rs1.v, false, true);
+},
+{
+  *vd =fsgnj64(vs2.v, rs1.v, false, true);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vv.h
new file mode 100755
index 000000000..409cbef9f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vv.h
@@ -0,0 +1,8 @@
+// vfsgnx
+VI_VFP_VV_LOOP
+({
+  *vd =fsgnj32(vs2.v, vs1.v, false, true);
+},
+{
+  *vd =fsgnj64(vs2.v, vs1.v, false, true);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsqrt_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfsqrt_v.h
new file mode 100755
index 000000000..8b50cc079
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsqrt_v.h
@@ -0,0 +1,8 @@
+// vsqrt.v *vd, *vd2, vm
+VI_VFP_VV_LOOP
+({
+  *vd =f32_sqrt(vs2);
+},
+{
+  *vd =f64_sqrt(vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsub_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfsub_vf.h
new file mode 100755
index 000000000..be191ef61
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsub_vf.h
@@ -0,0 +1,8 @@
+// vfsub.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP
+({
+  *vd =f32_sub(vs2, rs1);
+},
+{
+  *vd =f64_sub(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfsub_vv.h
new file mode 100755
index 000000000..9bae3349b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsub_vv.h
@@ -0,0 +1,8 @@
+// vfsub.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP
+({
+  *vd =f32_sub(vs2, vs1);
+},
+{
+  *vd =f64_sub(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vf.h
new file mode 100755
index 000000000..56ee79598
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vf.h
@@ -0,0 +1,5 @@
+// vfwadd.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_add(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vv.h
new file mode 100755
index 000000000..11c5612cc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vv.h
@@ -0,0 +1,5 @@
+// vfwadd.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_add(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wf.h
new file mode 100755
index 000000000..2cad4c1a1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wf.h
@@ -0,0 +1,5 @@
+// vfwadd.wf *vd, vs2, vs1
+VI_VFP_WF_LOOP_WIDE
+({
+  *vd =f64_add(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wv.h
new file mode 100755
index 000000000..a77615840
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wv.h
@@ -0,0 +1,5 @@
+// vfwadd.wv *vd, vs2, vs1
+VI_VFP_WV_LOOP_WIDE
+({
+  *vd =f64_add(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_f_v.h
new file mode 100755
index 000000000..c7f22aef5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_f_v.h
@@ -0,0 +1,9 @@
+// vfwcvt.f.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_DSS(false);
+  {
+  float32_t vs2 = *vector_elt_float32_t(VECTOR, rs2_num, i);
+  *vector_elt_float64_t(VECTOR, rd_num, i) = f32_to_f64(vs2);
+  }
+  set_fp_exceptions;
+VI_VFP_LOOP_WIDE_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_x_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_x_v.h
new file mode 100755
index 000000000..b4cfabc73
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_x_v.h
@@ -0,0 +1,9 @@
+// vfwcvt.f.x.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_DSS(false);
+  {
+  int32_t vs2 = *vector_elt_int32_t(VECTOR, rs2_num, i);
+  *vector_elt_float64_t(VECTOR, rd_num, i) = i32_to_f64(vs2);
+  }
+  set_fp_exceptions;
+VI_VFP_LOOP_WIDE_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_xu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_xu_v.h
new file mode 100755
index 000000000..a1dbf1ff5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_xu_v.h
@@ -0,0 +1,9 @@
+// vfwcvt.f.xu.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_DSS(false);
+  {
+  uint32_t vs2 = *vector_elt_uint32_t(VECTOR, rs2_num, i);
+  *vector_elt_float64_t(VECTOR, rd_num, i) = ui32_to_f64(vs2);
+  }
+  set_fp_exceptions;
+VI_VFP_LOOP_WIDE_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_x_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_x_f_v.h
new file mode 100755
index 000000000..81dafb583
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_x_f_v.h
@@ -0,0 +1,9 @@
+// vfwcvt.x.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_DSS(false);
+  {
+  float32_t vs2 = *vector_elt_float32_t(VECTOR, rs2_num, i);
+  *vector_elt_int64_t(VECTOR, rd_num, i) = f32_to_i64(vs2, STATE.frm, true);
+  }
+  set_fp_exceptions;
+VI_VFP_LOOP_WIDE_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_xu_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_xu_f_v.h
new file mode 100755
index 000000000..f368e7b61
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_xu_f_v.h
@@ -0,0 +1,9 @@
+// vfwcvt.xu.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_DSS(false);
+  {
+  float32_t vs2 = *vector_elt_float32_t(VECTOR, rs2_num, i);
+  *vector_elt_uint64_t(VECTOR, rd_num, i) = f32_to_ui64(vs2, STATE.frm, true);
+  }
+  set_fp_exceptions;
+VI_VFP_LOOP_WIDE_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vf.h
new file mode 100755
index 000000000..b4576514a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vf.h
@@ -0,0 +1,5 @@
+// vfwmacc.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_mulAdd(rs1, vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vv.h
new file mode 100755
index 000000000..f54a075e9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vv.h
@@ -0,0 +1,5 @@
+// vfwmacc.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_mulAdd(vs1, vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vf.h
new file mode 100755
index 000000000..fe96edfc6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vf.h
@@ -0,0 +1,5 @@
+// vfwmsac.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_mulAdd(rs1, vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vv.h
new file mode 100755
index 000000000..429739112
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vv.h
@@ -0,0 +1,5 @@
+// vfwmsac.vv  *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_mulAdd(vs1, vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vf.h
new file mode 100755
index 000000000..0581b3b04
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vf.h
@@ -0,0 +1,5 @@
+// vfwmul.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_mul(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vv.h
new file mode 100755
index 000000000..7f6939d13
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vv.h
@@ -0,0 +1,5 @@
+// vfwmul.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_mul(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vf.h
new file mode 100755
index 000000000..09bd6e24d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vf.h
@@ -0,0 +1,5 @@
+// vfwnmacc.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_mulAdd(f64(rs1.v ^ F64_SIGN), vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vv.h
new file mode 100755
index 000000000..4695d749a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vv.h
@@ -0,0 +1,5 @@
+// vfwnmacc.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_mulAdd(f64(vs1.v ^ F64_SIGN), vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vf.h
new file mode 100755
index 000000000..344aae1a5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vf.h
@@ -0,0 +1,5 @@
+// vfwnmacc.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_mulAdd(f64(rs1.v ^ F64_SIGN), vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vv.h
new file mode 100755
index 000000000..cd858a783
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vv.h
@@ -0,0 +1,5 @@
+// vfwnmsac.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_mulAdd(f64(vs1.v ^ F64_SIGN), vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwredosum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfwredosum_vs.h
new file mode 100755
index 000000000..377df8842
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwredosum_vs.h
@@ -0,0 +1,5 @@
+// vfwredosum.vs *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE_REDUCTION
+({
+  vd_0 = f64_add(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwredsum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfwredsum_vs.h
new file mode 100755
index 000000000..ae857bc30
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwredsum_vs.h
@@ -0,0 +1,5 @@
+// vfwredsum.vs *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE_REDUCTION
+({
+  vd_0 = f64_add(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vf.h
new file mode 100755
index 000000000..50d8b86df
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vf.h
@@ -0,0 +1,5 @@
+// vfwsub.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_sub(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vv.h
new file mode 100755
index 000000000..680f6a45c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vv.h
@@ -0,0 +1,5 @@
+// vfwsub.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_sub(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wf.h
new file mode 100755
index 000000000..829076a2a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wf.h
@@ -0,0 +1,5 @@
+// vfwsub.wf *vd, vs2, rs1
+VI_VFP_WF_LOOP_WIDE
+({
+  *vd =f64_sub(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wv.h
new file mode 100755
index 000000000..5d62b8ba6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wv.h
@@ -0,0 +1,5 @@
+// vfwsub.wv *vd, vs2, vs1
+VI_VFP_WV_LOOP_WIDE
+({
+  *vd =f64_sub(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vid_v.h b/arch/riscv/kernel/soft_vector/insns_func/vid_v.h
new file mode 100755
index 000000000..3c270e8d9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vid_v.h
@@ -0,0 +1,31 @@
+// vmpopc rd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t sew = VECTOR->vsew;
+reg_t rd_num = rd(insn);
+
+reg_t i;
+for (i = VECTOR->vstart ; i < VECTOR->vl; ++i) {
+  VI_LOOP_ELEMENT_SKIP();
+
+  switch (sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, i) = i;
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = i;
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = i;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = i;
+    break;
+  }
+}
+
+VI_TAIL_ZERO(1);
+VECTOR->vstart = 0;
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/viota_m.h b/arch/riscv/kernel/soft_vector/insns_func/viota_m.h
new file mode 100755
index 000000000..9b0312a7a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/viota_m.h
@@ -0,0 +1,54 @@
+// vmpopc rd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+require(VECTOR->vstart == 0);
+{
+reg_t vl = VECTOR->vl;
+reg_t sew = VECTOR->vsew;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+
+int cnt = 0;
+reg_t i;
+for (i = 0; i < vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR, rs2_num, midx) >> mpos) & 0x1) == 1;
+  bool do_mask = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+
+  bool has_one = false;
+  bool use_ori = (v_vm(insn) == 0) && !do_mask;
+  if (v_vm(insn) == 1 || (v_vm(insn) == 0 && do_mask)) {
+    if (vs2_lsb) {
+      has_one = true;
+    }
+  }
+
+  switch (sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, i) = use_ori ?
+                                   *vector_elt_uint8_t(VECTOR, rd_num, i) : cnt;
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = use_ori ?
+                                    *vector_elt_uint16_t(VECTOR, rd_num, i) : cnt;
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = use_ori ?
+                                    *vector_elt_uint32_t(VECTOR, rd_num, i) : cnt;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = use_ori ?
+                                    *vector_elt_uint64_t(VECTOR, rd_num, i) : cnt;
+    break;
+  }
+
+  if (has_one) {
+    cnt++;
+  }
+}
+
+VI_TAIL_ZERO(1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlb_v.h
new file mode 100755
index 000000000..cac7a0e8b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlb_v.h
@@ -0,0 +1,5 @@
+// vlb.v and vlseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_LD(0, i * nf + fn, int8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlbff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlbff_v.h
new file mode 100755
index 000000000..6517315b5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlbff_v.h
@@ -0,0 +1,2 @@
+// vlbff.v and vlseg[2-8]bff.v
+VI_LDST_FF(int, 8);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlbu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlbu_v.h
new file mode 100755
index 000000000..d4f7ef62a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlbu_v.h
@@ -0,0 +1,5 @@
+// vlbu.v and vlseg[2-8]bu.v
+require(VECTOR->vsew >= e8);
+{
+VI_LD(0, i * nf + fn, uint8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlbuff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlbuff_v.h
new file mode 100755
index 000000000..53a068513
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlbuff_v.h
@@ -0,0 +1,2 @@
+// vlbuff.v and vlseg[2-8]buff.v
+VI_LDST_FF(uint, 8);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vle_v.h b/arch/riscv/kernel/soft_vector/insns_func/vle_v.h
new file mode 100755
index 000000000..dab7f1203
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vle_v.h
@@ -0,0 +1,12 @@
+// vle.v and vlseg[2-8]e.v
+reg_t sew = VECTOR->vsew;
+if (sew == e8) {
+  VI_LD(0, (i * nf + fn), int8, 1);
+} else if (sew == e16) {
+  VI_LD(0, (i * nf + fn), int16, 2);
+} else if (sew == e32) {
+  VI_LD(0, (i * nf + fn), int32, 4);
+} else if (sew == e64) {
+  VI_LD(0, (i * nf + fn), int64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vleff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vleff_v.h
new file mode 100755
index 000000000..00c5288f7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vleff_v.h
@@ -0,0 +1,58 @@
+
+const reg_t nf = v_nf(insn) + 1;
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require((nf * VECTOR->vlmul) <= (NVPR / 4));
+{
+const reg_t sew = VECTOR->vsew;
+const reg_t vl = VECTOR->vl;
+const reg_t baseAddr = RS1;
+const reg_t rd_num = rd(insn);
+bool early_stop = false;
+const reg_t vlmul = VECTOR->vlmul;
+reg_t i;
+for (i = 0; i < VECTOR->vlmax && vl != 0; ++i) {
+  bool is_valid = true;
+  bool is_zero = false;
+  reg_t fn;
+  VI_STRIP(i);
+  VI_ELEMENT_SKIP(i);
+
+for (fn = 0; fn < nf; ++fn) {
+    load_uint8(baseAddr + (i * nf + fn) * 1);
+
+    switch (sew) {
+    case e8:
+      *vector_elt_uint8_t(VECTOR, rd_num + fn * vlmul, vreg_inx) =
+        is_valid ? load_uint8(baseAddr + (i * nf + fn) * 1) : 0;
+      is_zero = is_valid && *vector_elt_uint8_t(VECTOR, rd_num + fn * vlmul, vreg_inx) == 0;
+      break;
+    case e16:
+      *vector_elt_uint16_t(VECTOR, rd_num + fn * vlmul, vreg_inx) =
+        is_valid ? load_uint16(baseAddr + (i * nf + fn) * 2) : 0;
+      is_zero = is_valid && *vector_elt_uint16_t(VECTOR, rd_num + fn * vlmul, vreg_inx) == 0;
+      break;
+    case e32:
+      *vector_elt_uint32_t(VECTOR, rd_num + fn * vlmul, vreg_inx) =
+        is_valid ? load_uint32(baseAddr + (i * nf + fn) * 4) : 0;
+      is_zero = is_valid && *vector_elt_uint32_t(VECTOR, rd_num + fn * vlmul, vreg_inx) == 0;
+      break;
+    case e64:
+      *vector_elt_uint64_t(VECTOR, rd_num + fn * vlmul, vreg_inx) =
+        is_valid ? load_uint64(baseAddr + (i * nf + fn) * 8) : 0;
+      is_zero = is_valid && *vector_elt_uint64_t(VECTOR, rd_num + fn * vlmul, vreg_inx) == 0;
+      break;
+    }
+
+    if (is_zero) {
+      VECTOR->vl = i;
+      early_stop = true;
+      break;
+    }
+  }
+
+  if (early_stop) {
+    break;
+  }
+}
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlh_v.h
new file mode 100755
index 000000000..690ca02cf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlh_v.h
@@ -0,0 +1,5 @@
+// vlh.v and vlseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_LD(0, i * nf + fn, int16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlhff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlhff_v.h
new file mode 100755
index 000000000..c4c2d8ea3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlhff_v.h
@@ -0,0 +1,2 @@
+// vlh.v and vlseg[2-8]hff.v
+VI_LDST_FF(int, 16);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlhu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlhu_v.h
new file mode 100755
index 000000000..5d87a82fe
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlhu_v.h
@@ -0,0 +1,5 @@
+// vlhu.v and vlseg[2-8]hu.v
+require(VECTOR->vsew >= e16);
+{
+VI_LD(0, i * nf + fn, uint16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlhuff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlhuff_v.h
new file mode 100755
index 000000000..f23f82db6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlhuff_v.h
@@ -0,0 +1,2 @@
+// vlhuff.v and vlseg[2-8]huff.v
+VI_LDST_FF(uint, 16);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlsb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlsb_v.h
new file mode 100755
index 000000000..dabb453ca
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlsb_v.h
@@ -0,0 +1,5 @@
+// vlsb.v and vlsseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_LD(i * RS2, fn, int8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlsbu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlsbu_v.h
new file mode 100755
index 000000000..23f162f66
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlsbu_v.h
@@ -0,0 +1,5 @@
+// vlsb.v and vlsseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_LD(i * RS2, fn, uint8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlse_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlse_v.h
new file mode 100755
index 000000000..7967ea169
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlse_v.h
@@ -0,0 +1,13 @@
+// vlse.v and vlsseg[2-8]e.v
+reg_t sew = VECTOR->vsew;
+
+if (sew == e8) {
+  VI_LD(i * RS2, fn, int8, 1);
+} else if (sew == e16) {
+  VI_LD(i * RS2, fn, int16, 2);
+} else if (sew == e32) {
+  VI_LD(i * RS2, fn, int32, 4);
+} else if (sew == e64) {
+  VI_LD(i * RS2, fn, int64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlsh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlsh_v.h
new file mode 100755
index 000000000..d4289ae42
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlsh_v.h
@@ -0,0 +1,5 @@
+// vlsh.v and vlsseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_LD(i * RS2, fn, int16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlshu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlshu_v.h
new file mode 100755
index 000000000..a7017698d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlshu_v.h
@@ -0,0 +1,5 @@
+// vlsh.v and vlsseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_LD(i * RS2, fn, uint16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlsw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlsw_v.h
new file mode 100755
index 000000000..3647e9f1b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlsw_v.h
@@ -0,0 +1,5 @@
+// vlsw.v and vlsseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_LD(i * RS2, fn, int32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlswu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlswu_v.h
new file mode 100755
index 000000000..8f48eaa62
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlswu_v.h
@@ -0,0 +1,5 @@
+// vlsw.v and vlsseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_LD(i * RS2, fn, uint32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlw_v.h
new file mode 100755
index 000000000..447da4938
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlw_v.h
@@ -0,0 +1,5 @@
+// vlw.v and vlseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_LD(0, i * nf + fn, int32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlwff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlwff_v.h
new file mode 100755
index 000000000..b671b01be
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlwff_v.h
@@ -0,0 +1,3 @@
+// vlwff.v
+// vlw.v and vlseg[2-8]wff.v
+VI_LDST_FF(int, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlwu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlwu_v.h
new file mode 100755
index 000000000..476f55c59
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlwu_v.h
@@ -0,0 +1,5 @@
+// vlwu.v and vlseg[2-8]wu.v
+require(VECTOR->vsew >= e32);
+{
+VI_LD(0, i * nf + fn, uint32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlwuff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlwuff_v.h
new file mode 100755
index 000000000..d50cb6960
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlwuff_v.h
@@ -0,0 +1,2 @@
+// vlwuff.v and vlseg[2-8]wuff.v
+VI_LDST_FF(uint, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxb_v.h
new file mode 100755
index 000000000..e4a548f55
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxb_v.h
@@ -0,0 +1,8 @@
+// vlxb.v and vlsseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, int8, 1);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxbu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxbu_v.h
new file mode 100755
index 000000000..4018e724c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxbu_v.h
@@ -0,0 +1,8 @@
+// vlxbu.v and vlxseg[2-8]bu.v
+require(VECTOR->vsew >= e8);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, uint8, 1);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxe_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxe_v.h
new file mode 100755
index 000000000..683b50cb7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxe_v.h
@@ -0,0 +1,13 @@
+// vlxe.v and vlxseg[2-8]e.v
+reg_t sew = VECTOR->vsew;
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+if (sew == e8) {
+  VI_LD_WITH_I(index[i], fn, int8, 1);
+} else if (sew == e16) {
+  VI_LD_WITH_I(index[i], fn, int16, 2);
+} else if (sew == e32) {
+  VI_LD_WITH_I(index[i], fn, int32, 4);
+} else if (sew == e64) {
+  VI_LD_WITH_I(index[i], fn, int64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxh_v.h
new file mode 100755
index 000000000..9da2f767b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxh_v.h
@@ -0,0 +1,8 @@
+// vlxh.v and vlxseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, int16, 2);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxhu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxhu_v.h
new file mode 100755
index 000000000..82a503086
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxhu_v.h
@@ -0,0 +1,8 @@
+// vlxh.v and vlxseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, uint16, 2);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxw_v.h
new file mode 100755
index 000000000..78306853f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxw_v.h
@@ -0,0 +1,8 @@
+// vlxw.v and vlxseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, int32, 4);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxwu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxwu_v.h
new file mode 100755
index 000000000..9920d1bdd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxwu_v.h
@@ -0,0 +1,8 @@
+// vlxwu.v and vlxseg[2-8]wu.v
+require(VECTOR->vsew >= e32);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, uint32, 4);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmacc_vv.h
new file mode 100755
index 000000000..461eabf38
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmacc_vv.h
@@ -0,0 +1,5 @@
+// vmacc.vv: *vd[i] = +(vs1[i] * vs2[i]) + *vd[i]
+VI_VV_LOOP
+({
+  *vd =vs1 * vs2 + *vd;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmacc_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmacc_vx.h
new file mode 100755
index 000000000..ca1bc044d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmacc_vx.h
@@ -0,0 +1,5 @@
+// vmacc.vx: *vd[i] = +(x[rs1] * vs2[i]) + *vd[i]
+VI_VX_LOOP
+({
+  *vd =rs1 * vs2 + *vd;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmadc_vim.h b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vim.h
new file mode 100755
index 000000000..e016fda83
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vim.h
@@ -0,0 +1,16 @@
+// vmadc.vim *vd, vs2, simm5
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+{
+VI_XI_LOOP_CARRY
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & simm5) + (op_mask & vs2) + carry;
+
+  carry = (res >> sew) & 0x1u;
+  *vd =(*vd & ~mmask) | ((carry << mpos) & mmask);
+})
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmadc_vvm.h b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vvm.h
new file mode 100755
index 000000000..c9780bd93
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vvm.h
@@ -0,0 +1,16 @@
+// vmadc.vvm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+{
+VI_VV_LOOP_CARRY
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs1) + (op_mask & vs2) + carry;
+
+  carry = (res >> sew) & 0x1u;
+  *vd =(*vd & ~mmask) | ((carry << mpos) & mmask);
+})
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmadc_vxm.h b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vxm.h
new file mode 100755
index 000000000..17bec47d5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vxm.h
@@ -0,0 +1,16 @@
+// vadc.vx *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+{
+VI_XI_LOOP_CARRY
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & rs1) + (op_mask & vs2) + carry;
+
+  carry = (res >> sew) & 0x1u;
+  *vd =(*vd & ~mmask) | ((carry << mpos) & mmask);
+})
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmadd_vv.h
new file mode 100755
index 000000000..978c46e55
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmadd_vv.h
@@ -0,0 +1,5 @@
+// vmadd: *vd[i] = (*vd[i] * vs1[i]) + vs2[i]
+VI_VV_LOOP
+({
+  *vd =*vd * vs1 + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmadd_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmadd_vx.h
new file mode 100755
index 000000000..1d4becf17
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmadd_vx.h
@@ -0,0 +1,5 @@
+// vmadd: *vd[i] = (*vd[i] * x[rs1]) + vs2[i]
+VI_VX_LOOP
+({
+  *vd =*vd * rs1 + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmand_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmand_mm.h
new file mode 100755
index 000000000..d7e931519
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmand_mm.h
@@ -0,0 +1,2 @@
+// vmand.mm *vd, vs2, vs1
+VI_LOOP_MASK(vs2 & vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmandnot_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmandnot_mm.h
new file mode 100755
index 000000000..6d86f9cfa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmandnot_mm.h
@@ -0,0 +1,2 @@
+// vmandnot.mm *vd, vs2, vs1
+VI_LOOP_MASK(vs2 & ~vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmax_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmax_vv.h
new file mode 100755
index 000000000..b4682809f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmax_vv.h
@@ -0,0 +1,10 @@
+// vmax.vv *vd, vs2, vs1, vm   # Vector-vector
+VI_VV_LOOP
+({
+  if (vs1 >= vs2) {
+    *vd =vs1;
+  } else {
+    *vd =vs2;
+  }
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmax_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmax_vx.h
new file mode 100755
index 000000000..8b75d7648
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmax_vx.h
@@ -0,0 +1,10 @@
+// vmax.vx *vd, vs2, rs1, vm   # vector-scalar
+VI_VX_LOOP
+({
+  if (rs1 >= vs2) {
+    *vd =rs1;
+  } else {
+    *vd =vs2;
+  }
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vv.h
new file mode 100755
index 000000000..d65f4a81f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vv.h
@@ -0,0 +1,9 @@
+// vmaxu.vv *vd, vs2, vs1, vm   # Vector-vector
+VI_VV_ULOOP
+({
+  if (vs1 >= vs2) {
+    *vd =vs1;
+  } else {
+    *vd =vs2;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vx.h
new file mode 100755
index 000000000..68fe2f3bb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vx.h
@@ -0,0 +1,9 @@
+// vmaxu.vx *vd, vs2, rs1, vm   # vector-scalar
+VI_VX_ULOOP
+({
+  if (rs1 >= vs2) {
+    *vd =rs1;
+  } else {
+    *vd =vs2;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmerge_vim.h b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vim.h
new file mode 100755
index 000000000..7ea0d0502
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vim.h
@@ -0,0 +1,9 @@
+// vmerge.vim *vd, vs2, simm5
+VI_VVXI_MERGE_LOOP
+({
+  int midx = (VECTOR->vmlen * i) / 64;
+  int mpos = (VECTOR->vmlen * i) % 64;
+  bool use_first = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+
+  *vd =use_first ? simm5 : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmerge_vvm.h b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vvm.h
new file mode 100755
index 000000000..4f0e95c78
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vvm.h
@@ -0,0 +1,9 @@
+// vmerge.vvm *vd, vs2, vs1
+VI_VVXI_MERGE_LOOP
+({
+  int midx = (VECTOR->vmlen * i) / 64;
+  int mpos = (VECTOR->vmlen * i) % 64;
+  bool use_first = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+
+  *vd =use_first ? vs1 : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmerge_vxm.h b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vxm.h
new file mode 100755
index 000000000..64a3f9b93
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vxm.h
@@ -0,0 +1,9 @@
+// vmerge.vxm *vd, vs2, rs1
+VI_VVXI_MERGE_LOOP
+({
+  int midx = (VECTOR->vmlen * i) / 64;
+  int mpos = (VECTOR->vmlen * i) % 64;
+  bool use_first = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+
+  *vd =use_first ? rs1 : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vf.h
new file mode 100755
index 000000000..6d2a4e896
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vf.h
@@ -0,0 +1,5 @@
+// vfeq.vf *vd, vs2, fs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_eq(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vv.h
new file mode 100755
index 000000000..1e5ec2404
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vv.h
@@ -0,0 +1,5 @@
+// vfeq.vv *vd, vs2, vs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_eq(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfge_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmfge_vf.h
new file mode 100755
index 000000000..58535446e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfge_vf.h
@@ -0,0 +1,5 @@
+// vfge.vf *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_le_quiet(rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfgt_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmfgt_vf.h
new file mode 100755
index 000000000..153a526e5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfgt_vf.h
@@ -0,0 +1,5 @@
+// vfgt.vf *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_lt_quiet(rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfirst_m.h b/arch/riscv/kernel/soft_vector/insns_func/vmfirst_m.h
new file mode 100755
index 000000000..67d08ca2c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfirst_m.h
@@ -0,0 +1,22 @@
+// vmfirst rd, vs2
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+require(VECTOR->vstart == 0);
+{
+reg_t vl = VECTOR->vl;
+reg_t rs2_num = rs2(insn);
+reg_t pos = -1;
+reg_t i;
+for (i=VECTOR->vstart; i < vl; ++i) {
+  VI_LOOP_ELEMENT_SKIP()
+  {
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR,rs2_num, midx) >> mpos) & 0x1) == 1;
+  if (vs2_lsb) {
+    pos = i;
+    break;
+  }
+  }
+}
+VECTOR->vstart = 0;
+WRITE_RD(pos);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfle_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmfle_vf.h
new file mode 100755
index 000000000..41f7b55fb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfle_vf.h
@@ -0,0 +1,5 @@
+// vfle.vf *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_le(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfle_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmfle_vv.h
new file mode 100755
index 000000000..08a43a172
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfle_vv.h
@@ -0,0 +1,5 @@
+// vfle.vv *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_le_quiet(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmflt_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmflt_vf.h
new file mode 100755
index 000000000..51684537a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmflt_vf.h
@@ -0,0 +1,5 @@
+// vflt.vf *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_lt_quiet(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmflt_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmflt_vv.h
new file mode 100755
index 000000000..795a4f3cf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmflt_vv.h
@@ -0,0 +1,5 @@
+// vflt.vv *vd, vs2, vs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_lt_quiet(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfne_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmfne_vf.h
new file mode 100755
index 000000000..82d202446
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfne_vf.h
@@ -0,0 +1,5 @@
+// vfne.vf *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = !f64_eq(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfne_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmfne_vv.h
new file mode 100755
index 000000000..8f3a5861d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfne_vv.h
@@ -0,0 +1,5 @@
+// vfne.vv *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = !f64_eq(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmford_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmford_vf.h
new file mode 100755
index 000000000..02a89ad90
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmford_vf.h
@@ -0,0 +1,5 @@
+// vford.vf *vd, vs2, rs1, vm
+VI_VFP_LOOP_CMP
+({
+  res = !(f64_isSignalingNaN(vs2) || f64_isSignalingNaN(rs1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmford_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmford_vv.h
new file mode 100755
index 000000000..0422469b8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmford_vv.h
@@ -0,0 +1,5 @@
+// vford.vv *vd, vs2, vs1, vm
+VI_VFP_LOOP_CMP
+({
+  res = !(f64_isSignalingNaN(vs2) || f64_isSignalingNaN(vs1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmin_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmin_vv.h
new file mode 100755
index 000000000..d44465982
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmin_vv.h
@@ -0,0 +1,11 @@
+// vmin.vv *vd, vs2, vs1, vm   # Vector-vector
+VI_VV_LOOP
+({
+  if (vs1 <= vs2) {
+    *vd =vs1;
+  } else {
+    *vd =vs2;
+  }
+
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmin_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmin_vx.h
new file mode 100755
index 000000000..ba0d122de
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmin_vx.h
@@ -0,0 +1,11 @@
+// vminx.vx *vd, vs2, rs1, vm   # vector-scalar
+VI_VX_LOOP
+({
+  if (rs1 <= vs2) {
+    *vd =rs1;
+  } else {
+    *vd =vs2;
+  }
+
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vminu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vminu_vv.h
new file mode 100755
index 000000000..5629d7846
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vminu_vv.h
@@ -0,0 +1,9 @@
+// vminu.vv *vd, vs2, vs1, vm   # Vector-vector
+VI_VV_ULOOP
+({
+  if (vs1 <= vs2) {
+    *vd =vs1;
+  } else {
+    *vd =vs2;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vminu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vminu_vx.h
new file mode 100755
index 000000000..9d8fabd21
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vminu_vx.h
@@ -0,0 +1,10 @@
+// vminu.vx *vd, vs2, rs1, vm   # vector-scalar
+VI_VX_ULOOP
+({
+  if (rs1 <= vs2) {
+    *vd =rs1;
+  } else {
+    *vd =vs2;
+  }
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmnand_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmnand_mm.h
new file mode 100755
index 000000000..1fd8d6162
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmnand_mm.h
@@ -0,0 +1,2 @@
+// vmnand.mm *vd, vs2, vs1
+VI_LOOP_MASK(~(vs2 & vs1));
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmnor_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmnor_mm.h
new file mode 100755
index 000000000..e5356df7c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmnor_mm.h
@@ -0,0 +1,2 @@
+// vmnor.mm *vd, vs2, vs1
+VI_LOOP_MASK(~(vs2 | vs1));
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmor_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmor_mm.h
new file mode 100755
index 000000000..86b456a07
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmor_mm.h
@@ -0,0 +1,2 @@
+// vmor.mm *vd, vs2, vs1
+VI_LOOP_MASK(vs2 | vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmornot_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmornot_mm.h
new file mode 100755
index 000000000..34326f3b9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmornot_mm.h
@@ -0,0 +1,2 @@
+// vmornot.mm *vd, vs2, vs1
+VI_LOOP_MASK(vs2 | ~vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmpopc_m.h b/arch/riscv/kernel/soft_vector/insns_func/vmpopc_m.h
new file mode 100755
index 000000000..783108937
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmpopc_m.h
@@ -0,0 +1,25 @@
+// vmpopc rd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+require(VECTOR->vstart == 0);
+{
+reg_t vl = VECTOR->vl;
+reg_t rs2_num = rs2(insn);
+reg_t popcount = 0;
+reg_t i;
+for (i=VECTOR->vstart; i<vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR,rs2_num, midx) >> mpos) & 0x1) == 1;
+  if (v_vm(insn) == 1) {
+    popcount += vs2_lsb;
+  } else {
+    bool do_mask = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+    popcount += (vs2_lsb && do_mask);
+  }
+}
+VECTOR->vstart = 0;
+WRITE_RD(popcount);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vvm.h b/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vvm.h
new file mode 100755
index 000000000..3f50e3bf6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vvm.h
@@ -0,0 +1,16 @@
+// vmsbc.vvm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+{
+VI_VV_LOOP_CARRY
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs2) - (op_mask & vs1) - carry;
+
+  carry = (res >> sew) & 0x1u;
+  *vd =(*vd & ~mmask) | ((carry << mpos) & mmask);
+})
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vxm.h b/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vxm.h
new file mode 100755
index 000000000..257b7e4cd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vxm.h
@@ -0,0 +1,16 @@
+// vmsbc.vxm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+{
+VI_XI_LOOP_CARRY
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs2) - (op_mask & rs1) - carry;
+
+  carry = (res >> sew) & 0x1u;
+  *vd =(*vd & ~mmask) | ((carry << mpos) & mmask);
+})
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsbf_m.h b/arch/riscv/kernel/soft_vector/insns_func/vmsbf_m.h
new file mode 100755
index 000000000..b53701c6b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsbf_m.h
@@ -0,0 +1,35 @@
+// vmsbf.m *vd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+
+bool has_one = false;
+reg_t i;
+for (i = VECTOR->vstart; i < vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR,rs2_num, midx) >> mpos) & 0x1) == 1;
+  bool do_mask = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+  uint64_t *vd =vector_elt_uint64_t(VECTOR, rd_num, midx);
+
+
+  if (v_vm(insn) == 1 || (v_vm(insn) == 0 && do_mask)) {
+    uint64_t res = 0;
+    if (!has_one && !vs2_lsb) {
+      res = 1;
+    } else if(!has_one && vs2_lsb) {
+      has_one = true;
+    }
+    *vd =(*vd & ~mmask) | ((res << mpos) & mmask);
+  }
+}
+
+VI_TAIL_ZERO_MASK(rd_num);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmseq_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vi.h
new file mode 100755
index 000000000..db9b85753
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vi.h
@@ -0,0 +1,5 @@
+// vseq.vi *vd, vs2, simm5
+VI_VI_LOOP_CMP
+({
+  res = simm5 == vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmseq_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vv.h
new file mode 100755
index 000000000..796afc072
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vv.h
@@ -0,0 +1,6 @@
+// vseq.vv *vd, vs2, vs1
+VI_VV_LOOP_CMP
+({
+  res = vs2 == vs1;
+})
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmseq_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vx.h
new file mode 100755
index 000000000..2041508b1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vx.h
@@ -0,0 +1,5 @@
+// vseq.vx *vd, vs2, rs1
+VI_VX_LOOP_CMP
+({
+  res = rs1 == vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vi.h
new file mode 100755
index 000000000..8590f579e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vi.h
@@ -0,0 +1,5 @@
+// vsgt.vi  *vd, vs2, simm5
+VI_VI_LOOP_CMP
+({
+  res = vs2 > simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vx.h
new file mode 100755
index 000000000..ad5b35698
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vx.h
@@ -0,0 +1,5 @@
+// vsgt.vx  *vd, vs2, rs1
+VI_VX_LOOP_CMP
+({
+  res = vs2 > rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vi.h
new file mode 100755
index 000000000..07a3bf0bf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vi.h
@@ -0,0 +1,5 @@
+// vsgtu.vi  *vd, *vd2, zimm5
+VI_VI_ULOOP_CMP
+({
+  res = vs2 > simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vx.h
new file mode 100755
index 000000000..9e7d0356f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vx.h
@@ -0,0 +1,5 @@
+// vsgtu.vx  *vd, vs2, rs1
+VI_VX_ULOOP_CMP
+({
+  res = vs2 > rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsif_m.h b/arch/riscv/kernel/soft_vector/insns_func/vmsif_m.h
new file mode 100755
index 000000000..1eb44e644
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsif_m.h
@@ -0,0 +1,35 @@
+// vmpopc rd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+
+bool has_one = false;
+reg_t i;
+for (i = VECTOR->vstart ; i < vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR,rs2_num, midx) >> mpos) & 0x1) == 1;
+  bool do_mask = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+  uint64_t *vd =vector_elt_uint64_t(VECTOR, rd_num, midx);
+
+  if (v_vm(insn) == 1 || (v_vm(insn) == 0 && do_mask)) {
+    uint64_t res = 0;
+    if (!has_one && !vs2_lsb) {
+      res = 1;
+    } else if(!has_one && vs2_lsb) {
+      has_one = true;
+      res = 1;
+    }
+    *vd =(*vd & ~mmask) | ((res << mpos) & mmask);
+  }
+}
+
+VI_TAIL_ZERO_MASK(rd_num);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsle_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vi.h
new file mode 100755
index 000000000..d2e1bd271
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vi.h
@@ -0,0 +1,5 @@
+// vsle.vi *vd, vs2, simm5
+VI_VI_LOOP_CMP
+({
+  res = vs2 <= simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsle_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vv.h
new file mode 100755
index 000000000..3bce5bcf7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vv.h
@@ -0,0 +1,5 @@
+// vsle.vv *vd, vs2, vs1
+VI_VV_LOOP_CMP
+({
+  res = vs2 <= vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsle_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vx.h
new file mode 100755
index 000000000..1c22d4c33
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vx.h
@@ -0,0 +1,5 @@
+// vsle.vx *vd, vs2, rs1
+VI_VX_LOOP_CMP
+({
+  res = vs2 <= rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vi.h
new file mode 100755
index 000000000..dd664c238
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vi.h
@@ -0,0 +1,5 @@
+// vsleu.vi *vd, vs2, zimm5
+VI_VI_ULOOP_CMP
+({
+  res = vs2 <= simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vv.h
new file mode 100755
index 000000000..8f37f3f31
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vv.h
@@ -0,0 +1,5 @@
+// vsleu.vv *vd, vs2, vs1
+VI_VV_ULOOP_CMP
+({
+  res = vs2 <= vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vx.h
new file mode 100755
index 000000000..5c666ce2c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vx.h
@@ -0,0 +1,5 @@
+// vsleu.vx  *vd, vs2, rs1
+VI_VX_ULOOP_CMP
+({
+  res = vs2 <= rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmslt_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmslt_vv.h
new file mode 100755
index 000000000..80a31b13f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmslt_vv.h
@@ -0,0 +1,5 @@
+// vslt.vv  *vd, *vd2, vs1
+VI_VV_LOOP_CMP
+({
+  res = vs2 < vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmslt_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmslt_vx.h
new file mode 100755
index 000000000..ab1e8d653
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmslt_vx.h
@@ -0,0 +1,5 @@
+// vslt.vx  *vd, vs2, vs1
+VI_VX_LOOP_CMP
+({
+  res = vs2 < rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vv.h
new file mode 100755
index 000000000..d0cc56762
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vv.h
@@ -0,0 +1,5 @@
+// vsltu.vv  *vd, vs2, vs1
+VI_VV_ULOOP_CMP
+({
+  res = vs2 < vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vx.h
new file mode 100755
index 000000000..3740d5de3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vx.h
@@ -0,0 +1,5 @@
+// vsltu.vx  *vd, vs2, vs1
+VI_VX_ULOOP_CMP
+({
+  res = vs2 < rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsne_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vi.h
new file mode 100755
index 000000000..8b33b3eb9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vi.h
@@ -0,0 +1,5 @@
+// vsne.vi  *vd, vs2, simm5
+VI_VI_LOOP_CMP
+({
+  res = vs2 != simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsne_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vv.h
new file mode 100755
index 000000000..44217b2da
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vv.h
@@ -0,0 +1,5 @@
+// vneq.vv  *vd, vs2, vs1
+VI_VV_LOOP_CMP
+({
+  res = vs2 != vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsne_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vx.h
new file mode 100755
index 000000000..0171b4fbc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vx.h
@@ -0,0 +1,5 @@
+// vsne.vx  *vd, vs2, rs1
+VI_VX_LOOP_CMP
+({
+  res = vs2 != rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsof_m.h b/arch/riscv/kernel/soft_vector/insns_func/vmsof_m.h
new file mode 100755
index 000000000..ec6268ace
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsof_m.h
@@ -0,0 +1,33 @@
+// vmsof.m rd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+
+bool has_one = false;
+reg_t i;
+for (i = VECTOR->vstart ; i < vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR,rs2_num, midx) >> mpos) & 0x1) == 1;
+  bool do_mask = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+  uint64_t *vd = vector_elt_uint64_t(VECTOR, rd_num, midx);
+
+  if (v_vm(insn) == 1 || (v_vm(insn) == 0 && do_mask)) {
+    uint64_t res = 0;
+    if(!has_one && vs2_lsb) {
+      has_one = true;
+      res = 1;
+    }
+    *vd =(*vd & ~mmask) | ((res << mpos) & mmask);
+  }
+}
+
+VI_TAIL_ZERO_MASK(rd_num);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmul_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmul_vv.h
new file mode 100755
index 000000000..3233d8afd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmul_vv.h
@@ -0,0 +1,5 @@
+// vmul *vd, vs2, vs1
+VI_VV_LOOP
+({
+  *vd =vs2 * vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmul_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmul_vx.h
new file mode 100755
index 000000000..10c58b50c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmul_vx.h
@@ -0,0 +1,5 @@
+// vmul *vd, vs2, rs1
+VI_VX_LOOP
+({
+  *vd =vs2 * rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulh_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmulh_vv.h
new file mode 100755
index 000000000..bc57f685c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulh_vv.h
@@ -0,0 +1,5 @@
+// vmulh *vd, vs2, vs1
+VI_VV_LOOP
+({
+  *vd =((int128_t)vs2 * vs1) >> sew;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulh_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmulh_vx.h
new file mode 100755
index 000000000..3e647d9ab
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulh_vx.h
@@ -0,0 +1,5 @@
+// vmulh *vd, vs2, rs1
+VI_VX_LOOP
+({
+  *vd =((int128_t)vs2 * rs1) >> sew;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vv.h
new file mode 100755
index 000000000..657017870
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vv.h
@@ -0,0 +1,37 @@
+// vmulhsu.vv *vd, vs2, vs1
+VI_LOOP_BASE
+switch(sew) {
+case e8: {
+  int8_t *vd =vector_elt_int8_t(VECTOR, rd_num, i);
+  int8_t vs2 = *vector_elt_int8_t(VECTOR, rs2_num, i);
+  uint8_t vs1 = *vector_elt_uint8_t(VECTOR, rs1_num, i);
+
+  *vd =((int16_t)vs2 * (uint16_t)vs1) >> sew;
+  break;
+}
+case e16: {
+  int16_t *vd =vector_elt_int16_t(VECTOR, rd_num, i);
+  int16_t vs2 = *vector_elt_int16_t(VECTOR, rs2_num, i);
+  uint16_t vs1 = *vector_elt_uint16_t(VECTOR, rs1_num, i);
+
+  *vd =((int32_t)vs2 * (uint32_t)vs1) >> sew;
+  break;
+}
+case e32: {
+  int32_t *vd =vector_elt_int32_t(VECTOR, rd_num, i);
+  int32_t vs2 = *vector_elt_int32_t(VECTOR, rs2_num, i);
+  uint32_t vs1 = *vector_elt_uint32_t(VECTOR, rs1_num, i);
+
+  *vd =((int64_t)vs2 * (uint64_t)vs1) >> sew;
+  break;
+}
+default: {
+  int64_t *vd =vector_elt_int64_t(VECTOR, rd_num, i);
+  int64_t vs2 = *vector_elt_int64_t(VECTOR, rs2_num, i);
+  uint64_t vs1 = *vector_elt_uint64_t(VECTOR, rs1_num, i);
+
+  *vd =((int128_t)vs2 * (uint128_t)vs1) >> sew;
+  break;
+}
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vx.h
new file mode 100755
index 000000000..c3c750776
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vx.h
@@ -0,0 +1,37 @@
+// vmulhsu.vx *vd, vs2, rs1
+VI_LOOP_BASE
+switch(sew) {
+case e8: {
+  int8_t *vd =vector_elt_int8_t(VECTOR, rd_num, i);
+  int8_t vs2 = *vector_elt_int8_t(VECTOR, rs2_num, i);
+  uint8_t rs1 = RS1;
+
+  *vd =((int16_t)vs2 * (uint16_t)rs1) >> sew;
+  break;
+}
+case e16: {
+  int16_t *vd =vector_elt_int16_t(VECTOR, rd_num, i);
+  int16_t vs2 = *vector_elt_int16_t(VECTOR, rs2_num, i);
+  uint16_t rs1 = RS1;
+
+  *vd =((int32_t)vs2 * (uint32_t)rs1) >> sew;
+  break;
+}
+case e32: {
+  int32_t *vd =vector_elt_int32_t(VECTOR, rd_num, i);
+  int32_t vs2 = *vector_elt_int32_t(VECTOR, rs2_num, i);
+  uint32_t rs1 = RS1;
+
+  *vd =((int64_t)vs2 * (uint64_t)rs1) >> sew;
+  break;
+}
+default: {
+  int64_t *vd =vector_elt_int64_t(VECTOR, rd_num, i);
+  int64_t vs2 = *vector_elt_int64_t(VECTOR, rs2_num, i);
+  uint64_t rs1 = RS1;
+
+  *vd =((int128_t)vs2 * (uint128_t)rs1) >> sew;
+  break;
+}
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vv.h
new file mode 100755
index 000000000..f09da0608
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vv.h
@@ -0,0 +1,5 @@
+// vmulhu *vd ,vs2, vs1
+VI_VV_ULOOP
+({
+  *vd =((uint128_t)vs2 * vs1) >> sew;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vx.h
new file mode 100755
index 000000000..3addd9002
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vx.h
@@ -0,0 +1,5 @@
+// vmulhu *vd ,vs2, rs1
+VI_VX_ULOOP
+({
+  *vd =((uint128_t)vs2 * rs1) >> sew;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmv_s_x.h b/arch/riscv/kernel/soft_vector/insns_func/vmv_s_x.h
new file mode 100755
index 000000000..bb117c8c0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmv_s_x.h
@@ -0,0 +1,48 @@
+// vmv_s_x: *vd[0] = rs1
+require(v_vm(insn) == 1);
+require(VECTOR->vsew == e8 || VECTOR->vsew == e16 ||
+        VECTOR->vsew == e32 || VECTOR->vsew == e64);
+{
+reg_t vl = VECTOR->vl;
+
+if (vl > 0) {
+  reg_t rd_num = rd(insn);
+  reg_t sew = VECTOR->vsew;
+  const reg_t max_len = VECTOR->VLEN / sew;
+  reg_t i;
+  switch(sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, 0) = RS1;
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, 0) = RS1;
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, 0) = RS1;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, 0) = RS1;
+    break;
+  }
+
+  for (i = 1; i < max_len; ++i) {
+    switch(sew) {
+    case e8:
+      *vector_elt_uint8_t(VECTOR, rd_num, i) = 0;
+      break;
+    case e16:
+      *vector_elt_uint16_t(VECTOR, rd_num, i) = 0;
+      break;
+    case e32:
+      *vector_elt_uint32_t(VECTOR, rd_num, i) = 0;
+      break;
+    default:
+      *vector_elt_uint64_t(VECTOR, rd_num, i) = 0;
+      break;
+    }
+  }
+
+  vl = 0;
+}
+
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmv_v_i.h b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_i.h
new file mode 100755
index 000000000..6dc72c32d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_i.h
@@ -0,0 +1,5 @@
+// vmv.v.i *vd, simm5
+VI_VVXI_MERGE_LOOP
+({
+  *vd =simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmv_v_v.h b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_v.h
new file mode 100755
index 000000000..aafa28480
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_v.h
@@ -0,0 +1,5 @@
+// vvmv.v.v *vd, vs1
+VI_VVXI_MERGE_LOOP
+({
+  *vd =vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmv_v_x.h b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_x.h
new file mode 100755
index 000000000..2c4090433
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_x.h
@@ -0,0 +1,5 @@
+// vmv.v.x *vd, rs1
+VI_VVXI_MERGE_LOOP
+({
+  *vd =rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmxnor_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmxnor_mm.h
new file mode 100755
index 000000000..c9af826ff
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmxnor_mm.h
@@ -0,0 +1,2 @@
+// vmnxor.mm *vd, vs2, vs1
+VI_LOOP_MASK(~(vs2 ^ vs1));
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmxor_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmxor_mm.h
new file mode 100755
index 000000000..5076f7641
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmxor_mm.h
@@ -0,0 +1,2 @@
+// vmxor.mm *vd, vs2, vs1
+VI_LOOP_MASK(vs2 ^ vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclip_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vi.h
new file mode 100755
index 000000000..05573daae
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vi.h
@@ -0,0 +1,24 @@
+// vnclip: *vd[i] = clip(round(vs2[i] + rnd) >> simm)
+VRM xrm = VECTOR->vxrm;
+int64_t int_max = (1 << (VECTOR->vsew - 1)) - 1;
+int64_t int_min = -(1 << (VECTOR->vsew - 1));
+VI_VVXI_LOOP_NARROW
+({
+
+  int64_t result = vs2;
+// rounding
+  INT_ROUNDING(result, xrm, sew);
+
+  result = vsext(result, sew * 2) >> (zimm5 & ((sew * 2) < 32? (sew * 2) - 1: 31));
+
+// saturation
+  if (result < int_min) {
+    result = int_min;
+    VECTOR->vxsat = 1;
+  } else if (result > int_max) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclip_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vv.h
new file mode 100755
index 000000000..608a1e7bd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vv.h
@@ -0,0 +1,31 @@
+// vnclip: *vd[i] = clip(round(vs2[i] + rnd) >> vs1[i])
+VRM xrm = VECTOR->vxrm;
+int64_t int_max = (1 << (VECTOR->vsew - 1)) - 1;
+int64_t int_min = -(1 << (VECTOR->vsew - 1));
+VI_VVXI_LOOP_NARROW
+({
+
+  int64_t result = vs2;
+  uint64_t unsigned_shift_amount;
+// rounding
+  INT_ROUNDING(result, xrm, sew);
+
+// unsigned shifting to rs1
+  unsigned_shift_amount = (uint64_t)(vs1 & ((sew * 2) - 1));
+  if (unsigned_shift_amount >= (2 * sew)) {
+    unsigned_shift_amount = 2 * sew - 1;
+  }
+
+  result = (vsext(result, sew * 2)) >> unsigned_shift_amount;
+
+// saturation
+  if (result < int_min) {
+    result = int_min;
+    VECTOR->vxsat = 1;
+  } else if (result > int_max) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclip_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vx.h
new file mode 100755
index 000000000..373d9758f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vx.h
@@ -0,0 +1,30 @@
+// vnclip: *vd[i] = clip(round(vs2[i] + rnd) >> rs1[i])
+VRM xrm = VECTOR->vxrm;
+int64_t int_max = (1 << (VECTOR->vsew - 1)) - 1;
+int64_t int_min = -(1 << (VECTOR->vsew - 1));
+VI_VVXI_LOOP_NARROW
+({
+
+  int64_t result = vs2;
+  uint64_t unsigned_shift_amount;
+// rounding
+  INT_ROUNDING(result, xrm, sew);
+
+// unsigned shifting to rs1
+  unsigned_shift_amount = (uint64_t)(rs1 & ((sew * 2) - 1));
+  if (unsigned_shift_amount >= (2 * sew)) {
+    unsigned_shift_amount = 2 * sew - 1;
+  }
+  result = vsext(result, sew * 2) >> unsigned_shift_amount;
+
+// saturation
+  if (result < int_min) {
+    result = int_min;
+    VECTOR->vxsat = 1;
+  } else if (result > int_max) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vi.h
new file mode 100755
index 000000000..5c66ad82c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vi.h
@@ -0,0 +1,20 @@
+// vnclipu: *vd[i] = clip(round(vs2[i] + rnd) >> simm)
+VRM xrm = VECTOR->vxrm;
+uint64_t int_max = ~(-1ll << VECTOR->vsew);
+VI_VVXI_LOOP_NARROW
+({
+  uint64_t result = vs2_u;
+  // rounding
+  INT_ROUNDING(result, xrm, sew);
+
+  // unsigned shifting to rs1
+  result = vzext(result, sew * 2) >> (zimm5 & ((sew * 2) < 32? (sew * 2) - 1: 31));
+
+  // saturation
+  if (result & (uint64_t)(-1ll << sew)) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vv.h
new file mode 100755
index 000000000..a37bb76ea
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vv.h
@@ -0,0 +1,27 @@
+// vnclipu: *vd[i] = clip(round(vs2[i] + rnd) >> vs1[i])
+VRM xrm = VECTOR->vxrm;
+uint64_t int_max = ~(-1ll << VECTOR->vsew);
+VI_VVXI_LOOP_NARROW
+({
+
+  uint64_t result = vs2_u;
+  uint64_t unsigned_shift_amount;
+
+// rounding
+  INT_ROUNDING(result, xrm, sew);
+
+// unsigned shifting to rs1
+  unsigned_shift_amount = (uint64_t)(vs1 & ((sew * 2) - 1));
+  if (unsigned_shift_amount >= (2 * sew)) {
+    result = 0;
+  } else {
+    result = vzext(result, sew * 2) >> unsigned_shift_amount;
+  }
+// saturation
+  if (result & (uint64_t)(-1ll << sew)) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vx.h
new file mode 100755
index 000000000..f20b5e827
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vx.h
@@ -0,0 +1,26 @@
+// vnclipu: *vd[i] = clip(round(vs2[i] + rnd) >> rs1[i])
+VRM xrm = VECTOR->vxrm;
+uint64_t int_max = ~(-1ll << VECTOR->vsew);
+VI_VVXI_LOOP_NARROW
+({
+  uint64_t result = vs2;
+  uint64_t unsigned_shift_amount;
+// rounding
+  INT_ROUNDING(result, xrm, sew);
+
+// unsigned shifting to rs1
+  unsigned_shift_amount = (uint64_t)(rs1 & ((sew * 2) - 1));
+  if (unsigned_shift_amount >= (2 * sew)) {
+    result = 0;
+  } else {
+    result = vzext(result, sew * 2) >> unsigned_shift_amount;
+  }
+
+// saturation
+  if (result & (uint64_t)(-1ll << sew)) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vv.h
new file mode 100755
index 000000000..d21493dfe
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vv.h
@@ -0,0 +1,5 @@
+// vmsac.vv: *vd[i] = -(vs1[i] * vs2[i]) + *vd[i]
+VI_VV_LOOP
+({
+  *vd =-(vs1 * vs2) + *vd;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vx.h
new file mode 100755
index 000000000..9cc6ab4d2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vx.h
@@ -0,0 +1,5 @@
+// vmsac: *vd[i] = -(x[rs1] * vs2[i]) + *vd[i]
+VI_VX_LOOP
+({
+  *vd =-(rs1 * vs2) + *vd;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vv.h
new file mode 100755
index 000000000..4447ef4b8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vv.h
@@ -0,0 +1,5 @@
+// vnmsub.vv: *vd[i] = -(*vd[i] * vs1[i]) + vs2[i]
+VI_VV_LOOP
+({
+  *vd =-(*vd * vs1) + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vx.h
new file mode 100755
index 000000000..24f4bff0c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vx.h
@@ -0,0 +1,5 @@
+// vnmsub.vx: *vd[i] = -(*vd[i] * x[rs1]) + vs2[i]
+VI_VX_LOOP
+({
+  *vd =-(*vd * rs1) + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsra_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vi.h
new file mode 100755
index 000000000..04b2da18c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vi.h
@@ -0,0 +1,5 @@
+// vnsra.vi *vd, vs2, zimm5
+VI_VI_LOOP_NSHIFT
+({
+  *vd =vs2 >> (zimm5 & (sew * 2 - 1) & 0x1f);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsra_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vv.h
new file mode 100755
index 000000000..004e8a2ba
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vv.h
@@ -0,0 +1,5 @@
+// vnsra.vv *vd, vs2, vs1
+VI_VV_LOOP_NSHIFT
+({
+  *vd =vs2 >> (vs1 & (sew * 2 - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsra_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vx.h
new file mode 100755
index 000000000..a72b3f261
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vx.h
@@ -0,0 +1,5 @@
+// vnsra.vx *vd, vs2, rs1
+VI_VX_LOOP_NSHIFT
+({
+  *vd =vs2 >> (rs1 & (sew * 2 - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vi.h
new file mode 100755
index 000000000..53a98d071
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vi.h
@@ -0,0 +1,5 @@
+// vnsrl.vi *vd, vs2, zimm5
+VI_VI_LOOP_NSHIFT
+({
+  *vd =vs2_u >> (zimm5 & (sew * 2 - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vv.h
new file mode 100755
index 000000000..440d49774
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vv.h
@@ -0,0 +1,5 @@
+// vnsrl.vv *vd, vs2, vs1
+VI_VV_LOOP_NSHIFT
+({
+  *vd =vs2_u >> (vs1 & (sew * 2 - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vx.h
new file mode 100755
index 000000000..4c5d415f4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vx.h
@@ -0,0 +1,5 @@
+// vnsrl.vx *vd, vs2, rs1
+VI_VX_LOOP_NSHIFT
+({
+  *vd =vs2_u >> (rs1 & (sew * 2 - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vor_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vor_vi.h
new file mode 100755
index 000000000..858773291
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vor_vi.h
@@ -0,0 +1,5 @@
+// vor
+VI_VI_LOOP
+({
+  *vd =simm5 | vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vor_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vor_vv.h
new file mode 100755
index 000000000..5d0170342
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vor_vv.h
@@ -0,0 +1,5 @@
+// vor
+VI_VV_LOOP
+({
+  *vd =vs1 | vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vor_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vor_vx.h
new file mode 100755
index 000000000..e18b293bd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vor_vx.h
@@ -0,0 +1,5 @@
+// vor
+VI_VX_LOOP
+({
+  *vd =rs1 | vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredand_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredand_vs.h
new file mode 100755
index 000000000..5b32d07bb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredand_vs.h
@@ -0,0 +1,5 @@
+// vredand.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res &= vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredmax_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredmax_vs.h
new file mode 100755
index 000000000..ae2d43c08
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredmax_vs.h
@@ -0,0 +1,5 @@
+// vredmax.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res = (vd_0_res >= vs2) ? vd_0_res : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredmaxu_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredmaxu_vs.h
new file mode 100755
index 000000000..41296e25e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredmaxu_vs.h
@@ -0,0 +1,5 @@
+// vredmaxu.vs *vd, vs2 ,vs1
+VI_VV_ULOOP_REDUCTION
+({
+  vd_0_res = (vd_0_res >= vs2) ? vd_0_res : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredmin_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredmin_vs.h
new file mode 100755
index 000000000..822e20bc1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredmin_vs.h
@@ -0,0 +1,5 @@
+// vredmin.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res = (vd_0_res <= vs2) ? vd_0_res : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredminu_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredminu_vs.h
new file mode 100755
index 000000000..99c71ddba
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredminu_vs.h
@@ -0,0 +1,5 @@
+// vredminu.vs *vd, vs2 ,vs1
+VI_VV_ULOOP_REDUCTION
+({
+  vd_0_res = (vd_0_res <= vs2) ? vd_0_res : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredor_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredor_vs.h
new file mode 100755
index 000000000..8176e7c46
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredor_vs.h
@@ -0,0 +1,5 @@
+// vredor.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res |= vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredsum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredsum_vs.h
new file mode 100755
index 000000000..88418a57e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredsum_vs.h
@@ -0,0 +1,5 @@
+// vredsum.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res += vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredxor_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredxor_vs.h
new file mode 100755
index 000000000..15112092a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredxor_vs.h
@@ -0,0 +1,5 @@
+// vredxor.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res ^= vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrem_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vrem_vv.h
new file mode 100755
index 000000000..f277b32c4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrem_vv.h
@@ -0,0 +1,11 @@
+// vrem.vv *vd, vs2, vs1
+VI_VV_LOOP
+({
+  if (vs1 == 0)
+    *vd =vs2;
+  else if(vs2 == -(1 << (sew - 1)) && vs1 == -1)
+    *vd =0;
+  else {
+    *vd =vs2 % vs1;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrem_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vrem_vx.h
new file mode 100755
index 000000000..7b059ff43
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrem_vx.h
@@ -0,0 +1,10 @@
+// vrem.vx *vd, vs2, rs1
+VI_VX_LOOP
+({
+  if (rs1 == 0)
+    *vd =vs2;
+  else if (vs2 == -(1 << (sew - 1)) && rs1 == -1)
+    *vd =0;
+  else
+    *vd =vs2 % rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vremu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vremu_vv.h
new file mode 100755
index 000000000..dd93a9baa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vremu_vv.h
@@ -0,0 +1,8 @@
+// vremu.vv *vd, vs2, vs1
+VI_VV_ULOOP
+({
+  if (vs1 == 0)
+    *vd =vs2;
+  else
+    *vd =vs2 % vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vremu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vremu_vx.h
new file mode 100755
index 000000000..2373d0c6e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vremu_vx.h
@@ -0,0 +1,8 @@
+// vremu.vx *vd, vs2, rs1
+VI_VX_ULOOP
+({
+  if (rs1 == 0)
+    *vd =vs2;
+  else
+    *vd =vs2 % rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrgather_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vi.h
new file mode 100755
index 000000000..2216a32bb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vi.h
@@ -0,0 +1,32 @@
+// vrgather.vi *vd, vs2, zimm5 vm # *vd[i] = (zimm5 >= VLMAX) ? 0 : vs2[zimm5];
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t sew = VECTOR->vsew;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+reg_t zimm5 = v_zimm5(insn);
+reg_t i;
+for (i = VECTOR->vstart; i < vl; ++i) {
+  VI_LOOP_ELEMENT_SKIP();
+
+  switch (sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, i) = zimm5 >= VECTOR->vlmax ? 0 : *vector_elt_uint8_t(VECTOR, rs2_num, zimm5);
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = zimm5 >= VECTOR->vlmax ? 0 : *vector_elt_uint16_t(VECTOR, rs2_num, zimm5);
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = zimm5 >= VECTOR->vlmax ? 0 : *vector_elt_uint32_t(VECTOR, rs2_num, zimm5);
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = zimm5 >= VECTOR->vlmax ? 0 : *vector_elt_uint64_t(VECTOR, rs2_num, zimm5);
+    break;
+  }
+}
+
+VI_TAIL_ZERO(1);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrgather_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vv.h
new file mode 100755
index 000000000..963d1d431
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vv.h
@@ -0,0 +1,42 @@
+// vrgather.vv *vd, vs2, vs1, vm # *vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t sew = VECTOR->vsew;
+reg_t rd_num = rd(insn);
+reg_t rs1_num = insn_rs1(insn);
+reg_t rs2_num = rs2(insn);
+reg_t i;
+for (i = VECTOR->vstart; i < vl; ++i) {
+  VI_LOOP_ELEMENT_SKIP();
+  VI_CHECK_VREG_OVERLAP(rd_num, rs1_num);
+  VI_CHECK_VREG_OVERLAP(rd_num, rs2_num);
+  switch (sew) {
+  case e8: {
+    uint8_t vs1 = *vector_elt_uint8_t(VECTOR, rs1_num, i);
+    //if (i > 255) continue;
+    *vector_elt_uint8_t(VECTOR, rd_num, i) = vs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint8_t(VECTOR, rs2_num, vs1);
+    break;
+  }
+  case e16: {
+    uint16_t vs1 = *vector_elt_uint16_t(VECTOR, rs1_num, i);
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = vs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint16_t(VECTOR, rs2_num, vs1);
+    break;
+  }
+  case e32: {
+    uint32_t vs1 = *vector_elt_uint32_t(VECTOR, rs1_num, i);
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = vs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint32_t(VECTOR, rs2_num, vs1);
+    break;
+  }
+  default: {
+    uint64_t vs1 = *vector_elt_uint64_t(VECTOR, rs1_num, i);
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = vs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint64_t(VECTOR, rs2_num, vs1);
+    break;
+  }
+  }
+}
+
+VI_TAIL_ZERO(1);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrgather_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vx.h
new file mode 100755
index 000000000..e0a9af346
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vx.h
@@ -0,0 +1,32 @@
+// vrgather.vx *vd, vs2, rs1, vm # *vd[i] = (rs1 >= VLMAX) ? 0 : vs2[rs1];
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t sew = VECTOR->vsew;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+reg_t rs1 = RS1;
+reg_t i;
+for (i = VECTOR->vstart; i < vl; ++i) {
+  VI_LOOP_ELEMENT_SKIP();
+
+  switch (sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, i) = rs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint8_t(VECTOR, rs2_num, rs1);
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = rs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint16_t(VECTOR, rs2_num, rs1);
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = rs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint32_t(VECTOR, rs2_num, rs1);
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = rs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint64_t(VECTOR, rs2_num, rs1);
+    break;
+  }
+}
+
+VI_TAIL_ZERO(1);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrsub_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vrsub_vi.h
new file mode 100755
index 000000000..d82cc6839
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrsub_vi.h
@@ -0,0 +1,5 @@
+// vrsub.vi *vd, vs2, imm, vm   # *vd[i] = imm - vs2[i]
+VI_VI_LOOP
+({
+  *vd =simm5 - vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrsub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vrsub_vx.h
new file mode 100755
index 000000000..d4a98f92c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrsub_vx.h
@@ -0,0 +1,5 @@
+// vrsub.vx *vd, vs2, rs1, vm   # *vd[i] = rs1 - vs2[i]
+VI_VX_LOOP
+({
+  *vd =rs1 - vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsadd_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vi.h
new file mode 100755
index 000000000..d8165ca1a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vi.h
@@ -0,0 +1,29 @@
+// vsadd.vi *vd, vs2 simm5
+VI_LOOP_BASE
+{
+bool sat = false;
+switch(sew) {
+case e8: {
+  VI_PARAMS(8);
+  *vd =sat_add_int8_t_uint8_t(vs2, vsext(simm5, sew), &sat);
+  break;
+}
+case e16: {
+  VI_PARAMS(16);
+  *vd =sat_add_int16_t_uint16_t(vs2, vsext(simm5, sew), &sat);
+  break;
+}
+case e32: {
+  VI_PARAMS(32);
+  *vd =sat_add_int32_t_uint32_t(vs2, vsext(simm5, sew), &sat);
+  break;
+}
+default: {
+  VI_PARAMS(64);
+  *vd =sat_add_int64_t_uint64_t(vs2, vsext(simm5, sew), &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vv.h
new file mode 100755
index 000000000..51ff440ca
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vv.h
@@ -0,0 +1,30 @@
+// vsadd.vv *vd, vs2, vs1
+VI_LOOP_BASE
+{
+bool sat = false;
+switch(sew) {
+case e8: {
+  VV_PARAMS(8);
+  *vd =sat_add_int8_t_uint8_t(vs2, vs1, &sat);
+  break;
+}
+case e16: {
+  VV_PARAMS(16);
+  *vd =sat_add_int16_t_uint16_t(vs2, vs1, &sat);
+  break;
+}
+case e32: {
+  VV_PARAMS(32);
+  *vd =sat_add_int32_t_uint32_t(vs2, vs1, &sat);
+  break;
+}
+default: {
+  VV_PARAMS(64);
+  *vd =sat_add_int64_t_uint64_t(vs2, vs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsadd_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vx.h
new file mode 100755
index 000000000..df122a008
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vx.h
@@ -0,0 +1,29 @@
+// vsadd.vx *vd, vs2, rs1
+VI_LOOP_BASE
+{
+bool sat = false;
+switch(sew) {
+case e8: {
+  VX_PARAMS(8);
+  *vd =sat_add_int8_t_uint8_t(vs2, rs1, &sat);
+  break;
+}
+case e16: {
+  VX_PARAMS(16);
+  *vd =sat_add_int16_t_uint16_t(vs2, rs1, &sat);
+  break;
+}
+case e32: {
+  VX_PARAMS(32);
+  *vd =sat_add_int32_t_uint32_t(vs2, rs1, &sat);
+  break;
+}
+default: {
+  VX_PARAMS(64);
+  *vd =sat_add_int64_t_uint64_t(vs2, rs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vi.h
new file mode 100755
index 000000000..c389f8333
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vi.h
@@ -0,0 +1,11 @@
+// vsaddu *vd, vs2, zimm5
+VI_VI_ULOOP
+({
+  bool sat = false;
+  *vd =vs2 + simm5;
+
+  sat = *vd < vs2;
+  *vd |= -(*vd < vs2);
+
+  VECTOR->vxsat |= sat;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vv.h
new file mode 100755
index 000000000..dff560088
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vv.h
@@ -0,0 +1,11 @@
+// vsaddu *vd, vs2, vs1
+VI_VV_ULOOP
+({
+  bool sat = false;
+  *vd =vs2 + vs1;
+
+  sat = *vd < vs2;
+  *vd |= -(*vd < vs2);
+
+  VECTOR->vxsat |= sat;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vx.h
new file mode 100755
index 000000000..27bcb286f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vx.h
@@ -0,0 +1,12 @@
+// vsaddu *vd, vs2, rs1
+VI_VX_ULOOP
+({
+  bool sat = false;
+  *vd =vs2 + rs1;
+
+  sat = *vd < vs2;
+  *vd |= -(*vd < vs2);
+
+  VECTOR->vxsat |= sat;
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsb_v.h
new file mode 100755
index 000000000..8e6bc0782
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsb_v.h
@@ -0,0 +1,5 @@
+// vsb.v and vsseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_ST(0, i * nf + fn, uint8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsbc_vvm.h b/arch/riscv/kernel/soft_vector/insns_func/vsbc_vvm.h
new file mode 100755
index 000000000..9eaacc05a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsbc_vvm.h
@@ -0,0 +1,11 @@
+// vsbc.vvm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+VI_VV_LOOP
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs2) - (op_mask & vs1) - carry;
+  *vd =res;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsbc_vxm.h b/arch/riscv/kernel/soft_vector/insns_func/vsbc_vxm.h
new file mode 100755
index 000000000..4f947e7ba
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsbc_vxm.h
@@ -0,0 +1,11 @@
+// vsbc.vxm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+VI_VX_ULOOP
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs2) - (op_mask & rs1) - carry;
+  *vd =res;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vse_v.h b/arch/riscv/kernel/soft_vector/insns_func/vse_v.h
new file mode 100755
index 000000000..5d9c40764
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vse_v.h
@@ -0,0 +1,13 @@
+// vsw.v and vsseg[2-8]w.v
+reg_t sew = VECTOR->vsew;
+
+if (sew == e8) {
+  VI_ST(0, (i * nf + fn), uint8, 1);
+} else if (sew == e16) {
+  VI_ST(0, (i * nf + fn), uint16, 2);
+} else if (sew == e32) {
+  VI_ST(0, (i * nf + fn), uint32, 4);
+} else if (sew == e64) {
+  VI_ST(0, (i * nf + fn), uint64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsetvl.h b/arch/riscv/kernel/soft_vector/insns_func/vsetvl.h
new file mode 100755
index 000000000..6ba3d2f1f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsetvl.h
@@ -0,0 +1 @@
+WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, RS2));
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsetvli.h b/arch/riscv/kernel/soft_vector/insns_func/vsetvli.h
new file mode 100755
index 000000000..07148dc46
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsetvli.h
@@ -0,0 +1 @@
+WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, v_zimm11(insn)));
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsh_v.h
new file mode 100755
index 000000000..19b04511b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsh_v.h
@@ -0,0 +1,5 @@
+// vsh.v and vsseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_ST(0, i * nf + fn, uint16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslide1down_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vslide1down_vx.h
new file mode 100755
index 000000000..1ce25f3c1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslide1down_vx.h
@@ -0,0 +1,42 @@
+//vslide1down.vx *vd, vs2, rs1
+VI_LOOP_BASE
+if (i != vl - 1) {
+  switch (sew) {
+  case e8: {
+    VI_XI_SLIDEDOWN_PARAMS(8, 1);
+    *vd =vs2;
+  }
+  break;
+  case e16: {
+    VI_XI_SLIDEDOWN_PARAMS(16, 1);
+    *vd =vs2;
+  }
+  break;
+  case e32: {
+    VI_XI_SLIDEDOWN_PARAMS(32, 1);
+    *vd =vs2;
+  }
+  break;
+  default: {
+    VI_XI_SLIDEDOWN_PARAMS(64, 1);
+    *vd =vs2;
+  }
+  break;
+  }
+} else {
+  switch (sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, vl - 1) = RS1;
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, vl - 1) = RS1;
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, vl - 1) = RS1;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, vl - 1) = RS1;
+    break;
+  }
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslide1up_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vslide1up_vx.h
new file mode 100755
index 000000000..8857ff94c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslide1up_vx.h
@@ -0,0 +1,34 @@
+//vslide1up.vx *vd, vs2, rs1
+if (v_vm(insn) == 0)
+  require(rd(insn) != 0);
+
+VI_CHECK_SS
+{
+VI_LOOP_BASE
+if (i != 0) {
+  if (sew == e8) {
+    VI_XI_SLIDEUP_PARAMS(8, 1);
+    *vd =vs2;
+  } else if(sew == e16) {
+    VI_XI_SLIDEUP_PARAMS(16, 1);
+    *vd =vs2;
+  } else if(sew == e32) {
+    VI_XI_SLIDEUP_PARAMS(32, 1);
+    *vd =vs2;
+  } else if(sew == e64) {
+    VI_XI_SLIDEUP_PARAMS(64, 1);
+    *vd =vs2;
+  }
+} else {
+  if (sew == e8) {
+    *vector_elt_uint8_t(VECTOR, rd_num, 0) = RS1;
+  } else if(sew == e16) {
+    *vector_elt_uint16_t(VECTOR, rd_num, 0) = RS1;
+  } else if(sew == e32) {
+    *vector_elt_uint32_t(VECTOR, rd_num, 0) = RS1;
+  } else if(sew == e64) {
+    *vector_elt_uint64_t(VECTOR, rd_num, 0) = RS1;
+  }
+}
+VI_LOOP_END
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vi.h
new file mode 100755
index 000000000..b4da0c5ac
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vi.h
@@ -0,0 +1,35 @@
+// vslidedown.vi *vd, vs2, rs1
+VI_LOOP_BASE
+{
+const reg_t sh = v_zimm5(insn);
+bool is_valid = (i + sh) < VECTOR->vlmax;
+reg_t offset = 0;
+
+if (is_valid) {
+  offset = sh;
+}
+
+switch (sew) {
+case e8: {
+  VI_XI_SLIDEDOWN_PARAMS(8, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+case e16: {
+  VI_XI_SLIDEDOWN_PARAMS(16, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+case e32: {
+  VI_XI_SLIDEDOWN_PARAMS(32, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+default: {
+  VI_XI_SLIDEDOWN_PARAMS(64, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+}
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vx.h
new file mode 100755
index 000000000..3785aa1d1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vx.h
@@ -0,0 +1,34 @@
+//vslidedown.vx *vd, vs2, rs1
+VI_LOOP_BASE
+{
+reg_t offset = RS1 == (reg_t)-1 ? ((RS1 & (VECTOR->vlmax * 2 - 1)) + i) : RS1;
+bool is_valid = offset < VECTOR->vlmax;
+
+if (!is_valid) {
+  offset = 0;
+}
+
+switch (sew) {
+case e8: {
+  VI_XI_SLIDEDOWN_PARAMS(8, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+case e16: {
+  VI_XI_SLIDEDOWN_PARAMS(16, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+case e32: {
+  VI_XI_SLIDEDOWN_PARAMS(32, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+default: {
+  VI_XI_SLIDEDOWN_PARAMS(64, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+}
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslideup_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vslideup_vi.h
new file mode 100755
index 000000000..c18351ae1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslideup_vi.h
@@ -0,0 +1,37 @@
+// vslideup.vi *vd, vs2, rs1
+if (v_vm(insn) == 0)
+  require(rd(insn) != 0);
+
+VI_CHECK_SS
+{
+VI_LOOP_BASE
+{
+const reg_t offset = v_zimm5(insn);
+if (VECTOR->vstart < offset && i < offset)
+  continue;
+
+switch (sew) {
+case e8: {
+  VI_XI_SLIDEUP_PARAMS(8, offset);
+  *vd =vs2;
+}
+break;
+case e16: {
+  VI_XI_SLIDEUP_PARAMS(16, offset);
+  *vd =vs2;
+}
+break;
+case e32: {
+  VI_XI_SLIDEUP_PARAMS(32, offset);
+  *vd =vs2;
+}
+break;
+default: {
+  VI_XI_SLIDEUP_PARAMS(64, offset);
+  *vd =vs2;
+}
+break;
+}
+}
+VI_LOOP_END
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslideup_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vslideup_vx.h
new file mode 100755
index 000000000..0f9a6300c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslideup_vx.h
@@ -0,0 +1,32 @@
+//vslideup.vx *vd, vs2, rs1
+
+VI_LOOP_BASE
+{
+const reg_t offset = RS1;
+if (VECTOR->vstart < offset && i < offset)
+  continue;
+
+switch (sew) {
+case e8: {
+  VI_XI_SLIDEUP_PARAMS(8, offset);
+  *vd =vs2;
+}
+break;
+case e16: {
+  VI_XI_SLIDEUP_PARAMS(16, offset);
+  *vd =vs2;
+}
+break;
+case e32: {
+  VI_XI_SLIDEUP_PARAMS(32, offset);
+  *vd =vs2;
+}
+break;
+default: {
+  VI_XI_SLIDEUP_PARAMS(64, offset);
+  *vd =vs2;
+}
+break;
+}
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsll_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vsll_vi.h
new file mode 100755
index 000000000..18a809f53
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsll_vi.h
@@ -0,0 +1,5 @@
+// vsll.vi  *vd, vs2, zimm5
+VI_VI_LOOP
+({
+  *vd =vs2 << (simm5 & (sew - 1) & 0x1f);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsll_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsll_vv.h
new file mode 100755
index 000000000..dc575f02a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsll_vv.h
@@ -0,0 +1,5 @@
+// vsll
+VI_VV_LOOP
+({
+  *vd =vs2 << (vs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsll_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsll_vx.h
new file mode 100755
index 000000000..431c04b4f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsll_vx.h
@@ -0,0 +1,5 @@
+// vsll
+VI_VX_LOOP
+({
+  *vd =vs2 << (rs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsmul_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsmul_vv.h
new file mode 100755
index 000000000..9891cafe3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsmul_vv.h
@@ -0,0 +1,33 @@
+// vsmul: Signed saturating and rounding fractional multiply
+VRM xrm = VECTOR->vxrm;
+uint64_t int_max = (1ul << (VECTOR->vsew - 1)) - 1;
+uint64_t int_min = - (1 << (VECTOR->vsew - 1));
+uint64_t sign_mask = ((1ul << (VECTOR->vsew - 1)));
+
+VI_VV_ULOOP
+({
+  uint64_t vs1_sign;
+  uint64_t vs2_sign;
+  uint64_t result_sign;
+
+  bool overflow = vs1 == vs2 && vs1 == int_min;
+
+  uint128_t result = (int128_t)(int64_t)vs1 * (int128_t)(int64_t)vs2;
+  //result &= ((uint128_t)1llu << ((sew * 2) - 2)) - 1;
+  vs1_sign = vs1 & sign_mask;
+  vs2_sign = vs2 & sign_mask;
+  result_sign = (vs1_sign ^ vs2_sign) & sign_mask;
+  // rounding
+  INT_ROUNDING(result, xrm, sew - 1);
+  // unsigned shifting
+  result = result >> (sew - 1);
+
+  // saturation
+  if (overflow) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  } else {
+    //result |= result_sign;
+  }
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsmul_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsmul_vx.h
new file mode 100755
index 000000000..3a499ea86
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsmul_vx.h
@@ -0,0 +1,33 @@
+// vsmul
+VRM xrm = VECTOR->vxrm;
+int64_t int_max = (1ul << (VECTOR->vsew - 1)) - 1;
+int64_t int_min = - (1 << (VECTOR->vsew - 1));
+int64_t sign_mask = ((1ul << (VECTOR->vsew - 1)));
+
+VI_VX_ULOOP
+({
+  int64_t rs1_sign;
+  int64_t vs2_sign;
+  int64_t result_sign;
+
+  bool overflow = rs1 == vs2 && rs1 == int_min;
+
+  uint128_t result = (int128_t)(int64_t)rs1 * (int128_t)(int64_t)vs2;
+  //result &= ((uint128_t)1llu << ((sew * 2) - 2)) - 1;
+  rs1_sign = rs1 & sign_mask;
+  vs2_sign = vs2 & sign_mask;
+  result_sign = (rs1_sign ^ vs2_sign) & sign_mask;
+  // rounding
+  INT_ROUNDING(result, xrm, sew - 1);
+  // unsigned shifting
+  result = result >> (sew - 1);
+
+  // saturation
+  if (overflow) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  } else {
+    //result |= result_sign;
+  }
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsra_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vsra_vi.h
new file mode 100755
index 000000000..1bac96fae
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsra_vi.h
@@ -0,0 +1,5 @@
+// vsra.vi *vd, vs2, zimm5
+VI_VI_LOOP
+({
+  *vd =vs2 >> (simm5 & (sew - 1) & 0x1f);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsra_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsra_vv.h
new file mode 100755
index 000000000..b35bce322
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsra_vv.h
@@ -0,0 +1,5 @@
+// vsra.vv  *vd, vs2, vs1
+VI_VV_LOOP
+({
+  *vd =vs2 >> (vs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsra_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsra_vx.h
new file mode 100755
index 000000000..446154c25
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsra_vx.h
@@ -0,0 +1,5 @@
+// vsra.vx *vd, vs2, rs1
+VI_VX_LOOP
+({
+  *vd =vs2 >> (rs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsrl_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vi.h
new file mode 100755
index 000000000..4e020ec14
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vi.h
@@ -0,0 +1,5 @@
+// vsrl.vi *vd, vs2, zimm5
+VI_VI_ULOOP
+({
+  *vd =vs2 >> (simm5 & (sew - 1) & 0x1f);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsrl_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vv.h
new file mode 100755
index 000000000..be2f205e8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vv.h
@@ -0,0 +1,5 @@
+// vsrl.vv  *vd, vs2, vs1
+VI_VV_ULOOP
+({
+  *vd =vs2 >> (vs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsrl_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vx.h
new file mode 100755
index 000000000..02fe5ad79
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vx.h
@@ -0,0 +1,5 @@
+// vsrl.vx *vd, vs2, rs1
+VI_VX_ULOOP
+({
+  *vd =vs2 >> (rs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vssb_v.h
new file mode 100755
index 000000000..ee7bab9bd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssb_v.h
@@ -0,0 +1,5 @@
+// vssb.v and vssseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_ST(i * RS2, fn, uint8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsse_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsse_v.h
new file mode 100755
index 000000000..3229bcf17
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsse_v.h
@@ -0,0 +1,13 @@
+// vsse.v and vssseg[2-8]e.v
+reg_t sew = VECTOR->vsew;
+
+if (sew == e8) {
+  VI_ST(i * RS2, fn, uint8, 1);
+} else if (sew == e16) {
+  VI_ST(i * RS2, fn, uint16, 2);
+} else if (sew == e32) {
+  VI_ST(i * RS2, fn, uint32, 4);
+} else if (sew == e64) {
+  VI_ST(i * RS2, fn, uint64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vssh_v.h
new file mode 100755
index 000000000..e3c3319ed
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssh_v.h
@@ -0,0 +1,5 @@
+// vssh.v and vssseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_ST(i * RS2, fn, uint16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssra_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vssra_vi.h
new file mode 100755
index 000000000..5552af60f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssra_vi.h
@@ -0,0 +1,8 @@
+// vssra.vi *vd, vs2, simm5
+VRM xrm = VECTOR->vxrm;
+VI_VI_LOOP
+({
+  int sh = simm5 & (sew - 1) & 0x1f;
+  INT_ROUNDING(vs2, xrm, sh);
+  *vd =vs2 >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssra_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vssra_vv.h
new file mode 100755
index 000000000..d3847b85d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssra_vv.h
@@ -0,0 +1,9 @@
+// vssra.vv *vd, vs2, vs1
+VRM xrm = VECTOR->vxrm;
+VI_VV_LOOP
+({
+  int sh = vs1 & (sew - 1);
+
+  INT_ROUNDING(vs2, xrm, sh);
+  *vd =vs2 >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssra_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vssra_vx.h
new file mode 100755
index 000000000..877f575aa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssra_vx.h
@@ -0,0 +1,9 @@
+// vssra.vx *vd, vs2, rs1
+VRM xrm = VECTOR->vxrm;
+VI_VX_LOOP
+({
+  int sh = rs1 & (sew - 1);
+
+  INT_ROUNDING(vs2, xrm, sh);
+  *vd =vs2 >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssrl_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vi.h
new file mode 100755
index 000000000..d1644da39
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vi.h
@@ -0,0 +1,9 @@
+// vssra.vi *vd, vs2, simm5
+VRM xrm = VECTOR->vxrm;
+VI_VI_ULOOP
+({
+  int sh = simm5 & (sew - 1) & 0x1f;
+  uint128_t val = vs2;
+  INT_ROUNDING(val, xrm, sh);
+  *vd = val >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssrl_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vv.h
new file mode 100755
index 000000000..966e8be63
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vv.h
@@ -0,0 +1,10 @@
+// vssrl.vv *vd, vs2, vs1
+VRM xrm = VECTOR->vxrm;
+VI_VV_ULOOP
+({
+  int sh = vs1 & (sew - 1);
+  uint128_t val = vs2;
+
+  INT_ROUNDING(val, xrm, sh);
+  *vd = val >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssrl_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vx.h
new file mode 100755
index 000000000..693198deb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vx.h
@@ -0,0 +1,10 @@
+// vssrl.vx *vd, vs2, rs1
+VRM xrm = VECTOR->vxrm;
+VI_VX_ULOOP
+({
+  int sh = rs1 & (sew - 1);
+  uint128_t val = vs2;
+
+  INT_ROUNDING(val, xrm, sh);
+  *vd = val >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vssub_vv.h
new file mode 100755
index 000000000..19f4bde9d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssub_vv.h
@@ -0,0 +1,30 @@
+// vssub.vv *vd, vs2, vs1
+VI_LOOP_BASE
+{
+bool sat = false;
+
+switch (sew) {
+case e8: {
+  VV_PARAMS(8);
+  *vd =sat_sub_int8_t_uint8_t(vs2, vs1, &sat);
+  break;
+}
+case e16: {
+  VV_PARAMS(16);
+  *vd =sat_sub_int16_t_uint16_t(vs2, vs1, &sat);
+  break;
+}
+case e32: {
+  VV_PARAMS(32);
+  *vd =sat_sub_int32_t_uint32_t(vs2, vs1, &sat);
+  break;
+}
+default: {
+  VV_PARAMS(64);
+  *vd =sat_sub_int64_t_uint64_t(vs2, vs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vssub_vx.h
new file mode 100755
index 000000000..295b4f2c7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssub_vx.h
@@ -0,0 +1,30 @@
+// vssub.vx *vd, vs2, rs1
+VI_LOOP_BASE
+{
+bool sat = false;
+
+switch (sew) {
+case e8: {
+  VX_PARAMS(8);
+  *vd =sat_sub_int8_t_uint8_t(vs2, rs1, &sat);
+  break;
+}
+case e16: {
+  VX_PARAMS(16);
+  *vd =sat_sub_int16_t_uint16_t(vs2, rs1, &sat);
+  break;
+}
+case e32: {
+  VX_PARAMS(32);
+  *vd =sat_sub_int32_t_uint32_t(vs2, rs1, &sat);
+  break;
+}
+default: {
+  VX_PARAMS(64);
+  *vd =sat_sub_int64_t_uint64_t(vs2, rs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssubu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vssubu_vv.h
new file mode 100755
index 000000000..636c3f06c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssubu_vv.h
@@ -0,0 +1,30 @@
+// vssubu.vv *vd, vs2, vs1
+VI_LOOP_BASE
+{
+bool sat = false;
+
+switch (sew) {
+case e8: {
+  VV_U_PARAMS(8);
+  *vd =sat_subu_uint8_t(vs2, vs1, &sat);
+  break;
+}
+case e16: {
+  VV_U_PARAMS(16);
+  *vd =sat_subu_uint16_t(vs2, vs1, &sat);
+  break;
+}
+case e32: {
+  VV_U_PARAMS(32);
+  *vd =sat_subu_uint32_t(vs2, vs1, &sat);
+  break;
+}
+default: {
+  VV_U_PARAMS(64);
+  *vd =sat_subu_uint64_t(vs2, vs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssubu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vssubu_vx.h
new file mode 100755
index 000000000..b554349c3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssubu_vx.h
@@ -0,0 +1,30 @@
+// vssubu.vx *vd, vs2, rs1
+VI_LOOP_BASE
+{
+bool sat = false;
+
+switch (sew) {
+case e8: {
+  VX_U_PARAMS(8);
+  *vd =sat_subu_uint8_t(vs2, rs1, &sat);
+  break;
+}
+case e16: {
+  VX_U_PARAMS(16);
+  *vd =sat_subu_uint16_t(vs2, rs1, &sat);
+  break;
+}
+case e32: {
+  VX_U_PARAMS(32);
+  *vd =sat_subu_uint32_t(vs2, rs1, &sat);
+  break;
+}
+default: {
+  VX_U_PARAMS(64);
+  *vd =sat_subu_uint64_t(vs2, rs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vssw_v.h
new file mode 100755
index 000000000..91ba344ba
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssw_v.h
@@ -0,0 +1,5 @@
+// vssw.v and vssseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_ST(i * RS2, fn, uint32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsub_vv.h
new file mode 100755
index 000000000..4dd7d1833
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsub_vv.h
@@ -0,0 +1,5 @@
+// vsub
+VI_VV_LOOP
+({
+  *vd =vs2 - vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsub_vx.h
new file mode 100755
index 000000000..187e70203
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsub_vx.h
@@ -0,0 +1,5 @@
+// vsub: *vd[i] = (*vd[i] * x[rs1]) - vs2[i]
+VI_VX_LOOP
+({
+  *vd =vs2 - rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsuxb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsuxb_v.h
new file mode 100755
index 000000000..05bab138a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsuxb_v.h
@@ -0,0 +1,36 @@
+// vsuxb.v and vsxseg[2-8]b.v
+reg_t vl = VECTOR->vl;
+reg_t baseAddr = RS1;
+reg_t stride = rs2(insn);
+reg_t vs3 = rd(insn);
+reg_t vlmax = VECTOR->vlmax;
+VI_DUPLICATE_VREG(stride, vlmax);
+require(VECTOR->vsew >= e8);
+for (i = 0; i < vlmax && vl != 0; ++i) {
+  bool is_valid = true;
+  VI_STRIP(i)
+  VI_ELEMENT_SKIP(i);
+  switch (VECTOR->vsew) {
+  case e8:
+    if (is_valid)
+      store_uint8(baseAddr + index[i],
+                      *vector_elt_uint8_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e16:
+    if (is_valid)
+      store_uint8(baseAddr + index[i],
+                      *vector_elt_uint16_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e32:
+    if (is_valid)
+      store_uint8(baseAddr + index[i],
+                      *vector_elt_uint32_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e64:
+    if (is_valid)
+      store_uint8(baseAddr + index[i],
+                      *vector_elt_uint64_t(VECTOR, vs3, vreg_inx));
+    break;
+  }
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsuxe_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsuxe_v.h
new file mode 100755
index 000000000..018e058c5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsuxe_v.h
@@ -0,0 +1,37 @@
+// vsxe.v and vsxseg[2-8]e.v
+const reg_t sew = VECTOR->vsew;
+const reg_t vl = VECTOR->vl;
+reg_t baseAddr = RS1;
+reg_t stride = rs2(insn);
+reg_t vs3 = rd(insn);
+reg_t vlmax = VECTOR->vlmax;
+VI_DUPLICATE_VREG(stride, vlmax);
+require(sew >= e8 && sew <= e64);
+for (i = 0; i < vlmax && vl != 0; ++i) {
+  bool is_valid = true;
+  VI_STRIP(i)
+  VI_ELEMENT_SKIP(i);
+  switch (sew) {
+  case e8:
+    if (is_valid)
+      store_uint8(baseAddr + index[i],
+                      *vector_elt_uint8_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e16:
+    if (is_valid)
+      store_uint16(baseAddr + index[i],
+                       *vector_elt_uint16_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e32:
+    if (is_valid)
+      store_uint32(baseAddr + index[i],
+                       *vector_elt_uint32_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e64:
+    if (is_valid)
+      store_uint64(baseAddr + index[i],
+                       *vector_elt_uint64_t(VECTOR, vs3, vreg_inx));
+    break;
+  }
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsuxh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsuxh_v.h
new file mode 100755
index 000000000..c9d283db4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsuxh_v.h
@@ -0,0 +1,32 @@
+// vsxh.v and vsxseg[2-8]h.v
+reg_t vl = VECTOR->vl;
+reg_t baseAddr = RS1;
+reg_t stride = rs2(insn);
+reg_t vs3 = rd(insn);
+reg_t vlmax = VECTOR->vlmax;
+VI_DUPLICATE_VREG(stride, vlmax);
+require(VECTOR->vsew >= e16);
+for (i = 0; i < vlmax && vl != 0; ++i) {
+  bool is_valid = true;
+  VI_STRIP(i)
+  VI_ELEMENT_SKIP(i);
+
+  switch (VECTOR->vsew) {
+  case e16:
+    if (is_valid)
+      store_uint16(baseAddr + index[i],
+                       *vector_elt_uint16_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e32:
+    if (is_valid)
+      store_uint16(baseAddr + index[i],
+                       *vector_elt_uint32_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e64:
+    if (is_valid)
+      store_uint16(baseAddr + index[i],
+                       *vector_elt_uint64_t(VECTOR, vs3, vreg_inx));
+    break;
+  }
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsuxw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsuxw_v.h
new file mode 100755
index 000000000..7ef7a044d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsuxw_v.h
@@ -0,0 +1,26 @@
+// vsxw.v and vsxseg[2-8]w.v
+reg_t vl = VECTOR->vl;
+reg_t baseAddr = RS1;
+reg_t stride = rs2(insn);
+reg_t vs3 = rd(insn);
+reg_t vlmax = VECTOR->vlmax;
+VI_DUPLICATE_VREG(stride, vlmax);
+require(VECTOR->vsew >= e32);
+for (i = 0; i < vlmax && vl != 0; ++i) {
+  bool is_valid = true;
+  VI_STRIP(i)
+  VI_ELEMENT_SKIP(i);
+  switch (VECTOR->vsew) {
+  case e32:
+    if (is_valid)
+      store_uint32(baseAddr + index[i],
+                       *vector_elt_uint32_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e64:
+    if (is_valid)
+      store_uint32(baseAddr + index[i],
+                       *vector_elt_uint64_t(VECTOR, vs3, vreg_inx));
+    break;
+  }
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsw_v.h
new file mode 100755
index 000000000..976cbfd5a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsw_v.h
@@ -0,0 +1,5 @@
+// vsw.v and vsseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_ST(0, i * nf + fn, uint32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsxb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsxb_v.h
new file mode 100755
index 000000000..5efad746c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsxb_v.h
@@ -0,0 +1,8 @@
+// vsxb.v and vsxseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_ST_WITH_I(index[i], fn, uint8, 1);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsxe_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsxe_v.h
new file mode 100755
index 000000000..b5c0a7f5c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsxe_v.h
@@ -0,0 +1,14 @@
+// vsxe.v and vsxseg[2-8]e.v
+reg_t sew = VECTOR->vsew;
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+require(sew >= e8 && sew <= e64);
+if (sew == e8) {
+  VI_ST_WITH_I(index[i], fn, uint8, 1);
+} else if (sew == e16) {
+  VI_ST_WITH_I(index[i], fn, uint16, 2);
+} else if (sew == e32) {
+  VI_ST_WITH_I(index[i], fn, uint32, 4);
+} else if (sew == e64) {
+  VI_ST_WITH_I(index[i], fn, uint64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsxh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsxh_v.h
new file mode 100755
index 000000000..4ebe00725
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsxh_v.h
@@ -0,0 +1,8 @@
+// vsxh.v and vsxseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_ST_WITH_I(index[i], fn, uint16, 2);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsxw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsxw_v.h
new file mode 100755
index 000000000..a2aaaa2bf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsxw_v.h
@@ -0,0 +1,8 @@
+// vsxw.v and vsxseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_ST_WITH_I(index[i], fn, uint32, 4);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwadd_vv.h
new file mode 100755
index 000000000..039c43d0b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwadd_vv.h
@@ -0,0 +1,6 @@
+// vwadd.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, +, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwadd_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwadd_vx.h
new file mode 100755
index 000000000..e4bee2590
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwadd_vx.h
@@ -0,0 +1,6 @@
+// vwadd.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, +, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwadd_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vwadd_wv.h
new file mode 100755
index 000000000..45f60ad89
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwadd_wv.h
@@ -0,0 +1,6 @@
+// vwadd.wv *vd, vs2, vs1
+VI_CHECK_DDS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(vs1, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwadd_wx.h b/arch/riscv/kernel/soft_vector/insns_func/vwadd_wx.h
new file mode 100755
index 000000000..921b4ffbf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwadd_wx.h
@@ -0,0 +1,6 @@
+// vwaddu.wx *vd, vs2, rs1
+VI_CHECK_DDS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(rs1, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vv.h
new file mode 100755
index 000000000..da824ba07
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vv.h
@@ -0,0 +1,6 @@
+// vwaddu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, +, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vx.h
new file mode 100755
index 000000000..d3574a4a7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vx.h
@@ -0,0 +1,6 @@
+// vwaddu.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, +, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wv.h
new file mode 100755
index 000000000..f146a9273
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wv.h
@@ -0,0 +1,6 @@
+// vwaddu.wv *vd, vs2, vs1
+VI_CHECK_DDS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(vs1, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wx.h b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wx.h
new file mode 100755
index 000000000..4f3df8064
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wx.h
@@ -0,0 +1,6 @@
+// vwaddu.wx *vd, vs2, rs1
+VI_CHECK_DDS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(rs1, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vv.h
new file mode 100755
index 000000000..e085711d4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vv.h
@@ -0,0 +1,6 @@
+// vwmacc.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, vd_w, *, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vx.h
new file mode 100755
index 000000000..d90066522
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vx.h
@@ -0,0 +1,6 @@
+// vwmacc.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, vd_w, *, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vv.h
new file mode 100755
index 000000000..f3772ad38
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vv.h
@@ -0,0 +1,6 @@
+// vwmaccsu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN_MIX(vs2, vs1, vd_w, *, +, int, uint, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vx.h
new file mode 100755
index 000000000..23ff0e36d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vx.h
@@ -0,0 +1,6 @@
+// vwmaccsu.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN_MIX(vs2, rs1, vd_w, *, +, int, uint, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vv.h
new file mode 100755
index 000000000..0a8c68441
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vv.h
@@ -0,0 +1,6 @@
+// vwmaccu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, vd_w, *, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vx.h
new file mode 100755
index 000000000..7ccbe00cd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vx.h
@@ -0,0 +1,6 @@
+// vwmaccu.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, vd_w, *, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmaccus_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmaccus_vx.h
new file mode 100755
index 000000000..b397365d7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmaccus_vx.h
@@ -0,0 +1,6 @@
+// vwmaccus.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN_MIX(vs2, rs1, vd_w, *, +, int, int, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmul_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmul_vv.h
new file mode 100755
index 000000000..d6108263e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmul_vv.h
@@ -0,0 +1,6 @@
+// vwmul.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, *, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmul_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmul_vx.h
new file mode 100755
index 000000000..c3afc255a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmul_vx.h
@@ -0,0 +1,6 @@
+// vwmul.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, *, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vv.h
new file mode 100755
index 000000000..2e9b36c55
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vv.h
@@ -0,0 +1,16 @@
+// vwmulsu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  switch(VECTOR->vsew) {
+  case e8:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = (int16_t)(int8_t)vs2 * (int16_t)(uint8_t)vs1;
+    break;
+  case e16:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = (int32_t)(int16_t)vs2 * (int32_t)(uint16_t)vs1;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = (int64_t)(int32_t)vs2 * (int64_t)(uint32_t)vs1;
+    break;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vx.h
new file mode 100755
index 000000000..752f75e75
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vx.h
@@ -0,0 +1,16 @@
+// vwmulsu.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  switch(VECTOR->vsew) {
+  case e8:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = (int16_t)(int8_t)vs2 * (int16_t)(uint8_t)rs1;
+    break;
+  case e16:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = (int32_t)(int16_t)vs2 * (int32_t)(uint16_t)rs1;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = (int64_t)(int32_t)vs2 * (int64_t)(uint32_t)rs1;
+    break;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vv.h
new file mode 100755
index 000000000..955e7ed45
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vv.h
@@ -0,0 +1,6 @@
+// vwmulu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, *, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vx.h
new file mode 100755
index 000000000..a6cceeada
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vx.h
@@ -0,0 +1,6 @@
+// vwmul.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, *, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwredsum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vwredsum_vs.h
new file mode 100755
index 000000000..ee023ae21
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwredsum_vs.h
@@ -0,0 +1,5 @@
+// vwredsum.vs *vd, vs2, vs1
+VI_VV_LOOP_WIDE_REDUCTION
+({
+  vd_0_res += vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwredsumu_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vwredsumu_vs.h
new file mode 100755
index 000000000..b73d05661
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwredsumu_vs.h
@@ -0,0 +1,5 @@
+// vwredsum.vs *vd, vs2, vs1
+VI_VV_ULOOP_WIDE_REDUCTION
+({
+  vd_0_res += vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vv.h
new file mode 100755
index 000000000..899beda4f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vv.h
@@ -0,0 +1,2 @@
+// vwsmacc.vv *vd, vs2, vs1
+VI_VVX_LOOP_WIDE_SSMA(vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vx.h
new file mode 100755
index 000000000..d47bae0db
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vx.h
@@ -0,0 +1,2 @@
+// vwsmacc.vx *vd, vs2, rs1
+VI_VVX_LOOP_WIDE_SSMA(rs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vv.h
new file mode 100755
index 000000000..893a19aa9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vv.h
@@ -0,0 +1,2 @@
+// vwsmaccsu.vx *vd, vs2, vs1
+VI_VVX_LOOP_WIDE_SU_SSMA(vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vx.h
new file mode 100755
index 000000000..f386e19f2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vx.h
@@ -0,0 +1,2 @@
+// vwsmaccsu.vx *vd, vs2, rs1
+VI_VVX_LOOP_WIDE_SU_SSMA(rs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vv.h
new file mode 100755
index 000000000..8153f3227
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vv.h
@@ -0,0 +1,2 @@
+// vwsmaccu.vv *vd, vs2, vs1
+VI_VVX_LOOP_WIDE_USSMA(vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vx.h
new file mode 100755
index 000000000..3b832233e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vx.h
@@ -0,0 +1,2 @@
+// vwsmaccu *vd, vs2, rs1
+VI_VVX_LOOP_WIDE_USSMA(rs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmaccus_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccus_vx.h
new file mode 100755
index 000000000..a798f0e4a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccus_vx.h
@@ -0,0 +1,2 @@
+// vwsmaccus.vx  *vd, vs2, rs1
+VI_VVX_LOOP_WIDE_US_SSMA(rs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsub_vv.h
new file mode 100755
index 000000000..f4f5b290d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsub_vv.h
@@ -0,0 +1,6 @@
+// vwsub.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, -, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsub_vx.h
new file mode 100755
index 000000000..cc2d5f065
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsub_vx.h
@@ -0,0 +1,6 @@
+// vwsub.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, -, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsub_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsub_wv.h
new file mode 100755
index 000000000..072cafcb3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsub_wv.h
@@ -0,0 +1,6 @@
+// vwsub.wv *vd, vs2, vs1
+VI_CHECK_DDS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(vs1, -, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsub_wx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsub_wx.h
new file mode 100755
index 000000000..849a051a8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsub_wx.h
@@ -0,0 +1,6 @@
+// vwsub.wx *vd, vs2, rs1
+VI_CHECK_DDS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(rs1, -, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vv.h
new file mode 100755
index 000000000..4e99fd428
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vv.h
@@ -0,0 +1,6 @@
+// vwsubu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, -, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vx.h
new file mode 100755
index 000000000..a05db3d50
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vx.h
@@ -0,0 +1,6 @@
+// vwsubu.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, -, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wv.h
new file mode 100755
index 000000000..0979beeef
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wv.h
@@ -0,0 +1,6 @@
+// vwsubu.wv *vd, vs2, vs1
+VI_CHECK_DDS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(vs1, -, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wx.h
new file mode 100755
index 000000000..817f4b888
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wx.h
@@ -0,0 +1,6 @@
+// vwsubu.wx *vd, vs2, rs1
+VI_CHECK_DDS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(rs1, -, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vxor_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vxor_vi.h
new file mode 100755
index 000000000..bea4263c5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vxor_vi.h
@@ -0,0 +1,5 @@
+// vxor
+VI_VI_LOOP
+({
+  *vd =simm5 ^ vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vxor_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vxor_vv.h
new file mode 100755
index 000000000..b2de0b707
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vxor_vv.h
@@ -0,0 +1,5 @@
+// vxor
+VI_VV_LOOP
+({
+  *vd =vs1 ^ vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vxor_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vxor_vx.h
new file mode 100755
index 000000000..ed3552fb2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vxor_vx.h
@@ -0,0 +1,5 @@
+// vxor
+VI_VX_LOOP
+({
+  *vd =rs1 ^ vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/riscv_decode.h b/arch/riscv/kernel/soft_vector/riscv_decode.h
new file mode 100755
index 000000000..61eeca6ca
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/riscv_decode.h
@@ -0,0 +1,1933 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#ifndef _RISCV_DECODE_H
+#define _RISCV_DECODE_H
+
+#if (-1 != ~0) || ((-1 >> 1) != -1)
+# error spike requires a two''s-complement c++ implementation
+#endif
+
+#ifdef WORDS_BIGENDIAN
+# error spike requires a little-endian host
+#endif
+
+#include <asm/string.h>
+#include "encoding.h"
+#include "softfloat/config.h"
+#include "softfloat/softfloat_types.h"
+#include "softfloat/specialize.h"
+#include "arith.h"
+#include "softfloat/stdint.h"
+#include "softfloat/stdbool.h"
+#include "linux/compiler.h"
+typedef enum VRM{
+  RNU = 0,
+  RNE,
+  RDN,
+  ROD,
+  INVALID_RM
+} VRM;
+
+//#define   likely(x) __builtin_expect(x, 1)
+//#define unlikely(x) __builtin_expect(x, 0)
+
+#define NOINLINE __attribute__ ((noinline))
+
+typedef int64_t sreg_t;
+typedef unsigned long reg_t;
+typedef __int128 int128_t;
+typedef unsigned __int128 uint128_t;
+
+#define NXPR 32
+#define NFPR 32
+#define NVPR 32
+#define NCSR 4096
+
+#define X_RA 1
+#define X_SP 2
+
+#define FP_RD_NE  0
+#define FP_RD_0   1
+#define FP_RD_DN  2
+#define FP_RD_UP  3
+#define FP_RD_NMM 4
+
+#define FSR_RD_SHIFT 5
+#define FSR_RD   (0x7 << FSR_RD_SHIFT)
+
+#define FPEXC_NX 0x01
+#define FPEXC_UF 0x02
+#define FPEXC_OF 0x04
+#define FPEXC_DZ 0x08
+#define FPEXC_NV 0x10
+
+#define FSR_AEXC_SHIFT 0
+#define FSR_NVA  (FPEXC_NV << FSR_AEXC_SHIFT)
+#define FSR_OFA  (FPEXC_OF << FSR_AEXC_SHIFT)
+#define FSR_UFA  (FPEXC_UF << FSR_AEXC_SHIFT)
+#define FSR_DZA  (FPEXC_DZ << FSR_AEXC_SHIFT)
+#define FSR_NXA  (FPEXC_NX << FSR_AEXC_SHIFT)
+#define FSR_AEXC (FSR_NVA | FSR_OFA | FSR_UFA | FSR_DZA | FSR_NXA)
+
+#define insn_length(x) 4
+#define MAX_INSN_LENGTH 8
+#define PC_ALIGN 2
+
+#ifndef TAIL_ZEROING
+  #define TAIL_ZEROING true
+#else
+  #define TAIL_ZEROING false
+#endif
+
+typedef struct vector_state {
+    __uint128_t regs[32];
+    reg_t reg_mask, vlmax, vmlen;
+    reg_t vstart, vxrm, vxsat, vl, vtype;
+    reg_t vediv, vsew, vlmul;
+    reg_t ELEN, VLEN, SLEN;
+    bool vill;
+} vector_state;
+
+#define BITS(v, hi, lo) ((v >> lo) & ((2 << (hi - lo)) - 1))
+
+#define trap_illegal_instruction(n) return n;
+#define require(x) if (unlikely(!(x))) trap_illegal_instruction(0)
+
+#define vector_elt(type) \
+        type * vector_elt_##type(vector_state* vector, reg_t vReg, reg_t n);\
+
+vector_elt(float32_t)
+vector_elt(float64_t)
+vector_elt(int8_t)
+vector_elt(int16_t)
+vector_elt(int32_t)
+vector_elt(int64_t)
+vector_elt(uint8_t)
+vector_elt(uint16_t)
+vector_elt(uint32_t)
+vector_elt(uint64_t)
+#undef vector_elt
+
+typedef uint64_t insn_t;
+typedef uint64_t insn_bits_t;
+typedef float128_t freg_t;
+
+//TODO
+#define load_store(type) \
+      type##_t load_##type(reg_t addr);\
+      \
+      void store_##type(reg_t addr, type##_t val);
+      
+load_store(uint8)
+load_store(uint16)
+load_store(uint32)
+load_store(uint64)
+
+load_store(int8)
+load_store(int16)
+load_store(int32)
+load_store(int64)
+#undef load_store
+
+inline int get_max_xlen(void);
+reg_t set_vl(vector_state *vector, uint64_t regId, reg_t reqVL, reg_t newType);
+
+inline uint64_t x(insn_t b, int lo, int len);
+inline uint64_t xs(insn_t b, int lo, int len);
+inline uint64_t imm_sign(insn_t b);
+inline int length(insn_t b);
+inline int64_t i_imm(insn_t b);
+inline int64_t shamt(insn_t b);
+inline int64_t s_imm(insn_t b);
+inline int64_t sb_imm(insn_t b);
+inline int64_t u_imm(insn_t b);
+inline int64_t uj_imm(insn_t b);
+inline uint64_t rd(insn_t b);
+inline uint64_t insn_rs1(insn_t b);
+inline uint64_t rs2(insn_t b);
+inline uint64_t rs3(insn_t b);
+inline uint64_t rm(insn_t b);
+inline uint64_t csr(insn_t b);
+
+inline uint64_t v_vm(insn_t b);
+inline uint64_t v_wd(insn_t b);
+inline uint64_t v_nf(insn_t b);
+inline uint64_t v_simm5(insn_t b);
+inline uint64_t v_zimm5(insn_t b);
+inline uint64_t v_zimm11(insn_t b);
+inline uint64_t v_lmul(insn_t b);
+inline uint64_t v_sew(insn_t b);
+
+typedef struct processor{
+  reg_t XPR[32];
+  freg_t FPR[32];
+  vector_state vector;
+  reg_t saved_a0;
+  reg_t mstatus;
+  reg_t frm;
+  reg_t fflags;
+  reg_t pc;
+} processor_t;
+
+bool supports_extension(processor_t * state, unsigned char ext);
+
+int get_flen(processor_t * state);
+inline int get_xlen(void);
+#define STATE (*p) 
+#define VECTOR (&(p->vector))
+#define FLEN (get_flen(p)) 
+
+#define READ_REG(reg) STATE.XPR[reg]
+#define READ_FREG(reg) STATE.FPR[reg]
+# define WRITE_REG(reg, value) STATE.XPR[reg] = value
+
+#define RD READ_REG(rd(insn))
+#define RS1 READ_REG(insn_rs1(insn))
+#define RS2 READ_REG(rs2(insn))
+#define RS3 READ_REG(rs3(insn))
+#define WRITE_RD(value) WRITE_REG(rd(insn), value)
+
+// FPU macros
+#define FRS1 READ_FREG(insn_rs1(insn))
+#define FRS2 READ_FREG(rs2(insn))
+#define FRS3 READ_FREG(rs3(insn))
+#define dirty_fp_state (STATE.mstatus |= MSTATUS_FS | (xlen == 64 ? MSTATUS64_SD : MSTATUS32_SD))
+#define dirty_ext_state (STATE.mstatus |= MSTATUS_XS | (xlen == 64 ? MSTATUS64_SD : MSTATUS32_SD))
+#define DO_WRITE_FREG(reg, value) (STATE.FPR[reg] = value, dirty_fp_state)
+#define WRITE_FREG(reg, value, len) DO_WRITE_FREG(reg, freg##len(value))
+#define WRITE_FRD(value, len) WRITE_FREG(rd(insn), value, len)
+ 
+#define SHAMT (i_imm(insn) & 0x3F)
+#define RM ({ int rm = rm(insn); \
+              if(rm == 7) rm = STATE.frm; \
+              if(rm > 4) trap_illegal_instruction(0); \
+              rm; })
+
+#define require_rv64 require(xlen == 64)
+#define require_rv32 require(xlen == 32)
+#define require_extension(s) require(supports_extension(p,s))
+#define require_fp require((STATE.mstatus & MSTATUS_FS) != 0)
+#define require_accelerator require((STATE.mstatus & MSTATUS_XS) != 0)
+
+#define set_fp_exceptions ({ if (softfloat_exceptionFlags) { \
+                               dirty_fp_state; \
+                               STATE.fflags |= softfloat_exceptionFlags; \
+                             } \
+                             softfloat_exceptionFlags = 0; })
+
+#define sext32(x) ((sreg_t)(int32_t)(x))
+#define zext32(x) ((reg_t)(uint32_t)(x))
+#define sext_xlen(x) (((sreg_t)(x) << (64-xlen)) >> (64-xlen))
+#define zext_xlen(x) (((reg_t)(x) << (64-xlen)) >> (64-xlen))
+
+/* Convenience wrappers to simplify softfloat code sequences */
+#define isBoxedF32(r) (isBoxedF64(r) && ((uint32_t)((r.v[0] >> 32) + 1) == 0))
+#define unboxF32(r) (isBoxedF32(r) ? (uint32_t)r.v[0] : defaultNaNF32UI)
+#define isBoxedF64(r) ((r.v[1] + 1) == 0)
+#define unboxF64(r) (isBoxedF64(r) ? r.v[0] : defaultNaNF64UI)
+
+inline float32_t f32(uint32_t v);
+inline float64_t f64(uint64_t v);
+inline float32_t f32_f(freg_t r);
+inline float64_t f64_f(freg_t r);
+inline float128_t f128(freg_t r);
+inline freg_t freg32(float32_t f);
+inline freg_t freg64(float64_t f);
+inline freg_t freg128(float128_t f);
+#define F32_SIGN ((uint32_t)1 << 31)
+#define F64_SIGN ((uint64_t)1 << 63)
+#define fsgnj32(a, b, n, x) \
+  f32((f32(a).v & ~F32_SIGN) | ((((x) ? f32(a).v : (n) ? F32_SIGN : 0) ^ f32(b).v) & F32_SIGN))
+#define fsgnj64(a, b, n, x) \
+  f64((f64(a).v & ~F64_SIGN) | ((((x) ? f64(a).v : (n) ? F64_SIGN : 0) ^ f64(b).v) & F64_SIGN))
+
+#define isNaNF128(x) isNaNF128UI(x.v[1], x.v[0])
+inline float128_t defaultNaNF128(void);
+inline freg_t fsgnj128(freg_t a, freg_t b, bool n, bool x);
+inline freg_t f128_negate(freg_t a);
+
+// Vector macros
+#define e8 8      // 8b elements
+#define e16 16    // 16b elements
+#define e32 32    // 32b elements
+#define e64 64    // 64b elements
+#define e128 128  // 128b elements
+
+#define vsext(x, sew) (((sreg_t)(x) << (64-sew)) >> (64-sew))
+#define vzext(x, sew) (((reg_t)(x) << (64-sew)) >> (64-sew))
+
+#define DEBUG_RVV_FP_VV
+#define DEBUG_RVV_FP_VF
+#define DEBUG_RVV_FMA_VV
+#define DEBUG_RVV_FMA_VF
+//
+// vector: masking skip helper
+//
+#define VI_LOOP_ELEMENT_SKIP(BODY) \
+  const int mlen = VECTOR->vmlen; \
+  const int midx = (mlen * i) / 64; \
+  const int mpos = (mlen * i) % 64; \
+  if (v_vm(insn) == 0) { \
+	bool skip; \
+    BODY; \
+    skip = ((*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1) == 0; \
+    if (skip) \
+      continue; \
+  }
+
+#define VI_ELEMENT_SKIP(inx) \
+  if (inx >= vl && TAIL_ZEROING) { \
+    is_valid = false; \
+  } else if (inx >= vl && !TAIL_ZEROING) { \
+    continue; \
+  } else if (inx < VECTOR->vstart) { \
+    continue; \
+  } else { \
+    VI_LOOP_ELEMENT_SKIP(); \
+  }
+
+//
+// vector: operation and register acccess check helper
+//
+inline bool is_overlaped(const int astart, const int asize,
+                                const int bstart, const int bsize);
+
+#define VI_NARROW_CHECK_COMMON \
+  require(VECTOR->vlmul <= 4); \
+  require(VECTOR->vsew * 2 <= VECTOR->ELEN); \
+  require(rs2(insn) + VECTOR->vlmul * 2 <= 32);
+
+#define VI_WIDE_CHECK_COMMON \
+  require(!VECTOR->vill);\
+  require(VECTOR->vlmul <= 4); \
+  require(VECTOR->vsew * 2 <= VECTOR->ELEN); \
+  require(rd(insn) + VECTOR->vlmul * 2 <= 32); \
+  if (v_vm(insn) == 0) \
+    require(rd(insn) != 0);
+
+#define VI_CHECK_VREG_OVERLAP(v1, v2) \
+  require(!is_overlaped(v1, VECTOR->vlmul, v2, VECTOR->vlmul));
+
+#define VI_CHECK_SS \
+  require(!is_overlaped(rd(insn), VECTOR->vlmul, rs2(insn), VECTOR->vlmul));
+
+#define VI_CHECK_SD \
+  require(!is_overlaped(rd(insn), VECTOR->vlmul, rs2(insn), VECTOR->vlmul * 2));
+
+#define VI_CHECK_DSS(is_rs) \
+  VI_WIDE_CHECK_COMMON; \
+  require(!is_overlaped(rd(insn), VECTOR->vlmul * 2, rs2(insn), VECTOR->vlmul)); \
+  if (is_rs) \
+     require(!is_overlaped(rd(insn), VECTOR->vlmul * 2, insn_rs1(insn), VECTOR->vlmul));
+
+#define VI_CHECK_DDS(is_rs) \
+  VI_WIDE_CHECK_COMMON; \
+  require(rs2(insn) + VECTOR->vlmul * 2 <= 32); \
+  if (is_rs) \
+     require(!is_overlaped(rd(insn), VECTOR->vlmul * 2, insn_rs1(insn), VECTOR->vlmul));
+
+//
+// vector: loop header and end helper
+//
+#define VI_GENERAL_LOOP_BASE \
+  reg_t vl, sew, rd_num, rs1_num, rs2_num, i; \
+  require(VECTOR->vsew == e8 || VECTOR->vsew == e16 || VECTOR->vsew == e32 || VECTOR->vsew == e64); \
+  require(!VECTOR->vill);\
+  vl = VECTOR->vl; \
+  sew = VECTOR->vsew; \
+  rd_num = rd(insn); \
+  rs1_num = insn_rs1(insn); \
+  rs2_num = rs2(insn); \
+  for (i=VECTOR->vstart; i<vl; ++i){ 
+
+#define VI_TAIL_ZERO(elm) \
+  if (vl != 0 && vl < VECTOR->vlmax && TAIL_ZEROING) { \
+    uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, vl * ((sew >> 3) * elm)); \
+    memset(tail, 0, (VECTOR->vlmax - vl) * ((sew >> 3) * elm)); \
+  }
+
+#define VI_TAIL_ZERO_MASK(dst) \
+  if (vl != 0 && TAIL_ZEROING){ \
+    for (i=vl; i<VECTOR->vlmax; ++i){ \
+      const int mlen = VECTOR->vmlen; \
+      const int midx = (mlen * i) / 64; \
+      const int mpos = (mlen * i) % 64; \
+      uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+      uint64_t *vdi = vector_elt_uint64_t(VECTOR, dst, midx); \
+      *vdi = (*vdi & ~mmask);\
+    }\
+  }\
+
+#define VI_LOOP_BASE \
+    VI_GENERAL_LOOP_BASE \
+    VI_LOOP_ELEMENT_SKIP();
+
+#define VI_LOOP_END \
+  } \
+  if (vl != 0 && vl < VECTOR->vlmax && TAIL_ZEROING){ \
+    uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, vl * ((sew >> 3) * 1)); \
+    memset(tail, 0, (VECTOR->vlmax - vl) * ((sew >> 3) * 1)); \
+  }\
+  VECTOR->vstart = 0;
+
+#define VI_LOOP_END_NO_TAIL_ZERO \
+  } \
+  VECTOR->vstart = 0;
+
+#define VI_LOOP_WIDEN_END \
+  } \
+  if (vl != 0 && vl < VECTOR->vlmax && TAIL_ZEROING){ \
+    uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, vl * ((sew >> 3) * 2)); \
+    memset(tail, 0, (VECTOR->vlmax - vl) * ((sew >> 3) * 2)); \
+  }\
+  VECTOR->vstart = 0;
+
+#define VI_LOOP_REDUCTION_END(x) \
+  } \
+  if (vl > 0 && TAIL_ZEROING) { \
+    uint8_t *tail = (uint8_t *)vector_elt_int##x##_t(VECTOR, rd_num, 1); \
+    *vd_0_des = vd_0_res; \
+    memset(tail, 0, (VECTOR->VLEN - x) >> 3); \
+  } \
+  VECTOR->vstart = 0; 
+
+#define VI_LOOP_CMP_BASE \
+  reg_t vl, sew, rd_num, rs1_num, rs2_num, i; \
+  require(VECTOR->vsew == e8 || VECTOR->vsew == e16 || VECTOR->vsew == e32 || VECTOR->vsew == e64); \
+  require(!VECTOR->vill);\
+  vl = VECTOR->vl; \
+  sew = VECTOR->vsew; \
+  rd_num = rd(insn); \
+  rs1_num = insn_rs1(insn); \
+  rs2_num = rs2(insn); \
+  for (i = VECTOR->vstart; i<vl; ++i){ \
+	uint64_t mmask, res; \
+	uint64_t *vdi; \
+    VI_LOOP_ELEMENT_SKIP(); \
+    mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+    vdi = vector_elt_uint64_t(VECTOR, rd(insn), midx); \
+    res = 0;
+
+#define VI_LOOP_CMP_END \
+    *vdi = (*vdi & ~mmask) | (((res) << mpos) & mmask); \
+  } \
+  VI_TAIL_ZERO_MASK(rd_num); \
+  VECTOR->vstart = 0;
+
+#define VI_LOOP_MASK(op) \
+  reg_t vl, i; \
+  require(VECTOR->vsew <= e64); \
+  vl = VECTOR->vl; \
+  for (i = VECTOR->vstart; i < vl; ++i) { \
+    int mlen = VECTOR->vmlen; \
+    int midx = (mlen * i) / 64; \
+    int mpos = (mlen * i) % 64; \
+    uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+    uint64_t vs2 = *vector_elt_uint64_t(VECTOR, rs2(insn), midx); \
+    uint64_t vs1 = *vector_elt_uint64_t(VECTOR, insn_rs1(insn), midx); \
+    uint64_t *res = vector_elt_uint64_t(VECTOR, rd(insn), midx); \
+    *res = (*res & ~mmask) | ((op) & (1ULL << mpos)); \
+  } \
+  \
+  if (TAIL_ZEROING) {\
+  for (i = vl; i < VECTOR->vlmax && i > 0; ++i) { \
+    int mlen = VECTOR->vmlen; \
+    int midx = (mlen * i) / 64; \
+    int mpos = (mlen * i) % 64; \
+    uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+    uint64_t *res = vector_elt_uint64_t(VECTOR, rd(insn), midx); \
+    *res = (*res & ~mmask); \
+    } \
+  } \
+  VECTOR->vstart = 0;
+
+#define VI_LOOP_NSHIFT_BASE \
+  require(VECTOR->vsew <= e32); \
+  if (rd(insn) != 0){ \
+    VI_CHECK_SD; \
+  } \
+  { \
+  VI_GENERAL_LOOP_BASE; \
+  { \
+  VI_LOOP_ELEMENT_SKIP({\
+    require(!(rd(insn) == 0 && VECTOR->vlmul > 1));\
+  }); \
+  }
+
+
+#define INT_ROUNDING(result, xrm, gb) \
+  if (gb > 0) { \
+    switch(xrm) {\
+      case RNU:\
+        result += ((uint64_t)1 << ((gb) - 1));\
+        break;\
+      case RNE:\
+        if ((result & ((uint64_t)0x3 << ((gb) - 1))) == 0x1){\
+            result -= ((uint64_t)1 << ((gb) - 1));\
+            }else if ((result & ((uint64_t)0x3 << ((gb) - 1))) == 0x3){\
+            result += ((uint64_t)1 << ((gb) - 1));\
+        }\
+        break;\
+      case RDN:\
+        result = (result >> ((gb) - 1)) << ((gb) - 1);\
+        break;\
+      case ROD:\
+        result |= ((uint64_t)1ul << (gb)); \
+        break;\
+      case INVALID_RM:\
+        require(0);\
+    } \
+  } else if (gb == 0 && xrm == ROD) { \
+    result |= 1ul; \
+  }
+
+//
+// vector: integer and masking operand access helper
+//
+#define VXI_PARAMS(x) \
+  int##x##_t *vd; \
+  int##x##_t vs1, vs2; \
+  int##x##_t rs1; \
+  int##x##_t simm5; \
+  vd = vector_elt_int##x##_t(VECTOR, rd_num, i); \
+  rs1 = (int##x##_t)RS1; \
+  simm5 = (int##x##_t)v_simm5(insn); \
+  vs1 = *vector_elt_int##x##_t(VECTOR, rs1_num, i); \
+  vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i);
+
+#define VV_U_PARAMS(x) \
+  uint##x##_t *vd; \
+  uint##x##_t vs1 = *vector_elt_uint##x##_t(VECTOR, rs1_num, i); \
+  uint##x##_t vs2 = *vector_elt_uint##x##_t(VECTOR, rs2_num, i); \
+  vd = vector_elt_uint##x##_t(VECTOR, rd_num, i);
+
+#define VX_U_PARAMS(x) \
+  uint##x##_t *vd; \
+  uint##x##_t rs1 = (uint##x##_t)RS1; \
+  uint##x##_t vs2 = *vector_elt_uint##x##_t(VECTOR, rs2_num, i); \
+  vd = vector_elt_uint##x##_t(VECTOR, rd_num, i);
+
+#define VI_U_PARAMS(x) \
+  uint##x##_t *vd; \
+  uint##x##_t simm5 = (uint##x##_t)v_zimm5(insn); \
+  uint##x##_t vs2 = *vector_elt_uint##x##_t(VECTOR, rs2_num, i); \
+  vd = vector_elt_uint##x##_t(VECTOR, rd_num, i);
+
+#define VV_PARAMS(x) \
+  int##x##_t *vd; \
+  int##x##_t vs1; \
+  int##x##_t vs2; \
+  vs1 = *vector_elt_int##x##_t(VECTOR, rs1_num, i); \
+  vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i); \
+  vd = vector_elt_int##x##_t(VECTOR, rd_num, i);
+
+#define VX_PARAMS(x) \
+  int##x##_t *vd; \
+  int##x##_t rs1 = (int##x##_t)RS1; \
+  int##x##_t vs2; \
+  vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i); \
+  vd = vector_elt_int##x##_t(VECTOR, rd_num, i);
+
+#define VI_PARAMS(x) \
+  int##x##_t *vd; \
+  int##x##_t simm5 = (int##x##_t)v_simm5(insn); \
+  int##x##_t vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i);\
+  vd = vector_elt_int##x##_t(VECTOR, rd_num, i);
+
+#define XV_PARAMS(x) \
+  int##x##_t *vd = vector_elt_int##x##_t(VECTOR, rd_num, i); \
+  uint##x##_t vs2 = *vector_elt_uint##x##_t(VECTOR, rs2_num, RS1);
+
+#define VI_XI_SLIDEDOWN_PARAMS(x, off) \
+  int##x##_t *vd = vector_elt_int##x##_t(VECTOR, rd_num, i); \
+  int##x##_t vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i + off);
+
+#define VI_XI_SLIDEUP_PARAMS(x, offset) \
+  int##x##_t *vd = vector_elt_int##x##_t(VECTOR, rd_num, i); \
+  int##x##_t vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i - offset);
+
+#define VI_NSHIFT_PARAMS(sew1, sew2) \
+  uint##sew1##_t *vd = vector_elt_uint##sew1##_t(VECTOR, rd_num, i); \
+  uint##sew2##_t  vs2_u; \
+  uint##sew2##_t vs2; \
+  uint##sew1##_t zimm5 = (uint##sew1##_t)v_zimm5(insn); \
+  vs2_u = *vector_elt_uint##sew2##_t(VECTOR, rs2_num, i); \
+  vs2 = *vector_elt_int##sew2##_t(VECTOR, rs2_num, i); \
+
+#define VX_NSHIFT_PARAMS(sew1, sew2) \
+  uint##sew1##_t *vd = vector_elt_uint##sew1##_t(VECTOR, rd_num, i); \
+  uint##sew2##_t vs2_u; \
+  uint##sew2##_t vs2; \
+  uint##sew1##_t rs1 = (int##sew1##_t)RS1; \
+  vs2_u = *vector_elt_uint##sew2##_t(VECTOR, rs2_num, i); \
+  vs2 = *vector_elt_int##sew2##_t(VECTOR, rs2_num, i);
+
+#define VV_NSHIFT_PARAMS(sew1, sew2) \
+  uint##sew1##_t *vd = vector_elt_uint##sew1##_t(VECTOR, rd_num, i); \
+  uint##sew2##_t vs2_u; \
+  uint##sew2##_t vs2; \
+  uint##sew1##_t vs1 = *vector_elt_int##sew1##_t(VECTOR, rs1_num, i); \
+  vs2_u = *vector_elt_uint##sew2##_t(VECTOR, rs2_num, i); \
+  vs2 = *vector_elt_int##sew2##_t(VECTOR, rs2_num, i);
+
+#define XI_CARRY_PARAMS(x) \
+  int##x##_t vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i); \
+  int##x##_t rs1; \
+  int##x##_t simm5; \
+  uint64_t *vd = vector_elt_uint64_t(VECTOR, rd_num, midx); \
+  rs1 = (int##x##_t)RS1; \
+  simm5 = (int##x##_t)v_simm5(insn); \
+
+#define VV_CARRY_PARAMS(x) \
+  int##x##_t vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i); \
+  int##x##_t vs1 = *vector_elt_int##x##_t(VECTOR, rs1_num, i); \
+  uint64_t *vd = vector_elt_uint64_t(VECTOR, rd_num, midx);
+
+//
+// vector: integer and masking operation loop
+//
+
+// comparision result to masking register
+#define VI_VV_LOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VV_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VV_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VV_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VV_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+#define VI_VX_LOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VX_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VX_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VX_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VX_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+#define VI_VI_LOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VI_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VI_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VI_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VI_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+#define VI_VV_ULOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VV_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VV_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VV_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VV_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+#define VI_VX_ULOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VX_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VX_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VX_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VX_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+#define VI_VI_ULOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VI_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VI_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VI_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VI_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+// merge and copy loop
+#define VI_VVXI_MERGE_LOOP(BODY) \
+{ \
+  VI_GENERAL_LOOP_BASE \
+  if (sew == e8){ \
+    VXI_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VXI_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VXI_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VXI_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+// reduction loop - signed
+#define VI_LOOP_REDUCTION_BASE(x) \
+  reg_t vl = VECTOR->vl; \
+  reg_t rd_num = rd(insn); \
+  reg_t rs1_num = insn_rs1(insn); \
+  reg_t rs2_num = rs2(insn); \
+  int##x##_t *vd_0_des = vector_elt_int##x##_t(VECTOR, rd_num, 0); \
+  int##x##_t vd_0_res = *vector_elt_int##x##_t(VECTOR, rs1_num, 0); \
+  int##x##_t vs2; \
+  reg_t i; \
+  require(x == e8 || x == e16 || x == e32 || x == e64); \
+  require(!VECTOR->vill);\
+  for (i = VECTOR->vstart; i<vl; ++i){ \
+    VI_LOOP_ELEMENT_SKIP(); \
+    vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i); \
+
+#define REDUCTION_LOOP(x, BODY) \
+  VI_LOOP_REDUCTION_BASE(x) \
+  BODY; \
+  VI_LOOP_REDUCTION_END(x)
+
+#define VI_VV_LOOP_REDUCTION(BODY) \
+  reg_t sew = VECTOR->vsew; \
+  if (sew == e8) { \
+    REDUCTION_LOOP(8, BODY) \
+  } else if(sew == e16) { \
+    REDUCTION_LOOP(16, BODY) \
+  } else if(sew == e32) { \
+    REDUCTION_LOOP(32, BODY) \
+  } else if(sew == e64) { \
+    REDUCTION_LOOP(64, BODY) \
+  }
+
+// reduction loop - unsgied
+#define VI_ULOOP_REDUCTION_BASE(x) \
+  reg_t vl = VECTOR->vl; \
+  reg_t rd_num = rd(insn); \
+  reg_t rs1_num = insn_rs1(insn); \
+  reg_t rs2_num = rs2(insn); \
+  uint##x##_t *vd_0_des = vector_elt_uint##x##_t(VECTOR, rd_num, 0); \
+  uint##x##_t vd_0_res = *vector_elt_uint##x##_t(VECTOR, rs1_num, 0); \
+  uint##x##_t vs2; \
+  reg_t i; \
+  for (i=VECTOR->vstart; i<vl; ++i){ \
+    VI_LOOP_ELEMENT_SKIP(); \
+    vs2 = *vector_elt_uint##x##_t(VECTOR, rs2_num, i);
+
+#define REDUCTION_ULOOP(x, BODY) \
+  VI_ULOOP_REDUCTION_BASE(x) \
+  BODY; \
+  VI_LOOP_REDUCTION_END(x)
+
+#define VI_VV_ULOOP_REDUCTION(BODY) \
+  reg_t sew = VECTOR->vsew; \
+  if (sew == e8){ \
+    REDUCTION_ULOOP(8, BODY) \
+  } else if(sew == e16) { \
+    REDUCTION_ULOOP(16, BODY) \
+  } else if(sew == e32) { \
+    REDUCTION_ULOOP(32, BODY) \
+  } else if(sew == e64) { \
+    REDUCTION_ULOOP(64, BODY) \
+  }
+
+// genearl VXI signed/unsgied loop
+#define VI_VV_ULOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VV_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VV_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VV_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VV_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+#define VI_VV_LOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VV_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VV_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VV_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VV_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+#define VI_VX_ULOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VX_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VX_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VX_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VX_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+#define VI_VX_LOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VX_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VX_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VX_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VX_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+#define VI_VI_ULOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VI_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VI_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VI_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+#define VI_VI_LOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VI_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VI_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VI_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+// narrow operation loop
+#define VI_VV_LOOP_NARROW(BODY) \
+VI_NARROW_CHECK_COMMON; \
+{ \
+VI_LOOP_BASE \
+if (sew == e8){ \
+  VI_NARROW_SHIFT(8, 16) \
+  BODY; \
+}else if(sew == e16){ \
+  VI_NARROW_SHIFT(16, 32) \
+  BODY; \
+}else if(sew == e32){ \
+  VI_NARROW_SHIFT(32, 64) \
+  BODY; \
+} \
+VI_LOOP_END \
+}
+
+#define VI_NARROW_SHIFT(sew1, sew2) \
+  uint##sew1##_t *vd = vector_elt_uint##sew1##_t(VECTOR, rd_num, i); \
+  uint##sew2##_t vs2_u; \
+  uint##sew1##_t zimm5; \
+  int##sew2##_t vs2; \
+  int##sew1##_t vs1; \
+  int##sew1##_t rs1; \
+  rs1 = (int##sew1##_t)RS1; \
+  vs2 = *vector_elt_int##sew2##_t(VECTOR, rs2_num, i); \
+  vs1 = *vector_elt_int##sew1##_t(VECTOR, rs1_num, i); \
+  vs2_u = *vector_elt_uint##sew2##_t(VECTOR, rs2_num, i); \
+  zimm5 = (uint##sew1##_t)v_zimm5(insn);
+
+#define VI_VVXI_LOOP_NARROW(BODY) \
+  require(VECTOR->vsew <= e32); \
+  { \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_NARROW_SHIFT(8, 16) \
+    BODY; \
+  } else if (sew == e16) { \
+    VI_NARROW_SHIFT(16, 32) \
+    BODY; \
+  } else if (sew == e32) { \
+    VI_NARROW_SHIFT(32, 64) \
+    BODY; \
+  } \
+  VI_LOOP_END \
+  }
+
+#define VI_VI_LOOP_NSHIFT(BODY) \
+{ \
+  VI_LOOP_NSHIFT_BASE \
+  if (sew == e8){ \
+    VI_NSHIFT_PARAMS(8, 16) \
+    BODY; \
+  } else if (sew == e16) { \
+    VI_NSHIFT_PARAMS(16, 32) \
+    BODY; \
+  } else if (sew == e32) { \
+    VI_NSHIFT_PARAMS(32, 64) \
+    BODY; \
+  } \
+  VI_LOOP_END \
+  } \
+}
+
+#define VI_VX_LOOP_NSHIFT(BODY) \
+{ \
+  VI_LOOP_NSHIFT_BASE \
+  if (sew == e8){ \
+    VX_NSHIFT_PARAMS(8, 16) \
+    BODY; \
+  } else if (sew == e16) { \
+    VX_NSHIFT_PARAMS(16, 32) \
+    BODY; \
+  } else if (sew == e32) { \
+    VX_NSHIFT_PARAMS(32, 64) \
+    BODY; \
+  } \
+  VI_LOOP_END \
+} \
+}
+
+#define VI_VV_LOOP_NSHIFT(BODY) \
+{ \
+  VI_LOOP_NSHIFT_BASE \
+  if (sew == e8){ \
+    VV_NSHIFT_PARAMS(8, 16) \
+    BODY; \
+  } else if (sew == e16) { \
+    VV_NSHIFT_PARAMS(16, 32) \
+    BODY; \
+  } else if (sew == e32) { \
+    VV_NSHIFT_PARAMS(32, 64) \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}\
+}
+
+// widen operation loop
+#define VI_VV_LOOP_WIDEN(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VV_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VV_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VV_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VV_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_WIDEN_END \
+}
+
+#define VI_VX_LOOP_WIDEN(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VX_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VX_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VX_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VX_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_WIDEN_END \
+}
+
+#define VI_WIDE_OP_AND_ASSIGN(var0, var1, var2, op0, op1, sign) \
+  switch(VECTOR->vsew) { \
+  case e8: { \
+    sign##16_t vd_w; \
+    vd_w = *vector_elt_##sign##16_t(VECTOR, rd_num, i); \
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = \
+      op1((sign##16_t)(sign##8_t)var0 op0 (sign##16_t)(sign##8_t)var1) + var2; \
+    } \
+    break; \
+  case e16: { \
+    sign##32_t vd_w; \
+    vd_w = *vector_elt_##sign##32_t(VECTOR, rd_num, i); \
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = \
+      op1((sign##32_t)(sign##16_t)var0 op0 (sign##32_t)(sign##16_t)var1) + var2; \
+    } \
+    break; \
+  default: { \
+    sign##64_t vd_w; \
+    vd_w = *vector_elt_##sign##64_t(VECTOR, rd_num, i); \
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = \
+      op1((sign##64_t)(sign##32_t)var0 op0 (sign##64_t)(sign##32_t)var1) + var2; \
+    } \
+    break; \
+  }
+
+#define VI_WIDE_OP_AND_ASSIGN_MIX(var0, var1, var2, op0, op1, sign_d, sign_1, sign_2) \
+  switch(VECTOR->vsew) { \
+  case e8: { \
+    sign_d##16_t vd_w = *vector_elt_##sign_d##16_t(VECTOR, rd_num, i); \
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = \
+      op1((sign_1##16_t)(sign_1##8_t)var0 op0 (sign_2##16_t)(sign_2##8_t)var1) + var2; \
+    } \
+    break; \
+  case e16: { \
+    sign_d##32_t vd_w = *vector_elt_##sign_d##32_t(VECTOR, rd_num, i); \
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = \
+      op1((sign_1##32_t)(sign_1##16_t)var0 op0 (sign_2##32_t)(sign_2##16_t)var1) + var2; \
+    } \
+    break; \
+  default: { \
+    sign_d##64_t vd_w = *vector_elt_##sign_d##64_t(VECTOR, rd_num, i); \
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = \
+      op1((sign_1##64_t)(sign_1##32_t)var0 op0 (sign_2##64_t)(sign_2##32_t)var1) + var2; \
+    } \
+    break; \
+  }
+
+#define VI_WIDE_WVX_OP(var0, op0, sign) \
+  switch(VECTOR->vsew) { \
+  case e8: { \
+    sign##16_t *vd_w = vector_elt_##sign##16_t(VECTOR, rd_num, i); \
+    sign##16_t vs2_w = *vector_elt_##sign##16_t(VECTOR, rs2_num, i); \
+    *vd_w = vs2_w op0 (sign##16_t)(sign##8_t)var0; \
+    } \
+    break; \
+  case e16: { \
+    sign##32_t *vd_w = vector_elt_##sign##32_t(VECTOR, rd_num, i); \
+    sign##32_t vs2_w = *vector_elt_##sign##32_t(VECTOR, rs2_num, i); \
+    *vd_w = vs2_w op0 (sign##32_t)(sign##16_t)var0; \
+    } \
+    break; \
+  default: { \
+    sign##64_t *vd_w = vector_elt_##sign##64_t(VECTOR, rd_num, i); \
+    sign##64_t vs2_w = *vector_elt_##sign##64_t(VECTOR, rs2_num, i); \
+    *vd_w = vs2_w op0 (sign##64_t)(sign##32_t)var0; \
+    } \
+    break; \
+  }
+
+#define VI_WIDE_SSMA(sew1, sew2, opd) \
+  int##sew2##_t *vd = vector_elt_int##sew2##_t(VECTOR, rd_num, i); \
+  int##sew1##_t vs1 ; \
+  int##sew1##_t vs2 = *vector_elt_int##sew1##_t(VECTOR, rs2_num, i); \
+  int##sew1##_t rs1; \
+  int##sew2##_t res; \
+  bool sat = false; \
+  const int gb = sew1 / 2; \
+  VRM vrm = VECTOR->vxrm; \
+  rs1 = (int##sew1##_t)RS1; \
+  vs1 = *vector_elt_int##sew1##_t(VECTOR, rs1_num, i); \
+  res = (int##sew2##_t)vs2 * (int##sew2##_t)opd; \
+  INT_ROUNDING(res, vrm, gb); \
+  res = res >> gb; \
+  *vd = sat_add_int##sew2##_t_uint##sew2##_t(*vd, res, &sat); \
+  VECTOR->vxsat |= sat;
+
+#define VI_VVX_LOOP_WIDE_SSMA(opd) \
+  VI_WIDE_CHECK_COMMON \
+  { \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_WIDE_SSMA(8, 16, opd); \
+  } else if(sew == e16){ \
+    VI_WIDE_SSMA(16, 32, opd); \
+  } else if(sew == e32){ \
+    VI_WIDE_SSMA(32, 64, opd); \
+  } \
+  VI_LOOP_WIDEN_END \
+  }
+
+#define VI_WIDE_USSMA(sew1, sew2, opd) \
+  int##sew2##_t *vd = vector_elt_uint##sew2##_t(VECTOR, rd_num, i); \
+  int##sew1##_t vs1; \
+  int##sew1##_t vs2 = *vector_elt_uint##sew1##_t(VECTOR, rs2_num, i); \
+  int##sew1##_t rs1; \
+  uint##sew2##_t res; \
+  bool sat = false; \
+  const int gb = sew1 / 2; \
+  VRM vrm = VECTOR->vxrm; \
+  rs1 = (uint##sew1##_t)RS1; \
+  vs1 = *vector_elt_uint##sew1##_t(VECTOR, rs1_num, i); \
+  res = (uint##sew2##_t)vs2 * (uint##sew2##_t)opd; \
+  INT_ROUNDING(res, vrm, gb); \
+  \
+  res = res >> gb; \
+  *vd = sat_addu_uint##sew2##_t(*vd, res, &sat); \
+  VECTOR->vxsat |= sat;
+
+#define VI_VVX_LOOP_WIDE_USSMA(opd) \
+  VI_WIDE_CHECK_COMMON \
+  { \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_WIDE_USSMA(8, 16, opd); \
+  } else if(sew == e16){ \
+    VI_WIDE_USSMA(16, 32, opd); \
+  } else if(sew == e32){ \
+    VI_WIDE_USSMA(32, 64, opd); \
+  } \
+  VI_LOOP_WIDEN_END \
+  }
+
+#define VI_WIDE_SU_SSMA(sew1, sew2, opd) \
+  int##sew2##_t *vd = vector_elt_int##sew2##_t(VECTOR, rd_num, i); \
+  int##sew1##_t vs1; \
+  uint##sew1##_t vs2 = *vector_elt_uint##sew1##_t(VECTOR, rs2_num, i); \
+  int##sew1##_t rs1; \
+  int##sew2##_t res; \
+  bool sat = false; \
+  const int gb = sew1 / 2; \
+  VRM vrm = VECTOR->vxrm; \
+  rs1 = (int##sew1##_t)RS1; \
+  vs1 = *vector_elt_int##sew1##_t(VECTOR, rs1_num, i); \
+  res = (uint##sew2##_t)vs2 * (int##sew2##_t)opd; \
+  INT_ROUNDING(res, vrm, gb); \
+  \
+  res = res >> gb; \
+  *vd = sat_sub_int##sew2##_t_uint##sew2##_t(*vd, res, &sat); \
+  VECTOR->vxsat |= sat;
+
+#define VI_VVX_LOOP_WIDE_SU_SSMA(opd) \
+  VI_WIDE_CHECK_COMMON \
+  { \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_WIDE_SU_SSMA(8, 16, opd); \
+  } else if(sew == e16){ \
+    VI_WIDE_SU_SSMA(16, 32, opd); \
+  } else if(sew == e32){ \
+    VI_WIDE_SU_SSMA(32, 64, opd); \
+  } \
+  VI_LOOP_WIDEN_END \
+  }
+
+#define VI_WIDE_US_SSMA(sew1, sew2, opd) \
+  int##sew2##_t *vd = vector_elt_int##sew2##_t(VECTOR, rd_num, i); \
+  uint##sew1##_t vs1; \
+  int##sew1##_t vs2 = *vector_elt_int##sew1##_t(VECTOR, rs2_num, i); \
+  uint##sew1##_t rs1; \
+  int##sew2##_t res; \
+  bool sat = false; \
+  const int gb = sew1 / 2; \
+  VRM vrm = VECTOR->vxrm; \
+  rs1 = (uint##sew1##_t)RS1; \
+  vs1 = *vector_elt_uint##sew1##_t(VECTOR, rs1_num, i); \
+  res = (int##sew2##_t)vs2 * (uint##sew2##_t)opd; \
+  INT_ROUNDING(res, vrm, gb); \
+  \
+  res = res >> gb; \
+  *vd = sat_sub_int##sew2##_t_uint##sew2##_t(*vd, res, &sat); \
+  VECTOR->vxsat |= sat;
+
+#define VI_VVX_LOOP_WIDE_US_SSMA(opd) \
+  VI_WIDE_CHECK_COMMON \
+  { \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_WIDE_US_SSMA(8, 16, opd); \
+  } else if(sew == e16){ \
+    VI_WIDE_US_SSMA(16, 32, opd); \
+  } else if(sew == e32){ \
+    VI_WIDE_US_SSMA(32, 64, opd); \
+  } \
+  VI_LOOP_WIDEN_END \
+  }
+
+// wide reduction loop - signed
+#define VI_LOOP_WIDE_REDUCTION_BASE(sew1, sew2) \
+  reg_t vl = VECTOR->vl; \
+  reg_t rd_num = rd(insn); \
+  reg_t rs1_num = insn_rs1(insn); \
+  reg_t rs2_num = rs2(insn); \
+  int##sew1##_t vs2; \
+  int##sew2##_t *vd_0_des = vector_elt_int##sew2##_t(VECTOR, rd_num, 0); \
+  int##sew2##_t vd_0_res = *vector_elt_int##sew2##_t(VECTOR, rs1_num, 0); \
+  reg_t i;\
+  VI_CHECK_DSS(false); \
+  for (i=VECTOR->vstart; i<vl; ++i){ \
+    VI_LOOP_ELEMENT_SKIP(); \
+    vs2 = *vector_elt_int##sew1##_t(VECTOR, rs2_num, i);
+
+#define WIDE_REDUCTION_LOOP(sew1, sew2, BODY) \
+  VI_LOOP_WIDE_REDUCTION_BASE(sew1, sew2) \
+  BODY; \
+  VI_LOOP_REDUCTION_END(sew2)
+
+#define VI_VV_LOOP_WIDE_REDUCTION(BODY) \
+  reg_t sew = VECTOR->vsew; \
+  require(!VECTOR->vill);\
+  if (sew == e8){ \
+    WIDE_REDUCTION_LOOP(8, 16, BODY) \
+  } else if(sew == e16){ \
+    WIDE_REDUCTION_LOOP(16, 32, BODY) \
+  } else if(sew == e32){ \
+    WIDE_REDUCTION_LOOP(32, 64, BODY) \
+  }
+
+// wide reduction loop - unsigned
+#define VI_ULOOP_WIDE_REDUCTION_BASE(sew1, sew2) \
+  reg_t vl = VECTOR->vl; \
+  reg_t rd_num = rd(insn); \
+  reg_t rs1_num = insn_rs1(insn); \
+  reg_t rs2_num = rs2(insn); \
+  uint##sew2##_t *vd_0_des = vector_elt_uint##sew2##_t(VECTOR, rd_num, 0); \
+  uint##sew2##_t vd_0_res = *vector_elt_uint##sew2##_t(VECTOR, rs1_num, 0); \
+  reg_t i;\
+  VI_CHECK_DSS(false); \
+  for (i =VECTOR->vstart; i<vl; ++i) { \
+	uint##sew1##_t vs2; \
+    VI_LOOP_ELEMENT_SKIP(); \
+    vs2 = *vector_elt_uint##sew1##_t(VECTOR, rs2_num, i);
+
+#define WIDE_REDUCTION_ULOOP(sew1, sew2, BODY) \
+  VI_ULOOP_WIDE_REDUCTION_BASE(sew1, sew2) \
+  BODY; \
+  VI_LOOP_REDUCTION_END(sew2)
+
+#define VI_VV_ULOOP_WIDE_REDUCTION(BODY) \
+  reg_t sew = VECTOR->vsew; \
+  require(!VECTOR->vill);\
+  if (sew == e8){ \
+    WIDE_REDUCTION_ULOOP(8, 16, BODY) \
+  } else if(sew == e16){ \
+    WIDE_REDUCTION_ULOOP(16, 32, BODY) \
+  } else if(sew == e32){ \
+    WIDE_REDUCTION_ULOOP(32, 64, BODY) \
+  }
+
+// carry/borrow bit loop
+#define VI_VV_LOOP_CARRY(BODY) \
+  VI_LOOP_BASE \
+    if (sew == e8){ \
+      VV_CARRY_PARAMS(8) \
+      BODY; \
+    } else if (sew == e16) { \
+      VV_CARRY_PARAMS(16) \
+      BODY; \
+    } else if (sew == e32) { \
+      VV_CARRY_PARAMS(32) \
+      BODY; \
+    } else if (sew == e64) { \
+      VV_CARRY_PARAMS(64) \
+      BODY; \
+    } \
+  } \
+  VI_TAIL_ZERO_MASK(rd_num);
+
+#define VI_XI_LOOP_CARRY(BODY) \
+  VI_LOOP_BASE \
+    if (sew == e8){ \
+      XI_CARRY_PARAMS(8) \
+      BODY; \
+    } else if (sew == e16) { \
+      XI_CARRY_PARAMS(16) \
+      BODY; \
+    } else if (sew == e32) { \
+      XI_CARRY_PARAMS(32) \
+      BODY; \
+    } else if (sew == e64) { \
+      XI_CARRY_PARAMS(64) \
+      BODY; \
+    } \
+  } \
+  VI_TAIL_ZERO_MASK(rd_num);
+
+// average loop
+#define VI_VVX_LOOP_AVG(opd, op) \
+{ \
+VRM xrm = VECTOR->vxrm; \
+VI_LOOP_BASE \
+  switch(sew) { \
+    case e8: { \
+        int8_t rs1; \
+        int32_t res; \
+     VV_PARAMS(8); \
+     rs1 = RS1; \
+     res = (int32_t)vs2 op opd; \
+     INT_ROUNDING(res, xrm, 1); \
+     *vd = res >> 1; \
+     break; \
+    } \
+    case e16: { \
+     int16_t rs1; \
+     int32_t res; \
+     VV_PARAMS(16); \
+     rs1 = RS1; \
+     res = (int32_t)vs2 op opd; \
+     INT_ROUNDING(res, xrm, 1); \
+     *vd = res >> 1; \
+     break; \
+    } \
+    case e32: { \
+    int32_t rs1; \
+    int64_t res; \
+     VV_PARAMS(32); \
+     rs1 = RS1; \
+     res = (int64_t)vs2 op opd; \
+     INT_ROUNDING(res, xrm, 1); \
+     *vd = res >> 1; \
+     break; \
+    } \
+    default: { \
+     int64_t rs1; \
+     int128_t res; \
+     VV_PARAMS(64); \
+     rs1 = RS1; \
+     res = (int128_t)vs2 op opd; \
+     INT_ROUNDING(res, xrm, 1); \
+     *vd = res >> 1; \
+     break; \
+    } \
+  } \
+VI_LOOP_END \
+}
+
+//
+// vector: load/store helper 
+//
+#define VI_STRIP(inx) \
+  reg_t elems_per_strip = VECTOR->SLEN / VECTOR->vsew; \
+  reg_t elems_per_vreg = VECTOR->VLEN /VECTOR->vsew; \
+  reg_t elems_per_lane = VECTOR->vlmul * elems_per_strip; \
+  reg_t strip_index = (inx) / elems_per_lane; \
+  reg_t index_in_strip = (inx) % elems_per_strip; \
+  int32_t lmul_inx = (int32_t)(((inx) % elems_per_lane) / elems_per_strip); \
+  reg_t vreg_inx = lmul_inx * elems_per_vreg + strip_index * elems_per_strip + index_in_strip;
+
+
+#define VI_DUPLICATE_VREG(v, vlmax) \
+reg_t index[32]; \
+reg_t i = 0;\
+for (; i < vlmax; ++i) { \
+  switch(VECTOR->vsew) { \
+    case e32: \
+      index[i] = *vector_elt_int32_t(VECTOR, v, i); \
+      break; \
+    case e64: \
+      index[i] = *vector_elt_int64_t(VECTOR, v, i); \
+      break; \
+    default: \
+	  require(0); \
+  } \
+}
+
+#define VI_ST_WITH_I(stride, offset, st_width, elt_byte) \
+  const reg_t nf = v_nf(insn) + 1; \
+  const reg_t vl = VECTOR->vl; \
+  const reg_t baseAddr = RS1; \
+  const reg_t vs3 = rd(insn); \
+  const reg_t vlmax = VECTOR->vlmax; \
+  const reg_t vlmul = VECTOR->vlmul; \
+  i = 0;\
+  require((nf * VECTOR->vlmul) <= (NVPR / 4)); \
+  for (; i < vlmax && vl != 0; ++i) { \
+    bool is_valid = true; \
+    reg_t fn = 0;\
+    VI_STRIP(i) \
+    VI_ELEMENT_SKIP(i); \
+    if (!is_valid) \
+      continue; \
+    for (; fn < nf; ++fn) { \
+      st_width##_t val = 0; \
+      switch (VECTOR->vsew) { \
+      case e8: \
+        val = *vector_elt_uint8_t(VECTOR, vs3 + fn * vlmul, vreg_inx); \
+        break; \
+      case e16: \
+        val = *vector_elt_uint16_t(VECTOR, vs3 + fn * vlmul, vreg_inx); \
+        break; \
+      case e32: \
+        val = *vector_elt_uint32_t(VECTOR, vs3 + fn * vlmul, vreg_inx); \
+        break; \
+      default: \
+        val = *vector_elt_uint64_t(VECTOR, vs3 + fn * vlmul, vreg_inx); \
+        break; \
+      } \
+      store_##st_width(baseAddr + (stride) + (offset) * elt_byte, val); \
+    } \
+  } \
+  VECTOR->vstart = 0; 
+
+#define VI_ST(stride, offset, st_width, elt_byte) \
+  reg_t i; \
+  VI_ST_WITH_I(stride, offset, st_width, elt_byte)
+
+#define VI_LD_WITH_I(stride, offset, ld_width, elt_byte) \
+  const reg_t nf = v_nf(insn) + 1; \
+  const reg_t vl = VECTOR->vl; \
+  const reg_t baseAddr = RS1; \
+  const reg_t vd = rd(insn); \
+  const reg_t vlmax = VECTOR->vlmax; \
+  const reg_t vlmul = VECTOR->vlmul; \
+  i = 0; \
+  require((nf * VECTOR->vlmul) <= (NVPR / 4)); \
+  for (; i < vlmax && vl != 0; ++i) { \
+    bool is_valid = true; \
+    VI_ELEMENT_SKIP(i); \
+    { \
+    reg_t fn = 0; \
+    VI_STRIP(i); \
+    for (; fn < nf; ++fn) { \
+      ld_width##_t val = load_##ld_width(baseAddr + (stride) + (offset) * elt_byte); \
+      if (vd + fn >= NVPR){ \
+         VECTOR->vstart = vreg_inx;\
+         require(false); \
+      } \
+      switch(VECTOR->vsew){ \
+        case e8: \
+          *vector_elt_uint8_t(VECTOR, vd + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+          break; \
+        case e16: \
+          *vector_elt_uint16_t(VECTOR, vd + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+          break; \
+        case e32: \
+          *vector_elt_uint32_t(VECTOR, vd + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+          break; \
+        default: \
+          *vector_elt_uint64_t(VECTOR, vd + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+      } \
+    } \
+    } \
+  } \
+  VECTOR->vstart = 0;
+
+#define VI_LD(stride, offset, ld_width, elt_byte) \
+  reg_t i; \
+  VI_LD_WITH_I(stride, offset, ld_width, elt_byte)
+
+
+#define VI_LDST_FF(itype, tsew) \
+  const reg_t nf = v_nf(insn) + 1; \
+  const reg_t sew = VECTOR->vsew; \
+  const reg_t vl = VECTOR->vl; \
+  const reg_t baseAddr = RS1; \
+  const reg_t rd_num = rd(insn); \
+  bool early_stop = false; \
+  const reg_t vlmax = VECTOR->vlmax; \
+  const reg_t vlmul = VECTOR->vlmul; \
+  reg_t i = 0; \
+  require(VECTOR->vsew >= e##tsew && VECTOR->vsew <= e64); \
+  require((nf * VECTOR->vlmul) <= (NVPR / 4)); \
+  for (; i < vlmax && vl != 0; ++i) { \
+    bool is_valid = true; \
+    VI_STRIP(i); \
+    VI_ELEMENT_SKIP(i); \
+    { \
+    reg_t fn = 0; \
+    for (; fn < nf; ++fn) { \
+      itype##64_t val = load_##itype##tsew(baseAddr + (i * nf + fn) * (tsew / 8)); \
+      \
+      switch (sew) { \
+      case e8: \
+        *vector_elt_uint8_t(VECTOR, rd_num + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+        break; \
+      case e16: \
+        *vector_elt_uint16_t(VECTOR, rd_num + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+        break; \
+      case e32: \
+        *vector_elt_uint32_t(VECTOR, rd_num + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+        break; \
+      case e64: \
+        *vector_elt_uint64_t(VECTOR, rd_num + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+        break; \
+      } \
+       \
+      if (val == 0 && is_valid) { \
+        VECTOR->vl = i; \
+        early_stop = true; \
+        break; \
+      } \
+    } \
+    }\
+    if (early_stop) { \
+      break; \
+    } \
+  } \
+  VECTOR->vstart = 0;
+
+
+//
+// vector: vfp helper
+//
+#define VI_VFP_COMMON \
+  reg_t vl = VECTOR->vl; \
+  reg_t rd_num = rd(insn); \
+  reg_t rs1_num; \
+  reg_t rs2_num; \
+  rs2_num = rs2(insn); \
+  rs1_num = insn_rs1(insn); \
+  softfloat_roundingMode = STATE.frm; \
+  require_fp; \
+  require((VECTOR->vsew == e32 && supports_extension(p, 'F')) || \
+          (VECTOR->vsew == e64 && supports_extension(p, 'D'))); \
+  require(!VECTOR->vill);
+
+#define VI_VFP_LOOP_BASE \
+  VI_VFP_COMMON \
+  { \
+  reg_t i=VECTOR->vstart; \
+  for (; i<vl; ++i){ \
+    VI_LOOP_ELEMENT_SKIP();
+
+#define VI_VFP_LOOP_CMP_BASE \
+  VI_VFP_COMMON \
+  { \
+  reg_t i = VECTOR->vstart; \
+  for (; i < vl; ++i) { \
+	uint64_t mmask, res; \
+	uint64_t *vdi; \
+    float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+    float64_t vs1 = *vector_elt_float64_t(VECTOR, rs1_num, i); \
+    float64_t rs1 = f64_f(READ_FREG(rs1_num)); \
+    VI_LOOP_ELEMENT_SKIP(); \
+    mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+    vdi = vector_elt_uint64_t(VECTOR, rd_num, midx); \
+    res = 0;
+
+#define VI_VFP_LOOP_REDUCTION_BASE \
+  VI_VFP_COMMON \
+  { \
+  float64_t vd_0 = *vector_elt_float64_t(VECTOR, rd_num, 0); \
+  float64_t vs1_0 = *vector_elt_float64_t(VECTOR, rs1_num, 0); \
+  reg_t i = VECTOR->vstart; \
+  vd_0 = vs1_0;\
+  for (; i<vl; ++i){ \
+    VI_LOOP_ELEMENT_SKIP(); \
+
+#define VI_VFP_LOOP_WIDE_REDUCTION_BASE \
+  VI_VFP_COMMON \
+  { \
+  float64_t vd_0 = f64(vector_elt_float64_t(VECTOR, rs1_num, 0)->v); \
+  reg_t i =VECTOR->vstart; \
+  for (; i<vl; ++i) { \
+    VI_LOOP_ELEMENT_SKIP();
+
+#define VI_VFP_LOOP_END \
+  } \
+  } \
+  if (vl != 0 && vl < VECTOR->vlmax && TAIL_ZEROING){ \
+    uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, vl * ((VECTOR->vsew >> 3) * 1)); \
+    memset(tail, 0, (VECTOR->vlmax - vl) * ((VECTOR->vsew >> 3) * 1)); \
+  }\
+  VECTOR->vstart = 0; \
+
+#define VI_VFP_LOOP_WIDE_END \
+  } \
+  } \
+  if (vl != 0 && vl < VECTOR->vlmax && TAIL_ZEROING){ \
+    uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, vl * ((VECTOR->vsew >> 3) * 2)); \
+    memset(tail, 0, (VECTOR->vlmax - vl) * ((VECTOR->vsew >> 3) * 2)); \
+  }\
+  VECTOR->vstart = 0; \
+  set_fp_exceptions;
+
+#define VI_VFP_LOOP_REDUCTION_END(x) \
+  } \
+  VECTOR->vstart = 0; \
+  set_fp_exceptions; \
+  *vector_elt_int##x##_t(VECTOR, rd_num, 0) = vd_0.v; \
+  if (vl > 0 && TAIL_ZEROING) { \
+    for (i = 1; i < (VECTOR->VLEN / x); ++i) { \
+       *vector_elt_int##x##_t(VECTOR, rd_num, i) = 0; \
+    } \
+  } \
+  }
+
+#define VI_VFP_LOOP_CMP_END \
+  switch(VECTOR->vsew) { \
+    case e64: \
+    case e32: { \
+      *vdi = (*vdi & ~mmask) | (((res) << mpos) & mmask); \
+      break; \
+    } \
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+      break; \
+    }; \
+    rs1.v = vs1.v = 0; \
+  } \
+  if (vl != 0 && TAIL_ZEROING){ \
+    for (i=vl; i<VECTOR->vlmax; ++i){ \
+      const int mlen = VECTOR->vmlen; \
+      const int midx = (mlen * i) / 64; \
+      const int mpos = (mlen * i) % 64; \
+      uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+      uint64_t *vdi = vector_elt_uint64_t(VECTOR, rd(insn), midx); \
+      *vdi = (*vdi & ~mmask);\
+    }\
+  }\
+  }\
+  VECTOR->vstart = 0; \
+  set_fp_exceptions;
+
+#define VI_VFP_VV_LOOP(BODY32, BODY64) \
+{ \
+  VI_VFP_LOOP_BASE \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float32_t *vd; \
+      float32_t vs1, vs2; \
+      vs1 = *vector_elt_float32_t(VECTOR, rs1_num, i); \
+      vs2 = *vector_elt_float32_t(VECTOR, rs2_num, i); \
+      vd = vector_elt_float32_t(VECTOR, rd_num, i); \
+      BODY32; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e64: {\
+      float64_t *vd; \
+      float64_t vs1, vs2; \
+      vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+      vs1 = *vector_elt_float64_t(VECTOR, rs1_num, i); \
+      vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      BODY64; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+      break; \
+  }; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_END \
+}
+
+#define VI_VFP_VV_LOOP_REDUCTION(BODY) \
+{ \
+  VI_VFP_LOOP_REDUCTION_BASE \
+  { \
+  float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+  BODY; \
+  DEBUG_RVV_FP_VV; \
+  } \
+  VI_VFP_LOOP_REDUCTION_END(64) \
+}
+
+#define VI_VFP_VV_LOOP_WIDE_REDUCTION(BODY) \
+{ \
+  VI_VFP_LOOP_WIDE_REDUCTION_BASE \
+  { \
+  float64_t vs2 = f32_to_f64(*vector_elt_float32_t(VECTOR, rs2_num, i)); \
+  BODY; \
+  DEBUG_RVV_FP_VV; \
+  } \
+  VI_VFP_LOOP_REDUCTION_END(64) \
+}
+
+#define VI_VFP_VF_LOOP(BODY32, BODY64) \
+{ \
+  VI_VFP_LOOP_BASE \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float32_t *vd = vector_elt_float32_t(VECTOR, rd_num, i); \
+      float32_t rs1 = f32_f(READ_FREG(rs1_num)); \
+      float32_t vs2 = *vector_elt_float32_t(VECTOR, rs2_num, i); \
+      BODY32; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e64: {\
+      float64_t *vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      float64_t rs1 = f64_f(READ_FREG(rs1_num)); \
+      float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+      BODY64; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+      break; \
+  }; \
+  DEBUG_RVV_FP_VF; \
+  VI_VFP_LOOP_END \
+}
+
+#define VI_VFP_LOOP_CMP(BODY) \
+{ \
+  VI_VFP_LOOP_CMP_BASE \
+  BODY; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_CMP_END \
+}
+
+#define VI_VFP_VF_LOOP_WIDE(BODY) \
+{ \
+  VI_VFP_LOOP_BASE \
+  VI_CHECK_DSS(false); \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float64_t *vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      float64_t vs2 = f32_to_f64(*vector_elt_float32_t(VECTOR, rs2_num, i)); \
+      float64_t rs1 = f32_to_f64(f32_f(READ_FREG(rs1_num))); \
+      BODY; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+      break; \
+  }; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_WIDE_END \
+}
+
+#define VI_VFP_VV_LOOP_WIDE(BODY) \
+{ \
+  VI_VFP_LOOP_BASE \
+  VI_CHECK_DSS(true); \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float64_t *vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      float64_t vs2 = f32_to_f64(*vector_elt_float32_t(VECTOR, rs2_num, i)); \
+      float64_t vs1 = f32_to_f64(*vector_elt_float32_t(VECTOR, rs1_num, i)); \
+      BODY; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+      break; \
+  }; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_WIDE_END \
+}
+
+#define VI_VFP_WF_LOOP_WIDE(BODY) \
+{ \
+  VI_VFP_LOOP_BASE \
+  VI_CHECK_DDS(false); \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float64_t *vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+      float64_t rs1 = f32_to_f64(f32_f(READ_FREG(rs1_num))); \
+      BODY; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+  }; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_WIDE_END \
+}
+
+#define VI_VFP_WV_LOOP_WIDE(BODY) \
+{ \
+  VI_VFP_LOOP_BASE \
+  VI_CHECK_DDS(true); \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float64_t *vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+      float64_t vs1 = f32_to_f64(*vector_elt_float32_t(VECTOR, rs1_num, i)); \
+      BODY; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+  }; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_WIDE_END \
+}
+
+#define VI_AMO(op, type) \
+  const reg_t vl = VECTOR->vl; \
+  const reg_t baseAddr = RS1; \
+  const reg_t vd = rd(insn); \
+  require(!VECTOR->vill);\
+  require(rd(insn) + VECTOR->vlmul <= 32); \
+  if (v_vm(insn) == 0) \
+	require(rd(insn) != 0); \
+  require(VECTOR->vsew <= get_xlen() && VECTOR->vsew >= 32 && VECTOR->vsew >= type); \
+  { \
+  VI_DUPLICATE_VREG(rs2(insn), VECTOR->vsew); \
+  for (i = VECTOR->vstart; i < vl; ++i) { \
+    bool is_valid = true; \
+    VI_ELEMENT_SKIP(i); \
+    { \
+    VI_STRIP(i); \
+    switch (VECTOR->vsew) { \
+    case e32: {\
+      int32_t vs3 = *vector_elt_int32_t(VECTOR, vd, vreg_inx); \
+      int32_t lhs = load_int##type(baseAddr + index[i]); \
+      int32_t val; \
+      op\
+      store_int##type(baseAddr + index[i], val); \
+      if (v_wd(insn)) \
+        *vector_elt_int32_t(VECTOR, vd, vreg_inx) = lhs; \
+      } \
+      break; \
+    case e64: {\
+      int64_t vs3 = *vector_elt_int64_t(VECTOR, vd, vreg_inx); \
+      int64_t lhs = load_int##type(baseAddr + index[i]); \
+      int64_t val; \
+      op\
+      store_int##type(baseAddr + index[i], val); \
+      if (v_wd(insn)) \
+        *vector_elt_int64_t(VECTOR, vd, vreg_inx) = lhs; \
+      } \
+      break; \
+    default: \
+      require(0); \
+      break; \
+    } \
+    } \
+  } \
+  } \
+  VECTOR->vstart = 0;
+
+#define DEFINE_INSN(name) \
+   reg_t rv32_##name(processor_t* p, insn_t insn); \
+   reg_t rv64_##name(processor_t* p, insn_t insn); \
+   
+#include "insn_list.h"
+#undef DEFINE_INSN
+// Seems that 0x0 doesn't work.
+#define DEBUG_START             0x100
+#define DEBUG_END               (0x1000 - 1)
+#endif
diff --git a/arch/riscv/kernel/soft_vector/softfloat/Makefile b/arch/riscv/kernel/soft_vector/softfloat/Makefile
new file mode 100755
index 000000000..7166d6f51
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/Makefile
@@ -0,0 +1,227 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the RISC-V Linux kernel
+#
+obj-$(CONFIG_VECTOR_EMU)+= f128_add.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_classify.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_div.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_eq.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_eq_signaling.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_isSignalingNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_le.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_le_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_lt.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_lt_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_mulAdd.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_mul.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_rem.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_roundToInt.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_sqrt.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_sub.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_i32.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_i32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_i64.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_i64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_ui32.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_ui32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_ui64.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_ui64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_add.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_classify.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_div.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_eq.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_eq_signaling.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_isSignalingNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_le.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_le_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_lt.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_lt_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_mulAdd.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_mul.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_rem.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_roundToInt.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_sqrt.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_sub.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i8.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i16.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i32.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i64.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui8.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui16.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui32.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui64.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_add.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_classify.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_div.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_eq.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_eq_signaling.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_isSignalingNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_le.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_le_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_lt.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_lt_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_mulAdd.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_mul.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_rem.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_roundToInt.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_sqrt.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_sub.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_i16.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_i32.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_i32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_i64.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_i64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_ui16.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_ui32.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_ui32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_ui64.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_ui64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_add.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_classify.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_div.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_eq.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_eq_signaling.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_isSignalingNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_le.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_le_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_lt.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_lt_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_mulAdd.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_mul.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_rem.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_roundToInt.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_sqrt.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_sub.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_i32.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_i32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_i64.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_i64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_ui32.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_ui32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_ui64.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_ui64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= fall_maxmin.o
+obj-$(CONFIG_VECTOR_EMU)+= i32_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= i32_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= i32_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= i32_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= i64_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= i64_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= i64_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= i64_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_add128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_add256M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addCarryM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addComplCarryM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addMagsF128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addMagsF16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addMagsF32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addMagsF64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_approxRecip_1Ks.o
+obj-$(CONFIG_VECTOR_EMU)+= s_approxRecip32_1.o
+obj-$(CONFIG_VECTOR_EMU)+= s_approxRecipSqrt_1Ks.o
+obj-$(CONFIG_VECTOR_EMU)+= s_approxRecipSqrt32_1.o
+obj-$(CONFIG_VECTOR_EMU)+= s_commonNaNToF32UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_commonNaNToF64UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_compare128M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_compare96M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_countLeadingZeros16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_countLeadingZeros32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_countLeadingZeros64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_countLeadingZeros8.o
+obj-$(CONFIG_VECTOR_EMU)+= s_eq128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_f32UIToCommonNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= s_f64UIToCommonNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= s_le128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_lt128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul128By32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul128MTo256M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul128To256M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul64ByShifted32To128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul64To128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul64To128M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mulAddF128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mulAddF16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mulAddF32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mulAddF64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_negXM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normRoundPackToF128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normRoundPackToF16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normRoundPackToF32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normRoundPackToF64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normSubnormalF128Sig.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normSubnormalF16Sig.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normSubnormalF32Sig.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normSubnormalF64Sig.o
+obj-$(CONFIG_VECTOR_EMU)+= softfloat_raiseFlags.o
+obj-$(CONFIG_VECTOR_EMU)+= softfloat_state.o
+obj-$(CONFIG_VECTOR_EMU)+= s_propagateNaNF16UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_propagateNaNF32UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_propagateNaNF64UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_propagateNaNF128UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_remStepMBy32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundMToI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundMToUI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackMToI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackMToUI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToF128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToF16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToF32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToF64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToI32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToUI32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToUI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundToI32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundToI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundToUI32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundToUI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam128Extra.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam256M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam64Extra.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftLeft128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftLeft64To96M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRight128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightExtendM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightJam128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightJam128Extra.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightJam64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightJam64Extra.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_sub128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_sub1XM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_sub256M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_subMagsF128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_subMagsF16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_subMagsF32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_subMagsF64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_subM.o
+obj-$(CONFIG_VECTOR_EMU)+= ui32_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= ui32_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= ui32_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= ui32_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= ui64_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= ui64_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= ui64_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= ui64_to_f64.o
+clean:
diff --git a/arch/riscv/kernel/soft_vector/softfloat/config.h b/arch/riscv/kernel/soft_vector/softfloat/config.h
new file mode 100755
index 000000000..f425615d3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/config.h
@@ -0,0 +1,107 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Default value for --isa switch */
+#define DEFAULT_ISA "RV64IMAFDC"
+
+/* Default value for --priv switch */
+#define DEFAULT_PRIV "MSU"
+
+/* Default value for --vector switch */
+#define DEFAULT_VARCH "vlen:128,elen:64,slen:128"
+
+/* Path to the device-tree-compiler */
+#define DTC "dtc"
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+/* #undef DUMMY_ROCC_ENABLED */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `fesvr' library (-lfesvr). */
+/* #undef HAVE_LIBFESVR */
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+#define HAVE_LIBPTHREAD 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "Andrew Waterman"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "RISC-V ISA Simulator"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "RISC-V ISA Simulator ?"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "spike"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "?"
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+#define RISCV_ENABLED /**/
+
+/* Enable commit log generation */
+/* #undef RISCV_ENABLE_COMMITLOG */
+
+/* Enable hardware management of PTE accessed and dirty bits */
+/* #undef RISCV_ENABLE_DIRTY */
+
+/* Enable PC histogram generation */
+/* #undef RISCV_ENABLE_HISTOGRAM */
+
+/* Enable hardware support for misaligned loads and stores */
+/* #undef RISCV_ENABLE_MISALIGNED */
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+#define SOFTFLOAT_ENABLED /**/
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+#define SPIKE_MAIN_ENABLED /**/
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_add.c b/arch/riscv/kernel/soft_vector/softfloat/f128_add.c
new file mode 100755
index 000000000..94cea1343
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_add.c
@@ -0,0 +1,78 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t f128_add( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)
+    float128_t
+        (*magsFuncPtr)(
+            uint_fast64_t, uint_fast64_t, uint_fast64_t, uint_fast64_t, bool );
+#endif
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    signB = signF128UI64( uiB64 );
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+    if ( signA == signB ) {
+        return softfloat_addMagsF128( uiA64, uiA0, uiB64, uiB0, signA );
+    } else {
+        return softfloat_subMagsF128( uiA64, uiA0, uiB64, uiB0, signA );
+    }
+#else
+    magsFuncPtr =
+        (signA == signB) ? softfloat_addMagsF128 : softfloat_subMagsF128;
+    return (*magsFuncPtr)( uiA64, uiA0, uiB64, uiB0, signA );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_classify.c b/arch/riscv/kernel/soft_vector/softfloat/f128_classify.c
new file mode 100755
index 000000000..df2297395
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_classify.c
@@ -0,0 +1,37 @@
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f128_classify( float128_t a )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+
+    uint_fast16_t infOrNaN = expF128UI64( uiA64 ) == 0x7FFF;
+    uint_fast16_t subnormalOrZero = expF128UI64( uiA64 ) == 0;
+    bool sign = signF128UI64( uiA64 );
+    bool fracZero = fracF128UI64( uiA64 ) == 0 && uiA0 == 0;
+    bool isNaN = isNaNF128UI( uiA64, uiA0 );
+    bool isSNaN = softfloat_isSigNaNF128UI( uiA64, uiA0 );
+
+    return
+        (  sign && infOrNaN && fracZero )          << 0 |
+        (  sign && !infOrNaN && !subnormalOrZero ) << 1 |
+        (  sign && subnormalOrZero && !fracZero )  << 2 |
+        (  sign && subnormalOrZero && fracZero )   << 3 |
+        ( !sign && infOrNaN && fracZero )          << 7 |
+        ( !sign && !infOrNaN && !subnormalOrZero ) << 6 |
+        ( !sign && subnormalOrZero && !fracZero )  << 5 |
+        ( !sign && subnormalOrZero && fracZero )   << 4 |
+        ( isNaN &&  isSNaN )                       << 8 |
+        ( isNaN && !isSNaN )                       << 9;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_div.c b/arch/riscv/kernel/soft_vector/softfloat/f128_div.c
new file mode 100755
index 000000000..b95375b9a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_div.c
@@ -0,0 +1,199 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f128_div( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    int_fast32_t expA;
+    struct uint128 sigA;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signB;
+    int_fast32_t expB;
+    struct uint128 sigB;
+    bool signZ;
+    struct exp32_sig128 normExpSig;
+    int_fast32_t expZ;
+    struct uint128 rem;
+    uint_fast32_t recip32;
+    int ix;
+    uint_fast64_t q64;
+    uint_fast32_t q;
+    struct uint128 term;
+    uint_fast32_t qs[3];
+    uint_fast64_t sigZExtra;
+    struct uint128 sigZ, uiZ;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    expA  = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    signB = signF128UI64( uiB64 );
+    expB  = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FFF ) {
+        if ( sigA.v64 | sigA.v0 ) goto propagateNaN;
+        if ( expB == 0x7FFF ) {
+            if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+            goto invalid;
+        }
+        goto infinity;
+    }
+    if ( expB == 0x7FFF ) {
+        if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+        goto zero;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! (sigB.v64 | sigB.v0) ) {
+            if ( ! (expA | sigA.v64 | sigA.v0) ) goto invalid;
+            softfloat_raiseFlags( softfloat_flag_infinite );
+            goto infinity;
+        }
+        normExpSig = softfloat_normSubnormalF128Sig( sigB.v64, sigB.v0 );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! (sigA.v64 | sigA.v0) ) goto zero;
+        normExpSig = softfloat_normSubnormalF128Sig( sigA.v64, sigA.v0 );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA - expB + 0x3FFE;
+    sigA.v64 |= UINT64_C( 0x0001000000000000 );
+    sigB.v64 |= UINT64_C( 0x0001000000000000 );
+    rem = sigA;
+    if ( softfloat_lt128( sigA.v64, sigA.v0, sigB.v64, sigB.v0 ) ) {
+        --expZ;
+        rem = softfloat_add128( sigA.v64, sigA.v0, sigA.v64, sigA.v0 );
+    }
+    recip32 = softfloat_approxRecip32_1( sigB.v64>>17 );
+    ix = 3;
+    for (;;) {
+        q64 = (uint_fast64_t) (uint32_t) (rem.v64>>19) * recip32;
+        q = (q64 + 0x80000000)>>32;
+        --ix;
+        if ( ix < 0 ) break;
+        rem = softfloat_shortShiftLeft128( rem.v64, rem.v0, 29 );
+        term = softfloat_mul128By32( sigB.v64, sigB.v0, q );
+        rem = softfloat_sub128( rem.v64, rem.v0, term.v64, term.v0 );
+        if ( rem.v64 & UINT64_C( 0x8000000000000000 ) ) {
+            --q;
+            rem = softfloat_add128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+        }
+        qs[ix] = q;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ((q + 1) & 7) < 2 ) {
+        rem = softfloat_shortShiftLeft128( rem.v64, rem.v0, 29 );
+        term = softfloat_mul128By32( sigB.v64, sigB.v0, q );
+        rem = softfloat_sub128( rem.v64, rem.v0, term.v64, term.v0 );
+        if ( rem.v64 & UINT64_C( 0x8000000000000000 ) ) {
+            --q;
+            rem = softfloat_add128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+        } else if ( softfloat_le128( sigB.v64, sigB.v0, rem.v64, rem.v0 ) ) {
+            ++q;
+            rem = softfloat_sub128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+        }
+        if ( rem.v64 | rem.v0 ) q |= 1;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sigZExtra = (uint64_t) ((uint_fast64_t) q<<60);
+    term = softfloat_shortShiftLeft128( 0, qs[1], 54 );
+    sigZ =
+        softfloat_add128(
+            (uint_fast64_t) qs[2]<<19, ((uint_fast64_t) qs[0]<<25) + (q>>4),
+            term.v64, term.v0
+        );
+    return
+        softfloat_roundPackToF128( signZ, expZ, sigZ.v64, sigZ.v0, sigZExtra );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infinity:
+    uiZ.v64 = packToF128UI64( signZ, 0x7FFF, 0 );
+    goto uiZ0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ.v64 = packToF128UI64( signZ, 0, 0 );
+ uiZ0:
+    uiZ.v0 = 0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_eq.c b/arch/riscv/kernel/soft_vector/softfloat/f128_eq.c
new file mode 100755
index 000000000..de10a2598
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_eq.c
@@ -0,0 +1,73 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f128_eq( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        if (
+               softfloat_isSigNaNF128UI( uiA64, uiA0 )
+            || softfloat_isSigNaNF128UI( uiB64, uiB0 )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    return
+           (uiA0 == uiB0)
+        && (   (uiA64 == uiB64)
+            || (! uiA0 && ! ((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF )))
+           );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_eq_signaling.c b/arch/riscv/kernel/soft_vector/softfloat/f128_eq_signaling.c
new file mode 100755
index 000000000..fcf661229
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_eq_signaling.c
@@ -0,0 +1,67 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f128_eq_signaling( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    return
+           (uiA0 == uiB0)
+        && (   (uiA64 == uiB64)
+            || (! uiA0 && ! ((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF )))
+           );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_isSignalingNaN.c b/arch/riscv/kernel/soft_vector/softfloat/f128_isSignalingNaN.c
new file mode 100755
index 000000000..bec24c5c2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_isSignalingNaN.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f128_isSignalingNaN( float128_t a )
+{
+    union ui128_f128 uA;
+
+    uA.f = a;
+    return softfloat_isSigNaNF128UI( uA.ui.v64, uA.ui.v0 );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_le.c b/arch/riscv/kernel/soft_vector/softfloat/f128_le.c
new file mode 100755
index 000000000..38ffaf36d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_le.c
@@ -0,0 +1,72 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f128_le( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF128UI64( uiA64 );
+    signB = signF128UI64( uiB64 );
+    return
+        (signA != signB)
+            ? signA
+                  || ! (((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                            | uiA0 | uiB0)
+            : ((uiA64 == uiB64) && (uiA0 == uiB0))
+                  || (signA ^ softfloat_lt128( uiA64, uiA0, uiB64, uiB0 ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_le_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f128_le_quiet.c
new file mode 100755
index 000000000..b2a9048bf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_le_quiet.c
@@ -0,0 +1,78 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f128_le_quiet( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        if (
+               softfloat_isSigNaNF128UI( uiA64, uiA0 )
+            || softfloat_isSigNaNF128UI( uiB64, uiB0 )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF128UI64( uiA64 );
+    signB = signF128UI64( uiB64 );
+    return
+        (signA != signB)
+            ? signA
+                  || ! (((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                            | uiA0 | uiB0)
+            : ((uiA64 == uiB64) && (uiA0 == uiB0))
+                  || (signA ^ softfloat_lt128( uiA64, uiA0, uiB64, uiB0 ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_lt.c b/arch/riscv/kernel/soft_vector/softfloat/f128_lt.c
new file mode 100755
index 000000000..3722db711
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_lt.c
@@ -0,0 +1,72 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f128_lt( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF128UI64( uiA64 );
+    signB = signF128UI64( uiB64 );
+    return
+        (signA != signB)
+            ? signA
+                  && (((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                          | uiA0 | uiB0)
+            : ((uiA64 != uiB64) || (uiA0 != uiB0))
+                  && (signA ^ softfloat_lt128( uiA64, uiA0, uiB64, uiB0 ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_lt_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f128_lt_quiet.c
new file mode 100755
index 000000000..b05431d36
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_lt_quiet.c
@@ -0,0 +1,78 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f128_lt_quiet( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        if (
+               softfloat_isSigNaNF128UI( uiA64, uiA0 )
+            || softfloat_isSigNaNF128UI( uiB64, uiB0 )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF128UI64( uiA64 );
+    signB = signF128UI64( uiB64 );
+    return
+        (signA != signB)
+            ? signA
+                  && (((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                          | uiA0 | uiB0)
+            : ((uiA64 != uiB64) || (uiA0 != uiB0))
+                  && (signA ^ softfloat_lt128( uiA64, uiA0, uiB64, uiB0 ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_mul.c b/arch/riscv/kernel/soft_vector/softfloat/f128_mul.c
new file mode 100755
index 000000000..e5dc189a5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_mul.c
@@ -0,0 +1,163 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f128_mul( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    int_fast32_t expA;
+    struct uint128 sigA;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signB;
+    int_fast32_t expB;
+    struct uint128 sigB;
+    bool signZ;
+    uint_fast64_t magBits;
+    struct exp32_sig128 normExpSig;
+    int_fast32_t expZ;
+    uint64_t sig256Z[4];
+    uint_fast64_t sigZExtra;
+    struct uint128 sigZ;
+    struct uint128_extra sig128Extra;
+    struct uint128 uiZ;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    expA  = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    signB = signF128UI64( uiB64 );
+    expB  = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FFF ) {
+        if (
+            (sigA.v64 | sigA.v0) || ((expB == 0x7FFF) && (sigB.v64 | sigB.v0))
+        ) {
+            goto propagateNaN;
+        }
+        magBits = expB | sigB.v64 | sigB.v0;
+        goto infArg;
+    }
+    if ( expB == 0x7FFF ) {
+        if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+        magBits = expA | sigA.v64 | sigA.v0;
+        goto infArg;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! (sigA.v64 | sigA.v0) ) goto zero;
+        normExpSig = softfloat_normSubnormalF128Sig( sigA.v64, sigA.v0 );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! (sigB.v64 | sigB.v0) ) goto zero;
+        normExpSig = softfloat_normSubnormalF128Sig( sigB.v64, sigB.v0 );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x4000;
+    sigA.v64 |= UINT64_C( 0x0001000000000000 );
+    sigB = softfloat_shortShiftLeft128( sigB.v64, sigB.v0, 16 );
+    softfloat_mul128To256M( sigA.v64, sigA.v0, sigB.v64, sigB.v0, sig256Z );
+    sigZExtra = sig256Z[indexWord( 4, 1 )] | (sig256Z[indexWord( 4, 0 )] != 0);
+    sigZ =
+        softfloat_add128(
+            sig256Z[indexWord( 4, 3 )], sig256Z[indexWord( 4, 2 )],
+            sigA.v64, sigA.v0
+        );
+    if ( UINT64_C( 0x0002000000000000 ) <= sigZ.v64 ) {
+        ++expZ;
+        sig128Extra =
+            softfloat_shortShiftRightJam128Extra(
+                sigZ.v64, sigZ.v0, sigZExtra, 1 );
+        sigZ = sig128Extra.v;
+        sigZExtra = sig128Extra.extra;
+    }
+    return
+        softfloat_roundPackToF128( signZ, expZ, sigZ.v64, sigZ.v0, sigZExtra );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infArg:
+    if ( ! magBits ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        uiZ.v64 = defaultNaNF128UI64;
+        uiZ.v0  = defaultNaNF128UI0;
+        goto uiZ;
+    }
+    uiZ.v64 = packToF128UI64( signZ, 0x7FFF, 0 );
+    goto uiZ0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ.v64 = packToF128UI64( signZ, 0, 0 );
+ uiZ0:
+    uiZ.v0 = 0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_mulAdd.c b/arch/riscv/kernel/soft_vector/softfloat/f128_mulAdd.c
new file mode 100755
index 000000000..d4fd9e0ee
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_mulAdd.c
@@ -0,0 +1,63 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t f128_mulAdd( float128_t a, float128_t b, float128_t c )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    union ui128_f128 uC;
+    uint_fast64_t uiC64, uiC0;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    uC.f = c;
+    uiC64 = uC.ui.v64;
+    uiC0  = uC.ui.v0;
+    return softfloat_mulAddF128( uiA64, uiA0, uiB64, uiB0, uiC64, uiC0, 0 );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_rem.c b/arch/riscv/kernel/soft_vector/softfloat/f128_rem.c
new file mode 100755
index 000000000..eee31096d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_rem.c
@@ -0,0 +1,190 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f128_rem( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    int_fast32_t expA;
+    struct uint128 sigA;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    int_fast32_t expB;
+    struct uint128 sigB;
+    struct exp32_sig128 normExpSig;
+    struct uint128 rem;
+    int_fast32_t expDiff;
+    uint_fast32_t q, recip32;
+    uint_fast64_t q64;
+    struct uint128 term, altRem, meanRem;
+    bool signRem;
+    struct uint128 uiZ;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    expA  = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    expB  = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FFF ) {
+        if (
+            (sigA.v64 | sigA.v0) || ((expB == 0x7FFF) && (sigB.v64 | sigB.v0))
+        ) {
+            goto propagateNaN;
+        }
+        goto invalid;
+    }
+    if ( expB == 0x7FFF ) {
+        if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! (sigB.v64 | sigB.v0) ) goto invalid;
+        normExpSig = softfloat_normSubnormalF128Sig( sigB.v64, sigB.v0 );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! (sigA.v64 | sigA.v0) ) return a;
+        normExpSig = softfloat_normSubnormalF128Sig( sigA.v64, sigA.v0 );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sigA.v64 |= UINT64_C( 0x0001000000000000 );
+    sigB.v64 |= UINT64_C( 0x0001000000000000 );
+    rem = sigA;
+    expDiff = expA - expB;
+    if ( expDiff < 1 ) {
+        if ( expDiff < -1 ) return a;
+        if ( expDiff ) {
+            --expB;
+            sigB = softfloat_add128( sigB.v64, sigB.v0, sigB.v64, sigB.v0 );
+            q = 0;
+        } else {
+            q = softfloat_le128( sigB.v64, sigB.v0, rem.v64, rem.v0 );
+            if ( q ) {
+                rem = softfloat_sub128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+            }
+        }
+    } else {
+        recip32 = softfloat_approxRecip32_1( sigB.v64>>17 );
+        expDiff -= 30;
+        for (;;) {
+            q64 = (uint_fast64_t) (uint32_t) (rem.v64>>19) * recip32;
+            if ( expDiff < 0 ) break;
+            q = (q64 + 0x80000000)>>32;
+            rem = softfloat_shortShiftLeft128( rem.v64, rem.v0, 29 );
+            term = softfloat_mul128By32( sigB.v64, sigB.v0, q );
+            rem = softfloat_sub128( rem.v64, rem.v0, term.v64, term.v0 );
+            if ( rem.v64 & UINT64_C( 0x8000000000000000 ) ) {
+                rem = softfloat_add128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+            }
+            expDiff -= 29;
+        }
+        /*--------------------------------------------------------------------
+        | (`expDiff' cannot be less than -29 here.)
+        *--------------------------------------------------------------------*/
+        q = (uint32_t) (q64>>32)>>(~expDiff & 31);
+        rem = softfloat_shortShiftLeft128( rem.v64, rem.v0, expDiff + 30 );
+        term = softfloat_mul128By32( sigB.v64, sigB.v0, q );
+        rem = softfloat_sub128( rem.v64, rem.v0, term.v64, term.v0 );
+        if ( rem.v64 & UINT64_C( 0x8000000000000000 ) ) {
+            altRem = softfloat_add128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+            goto selectRem;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    do {
+        altRem = rem;
+        ++q;
+        rem = softfloat_sub128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+    } while ( ! (rem.v64 & UINT64_C( 0x8000000000000000 )) );
+ selectRem:
+    meanRem = softfloat_add128( rem.v64, rem.v0, altRem.v64, altRem.v0 );
+    if (
+        (meanRem.v64 & UINT64_C( 0x8000000000000000 ))
+            || (! (meanRem.v64 | meanRem.v0) && (q & 1))
+    ) {
+        rem = altRem;
+    }
+    signRem = signA;
+    if ( rem.v64 & UINT64_C( 0x8000000000000000 ) ) {
+        signRem = ! signRem;
+        rem = softfloat_sub128( 0, 0, rem.v64, rem.v0 );
+    }
+    return softfloat_normRoundPackToF128( signRem, expB - 1, rem.v64, rem.v0 );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_roundToInt.c b/arch/riscv/kernel/soft_vector/softfloat/f128_roundToInt.c
new file mode 100755
index 000000000..88330b609
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_roundToInt.c
@@ -0,0 +1,160 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t
+ f128_roundToInt( float128_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    int_fast32_t exp;
+    struct uint128 uiZ;
+    uint_fast64_t lastBitMask, roundBitsMask;
+    bool roundNearEven;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    exp = expF128UI64( uiA64 );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x402F <= exp ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( 0x406F <= exp ) {
+            if ( (exp == 0x7FFF) && (fracF128UI64( uiA64 ) | uiA0) ) {
+                uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, 0, 0 );
+                goto uiZ;
+            }
+            return a;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        lastBitMask = (uint_fast64_t) 2<<(0x406E - exp);
+        roundBitsMask = lastBitMask - 1;
+        uiZ.v64 = uiA64;
+        uiZ.v0  = uiA0;
+        roundNearEven = (roundingMode == softfloat_round_near_even);
+        if ( roundNearEven || (roundingMode == softfloat_round_near_maxMag) ) {
+            if ( exp == 0x402F ) {
+                if ( UINT64_C( 0x8000000000000000 ) <= uiZ.v0 ) {
+                    ++uiZ.v64;
+                    if (
+                        roundNearEven
+                            && (uiZ.v0 == UINT64_C( 0x8000000000000000 ))
+                    ) {
+                        uiZ.v64 &= ~1;
+                    }
+                }
+            } else {
+                uiZ = softfloat_add128( uiZ.v64, uiZ.v0, 0, lastBitMask>>1 );
+                if ( roundNearEven && ! (uiZ.v0 & roundBitsMask) ) {
+                    uiZ.v0 &= ~lastBitMask;
+                }
+            }
+        } else if (
+            roundingMode
+                == (signF128UI64( uiZ.v64 ) ? softfloat_round_min
+                        : softfloat_round_max)
+        ) {
+            uiZ = softfloat_add128( uiZ.v64, uiZ.v0, 0, roundBitsMask );
+        }
+        uiZ.v0 &= ~roundBitsMask;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( exp < 0x3FFF ) {
+            if ( ! ((uiA64 & UINT64_C( 0x7FFFFFFFFFFFFFFF )) | uiA0) ) {
+                return a;
+            }
+            if ( exact ) softfloat_exceptionFlags |= softfloat_flag_inexact;
+            uiZ.v64 = uiA64 & packToF128UI64( 1, 0, 0 );
+            uiZ.v0  = 0;
+            switch ( roundingMode ) {
+             case softfloat_round_near_even:
+                if ( ! (fracF128UI64( uiA64 ) | uiA0) ) break;
+             case softfloat_round_near_maxMag:
+                if ( exp == 0x3FFE ) uiZ.v64 |= packToF128UI64( 0, 0x3FFF, 0 );
+                break;
+             case softfloat_round_min:
+                if ( uiZ.v64 ) uiZ.v64 = packToF128UI64( 1, 0x3FFF, 0 );
+                break;
+             case softfloat_round_max:
+                if ( ! uiZ.v64 ) uiZ.v64 = packToF128UI64( 0, 0x3FFF, 0 );
+                break;
+            }
+            goto uiZ;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        uiZ.v64 = uiA64;
+        uiZ.v0  = 0;
+        lastBitMask = (uint_fast64_t) 1<<(0x402F - exp);
+        roundBitsMask = lastBitMask - 1;
+        if ( roundingMode == softfloat_round_near_maxMag ) {
+            uiZ.v64 += lastBitMask>>1;
+        } else if ( roundingMode == softfloat_round_near_even ) {
+            uiZ.v64 += lastBitMask>>1;
+            if ( ! ((uiZ.v64 & roundBitsMask) | uiA0) ) {
+                uiZ.v64 &= ~lastBitMask;
+            }
+        } else if (
+            roundingMode
+                == (signF128UI64( uiZ.v64 ) ? softfloat_round_min
+                        : softfloat_round_max)
+        ) {
+            uiZ.v64 = (uiZ.v64 | (uiA0 != 0)) + roundBitsMask;
+        }
+        uiZ.v64 &= ~roundBitsMask;
+    }
+    if ( exact && ((uiZ.v64 != uiA64) || (uiZ.v0 != uiA0)) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_sqrt.c b/arch/riscv/kernel/soft_vector/softfloat/f128_sqrt.c
new file mode 100755
index 000000000..20094106a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_sqrt.c
@@ -0,0 +1,201 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f128_sqrt( float128_t a )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    int_fast32_t expA;
+    struct uint128 sigA, uiZ;
+    struct exp32_sig128 normExpSig;
+    int_fast32_t expZ;
+    uint_fast32_t sig32A, recipSqrt32, sig32Z;
+    struct uint128 rem;
+    uint32_t qs[3];
+    uint_fast32_t q;
+    uint_fast64_t x64, sig64Z;
+    struct uint128 y, term;
+    uint_fast64_t sigZExtra;
+    struct uint128 sigZ;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    expA  = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FFF ) {
+        if ( sigA.v64 | sigA.v0 ) {
+            uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, 0, 0 );
+            goto uiZ;
+        }
+        if ( ! signA ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signA ) {
+        if ( ! (expA | sigA.v64 | sigA.v0) ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! (sigA.v64 | sigA.v0) ) return a;
+        normExpSig = softfloat_normSubnormalF128Sig( sigA.v64, sigA.v0 );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    | (`sig32Z' is guaranteed to be a lower bound on the square root of
+    | `sig32A', which makes `sig32Z' also a lower bound on the square root of
+    | `sigA'.)
+    *------------------------------------------------------------------------*/
+    expZ = ((expA - 0x3FFF)>>1) + 0x3FFE;
+    expA &= 1;
+    sigA.v64 |= UINT64_C( 0x0001000000000000 );
+    sig32A = sigA.v64>>17;
+    recipSqrt32 = softfloat_approxRecipSqrt32_1( expA, sig32A );
+    sig32Z = ((uint_fast64_t) sig32A * recipSqrt32)>>32;
+    if ( expA ) {
+        sig32Z >>= 1;
+        rem = softfloat_shortShiftLeft128( sigA.v64, sigA.v0, 12 );
+    } else {
+        rem = softfloat_shortShiftLeft128( sigA.v64, sigA.v0, 13 );
+    }
+    qs[2] = sig32Z;
+    rem.v64 -= (uint_fast64_t) sig32Z * sig32Z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    q = ((uint32_t) (rem.v64>>2) * (uint_fast64_t) recipSqrt32)>>32;
+    x64 = (uint_fast64_t) sig32Z<<32;
+    sig64Z = x64 + ((uint_fast64_t) q<<3);
+    y = softfloat_shortShiftLeft128( rem.v64, rem.v0, 29 );
+    /*------------------------------------------------------------------------
+    | (Repeating this loop is a rare occurrence.)
+    *------------------------------------------------------------------------*/
+    for (;;) {
+        term = softfloat_mul64ByShifted32To128( x64 + sig64Z, q );
+        rem = softfloat_sub128( y.v64, y.v0, term.v64, term.v0 );
+        if ( ! (rem.v64 & UINT64_C( 0x8000000000000000 )) ) break;
+        --q;
+        sig64Z -= 1<<3;
+    }
+    qs[1] = q;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    q = ((rem.v64>>2) * recipSqrt32)>>32;
+    y = softfloat_shortShiftLeft128( rem.v64, rem.v0, 29 );
+    sig64Z <<= 1;
+    /*------------------------------------------------------------------------
+    | (Repeating this loop is a rare occurrence.)
+    *------------------------------------------------------------------------*/
+    for (;;) {
+        term = softfloat_shortShiftLeft128( 0, sig64Z, 32 );
+        term = softfloat_add128( term.v64, term.v0, 0, (uint_fast64_t) q<<6 );
+        term = softfloat_mul128By32( term.v64, term.v0, q );
+        rem = softfloat_sub128( y.v64, y.v0, term.v64, term.v0 );
+        if ( ! (rem.v64 & UINT64_C( 0x8000000000000000 )) ) break;
+        --q;
+    }
+    qs[0] = q;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    q = (((rem.v64>>2) * recipSqrt32)>>32) + 2;
+    sigZExtra = (uint64_t) ((uint_fast64_t) q<<59);
+    term = softfloat_shortShiftLeft128( 0, qs[1], 53 );
+    sigZ =
+        softfloat_add128(
+            (uint_fast64_t) qs[2]<<18, ((uint_fast64_t) qs[0]<<24) + (q>>5),
+            term.v64, term.v0
+        );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( (q & 0xF) <= 2 ) {
+        q &= ~3;
+        sigZExtra = (uint64_t) ((uint_fast64_t) q<<59);
+        y = softfloat_shortShiftLeft128( sigZ.v64, sigZ.v0, 6 );
+        y.v0 |= sigZExtra>>58;
+        term = softfloat_sub128( y.v64, y.v0, 0, q );
+        y    = softfloat_mul64ByShifted32To128( term.v0,  q );
+        term = softfloat_mul64ByShifted32To128( term.v64, q );
+        term = softfloat_add128( term.v64, term.v0, 0, y.v64 );
+        rem = softfloat_shortShiftLeft128( rem.v64, rem.v0, 20 );
+        term = softfloat_sub128( term.v64, term.v0, rem.v64, rem.v0 );
+        /*--------------------------------------------------------------------
+        | The concatenation of `term' and `y.v0' is now the negative remainder
+        | (3 words altogether).
+        *--------------------------------------------------------------------*/
+        if ( term.v64 & UINT64_C( 0x8000000000000000 ) ) {
+            sigZExtra |= 1;
+        } else {
+            if ( term.v64 | term.v0 | y.v0 ) {
+                if ( sigZExtra ) {
+                    --sigZExtra;
+                } else {
+                    sigZ = softfloat_sub128( sigZ.v64, sigZ.v0, 0, 1 );
+                    sigZExtra = ~0;
+                }
+            }
+        }
+    }
+    return softfloat_roundPackToF128( 0, expZ, sigZ.v64, sigZ.v0, sigZExtra );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_sub.c b/arch/riscv/kernel/soft_vector/softfloat/f128_sub.c
new file mode 100755
index 000000000..da433b24d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_sub.c
@@ -0,0 +1,78 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t f128_sub( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)
+    float128_t
+        (*magsFuncPtr)(
+            uint_fast64_t, uint_fast64_t, uint_fast64_t, uint_fast64_t, bool );
+#endif
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    signB = signF128UI64( uiB64 );
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+    if ( signA == signB ) {
+        return softfloat_subMagsF128( uiA64, uiA0, uiB64, uiB0, signA );
+    } else {
+        return softfloat_addMagsF128( uiA64, uiA0, uiB64, uiB0, signA );
+    }
+#else
+    magsFuncPtr =
+        (signA == signB) ? softfloat_subMagsF128 : softfloat_addMagsF128;
+    return (*magsFuncPtr)( uiA64, uiA0, uiB64, uiB0, signA );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f16.c
new file mode 100755
index 000000000..cfcc646f7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f16.c
@@ -0,0 +1,95 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f128_to_f16( float128_t a )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t frac64;
+    struct commonNaN commonNaN;
+    uint_fast16_t uiZ, frac16;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    frac64 = fracF128UI64( uiA64 ) | (uiA0 != 0);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FFF ) {
+        if ( frac64 ) {
+            softfloat_f128UIToCommonNaN( uiA64, uiA0, &commonNaN );
+            uiZ = softfloat_commonNaNToF16UI( &commonNaN );
+        } else {
+            uiZ = packToF16UI( sign, 0x1F, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac16 = softfloat_shortShiftRightJam64( frac64, 34 );
+    if ( ! (exp | frac16) ) {
+        uiZ = packToF16UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    exp -= 0x3FF1;
+    if ( sizeof (int_fast16_t) < sizeof (int_fast32_t) ) {
+        if ( exp < -0x40 ) exp = -0x40;
+    }
+    return softfloat_roundPackToF16( sign, exp, frac16 | 0x4000 );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f32.c
new file mode 100755
index 000000000..58aaada58
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f32.c
@@ -0,0 +1,95 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f128_to_f32( float128_t a )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t frac64;
+    struct commonNaN commonNaN;
+    uint_fast32_t uiZ, frac32;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    frac64 = fracF128UI64( uiA64 ) | (uiA0 != 0);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FFF ) {
+        if ( frac64 ) {
+            softfloat_f128UIToCommonNaN( uiA64, uiA0, &commonNaN );
+            uiZ = softfloat_commonNaNToF32UI( &commonNaN );
+        } else {
+            uiZ = packToF32UI( sign, 0xFF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac32 = softfloat_shortShiftRightJam64( frac64, 18 );
+    if ( ! (exp | frac32) ) {
+        uiZ = packToF32UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    exp -= 0x3F81;
+    if ( sizeof (int_fast16_t) < sizeof (int_fast32_t) ) {
+        if ( exp < -0x1000 ) exp = -0x1000;
+    }
+    return softfloat_roundPackToF32( sign, exp, frac32 | 0x40000000 );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f64.c
new file mode 100755
index 000000000..c6ad8f2e8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f64.c
@@ -0,0 +1,100 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f128_to_f64( float128_t a )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t frac64, frac0;
+    struct commonNaN commonNaN;
+    uint_fast64_t uiZ;
+    struct uint128 frac128;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    frac64 = fracF128UI64( uiA64 );
+    frac0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FFF ) {
+        if ( frac64 | frac0 ) {
+            softfloat_f128UIToCommonNaN( uiA64, uiA0, &commonNaN );
+            uiZ = softfloat_commonNaNToF64UI( &commonNaN );
+        } else {
+            uiZ = packToF64UI( sign, 0x7FF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac128 = softfloat_shortShiftLeft128( frac64, frac0, 14 );
+    frac64 = frac128.v64 | (frac128.v0 != 0);
+    if ( ! (exp | frac64) ) {
+        uiZ = packToF64UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    exp -= 0x3C01;
+    if ( sizeof (int_fast16_t) < sizeof (int_fast32_t) ) {
+        if ( exp < -0x1000 ) exp = -0x1000;
+    }
+    return
+        softfloat_roundPackToF64(
+            sign, exp, frac64 | UINT64_C( 0x4000000000000000 ) );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32.c
new file mode 100755
index 000000000..3f0a8a3fc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32.c
@@ -0,0 +1,85 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f128_to_i32( float128_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64, sig0;
+    int_fast32_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 );
+    sig0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (i32_fromNaN != i32_fromPosOverflow) || (i32_fromNaN != i32_fromNegOverflow)
+    if ( (exp == 0x7FFF) && (sig64 | sig0) ) {
+#if (i32_fromNaN == i32_fromPosOverflow)
+        sign = 0;
+#elif (i32_fromNaN == i32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return i32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig64 |= UINT64_C( 0x0001000000000000 );
+    sig64 |= (sig0 != 0);
+    shiftDist = 0x4023 - exp;
+    if ( 0 < shiftDist ) sig64 = softfloat_shiftRightJam64( sig64, shiftDist );
+    return softfloat_roundToI32( sign, sig64, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32_r_minMag.c
new file mode 100755
index 000000000..17334331c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32_r_minMag.c
@@ -0,0 +1,100 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f128_to_i32_r_minMag( float128_t a, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    int_fast32_t exp;
+    uint_fast64_t sig64;
+    int_fast32_t shiftDist;
+    bool sign;
+    int_fast32_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 ) | (uiA0 != 0);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( 49 <= shiftDist ) {
+        if ( exact && (exp | sig64) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF128UI64( uiA64 );
+    if ( shiftDist < 18 ) {
+        if (
+            sign && (shiftDist == 17)
+                && (sig64 < UINT64_C( 0x0000000000020000 ))
+        ) {
+            if ( exact && sig64 ) {
+                softfloat_exceptionFlags |= softfloat_flag_inexact;
+            }
+            return -0x7FFFFFFF - 1;
+        }
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x7FFF) && sig64 ? i32_fromNaN
+                : sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig64 |= UINT64_C( 0x0001000000000000 );
+    absZ = sig64>>shiftDist;
+    if (
+        exact && ((uint_fast64_t) (uint_fast32_t) absZ<<shiftDist != sig64)
+    ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64.c
new file mode 100755
index 000000000..dc2115100
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64.c
@@ -0,0 +1,95 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f128_to_i64( float128_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64, sig0;
+    int_fast32_t shiftDist;
+    struct uint128 sig128;
+    struct uint64_extra sigExtra;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 );
+    sig0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( shiftDist <= 0 ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( shiftDist < -15 ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            return
+                (exp == 0x7FFF) && (sig64 | sig0) ? i64_fromNaN
+                    : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        if ( shiftDist ) {
+            sig128 = softfloat_shortShiftLeft128( sig64, sig0, -shiftDist );
+            sig64 = sig128.v64;
+            sig0  = sig128.v0;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( exp ) sig64 |= UINT64_C( 0x0001000000000000 );
+        sigExtra = softfloat_shiftRightJam64Extra( sig64, sig0, shiftDist );
+        sig64 = sigExtra.v;
+        sig0  = sigExtra.extra;
+    }
+    return softfloat_roundToI64( sign, sig64, sig0, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64_r_minMag.c
new file mode 100755
index 000000000..42313a3fb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64_r_minMag.c
@@ -0,0 +1,113 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f128_to_i64_r_minMag( float128_t a, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64, sig0;
+    int_fast32_t shiftDist;
+    int_fast8_t negShiftDist;
+    int_fast64_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 );
+    sig0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( shiftDist < 0 ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( shiftDist < -14 ) {
+            if (
+                   (uiA64 == UINT64_C( 0xC03E000000000000 ))
+                && (sig0 < UINT64_C( 0x0002000000000000 ))
+            ) {
+                if ( exact && sig0 ) {
+                    softfloat_exceptionFlags |= softfloat_flag_inexact;
+                }
+                return -INT64_C( 0x7FFFFFFFFFFFFFFF ) - 1;
+            }
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            return
+                (exp == 0x7FFF) && (sig64 | sig0) ? i64_fromNaN
+                    : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        negShiftDist = -shiftDist;
+        absZ = sig64<<negShiftDist | sig0>>(shiftDist & 63);
+        if ( exact && (uint64_t) (sig0<<negShiftDist) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( 49 <= shiftDist ) {
+            if ( exact && (exp | sig64 | sig0) ) {
+                softfloat_exceptionFlags |= softfloat_flag_inexact;
+            }
+            return 0;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        absZ = sig64>>shiftDist;
+        if ( exact && (sig0 || (absZ<<shiftDist != sig64)) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32.c
new file mode 100755
index 000000000..463d87288
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32.c
@@ -0,0 +1,86 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t
+ f128_to_ui32( float128_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64;
+    int_fast32_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 ) | (uiA0 != 0);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (ui32_fromNaN != ui32_fromPosOverflow) || (ui32_fromNaN != ui32_fromNegOverflow)
+    if ( (exp == 0x7FFF) && sig64 ) {
+#if (ui32_fromNaN == ui32_fromPosOverflow)
+        sign = 0;
+#elif (ui32_fromNaN == ui32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return ui32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig64 |= UINT64_C( 0x0001000000000000 );
+    shiftDist = 0x4023 - exp;
+    if ( 0 < shiftDist ) {
+        sig64 = softfloat_shiftRightJam64( sig64, shiftDist );
+    }
+    return softfloat_roundToUI32( sign, sig64, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32_r_minMag.c
new file mode 100755
index 000000000..3e4c4c8c3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32_r_minMag.c
@@ -0,0 +1,89 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f128_to_ui32_r_minMag( float128_t a, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    int_fast32_t exp;
+    uint_fast64_t sig64;
+    int_fast32_t shiftDist;
+    bool sign;
+    uint_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 ) | (uiA0 != 0);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( 49 <= shiftDist ) {
+        if ( exact && (exp | sig64) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF128UI64( uiA64 );
+    if ( sign || (shiftDist < 17) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x7FFF) && sig64 ? ui32_fromNaN
+                : sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig64 |= UINT64_C( 0x0001000000000000 );
+    z = sig64>>shiftDist;
+    if ( exact && ((uint_fast64_t) z<<shiftDist != sig64) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64.c
new file mode 100755
index 000000000..53d5ef2c9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t
+ f128_to_ui64( float128_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64, sig0;
+    int_fast32_t shiftDist;
+    struct uint128 sig128;
+    struct uint64_extra sigExtra;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 );
+    sig0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( shiftDist <= 0 ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( shiftDist < -15 ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            return
+                (exp == 0x7FFF) && (sig64 | sig0) ? ui64_fromNaN
+                    : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        if ( shiftDist ) {
+            sig128 = softfloat_shortShiftLeft128( sig64, sig0, -shiftDist );
+            sig64 = sig128.v64;
+            sig0  = sig128.v0;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( exp ) sig64 |= UINT64_C( 0x0001000000000000 );
+        sigExtra = softfloat_shiftRightJam64Extra( sig64, sig0, shiftDist );
+        sig64 = sigExtra.v;
+        sig0  = sigExtra.extra;
+    }
+    return softfloat_roundToUI64( sign, sig64, sig0, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64_r_minMag.c
new file mode 100755
index 000000000..fb478012c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64_r_minMag.c
@@ -0,0 +1,105 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f128_to_ui64_r_minMag( float128_t a, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64, sig0;
+    int_fast32_t shiftDist;
+    int_fast8_t negShiftDist;
+    uint_fast64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 );
+    sig0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( shiftDist < 0 ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( sign || (shiftDist < -15) ) goto invalid;
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        negShiftDist = -shiftDist;
+        z = sig64<<negShiftDist | sig0>>(shiftDist & 63);
+        if ( exact && (uint64_t) (sig0<<negShiftDist) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( 49 <= shiftDist ) {
+            if ( exact && (exp | sig64 | sig0) ) {
+                softfloat_exceptionFlags |= softfloat_flag_inexact;
+            }
+            return 0;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( sign ) goto invalid;
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        z = sig64>>shiftDist;
+        if ( exact && (sig0 || (z<<shiftDist != sig64)) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return
+        (exp == 0x7FFF) && (sig64 | sig0) ? ui64_fromNaN
+            : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_add.c b/arch/riscv/kernel/soft_vector/softfloat/f16_add.c
new file mode 100755
index 000000000..c89b55ffd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_add.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t f16_add( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 1)
+    float16_t (*magsFuncPtr)( uint_fast16_t, uint_fast16_t );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+#if defined INLINE_LEVEL && (1 <= INLINE_LEVEL)
+    if ( signF16UI( uiA ^ uiB ) ) {
+        return softfloat_subMagsF16( uiA, uiB );
+    } else {
+        return softfloat_addMagsF16( uiA, uiB );
+    }
+#else
+    magsFuncPtr =
+        signF16UI( uiA ^ uiB ) ? softfloat_subMagsF16 : softfloat_addMagsF16;
+    return (*magsFuncPtr)( uiA, uiB );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_classify.c b/arch/riscv/kernel/soft_vector/softfloat/f16_classify.c
new file mode 100755
index 000000000..4a1191679
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_classify.c
@@ -0,0 +1,36 @@
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f16_classify( float16_t a )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+
+    uA.f = a;
+    uiA = uA.ui;
+
+    uint_fast16_t infOrNaN = expF16UI( uiA ) == 0x1F;
+    uint_fast16_t subnormalOrZero = expF16UI( uiA ) == 0;
+    bool sign = signF16UI( uiA );
+    bool fracZero = fracF16UI( uiA ) == 0;
+    bool isNaN = isNaNF16UI( uiA );
+    bool isSNaN = softfloat_isSigNaNF16UI( uiA );
+
+    return
+        (  sign && infOrNaN && fracZero )          << 0 |
+        (  sign && !infOrNaN && !subnormalOrZero ) << 1 |
+        (  sign && subnormalOrZero && !fracZero )  << 2 |
+        (  sign && subnormalOrZero && fracZero )   << 3 |
+        ( !sign && infOrNaN && fracZero )          << 7 |
+        ( !sign && !infOrNaN && !subnormalOrZero ) << 6 |
+        ( !sign && subnormalOrZero && !fracZero )  << 5 |
+        ( !sign && subnormalOrZero && fracZero )   << 4 |
+        ( isNaN &&  isSNaN )                       << 8 |
+        ( isNaN && !isSNaN )                       << 9;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_div.c b/arch/riscv/kernel/soft_vector/softfloat/f16_div.c
new file mode 100755
index 000000000..9c5d33b28
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_div.c
@@ -0,0 +1,186 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+extern const uint16_t softfloat_approxRecip_1k0s[];
+extern const uint16_t softfloat_approxRecip_1k1s[];
+
+float16_t f16_div( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool signA;
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signB;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    bool signZ;
+    struct exp8_sig16 normExpSig;
+    int_fast8_t expZ;
+#ifdef SOFTFLOAT_FAST_DIV32TO16
+    uint_fast32_t sig32A;
+    uint_fast16_t sigZ;
+#else
+    int index;
+    uint16_t r0;
+    uint_fast16_t sigZ, rem;
+#endif
+    uint_fast16_t uiZ;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF16UI( uiA );
+    expA  = expF16UI( uiA );
+    sigA  = fracF16UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF16UI( uiB );
+    expB  = expF16UI( uiB );
+    sigB  = fracF16UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x1F ) {
+        if ( sigA ) goto propagateNaN;
+        if ( expB == 0x1F ) {
+            if ( sigB ) goto propagateNaN;
+            goto invalid;
+        }
+        goto infinity;
+    }
+    if ( expB == 0x1F ) {
+        if ( sigB ) goto propagateNaN;
+        goto zero;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) {
+            if ( ! (expA | sigA) ) goto invalid;
+            softfloat_raiseFlags( softfloat_flag_infinite );
+            goto infinity;
+        }
+        normExpSig = softfloat_normSubnormalF16Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF16Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA - expB + 0xE;
+    sigA |= 0x0400;
+    sigB |= 0x0400;
+#ifdef SOFTFLOAT_FAST_DIV32TO16
+    if ( sigA < sigB ) {
+        --expZ;
+        sig32A = (uint_fast32_t) sigA<<15;
+    } else {
+        sig32A = (uint_fast32_t) sigA<<14;
+    }
+    sigZ = sig32A / sigB;
+    if ( ! (sigZ & 7) ) sigZ |= ((uint_fast32_t) sigB * sigZ != sig32A);
+#else
+    if ( sigA < sigB ) {
+        --expZ;
+        sigA <<= 5;
+    } else {
+        sigA <<= 4;
+    }
+    index = sigB>>6 & 0xF;
+    r0 = softfloat_approxRecip_1k0s[index]
+             - (((uint_fast32_t) softfloat_approxRecip_1k1s[index]
+                     * (sigB & 0x3F))
+                    >>10);
+    sigZ = ((uint_fast32_t) sigA * r0)>>16;
+    rem = (sigA<<10) - sigZ * sigB;
+    sigZ += (rem * (uint_fast32_t) r0)>>26;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    ++sigZ;
+    if ( ! (sigZ & 7) ) {
+        sigZ &= ~1;
+        rem = (sigA<<10) - sigZ * sigB;
+        if ( rem & 0x8000 ) {
+            sigZ -= 2;
+        } else {
+            if ( rem ) sigZ |= 1;
+        }
+    }
+#endif
+    return softfloat_roundPackToF16( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF16UI;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infinity:
+    uiZ = packToF16UI( signZ, 0x1F, 0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF16UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_eq.c b/arch/riscv/kernel/soft_vector/softfloat/f16_eq.c
new file mode 100755
index 000000000..057354b20
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_eq.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f16_eq( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF16UI( uiA ) || softfloat_isSigNaNF16UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    return (uiA == uiB) || ! (uint16_t) ((uiA | uiB)<<1);
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_eq_signaling.c b/arch/riscv/kernel/soft_vector/softfloat/f16_eq_signaling.c
new file mode 100755
index 000000000..ad6fe11f9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_eq_signaling.c
@@ -0,0 +1,61 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f16_eq_signaling( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    return (uiA == uiB) || ! (uint16_t) ((uiA | uiB)<<1);
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_isSignalingNaN.c b/arch/riscv/kernel/soft_vector/softfloat/f16_isSignalingNaN.c
new file mode 100755
index 000000000..81082a26a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_isSignalingNaN.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f16_isSignalingNaN( float16_t a )
+{
+    union ui16_f16 uA;
+
+    uA.f = a;
+    return softfloat_isSigNaNF16UI( uA.ui );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_le.c b/arch/riscv/kernel/soft_vector/softfloat/f16_le.c
new file mode 100755
index 000000000..736d3c35a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_le.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f16_le( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF16UI( uiA );
+    signB = signF16UI( uiB );
+    return
+        (signA != signB) ? signA || ! (uint16_t) ((uiA | uiB)<<1)
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_le_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f16_le_quiet.c
new file mode 100755
index 000000000..22430d0b5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_le_quiet.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f16_le_quiet( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF16UI( uiA ) || softfloat_isSigNaNF16UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF16UI( uiA );
+    signB = signF16UI( uiB );
+    return
+        (signA != signB) ? signA || ! (uint16_t) ((uiA | uiB)<<1)
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_lt.c b/arch/riscv/kernel/soft_vector/softfloat/f16_lt.c
new file mode 100755
index 000000000..d0e6a31d0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_lt.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f16_lt( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF16UI( uiA );
+    signB = signF16UI( uiB );
+    return
+        (signA != signB) ? signA && ((uint16_t) ((uiA | uiB)<<1) != 0)
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_lt_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f16_lt_quiet.c
new file mode 100755
index 000000000..14c9a1c58
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_lt_quiet.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f16_lt_quiet( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF16UI( uiA ) || softfloat_isSigNaNF16UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF16UI( uiA );
+    signB = signF16UI( uiB );
+    return
+        (signA != signB) ? signA && ((uint16_t) ((uiA | uiB)<<1) != 0)
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_mul.c b/arch/riscv/kernel/soft_vector/softfloat/f16_mul.c
new file mode 100755
index 000000000..c0d4177ac
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_mul.c
@@ -0,0 +1,140 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f16_mul( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool signA;
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signB;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    bool signZ;
+    uint_fast16_t magBits;
+    struct exp8_sig16 normExpSig;
+    int_fast8_t expZ;
+    uint_fast32_t sig32Z;
+    uint_fast16_t sigZ, uiZ;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF16UI( uiA );
+    expA  = expF16UI( uiA );
+    sigA  = fracF16UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF16UI( uiB );
+    expB  = expF16UI( uiB );
+    sigB  = fracF16UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x1F ) {
+        if ( sigA || ((expB == 0x1F) && sigB) ) goto propagateNaN;
+        magBits = expB | sigB;
+        goto infArg;
+    }
+    if ( expB == 0x1F ) {
+        if ( sigB ) goto propagateNaN;
+        magBits = expA | sigA;
+        goto infArg;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF16Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zero;
+        normExpSig = softfloat_normSubnormalF16Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0xF;
+    sigA = (sigA | 0x0400)<<4;
+    sigB = (sigB | 0x0400)<<5;
+    sig32Z = (uint_fast32_t) sigA * sigB;
+    sigZ = sig32Z>>16;
+    if ( sig32Z & 0xFFFF ) sigZ |= 1;
+    if ( sigZ < 0x4000 ) {
+        --expZ;
+        sigZ <<= 1;
+    }
+    return softfloat_roundPackToF16( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infArg:
+    if ( ! magBits ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        uiZ = defaultNaNF16UI;
+    } else {
+        uiZ = packToF16UI( signZ, 0x1F, 0 );
+    }
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF16UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_mulAdd.c b/arch/riscv/kernel/soft_vector/softfloat/f16_mulAdd.c
new file mode 100755
index 000000000..42d94f3f0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_mulAdd.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t f16_mulAdd( float16_t a, float16_t b, float16_t c )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    union ui16_f16 uC;
+    uint_fast16_t uiC;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    uC.f = c;
+    uiC = uC.ui;
+    return softfloat_mulAddF16( uiA, uiB, uiC, 0 );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_rem.c b/arch/riscv/kernel/soft_vector/softfloat/f16_rem.c
new file mode 100755
index 000000000..d3601be6d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_rem.c
@@ -0,0 +1,171 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f16_rem( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool signA;
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    struct exp8_sig16 normExpSig;
+    uint16_t rem;
+    int_fast8_t expDiff;
+    uint_fast16_t q;
+    uint32_t recip32, q32;
+    uint16_t altRem, meanRem;
+    bool signRem;
+    uint_fast16_t uiZ;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF16UI( uiA );
+    expA  = expF16UI( uiA );
+    sigA  = fracF16UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    expB = expF16UI( uiB );
+    sigB = fracF16UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x1F ) {
+        if ( sigA || ((expB == 0x1F) && sigB) ) goto propagateNaN;
+        goto invalid;
+    }
+    if ( expB == 0x1F ) {
+        if ( sigB ) goto propagateNaN;
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) goto invalid;
+        normExpSig = softfloat_normSubnormalF16Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF16Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    rem = sigA | 0x0400;
+    sigB |= 0x0400;
+    expDiff = expA - expB;
+    if ( expDiff < 1 ) {
+        if ( expDiff < -1 ) return a;
+        sigB <<= 3;
+        if ( expDiff ) {
+            rem <<= 2;
+            q = 0;
+        } else {
+            rem <<= 3;
+            q = (sigB <= rem);
+            if ( q ) rem -= sigB;
+        }
+    } else {
+        recip32 = softfloat_approxRecip32_1( (uint_fast32_t) sigB<<21 );
+        /*--------------------------------------------------------------------
+        | Changing the shift of `rem' here requires also changing the initial
+        | subtraction from `expDiff'.
+        *--------------------------------------------------------------------*/
+        rem <<= 4;
+        expDiff -= 31;
+        /*--------------------------------------------------------------------
+        | The scale of `sigB' affects how many bits are obtained during each
+        | cycle of the loop.  Currently this is 29 bits per loop iteration,
+        | which is believed to be the maximum possible.
+        *--------------------------------------------------------------------*/
+        sigB <<= 3;
+        for (;;) {
+            q32 = (rem * (uint_fast64_t) recip32)>>16;
+            if ( expDiff < 0 ) break;
+            rem = -((uint_fast16_t) q32 * sigB);
+            expDiff -= 29;
+        }
+        /*--------------------------------------------------------------------
+        | (`expDiff' cannot be less than -30 here.)
+        *--------------------------------------------------------------------*/
+        q32 >>= ~expDiff & 31;
+        q = q32;
+        rem = (rem<<(expDiff + 30)) - q * sigB;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    do {
+        altRem = rem;
+        ++q;
+        rem -= sigB;
+    } while ( ! (rem & 0x8000) );
+    meanRem = rem + altRem;
+    if ( (meanRem & 0x8000) || (! meanRem && (q & 1)) ) rem = altRem;
+    signRem = signA;
+    if ( 0x8000 <= rem ) {
+        signRem = ! signRem;
+        rem = -rem;
+    }
+    return softfloat_normRoundPackToF16( signRem, expB, rem );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto uiZ;
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF16UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_roundToInt.c b/arch/riscv/kernel/soft_vector/softfloat/f16_roundToInt.c
new file mode 100755
index 000000000..ce66adf48
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_roundToInt.c
@@ -0,0 +1,112 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f16_roundToInt( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    int_fast8_t exp;
+    uint_fast16_t uiZ, lastBitMask, roundBitsMask;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp <= 0xE ) {
+        if ( ! (uint16_t) (uiA<<1) ) return a;
+        if ( exact ) softfloat_exceptionFlags |= softfloat_flag_inexact;
+        uiZ = uiA & packToF16UI( 1, 0, 0 );
+        switch ( roundingMode ) {
+         case softfloat_round_near_even:
+            if ( ! fracF16UI( uiA ) ) break;
+         case softfloat_round_near_maxMag:
+            if ( exp == 0xE ) uiZ |= packToF16UI( 0, 0xF, 0 );
+            break;
+         case softfloat_round_min:
+            if ( uiZ ) uiZ = packToF16UI( 1, 0xF, 0 );
+            break;
+         case softfloat_round_max:
+            if ( ! uiZ ) uiZ = packToF16UI( 0, 0xF, 0 );
+            break;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x19 <= exp ) {
+        if ( (exp == 0x1F) && fracF16UI( uiA ) ) {
+            uiZ = softfloat_propagateNaNF16UI( uiA, 0 );
+            goto uiZ;
+        }
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = uiA;
+    lastBitMask = (uint_fast16_t) 1<<(0x19 - exp);
+    roundBitsMask = lastBitMask - 1;
+    if ( roundingMode == softfloat_round_near_maxMag ) {
+        uiZ += lastBitMask>>1;
+    } else if ( roundingMode == softfloat_round_near_even ) {
+        uiZ += lastBitMask>>1;
+        if ( ! (uiZ & roundBitsMask) ) uiZ &= ~lastBitMask;
+    } else if (
+        roundingMode
+            == (signF16UI( uiZ ) ? softfloat_round_min : softfloat_round_max)
+    ) {
+        uiZ += roundBitsMask;
+    }
+    uiZ &= ~roundBitsMask;
+    if ( exact && (uiZ != uiA) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_sqrt.c b/arch/riscv/kernel/soft_vector/softfloat/f16_sqrt.c
new file mode 100755
index 000000000..90302dcf6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_sqrt.c
@@ -0,0 +1,136 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+extern const uint16_t softfloat_approxRecipSqrt_1k0s[];
+extern const uint16_t softfloat_approxRecipSqrt_1k1s[];
+
+float16_t f16_sqrt( float16_t a )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool signA;
+    int_fast8_t expA;
+    uint_fast16_t sigA, uiZ;
+    struct exp8_sig16 normExpSig;
+    int_fast8_t expZ;
+    int index;
+    uint_fast16_t r0;
+    uint_fast32_t ESqrR0;
+    uint16_t sigma0;
+    uint_fast16_t recipSqrt16, sigZ, shiftedSigZ;
+    uint16_t negRem;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF16UI( uiA );
+    expA  = expF16UI( uiA );
+    sigA  = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x1F ) {
+        if ( sigA ) {
+            uiZ = softfloat_propagateNaNF16UI( uiA, 0 );
+            goto uiZ;
+        }
+        if ( ! signA ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signA ) {
+        if ( ! (expA | sigA) ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF16Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = ((expA - 0xF)>>1) + 0xE;
+    expA &= 1;
+    sigA |= 0x0400;
+    index = (sigA>>6 & 0xE) + expA;
+    r0 = softfloat_approxRecipSqrt_1k0s[index]
+             - (((uint_fast32_t) softfloat_approxRecipSqrt_1k1s[index]
+                     * (sigA & 0x7F))
+                    >>11);
+    ESqrR0 = ((uint_fast32_t) r0 * r0)>>1;
+    if ( expA ) ESqrR0 >>= 1;
+    sigma0 = ~(uint_fast16_t) ((ESqrR0 * sigA)>>16);
+    recipSqrt16 = r0 + (((uint_fast32_t) r0 * sigma0)>>25);
+    if ( ! (recipSqrt16 & 0x8000) ) recipSqrt16 = 0x8000;
+    sigZ = ((uint_fast32_t) (sigA<<5) * recipSqrt16)>>16;
+    if ( expA ) sigZ >>= 1;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    ++sigZ;
+    if ( ! (sigZ & 7) ) {
+        shiftedSigZ = sigZ>>1;
+        negRem = shiftedSigZ * shiftedSigZ;
+        sigZ &= ~1;
+        if ( negRem & 0x8000 ) {
+            sigZ |= 1;
+        } else {
+            if ( negRem ) --sigZ;
+        }
+    }
+    return softfloat_roundPackToF16( 0, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF16UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_sub.c b/arch/riscv/kernel/soft_vector/softfloat/f16_sub.c
new file mode 100755
index 000000000..17e09cc7e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_sub.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t f16_sub( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 1)
+    float16_t (*magsFuncPtr)( uint_fast16_t, uint_fast16_t );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+#if defined INLINE_LEVEL && (1 <= INLINE_LEVEL)
+    if ( signF16UI( uiA ^ uiB ) ) {
+        return softfloat_addMagsF16( uiA, uiB );
+    } else {
+        return softfloat_subMagsF16( uiA, uiB );
+    }
+#else
+    magsFuncPtr =
+        signF16UI( uiA ^ uiB ) ? softfloat_addMagsF16 : softfloat_subMagsF16;
+    return (*magsFuncPtr)( uiA, uiB );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f128.c
new file mode 100755
index 000000000..1f9f15052
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f128.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f16_to_f128( float16_t a )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    struct commonNaN commonNaN;
+    struct uint128 uiZ;
+    struct exp8_sig16 normExpSig;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        if ( frac ) {
+            softfloat_f16UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF128UI( &commonNaN );
+        } else {
+            uiZ.v64 = packToF128UI64( sign, 0x7FFF, 0 );
+            uiZ.v0  = 0;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ.v64 = packToF128UI64( sign, 0, 0 );
+            uiZ.v0  = 0;
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF16Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ.v64 = packToF128UI64( sign, exp + 0x3FF0, (uint_fast64_t) frac<<38 );
+    uiZ.v0  = 0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f32.c
new file mode 100755
index 000000000..9618d72d2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f32.c
@@ -0,0 +1,93 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f16_to_f32( float16_t a )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    struct commonNaN commonNaN;
+    uint_fast32_t uiZ;
+    struct exp8_sig16 normExpSig;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        if ( frac ) {
+            softfloat_f16UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF32UI( &commonNaN );
+        } else {
+            uiZ = packToF32UI( sign, 0xFF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ = packToF32UI( sign, 0, 0 );
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF16Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = packToF32UI( sign, exp + 0x70, (uint_fast32_t) frac<<13 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f64.c
new file mode 100755
index 000000000..87e768b33
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f64.c
@@ -0,0 +1,93 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f16_to_f64( float16_t a )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    struct commonNaN commonNaN;
+    uint_fast64_t uiZ;
+    struct exp8_sig16 normExpSig;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        if ( frac ) {
+            softfloat_f16UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF64UI( &commonNaN );
+        } else {
+            uiZ = packToF64UI( sign, 0x7FF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ = packToF64UI( sign, 0, 0 );
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF16Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = packToF64UI( sign, exp + 0x3F0, (uint_fast64_t) frac<<42 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i16.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i16.c
new file mode 100755
index 000000000..9e71a4acd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i16.c
@@ -0,0 +1,57 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast16_t f16_to_i16( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    int_fast32_t sig32 = f16_to_i32(a, roundingMode, exact);
+
+    if (sig32 > INT16_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i16_fromPosOverflow;
+    } else if (sig32 < INT16_MIN) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i16_fromNegOverflow;
+    } else {
+        return sig32;
+    }
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32.c
new file mode 100755
index 000000000..a2c9440e2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32.c
@@ -0,0 +1,87 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f16_to_i32( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast32_t sig32;
+    int_fast8_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            frac ? i32_fromNaN
+                : sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig32 = frac;
+    if ( exp ) {
+        sig32 |= 0x0400;
+        shiftDist = exp - 0x19;
+        if ( 0 <= shiftDist ) {
+            sig32 <<= shiftDist;
+            return sign ? -sig32 : sig32;
+        }
+        shiftDist = exp - 0x0D;
+        if ( 0 < shiftDist ) sig32 <<= shiftDist;
+    }
+    return
+        softfloat_roundToI32(
+            sign, (uint_fast32_t) sig32, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32_r_minMag.c
new file mode 100755
index 000000000..dd230c334
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32_r_minMag.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f16_to_i32_r_minMag( float16_t a, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast8_t shiftDist;
+    bool sign;
+    int_fast32_t alignedSig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = exp - 0x0F;
+    if ( shiftDist < 0 ) {
+        if ( exact && (exp | frac) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF16UI( uiA );
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x1F) && frac ? i32_fromNaN
+                : sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    alignedSig = (int_fast32_t) (frac | 0x0400)<<shiftDist;
+    if ( exact && (alignedSig & 0x3FF) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    alignedSig >>= 10;
+    return sign ? -alignedSig : alignedSig;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64.c
new file mode 100755
index 000000000..87b4d5c06
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64.c
@@ -0,0 +1,87 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f16_to_i64( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast32_t sig32;
+    int_fast8_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            frac ? i64_fromNaN
+                : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig32 = frac;
+    if ( exp ) {
+        sig32 |= 0x0400;
+        shiftDist = exp - 0x19;
+        if ( 0 <= shiftDist ) {
+            sig32 <<= shiftDist;
+            return sign ? -sig32 : sig32;
+        }
+        shiftDist = exp - 0x0D;
+        if ( 0 < shiftDist ) sig32 <<= shiftDist;
+    }
+    return
+        softfloat_roundToI32(
+            sign, (uint_fast32_t) sig32, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64_r_minMag.c
new file mode 100755
index 000000000..6bf63d0c0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64_r_minMag.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f16_to_i64_r_minMag( float16_t a, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast8_t shiftDist;
+    bool sign;
+    int_fast32_t alignedSig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = exp - 0x0F;
+    if ( shiftDist < 0 ) {
+        if ( exact && (exp | frac) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF16UI( uiA );
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x1F) && frac ? i64_fromNaN
+                : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    alignedSig = (int_fast32_t) (frac | 0x0400)<<shiftDist;
+    if ( exact && (alignedSig & 0x3FF) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    alignedSig >>= 10;
+    return sign ? -alignedSig : alignedSig;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i8.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i8.c
new file mode 100755
index 000000000..280bffbbc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i8.c
@@ -0,0 +1,57 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast8_t f16_to_i8( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    int_fast32_t sig32 = f16_to_i32(a, roundingMode, exact);
+
+    if (sig32 > INT8_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i8_fromPosOverflow;
+    } else if (sig32 < INT8_MIN) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i8_fromNegOverflow;
+    } else {
+        return sig32;
+    }
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui16.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui16.c
new file mode 100755
index 000000000..9f5e1c57f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui16.c
@@ -0,0 +1,54 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f16_to_ui16( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    uint_fast32_t sig32 = f16_to_ui32(a, roundingMode, exact);
+
+    if (sig32 > UINT16_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return ui16_fromPosOverflow;
+    } else {
+        return sig32;
+    }
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32.c
new file mode 100755
index 000000000..ce1aa184d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f16_to_ui32( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    uint_fast32_t sig32;
+    int_fast8_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            frac ? ui32_fromNaN
+                : sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig32 = frac;
+    if ( exp ) {
+        sig32 |= 0x0400;
+        shiftDist = exp - 0x19;
+        if ( (0 <= shiftDist) && ! sign ) {
+            return sig32<<shiftDist;
+        }
+        shiftDist = exp - 0x0D;
+        if ( 0 < shiftDist ) sig32 <<= shiftDist;
+    }
+    return softfloat_roundToUI32( sign, sig32, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32_r_minMag.c
new file mode 100755
index 000000000..c05e88267
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32_r_minMag.c
@@ -0,0 +1,87 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f16_to_ui32_r_minMag( float16_t a, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast8_t shiftDist;
+    bool sign;
+    uint_fast32_t alignedSig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = exp - 0x0F;
+    if ( shiftDist < 0 ) {
+        if ( exact && (exp | frac) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF16UI( uiA );
+    if ( sign || (exp == 0x1F) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x1F) && frac ? ui32_fromNaN
+                : sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    alignedSig = (uint_fast32_t) (frac | 0x0400)<<shiftDist;
+    if ( exact && (alignedSig & 0x3FF) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return alignedSig>>10;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64.c
new file mode 100755
index 000000000..a2d0ce80a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f16_to_ui64( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    uint_fast32_t sig32;
+    int_fast8_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            frac ? ui64_fromNaN
+                : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig32 = frac;
+    if ( exp ) {
+        sig32 |= 0x0400;
+        shiftDist = exp - 0x19;
+        if ( (0 <= shiftDist) && ! sign ) {
+            return sig32<<shiftDist;
+        }
+        shiftDist = exp - 0x0D;
+        if ( 0 < shiftDist ) sig32 <<= shiftDist;
+    }
+    return softfloat_roundToUI32( sign, sig32, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64_r_minMag.c
new file mode 100755
index 000000000..a49944122
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64_r_minMag.c
@@ -0,0 +1,87 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f16_to_ui64_r_minMag( float16_t a, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast8_t shiftDist;
+    bool sign;
+    uint_fast32_t alignedSig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = exp - 0x0F;
+    if ( shiftDist < 0 ) {
+        if ( exact && (exp | frac) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF16UI( uiA );
+    if ( sign || (exp == 0x1F) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x1F) && frac ? ui64_fromNaN
+                : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    alignedSig = (uint_fast32_t) (frac | 0x0400)<<shiftDist;
+    if ( exact && (alignedSig & 0x3FF) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return alignedSig>>10;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui8.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui8.c
new file mode 100755
index 000000000..cda41b560
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui8.c
@@ -0,0 +1,54 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast8_t f16_to_ui8( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    uint_fast32_t sig32 = f16_to_ui32(a, roundingMode, exact);
+
+    if (sig32 > UINT8_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return ui8_fromPosOverflow;
+    } else {
+        return sig32;
+    }
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_add.c b/arch/riscv/kernel/soft_vector/softfloat/f32_add.c
new file mode 100755
index 000000000..9829d5e31
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_add.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t f32_add( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 1)
+    float32_t (*magsFuncPtr)( uint_fast32_t, uint_fast32_t );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+#if defined INLINE_LEVEL && (1 <= INLINE_LEVEL)
+    if ( signF32UI( uiA ^ uiB ) ) {
+        return softfloat_subMagsF32( uiA, uiB );
+    } else {
+        return softfloat_addMagsF32( uiA, uiB );
+    }
+#else
+    magsFuncPtr =
+        signF32UI( uiA ^ uiB ) ? softfloat_subMagsF32 : softfloat_addMagsF32;
+    return (*magsFuncPtr)( uiA, uiB );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_classify.c b/arch/riscv/kernel/soft_vector/softfloat/f32_classify.c
new file mode 100755
index 000000000..9f0b0f2d1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_classify.c
@@ -0,0 +1,36 @@
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f32_classify( float32_t a )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+
+    uA.f = a;
+    uiA = uA.ui;
+
+    uint_fast16_t infOrNaN = expF32UI( uiA ) == 0xFF;
+    uint_fast16_t subnormalOrZero = expF32UI( uiA ) == 0;
+    bool sign = signF32UI( uiA );
+    bool fracZero = fracF32UI( uiA ) == 0;
+    bool isNaN = isNaNF32UI( uiA );
+    bool isSNaN = softfloat_isSigNaNF32UI( uiA );
+
+    return
+        (  sign && infOrNaN && fracZero )          << 0 |
+        (  sign && !infOrNaN && !subnormalOrZero ) << 1 |
+        (  sign && subnormalOrZero && !fracZero )  << 2 |
+        (  sign && subnormalOrZero && fracZero )   << 3 |
+        ( !sign && infOrNaN && fracZero )          << 7 |
+        ( !sign && !infOrNaN && !subnormalOrZero ) << 6 |
+        ( !sign && subnormalOrZero && !fracZero )  << 5 |
+        ( !sign && subnormalOrZero && fracZero )   << 4 |
+        ( isNaN &&  isSNaN )                       << 8 |
+        ( isNaN && !isSNaN )                       << 9;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_div.c b/arch/riscv/kernel/soft_vector/softfloat/f32_div.c
new file mode 100755
index 000000000..6f297eb0f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_div.c
@@ -0,0 +1,180 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f32_div( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    bool signZ;
+    struct exp16_sig32 normExpSig;
+    int_fast16_t expZ;
+#ifdef SOFTFLOAT_FAST_DIV64TO32
+    uint_fast64_t sig64A;
+    uint_fast32_t sigZ;
+#else
+    uint_fast32_t sigZ;
+    uint_fast64_t rem;
+#endif
+    uint_fast32_t uiZ;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF32UI( uiA );
+    expA  = expF32UI( uiA );
+    sigA  = fracF32UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF32UI( uiB );
+    expB  = expF32UI( uiB );
+    sigB  = fracF32UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0xFF ) {
+        if ( sigA ) goto propagateNaN;
+        if ( expB == 0xFF ) {
+            if ( sigB ) goto propagateNaN;
+            goto invalid;
+        }
+        goto infinity;
+    }
+    if ( expB == 0xFF ) {
+        if ( sigB ) goto propagateNaN;
+        goto zero;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) {
+            if ( ! (expA | sigA) ) goto invalid;
+            softfloat_raiseFlags( softfloat_flag_infinite );
+            goto infinity;
+        }
+        normExpSig = softfloat_normSubnormalF32Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF32Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA - expB + 0x7E;
+    sigA |= 0x00800000;
+    sigB |= 0x00800000;
+#ifdef SOFTFLOAT_FAST_DIV64TO32
+    if ( sigA < sigB ) {
+        --expZ;
+        sig64A = (uint_fast64_t) sigA<<31;
+    } else {
+        sig64A = (uint_fast64_t) sigA<<30;
+    }
+    sigZ = sig64A / sigB;
+    if ( ! (sigZ & 0x3F) ) sigZ |= ((uint_fast64_t) sigB * sigZ != sig64A);
+#else
+    if ( sigA < sigB ) {
+        --expZ;
+        sigA <<= 8;
+    } else {
+        sigA <<= 7;
+    }
+    sigB <<= 8;
+    sigZ = ((uint_fast64_t) sigA * softfloat_approxRecip32_1( sigB ))>>32;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sigZ += 2;
+    if ( (sigZ & 0x3F) < 2 ) {
+        sigZ &= ~3;
+#ifdef SOFTFLOAT_FAST_INT64
+        rem = ((uint_fast64_t) sigA<<31) - (uint_fast64_t) sigZ * sigB;
+#else
+        rem = ((uint_fast64_t) sigA<<32) - (uint_fast64_t) (sigZ<<1) * sigB;
+#endif
+        if ( rem & UINT64_C( 0x8000000000000000 ) ) {
+            sigZ -= 4;
+        } else {
+            if ( rem ) sigZ |= 1;
+        }
+    }
+#endif
+    return softfloat_roundPackToF32( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF32UI;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infinity:
+    uiZ = packToF32UI( signZ, 0xFF, 0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF32UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_eq.c b/arch/riscv/kernel/soft_vector/softfloat/f32_eq.c
new file mode 100755
index 000000000..e13418926
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_eq.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f32_eq( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF32UI( uiA ) || softfloat_isSigNaNF32UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    return (uiA == uiB) || ! (uint32_t) ((uiA | uiB)<<1);
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_eq_signaling.c b/arch/riscv/kernel/soft_vector/softfloat/f32_eq_signaling.c
new file mode 100755
index 000000000..e86288e1a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_eq_signaling.c
@@ -0,0 +1,61 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f32_eq_signaling( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    return (uiA == uiB) || ! (uint32_t) ((uiA | uiB)<<1);
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_isSignalingNaN.c b/arch/riscv/kernel/soft_vector/softfloat/f32_isSignalingNaN.c
new file mode 100755
index 000000000..196b0cd9c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_isSignalingNaN.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f32_isSignalingNaN( float32_t a )
+{
+    union ui32_f32 uA;
+
+    uA.f = a;
+    return softfloat_isSigNaNF32UI( uA.ui );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_le.c b/arch/riscv/kernel/soft_vector/softfloat/f32_le.c
new file mode 100755
index 000000000..0dd030eec
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_le.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f32_le( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF32UI( uiA );
+    signB = signF32UI( uiB );
+    return
+        (signA != signB) ? signA || ! (uint32_t) ((uiA | uiB)<<1)
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_le_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f32_le_quiet.c
new file mode 100755
index 000000000..5b4624974
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_le_quiet.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f32_le_quiet( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF32UI( uiA ) || softfloat_isSigNaNF32UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF32UI( uiA );
+    signB = signF32UI( uiB );
+    return
+        (signA != signB) ? signA || ! (uint32_t) ((uiA | uiB)<<1)
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_lt.c b/arch/riscv/kernel/soft_vector/softfloat/f32_lt.c
new file mode 100755
index 000000000..7e6ebd8da
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_lt.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f32_lt( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF32UI( uiA );
+    signB = signF32UI( uiB );
+    return
+        (signA != signB) ? signA && ((uint32_t) ((uiA | uiB)<<1) != 0)
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_lt_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f32_lt_quiet.c
new file mode 100755
index 000000000..bc491c1b2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_lt_quiet.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f32_lt_quiet( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF32UI( uiA ) || softfloat_isSigNaNF32UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF32UI( uiA );
+    signB = signF32UI( uiB );
+    return
+        (signA != signB) ? signA && ((uint32_t) ((uiA | uiB)<<1) != 0)
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_mul.c b/arch/riscv/kernel/soft_vector/softfloat/f32_mul.c
new file mode 100755
index 000000000..8d5225f06
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_mul.c
@@ -0,0 +1,137 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f32_mul( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    bool signZ;
+    uint_fast32_t magBits;
+    struct exp16_sig32 normExpSig;
+    int_fast16_t expZ;
+    uint_fast32_t sigZ, uiZ;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF32UI( uiA );
+    expA  = expF32UI( uiA );
+    sigA  = fracF32UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF32UI( uiB );
+    expB  = expF32UI( uiB );
+    sigB  = fracF32UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0xFF ) {
+        if ( sigA || ((expB == 0xFF) && sigB) ) goto propagateNaN;
+        magBits = expB | sigB;
+        goto infArg;
+    }
+    if ( expB == 0xFF ) {
+        if ( sigB ) goto propagateNaN;
+        magBits = expA | sigA;
+        goto infArg;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF32Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zero;
+        normExpSig = softfloat_normSubnormalF32Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x7F;
+    sigA = (sigA | 0x00800000)<<7;
+    sigB = (sigB | 0x00800000)<<8;
+    sigZ = softfloat_shortShiftRightJam64( (uint_fast64_t) sigA * sigB, 32 );
+    if ( sigZ < 0x40000000 ) {
+        --expZ;
+        sigZ <<= 1;
+    }
+    return softfloat_roundPackToF32( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infArg:
+    if ( ! magBits ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        uiZ = defaultNaNF32UI;
+    } else {
+        uiZ = packToF32UI( signZ, 0xFF, 0 );
+    }
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF32UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_mulAdd.c b/arch/riscv/kernel/soft_vector/softfloat/f32_mulAdd.c
new file mode 100755
index 000000000..f7d947db6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_mulAdd.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t f32_mulAdd( float32_t a, float32_t b, float32_t c )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    union ui32_f32 uC;
+    uint_fast32_t uiC;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    uC.f = c;
+    uiC = uC.ui;
+    return softfloat_mulAddF32( uiA, uiB, uiC, 0 );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_rem.c b/arch/riscv/kernel/soft_vector/softfloat/f32_rem.c
new file mode 100755
index 000000000..a44dcff1b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_rem.c
@@ -0,0 +1,168 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f32_rem( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    struct exp16_sig32 normExpSig;
+    uint32_t rem;
+    int_fast16_t expDiff;
+    uint32_t q, recip32, altRem, meanRem;
+    bool signRem;
+    uint_fast32_t uiZ;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF32UI( uiA );
+    expA  = expF32UI( uiA );
+    sigA  = fracF32UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    expB = expF32UI( uiB );
+    sigB = fracF32UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0xFF ) {
+        if ( sigA || ((expB == 0xFF) && sigB) ) goto propagateNaN;
+        goto invalid;
+    }
+    if ( expB == 0xFF ) {
+        if ( sigB ) goto propagateNaN;
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) goto invalid;
+        normExpSig = softfloat_normSubnormalF32Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF32Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    rem = sigA | 0x00800000;
+    sigB |= 0x00800000;
+    expDiff = expA - expB;
+    if ( expDiff < 1 ) {
+        if ( expDiff < -1 ) return a;
+        sigB <<= 6;
+        if ( expDiff ) {
+            rem <<= 5;
+            q = 0;
+        } else {
+            rem <<= 6;
+            q = (sigB <= rem);
+            if ( q ) rem -= sigB;
+        }
+    } else {
+        recip32 = softfloat_approxRecip32_1( sigB<<8 );
+        /*--------------------------------------------------------------------
+        | Changing the shift of `rem' here requires also changing the initial
+        | subtraction from `expDiff'.
+        *--------------------------------------------------------------------*/
+        rem <<= 7;
+        expDiff -= 31;
+        /*--------------------------------------------------------------------
+        | The scale of `sigB' affects how many bits are obtained during each
+        | cycle of the loop.  Currently this is 29 bits per loop iteration,
+        | which is believed to be the maximum possible.
+        *--------------------------------------------------------------------*/
+        sigB <<= 6;
+        for (;;) {
+            q = (rem * (uint_fast64_t) recip32)>>32;
+            if ( expDiff < 0 ) break;
+            rem = -(q * (uint32_t) sigB);
+            expDiff -= 29;
+        }
+        /*--------------------------------------------------------------------
+        | (`expDiff' cannot be less than -30 here.)
+        *--------------------------------------------------------------------*/
+        q >>= ~expDiff & 31;
+        rem = (rem<<(expDiff + 30)) - q * (uint32_t) sigB;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    do {
+        altRem = rem;
+        ++q;
+        rem -= sigB;
+    } while ( ! (rem & 0x80000000) );
+    meanRem = rem + altRem;
+    if ( (meanRem & 0x80000000) || (! meanRem && (q & 1)) ) rem = altRem;
+    signRem = signA;
+    if ( 0x80000000 <= rem ) {
+        signRem = ! signRem;
+        rem = -rem;
+    }
+    return softfloat_normRoundPackToF32( signRem, expB, rem );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+    goto uiZ;
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF32UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_roundToInt.c b/arch/riscv/kernel/soft_vector/softfloat/f32_roundToInt.c
new file mode 100755
index 000000000..7eb807435
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_roundToInt.c
@@ -0,0 +1,112 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f32_roundToInt( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    int_fast16_t exp;
+    uint_fast32_t uiZ, lastBitMask, roundBitsMask;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp <= 0x7E ) {
+        if ( ! (uint32_t) (uiA<<1) ) return a;
+        if ( exact ) softfloat_exceptionFlags |= softfloat_flag_inexact;
+        uiZ = uiA & packToF32UI( 1, 0, 0 );
+        switch ( roundingMode ) {
+         case softfloat_round_near_even:
+            if ( ! fracF32UI( uiA ) ) break;
+         case softfloat_round_near_maxMag:
+            if ( exp == 0x7E ) uiZ |= packToF32UI( 0, 0x7F, 0 );
+            break;
+         case softfloat_round_min:
+            if ( uiZ ) uiZ = packToF32UI( 1, 0x7F, 0 );
+            break;
+         case softfloat_round_max:
+            if ( ! uiZ ) uiZ = packToF32UI( 0, 0x7F, 0 );
+            break;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x96 <= exp ) {
+        if ( (exp == 0xFF) && fracF32UI( uiA ) ) {
+            uiZ = softfloat_propagateNaNF32UI( uiA, 0 );
+            goto uiZ;
+        }
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = uiA;
+    lastBitMask = (uint_fast32_t) 1<<(0x96 - exp);
+    roundBitsMask = lastBitMask - 1;
+    if ( roundingMode == softfloat_round_near_maxMag ) {
+        uiZ += lastBitMask>>1;
+    } else if ( roundingMode == softfloat_round_near_even ) {
+        uiZ += lastBitMask>>1;
+        if ( ! (uiZ & roundBitsMask) ) uiZ &= ~lastBitMask;
+    } else if (
+        roundingMode
+            == (signF32UI( uiZ ) ? softfloat_round_min : softfloat_round_max)
+    ) {
+        uiZ += roundBitsMask;
+    }
+    uiZ &= ~roundBitsMask;
+    if ( exact && (uiZ != uiA) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_sqrt.c b/arch/riscv/kernel/soft_vector/softfloat/f32_sqrt.c
new file mode 100755
index 000000000..533b3652c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_sqrt.c
@@ -0,0 +1,121 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f32_sqrt( float32_t a )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast32_t sigA, uiZ;
+    struct exp16_sig32 normExpSig;
+    int_fast16_t expZ;
+    uint_fast32_t sigZ, shiftedSigZ;
+    uint32_t negRem;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF32UI( uiA );
+    expA  = expF32UI( uiA );
+    sigA  = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0xFF ) {
+        if ( sigA ) {
+            uiZ = softfloat_propagateNaNF32UI( uiA, 0 );
+            goto uiZ;
+        }
+        if ( ! signA ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signA ) {
+        if ( ! (expA | sigA) ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF32Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = ((expA - 0x7F)>>1) + 0x7E;
+    expA &= 1;
+    sigA = (sigA | 0x00800000)<<8;
+    sigZ =
+        ((uint_fast64_t) sigA * softfloat_approxRecipSqrt32_1( expA, sigA ))
+            >>32;
+    if ( expA ) sigZ >>= 1;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sigZ += 2;
+    if ( (sigZ & 0x3F) < 2 ) {
+        shiftedSigZ = sigZ>>2;
+        negRem = shiftedSigZ * shiftedSigZ;
+        sigZ &= ~3;
+        if ( negRem & 0x80000000 ) {
+            sigZ |= 1;
+        } else {
+            if ( negRem ) --sigZ;
+        }
+    }
+    return softfloat_roundPackToF32( 0, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF32UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_sub.c b/arch/riscv/kernel/soft_vector/softfloat/f32_sub.c
new file mode 100755
index 000000000..6268552be
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_sub.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t f32_sub( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 1)
+    float32_t (*magsFuncPtr)( uint_fast32_t, uint_fast32_t );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+#if defined INLINE_LEVEL && (1 <= INLINE_LEVEL)
+    if ( signF32UI( uiA ^ uiB ) ) {
+        return softfloat_addMagsF32( uiA, uiB );
+    } else {
+        return softfloat_subMagsF32( uiA, uiB );
+    }
+#else
+    magsFuncPtr =
+        signF32UI( uiA ^ uiB ) ? softfloat_addMagsF32 : softfloat_subMagsF32;
+    return (*magsFuncPtr)( uiA, uiB );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f128.c
new file mode 100755
index 000000000..ea58e8d03
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f128.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f32_to_f128( float32_t a )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t frac;
+    struct commonNaN commonNaN;
+    struct uint128 uiZ;
+    struct exp16_sig32 normExpSig;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    frac = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0xFF ) {
+        if ( frac ) {
+            softfloat_f32UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF128UI( &commonNaN );
+        } else {
+            uiZ.v64 = packToF128UI64( sign, 0x7FFF, 0 );
+            uiZ.v0  = 0;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ.v64 = packToF128UI64( sign, 0, 0 );
+            uiZ.v0  = 0;
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF32Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ.v64 = packToF128UI64( sign, exp + 0x3F80, (uint_fast64_t) frac<<25 );
+    uiZ.v0  = 0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f16.c
new file mode 100755
index 000000000..403ce34a5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f16.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f32_to_f16( float32_t a )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t frac;
+    struct commonNaN commonNaN;
+    uint_fast16_t uiZ, frac16;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    frac = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0xFF ) {
+        if ( frac ) {
+            softfloat_f32UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF16UI( &commonNaN );
+        } else {
+            uiZ = packToF16UI( sign, 0x1F, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac16 = frac>>9 | ((frac & 0x1FF) != 0);
+    if ( ! (exp | frac16) ) {
+        uiZ = packToF16UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    return softfloat_roundPackToF16( sign, exp - 0x71, frac16 | 0x4000 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f64.c
new file mode 100755
index 000000000..12040185e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f64.c
@@ -0,0 +1,93 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f32_to_f64( float32_t a )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t frac;
+    struct commonNaN commonNaN;
+    uint_fast64_t uiZ;
+    struct exp16_sig32 normExpSig;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    frac = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0xFF ) {
+        if ( frac ) {
+            softfloat_f32UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF64UI( &commonNaN );
+        } else {
+            uiZ = packToF64UI( sign, 0x7FF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ = packToF64UI( sign, 0, 0 );
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF32Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = packToF64UI( sign, exp + 0x380, (uint_fast64_t) frac<<29 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_i16.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i16.c
new file mode 100755
index 000000000..eef8ff0ea
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i16.c
@@ -0,0 +1,57 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast16_t f32_to_i16( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    int_fast32_t sig32 = f32_to_i32(a, roundingMode, exact);
+
+    if (sig32 > INT16_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i16_fromPosOverflow;
+    } else if (sig32 < INT16_MIN) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i16_fromNegOverflow;
+    } else {
+        return sig32;
+    }
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32.c
new file mode 100755
index 000000000..ded5c6def
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f32_to_i32( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    uint_fast64_t sig64;
+    int_fast16_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    sig  = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (i32_fromNaN != i32_fromPosOverflow) || (i32_fromNaN != i32_fromNegOverflow)
+    if ( (exp == 0xFF) && sig ) {
+#if (i32_fromNaN == i32_fromPosOverflow)
+        sign = 0;
+#elif (i32_fromNaN == i32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return i32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= 0x00800000;
+    sig64 = (uint_fast64_t) sig<<32;
+    shiftDist = 0xAA - exp;
+    if ( 0 < shiftDist ) sig64 = softfloat_shiftRightJam64( sig64, shiftDist );
+    return softfloat_roundToI32( sign, sig64, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32_r_minMag.c
new file mode 100755
index 000000000..7b5fc1ad5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32_r_minMag.c
@@ -0,0 +1,89 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f32_to_i32_r_minMag( float32_t a, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    int_fast32_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF32UI( uiA );
+    sig = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x9E - exp;
+    if ( 32 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF32UI( uiA );
+    if ( shiftDist <= 0 ) {
+        if ( uiA == packToF32UI( 1, 0x9E, 0 ) ) return -0x7FFFFFFF - 1;
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? i32_fromNaN
+                : sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig = (sig | 0x00800000)<<8;
+    absZ = sig>>shiftDist;
+    if ( exact && ((uint_fast32_t) absZ<<shiftDist != sig) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64.c
new file mode 100755
index 000000000..cdc847da4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f32_to_i64( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+#ifdef SOFTFLOAT_FAST_INT64
+    uint_fast64_t sig64, extra;
+    struct uint64_extra sig64Extra;
+#else
+    uint32_t extSig[3];
+#endif
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    sig  = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0xBE - exp;
+    if ( shiftDist < 0 ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? i64_fromNaN
+                : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= 0x00800000;
+#ifdef SOFTFLOAT_FAST_INT64
+    sig64 = (uint_fast64_t) sig<<40;
+    extra = 0;
+    if ( shiftDist ) {
+        sig64Extra = softfloat_shiftRightJam64Extra( sig64, 0, shiftDist );
+        sig64 = sig64Extra.v;
+        extra = sig64Extra.extra;
+    }
+    return softfloat_roundToI64( sign, sig64, extra, roundingMode, exact );
+#else
+    extSig[indexWord( 3, 2 )] = sig<<8;
+    extSig[indexWord( 3, 1 )] = 0;
+    extSig[indexWord( 3, 0 )] = 0;
+    if ( shiftDist ) softfloat_shiftRightJam96M( extSig, shiftDist, extSig );
+    return softfloat_roundMToI64( sign, extSig, roundingMode, exact );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64_r_minMag.c
new file mode 100755
index 000000000..cf6f95d59
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64_r_minMag.c
@@ -0,0 +1,94 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f32_to_i64_r_minMag( float32_t a, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    uint_fast64_t sig64;
+    int_fast64_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF32UI( uiA );
+    sig = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0xBE - exp;
+    if ( 64 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF32UI( uiA );
+    if ( shiftDist <= 0 ) {
+        if ( uiA == packToF32UI( 1, 0xBE, 0 ) ) {
+            return -INT64_C( 0x7FFFFFFFFFFFFFFF ) - 1;
+        }
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? i64_fromNaN
+                : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig |= 0x00800000;
+    sig64 = (uint_fast64_t) sig<<40;
+    absZ = sig64>>shiftDist;
+    shiftDist = 40 - shiftDist;
+    if ( exact && (shiftDist < 0) && (uint32_t) (sig<<(shiftDist & 31)) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui16.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui16.c
new file mode 100755
index 000000000..5ca3c254e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui16.c
@@ -0,0 +1,53 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f32_to_ui16( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    uint_fast32_t sig32 = f32_to_ui32(a, roundingMode, exact);
+
+    if (sig32 > UINT16_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return ui16_fromPosOverflow;
+    } else {
+        return sig32;
+    }
+}
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32.c
new file mode 100755
index 000000000..5df0576f8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f32_to_ui32( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    uint_fast64_t sig64;
+    int_fast16_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    sig  = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (ui32_fromNaN != ui32_fromPosOverflow) || (ui32_fromNaN != ui32_fromNegOverflow)
+    if ( (exp == 0xFF) && sig ) {
+#if (ui32_fromNaN == ui32_fromPosOverflow)
+        sign = 0;
+#elif (ui32_fromNaN == ui32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return ui32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= 0x00800000;
+    sig64 = (uint_fast64_t) sig<<32;
+    shiftDist = 0xAA - exp;
+    if ( 0 < shiftDist ) sig64 = softfloat_shiftRightJam64( sig64, shiftDist );
+    return softfloat_roundToUI32( sign, sig64, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32_r_minMag.c
new file mode 100755
index 000000000..9f92cc0ff
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32_r_minMag.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f32_to_ui32_r_minMag( float32_t a, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    uint_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF32UI( uiA );
+    sig = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x9E - exp;
+    if ( 32 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF32UI( uiA );
+    if ( sign || (shiftDist < 0) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? ui32_fromNaN
+                : sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig = (sig | 0x00800000)<<8;
+    z = sig>>shiftDist;
+    if ( exact && (z<<shiftDist != sig) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64.c
new file mode 100755
index 000000000..0fb61423b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f32_to_ui64( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+#ifdef SOFTFLOAT_FAST_INT64
+    uint_fast64_t sig64, extra;
+    struct uint64_extra sig64Extra;
+#else
+    uint32_t extSig[3];
+#endif
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    sig  = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0xBE - exp;
+    if ( shiftDist < 0 ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? ui64_fromNaN
+                : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= 0x00800000;
+#ifdef SOFTFLOAT_FAST_INT64
+    sig64 = (uint_fast64_t) sig<<40;
+    extra = 0;
+    if ( shiftDist ) {
+        sig64Extra = softfloat_shiftRightJam64Extra( sig64, 0, shiftDist );
+        sig64 = sig64Extra.v;
+        extra = sig64Extra.extra;
+    }
+    return softfloat_roundToUI64( sign, sig64, extra, roundingMode, exact );
+#else
+    extSig[indexWord( 3, 2 )] = sig<<8;
+    extSig[indexWord( 3, 1 )] = 0;
+    extSig[indexWord( 3, 0 )] = 0;
+    if ( shiftDist ) softfloat_shiftRightJam96M( extSig, shiftDist, extSig );
+    return softfloat_roundMToUI64( sign, extSig, roundingMode, exact );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64_r_minMag.c
new file mode 100755
index 000000000..2c3db1cc1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64_r_minMag.c
@@ -0,0 +1,90 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f32_to_ui64_r_minMag( float32_t a, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    uint_fast64_t sig64, z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF32UI( uiA );
+    sig = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0xBE - exp;
+    if ( 64 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF32UI( uiA );
+    if ( sign || (shiftDist < 0) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? ui64_fromNaN
+                : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig |= 0x00800000;
+    sig64 = (uint_fast64_t) sig<<40;
+    z = sig64>>shiftDist;
+    shiftDist = 40 - shiftDist;
+    if ( exact && (shiftDist < 0) && (uint32_t) (sig<<(shiftDist & 31)) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_add.c b/arch/riscv/kernel/soft_vector/softfloat/f64_add.c
new file mode 100755
index 000000000..190cdf53f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_add.c
@@ -0,0 +1,74 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t f64_add( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)
+    float64_t (*magsFuncPtr)( uint_fast64_t, uint_fast64_t, bool );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF64UI( uiB );
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+    if ( signA == signB ) {
+        return softfloat_addMagsF64( uiA, uiB, signA );
+    } else {
+        return softfloat_subMagsF64( uiA, uiB, signA );
+    }
+#else
+    magsFuncPtr =
+        (signA == signB) ? softfloat_addMagsF64 : softfloat_subMagsF64;
+    return (*magsFuncPtr)( uiA, uiB, signA );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_classify.c b/arch/riscv/kernel/soft_vector/softfloat/f64_classify.c
new file mode 100755
index 000000000..a6944c93e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_classify.c
@@ -0,0 +1,36 @@
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f64_classify( float64_t a )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+
+    uA.f = a;
+    uiA = uA.ui;
+
+    uint_fast16_t infOrNaN = expF64UI( uiA ) == 0x7FF;
+    uint_fast16_t subnormalOrZero = expF64UI( uiA ) == 0;
+    bool sign = signF64UI( uiA );
+    bool fracZero = fracF64UI( uiA ) == 0;
+    bool isNaN = isNaNF64UI( uiA );
+    bool isSNaN = softfloat_isSigNaNF64UI( uiA );
+
+    return
+        (  sign && infOrNaN && fracZero )          << 0 |
+        (  sign && !infOrNaN && !subnormalOrZero ) << 1 |
+        (  sign && subnormalOrZero && !fracZero )  << 2 |
+        (  sign && subnormalOrZero && fracZero )   << 3 |
+        ( !sign && infOrNaN && fracZero )          << 7 |
+        ( !sign && !infOrNaN && !subnormalOrZero ) << 6 |
+        ( !sign && subnormalOrZero && !fracZero )  << 5 |
+        ( !sign && subnormalOrZero && fracZero )   << 4 |
+        ( isNaN &&  isSNaN )                       << 8 |
+        ( isNaN && !isSNaN )                       << 9;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_div.c b/arch/riscv/kernel/soft_vector/softfloat/f64_div.c
new file mode 100755
index 000000000..16befb2fa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_div.c
@@ -0,0 +1,172 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f64_div( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    bool signZ;
+    struct exp16_sig64 normExpSig;
+    int_fast16_t expZ;
+    uint32_t recip32, sig32Z, doubleTerm;
+    uint_fast64_t rem;
+    uint32_t q;
+    uint_fast64_t sigZ;
+    uint_fast64_t uiZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF64UI( uiB );
+    expB  = expF64UI( uiB );
+    sigB  = fracF64UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA ) goto propagateNaN;
+        if ( expB == 0x7FF ) {
+            if ( sigB ) goto propagateNaN;
+            goto invalid;
+        }
+        goto infinity;
+    }
+    if ( expB == 0x7FF ) {
+        if ( sigB ) goto propagateNaN;
+        goto zero;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) {
+            if ( ! (expA | sigA) ) goto invalid;
+            softfloat_raiseFlags( softfloat_flag_infinite );
+            goto infinity;
+        }
+        normExpSig = softfloat_normSubnormalF64Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA - expB + 0x3FE;
+    sigA |= UINT64_C( 0x0010000000000000 );
+    sigB |= UINT64_C( 0x0010000000000000 );
+    if ( sigA < sigB ) {
+        --expZ;
+        sigA <<= 11;
+    } else {
+        sigA <<= 10;
+    }
+    sigB <<= 11;
+    recip32 = softfloat_approxRecip32_1( sigB>>32 ) - 2;
+    sig32Z = ((uint32_t) (sigA>>32) * (uint_fast64_t) recip32)>>32;
+    doubleTerm = sig32Z<<1;
+    rem =
+        ((sigA - (uint_fast64_t) doubleTerm * (uint32_t) (sigB>>32))<<28)
+            - (uint_fast64_t) doubleTerm * ((uint32_t) sigB>>4);
+    q = (((uint32_t) (rem>>32) * (uint_fast64_t) recip32)>>32) + 4;
+    sigZ = ((uint_fast64_t) sig32Z<<32) + ((uint_fast64_t) q<<4);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( (sigZ & 0x1FF) < 4<<4 ) {
+        q &= ~7;
+        sigZ &= ~(uint_fast64_t) 0x7F;
+        doubleTerm = q<<1;
+        rem =
+            ((rem - (uint_fast64_t) doubleTerm * (uint32_t) (sigB>>32))<<28)
+                - (uint_fast64_t) doubleTerm * ((uint32_t) sigB>>4);
+        if ( rem & UINT64_C( 0x8000000000000000 ) ) {
+            sigZ -= 1<<7;
+        } else {
+            if ( rem ) sigZ |= 1;
+        }
+    }
+    return softfloat_roundPackToF64( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF64UI;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infinity:
+    uiZ = packToF64UI( signZ, 0x7FF, 0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF64UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_eq.c b/arch/riscv/kernel/soft_vector/softfloat/f64_eq.c
new file mode 100755
index 000000000..fe8eac058
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_eq.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f64_eq( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF64UI( uiA ) || softfloat_isSigNaNF64UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    return (uiA == uiB) || ! ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_eq_signaling.c b/arch/riscv/kernel/soft_vector/softfloat/f64_eq_signaling.c
new file mode 100755
index 000000000..1e300930c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_eq_signaling.c
@@ -0,0 +1,61 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f64_eq_signaling( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    return (uiA == uiB) || ! ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_isSignalingNaN.c b/arch/riscv/kernel/soft_vector/softfloat/f64_isSignalingNaN.c
new file mode 100755
index 000000000..0b81d4ae1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_isSignalingNaN.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f64_isSignalingNaN( float64_t a )
+{
+    union ui64_f64 uA;
+
+    uA.f = a;
+    return softfloat_isSigNaNF64UI( uA.ui );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_le.c b/arch/riscv/kernel/soft_vector/softfloat/f64_le.c
new file mode 100755
index 000000000..fabc13459
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_le.c
@@ -0,0 +1,67 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f64_le( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF64UI( uiA );
+    signB = signF64UI( uiB );
+    return
+        (signA != signB)
+            ? signA || ! ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_le_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f64_le_quiet.c
new file mode 100755
index 000000000..26d70f86f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_le_quiet.c
@@ -0,0 +1,72 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f64_le_quiet( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF64UI( uiA ) || softfloat_isSigNaNF64UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF64UI( uiA );
+    signB = signF64UI( uiB );
+    return
+        (signA != signB)
+            ? signA || ! ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_lt.c b/arch/riscv/kernel/soft_vector/softfloat/f64_lt.c
new file mode 100755
index 000000000..f42a91797
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_lt.c
@@ -0,0 +1,67 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f64_lt( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF64UI( uiA );
+    signB = signF64UI( uiB );
+    return
+        (signA != signB)
+            ? signA && ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_lt_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f64_lt_quiet.c
new file mode 100755
index 000000000..ce683a3cd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_lt_quiet.c
@@ -0,0 +1,72 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f64_lt_quiet( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF64UI( uiA ) || softfloat_isSigNaNF64UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF64UI( uiA );
+    signB = signF64UI( uiB );
+    return
+        (signA != signB)
+            ? signA && ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_mul.c b/arch/riscv/kernel/soft_vector/softfloat/f64_mul.c
new file mode 100755
index 000000000..cfaa69775
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_mul.c
@@ -0,0 +1,150 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f64_mul( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    bool signZ;
+    uint_fast64_t magBits;
+    struct exp16_sig64 normExpSig;
+    int_fast16_t expZ;
+#ifdef SOFTFLOAT_FAST_INT64
+    struct uint128 sig128Z;
+#else
+    uint32_t sig128Z[4];
+#endif
+    uint_fast64_t sigZ, uiZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF64UI( uiB );
+    expB  = expF64UI( uiB );
+    sigB  = fracF64UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA || ((expB == 0x7FF) && sigB) ) goto propagateNaN;
+        magBits = expB | sigB;
+        goto infArg;
+    }
+    if ( expB == 0x7FF ) {
+        if ( sigB ) goto propagateNaN;
+        magBits = expA | sigA;
+        goto infArg;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zero;
+        normExpSig = softfloat_normSubnormalF64Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x3FF;
+    sigA = (sigA | UINT64_C( 0x0010000000000000 ))<<10;
+    sigB = (sigB | UINT64_C( 0x0010000000000000 ))<<11;
+#ifdef SOFTFLOAT_FAST_INT64
+    sig128Z = softfloat_mul64To128( sigA, sigB );
+    sigZ = sig128Z.v64 | (sig128Z.v0 != 0);
+#else
+    softfloat_mul64To128M( sigA, sigB, sig128Z );
+    sigZ =
+        (uint64_t) sig128Z[indexWord( 4, 3 )]<<32 | sig128Z[indexWord( 4, 2 )];
+    if ( sig128Z[indexWord( 4, 1 )] || sig128Z[indexWord( 4, 0 )] ) sigZ |= 1;
+#endif
+    if ( sigZ < UINT64_C( 0x4000000000000000 ) ) {
+        --expZ;
+        sigZ <<= 1;
+    }
+    return softfloat_roundPackToF64( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infArg:
+    if ( ! magBits ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        uiZ = defaultNaNF64UI;
+    } else {
+        uiZ = packToF64UI( signZ, 0x7FF, 0 );
+    }
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF64UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_mulAdd.c b/arch/riscv/kernel/soft_vector/softfloat/f64_mulAdd.c
new file mode 100755
index 000000000..8123ef863
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_mulAdd.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t f64_mulAdd( float64_t a, float64_t b, float64_t c )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    union ui64_f64 uC;
+    uint_fast64_t uiC;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    uC.f = c;
+    uiC = uC.ui;
+    return softfloat_mulAddF64( uiA, uiB, uiC, 0 );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_rem.c b/arch/riscv/kernel/soft_vector/softfloat/f64_rem.c
new file mode 100755
index 000000000..041b8fe17
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_rem.c
@@ -0,0 +1,189 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f64_rem( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    struct exp16_sig64 normExpSig;
+    uint64_t rem;
+    int_fast16_t expDiff;
+    uint32_t q, recip32;
+    uint_fast64_t q64;
+    uint64_t altRem, meanRem;
+    bool signRem;
+    uint_fast64_t uiZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    expB = expF64UI( uiB );
+    sigB = fracF64UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA || ((expB == 0x7FF) && sigB) ) goto propagateNaN;
+        goto invalid;
+    }
+    if ( expB == 0x7FF ) {
+        if ( sigB ) goto propagateNaN;
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA < expB - 1 ) return a;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) goto invalid;
+        normExpSig = softfloat_normSubnormalF64Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    rem = sigA | UINT64_C( 0x0010000000000000 );
+    sigB |= UINT64_C( 0x0010000000000000 );
+    expDiff = expA - expB;
+    if ( expDiff < 1 ) {
+        if ( expDiff < -1 ) return a;
+        sigB <<= 9;
+        if ( expDiff ) {
+            rem <<= 8;
+            q = 0;
+        } else {
+            rem <<= 9;
+            q = (sigB <= rem);
+            if ( q ) rem -= sigB;
+        }
+    } else {
+        recip32 = softfloat_approxRecip32_1( sigB>>21 );
+        /*--------------------------------------------------------------------
+        | Changing the shift of `rem' here requires also changing the initial
+        | subtraction from `expDiff'.
+        *--------------------------------------------------------------------*/
+        rem <<= 9;
+        expDiff -= 30;
+        /*--------------------------------------------------------------------
+        | The scale of `sigB' affects how many bits are obtained during each
+        | cycle of the loop.  Currently this is 29 bits per loop iteration,
+        | the maximum possible.
+        *--------------------------------------------------------------------*/
+        sigB <<= 9;
+        for (;;) {
+            q64 = (uint32_t) (rem>>32) * (uint_fast64_t) recip32;
+            if ( expDiff < 0 ) break;
+            q = (q64 + 0x80000000)>>32;
+#ifdef SOFTFLOAT_FAST_INT64
+            rem <<= 29;
+#else
+            rem = (uint_fast64_t) (uint32_t) (rem>>3)<<32;
+#endif
+            rem -= q * (uint64_t) sigB;
+            if ( rem & UINT64_C( 0x8000000000000000 ) ) rem += sigB;
+            expDiff -= 29;
+        }
+        /*--------------------------------------------------------------------
+        | (`expDiff' cannot be less than -29 here.)
+        *--------------------------------------------------------------------*/
+        q = (uint32_t) (q64>>32)>>(~expDiff & 31);
+        rem = (rem<<(expDiff + 30)) - q * (uint64_t) sigB;
+        if ( rem & UINT64_C( 0x8000000000000000 ) ) {
+            altRem = rem + sigB;
+            goto selectRem;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    do {
+        altRem = rem;
+        ++q;
+        rem -= sigB;
+    } while ( ! (rem & UINT64_C( 0x8000000000000000 )) );
+ selectRem:
+    meanRem = rem + altRem;
+    if (
+        (meanRem & UINT64_C( 0x8000000000000000 )) || (! meanRem && (q & 1))
+    ) {
+        rem = altRem;
+    }
+    signRem = signA;
+    if ( rem & UINT64_C( 0x8000000000000000 ) ) {
+        signRem = ! signRem;
+        rem = -rem;
+    }
+    return softfloat_normRoundPackToF64( signRem, expB, rem );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+    goto uiZ;
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF64UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_roundToInt.c b/arch/riscv/kernel/soft_vector/softfloat/f64_roundToInt.c
new file mode 100755
index 000000000..c3864bdfc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_roundToInt.c
@@ -0,0 +1,112 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f64_roundToInt( float64_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    int_fast16_t exp;
+    uint_fast64_t uiZ, lastBitMask, roundBitsMask;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp <= 0x3FE ) {
+        if ( ! (uiA & UINT64_C( 0x7FFFFFFFFFFFFFFF )) ) return a;
+        if ( exact ) softfloat_exceptionFlags |= softfloat_flag_inexact;
+        uiZ = uiA & packToF64UI( 1, 0, 0 );
+        switch ( roundingMode ) {
+         case softfloat_round_near_even:
+            if ( ! fracF64UI( uiA ) ) break;
+         case softfloat_round_near_maxMag:
+            if ( exp == 0x3FE ) uiZ |= packToF64UI( 0, 0x3FF, 0 );
+            break;
+         case softfloat_round_min:
+            if ( uiZ ) uiZ = packToF64UI( 1, 0x3FF, 0 );
+            break;
+         case softfloat_round_max:
+            if ( ! uiZ ) uiZ = packToF64UI( 0, 0x3FF, 0 );
+            break;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x433 <= exp ) {
+        if ( (exp == 0x7FF) && fracF64UI( uiA ) ) {
+            uiZ = softfloat_propagateNaNF64UI( uiA, 0 );
+            goto uiZ;
+        }
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = uiA;
+    lastBitMask = (uint_fast64_t) 1<<(0x433 - exp);
+    roundBitsMask = lastBitMask - 1;
+    if ( roundingMode == softfloat_round_near_maxMag ) {
+        uiZ += lastBitMask>>1;
+    } else if ( roundingMode == softfloat_round_near_even ) {
+        uiZ += lastBitMask>>1;
+        if ( ! (uiZ & roundBitsMask) ) uiZ &= ~lastBitMask;
+    } else if (
+        roundingMode
+            == (signF64UI( uiZ ) ? softfloat_round_min : softfloat_round_max)
+    ) {
+        uiZ += roundBitsMask;
+    }
+    uiZ &= ~roundBitsMask;
+    if ( exact && (uiZ != uiA) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_sqrt.c b/arch/riscv/kernel/soft_vector/softfloat/f64_sqrt.c
new file mode 100755
index 000000000..d6d189526
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_sqrt.c
@@ -0,0 +1,133 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f64_sqrt( float64_t a )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast64_t sigA, uiZ;
+    struct exp16_sig64 normExpSig;
+    int_fast16_t expZ;
+    uint32_t sig32A, recipSqrt32, sig32Z;
+    uint_fast64_t rem;
+    uint32_t q;
+    uint_fast64_t sigZ, shiftedSigZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA ) {
+            uiZ = softfloat_propagateNaNF64UI( uiA, 0 );
+            goto uiZ;
+        }
+        if ( ! signA ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signA ) {
+        if ( ! (expA | sigA) ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    | (`sig32Z' is guaranteed to be a lower bound on the square root of
+    | `sig32A', which makes `sig32Z' also a lower bound on the square root of
+    | `sigA'.)
+    *------------------------------------------------------------------------*/
+    expZ = ((expA - 0x3FF)>>1) + 0x3FE;
+    expA &= 1;
+    sigA |= UINT64_C( 0x0010000000000000 );
+    sig32A = sigA>>21;
+    recipSqrt32 = softfloat_approxRecipSqrt32_1( expA, sig32A );
+    sig32Z = ((uint_fast64_t) sig32A * recipSqrt32)>>32;
+    if ( expA ) {
+        sigA <<= 8;
+        sig32Z >>= 1;
+    } else {
+        sigA <<= 9;
+    }
+    rem = sigA - (uint_fast64_t) sig32Z * sig32Z;
+    q = ((uint32_t) (rem>>2) * (uint_fast64_t) recipSqrt32)>>32;
+    sigZ = ((uint_fast64_t) sig32Z<<32 | 1<<5) + ((uint_fast64_t) q<<3);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( (sigZ & 0x1FF) < 0x22 ) {
+        sigZ &= ~(uint_fast64_t) 0x3F;
+        shiftedSigZ = sigZ>>6;
+        rem = (sigA<<52) - shiftedSigZ * shiftedSigZ;
+        if ( rem & UINT64_C( 0x8000000000000000 ) ) {
+            --sigZ;
+        } else {
+            if ( rem ) sigZ |= 1;
+        }
+    }
+    return softfloat_roundPackToF64( 0, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF64UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_sub.c b/arch/riscv/kernel/soft_vector/softfloat/f64_sub.c
new file mode 100755
index 000000000..aa601055f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_sub.c
@@ -0,0 +1,74 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t f64_sub( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)
+    float64_t (*magsFuncPtr)( uint_fast64_t, uint_fast64_t, bool );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF64UI( uiB );
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+    if ( signA == signB ) {
+        return softfloat_subMagsF64( uiA, uiB, signA );
+    } else {
+        return softfloat_addMagsF64( uiA, uiB, signA );
+    }
+#else
+    magsFuncPtr =
+        (signA == signB) ? softfloat_subMagsF64 : softfloat_addMagsF64;
+    return (*magsFuncPtr)( uiA, uiB, signA );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f128.c
new file mode 100755
index 000000000..361c24611
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f128.c
@@ -0,0 +1,98 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f64_to_f128( float64_t a )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t frac;
+    struct commonNaN commonNaN;
+    struct uint128 uiZ;
+    struct exp16_sig64 normExpSig;
+    struct uint128 frac128;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    frac = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FF ) {
+        if ( frac ) {
+            softfloat_f64UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF128UI( &commonNaN );
+        } else {
+            uiZ.v64 = packToF128UI64( sign, 0x7FFF, 0 );
+            uiZ.v0  = 0;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ.v64 = packToF128UI64( sign, 0, 0 );
+            uiZ.v0  = 0;
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF64Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac128 = softfloat_shortShiftLeft128( 0, frac, 60 );
+    uiZ.v64 = packToF128UI64( sign, exp + 0x3C00, frac128.v64 );
+    uiZ.v0  = frac128.v0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f16.c
new file mode 100755
index 000000000..8b4fe6668
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f16.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f64_to_f16( float64_t a )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t frac;
+    struct commonNaN commonNaN;
+    uint_fast16_t uiZ, frac16;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    frac = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FF ) {
+        if ( frac ) {
+            softfloat_f64UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF16UI( &commonNaN );
+        } else {
+            uiZ = packToF16UI( sign, 0x1F, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac16 = softfloat_shortShiftRightJam64( frac, 38 );
+    if ( ! (exp | frac16) ) {
+        uiZ = packToF16UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    return softfloat_roundPackToF16( sign, exp - 0x3F1, frac16 | 0x4000 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f32.c
new file mode 100755
index 000000000..9d8412c7b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f32.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f64_to_f32( float64_t a )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t frac;
+    struct commonNaN commonNaN;
+    uint_fast32_t uiZ, frac32;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    frac = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FF ) {
+        if ( frac ) {
+            softfloat_f64UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF32UI( &commonNaN );
+        } else {
+            uiZ = packToF32UI( sign, 0xFF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac32 = softfloat_shortShiftRightJam64( frac, 22 );
+    if ( ! (exp | frac32) ) {
+        uiZ = packToF32UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    return softfloat_roundPackToF32( sign, exp - 0x381, frac32 | 0x40000000 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32.c
new file mode 100755
index 000000000..aa3d673d5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32.c
@@ -0,0 +1,82 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f64_to_i32( float64_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    sig  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (i32_fromNaN != i32_fromPosOverflow) || (i32_fromNaN != i32_fromNegOverflow)
+    if ( (exp == 0x7FF) && sig ) {
+#if (i32_fromNaN == i32_fromPosOverflow)
+        sign = 0;
+#elif (i32_fromNaN == i32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return i32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= UINT64_C( 0x0010000000000000 );
+    shiftDist = 0x427 - exp;
+    if ( 0 < shiftDist ) sig = softfloat_shiftRightJam64( sig, shiftDist );
+    return softfloat_roundToI32( sign, sig, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32_r_minMag.c
new file mode 100755
index 000000000..ec707a1dc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32_r_minMag.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f64_to_i32_r_minMag( float64_t a, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    int_fast32_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF64UI( uiA );
+    sig = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x433 - exp;
+    if ( 53 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF64UI( uiA );
+    if ( shiftDist < 22 ) {
+        if (
+            sign && (exp == 0x41E) && (sig < UINT64_C( 0x0000000000200000 ))
+        ) {
+            if ( exact && sig ) {
+                softfloat_exceptionFlags |= softfloat_flag_inexact;
+            }
+            return -0x7FFFFFFF - 1;
+        }
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x7FF) && sig ? i32_fromNaN
+                : sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig |= UINT64_C( 0x0010000000000000 );
+    absZ = sig>>shiftDist;
+    if ( exact && ((uint_fast64_t) (uint_fast32_t) absZ<<shiftDist != sig) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64.c
new file mode 100755
index 000000000..1119cfa41
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64.c
@@ -0,0 +1,103 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f64_to_i64( float64_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+#ifdef SOFTFLOAT_FAST_INT64
+    struct uint64_extra sigExtra;
+#else
+    uint32_t extSig[3];
+#endif
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    sig  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= UINT64_C( 0x0010000000000000 );
+    shiftDist = 0x433 - exp;
+#ifdef SOFTFLOAT_FAST_INT64
+    if ( shiftDist <= 0 ) {
+        if ( shiftDist < -11 ) goto invalid;
+        sigExtra.v = sig<<-shiftDist;
+        sigExtra.extra = 0;
+    } else {
+        sigExtra = softfloat_shiftRightJam64Extra( sig, 0, shiftDist );
+    }
+    return
+        softfloat_roundToI64(
+            sign, sigExtra.v, sigExtra.extra, roundingMode, exact );
+#else
+    extSig[indexWord( 3, 0 )] = 0;
+    if ( shiftDist <= 0 ) {
+        if ( shiftDist < -11 ) goto invalid;
+        sig <<= -shiftDist;
+        extSig[indexWord( 3, 2 )] = sig>>32;
+        extSig[indexWord( 3, 1 )] = sig;
+    } else {
+        extSig[indexWord( 3, 2 )] = sig>>32;
+        extSig[indexWord( 3, 1 )] = sig;
+        softfloat_shiftRightJam96M( extSig, shiftDist, extSig );
+    }
+    return softfloat_roundMToI64( sign, extSig, roundingMode, exact );
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return
+        (exp == 0x7FF) && fracF64UI( uiA ) ? i64_fromNaN
+            : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64_r_minMag.c
new file mode 100755
index 000000000..012dce40b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64_r_minMag.c
@@ -0,0 +1,100 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f64_to_i64_r_minMag( float64_t a, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+    int_fast64_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    sig  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x433 - exp;
+    if ( shiftDist <= 0 ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( shiftDist < -10 ) {
+            if ( uiA == packToF64UI( 1, 0x43E, 0 ) ) {
+                return -INT64_C( 0x7FFFFFFFFFFFFFFF ) - 1;
+            }
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            return
+                (exp == 0x7FF) && sig ? i64_fromNaN
+                    : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig |= UINT64_C( 0x0010000000000000 );
+        absZ = sig<<-shiftDist;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( 53 <= shiftDist ) {
+            if ( exact && (exp | sig) ) {
+                softfloat_exceptionFlags |= softfloat_flag_inexact;
+            }
+            return 0;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig |= UINT64_C( 0x0010000000000000 );
+        absZ = sig>>shiftDist;
+        if ( exact && (absZ<<shiftDist != sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32.c
new file mode 100755
index 000000000..6bc754f3f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32.c
@@ -0,0 +1,82 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f64_to_ui32( float64_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    sig  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (ui32_fromNaN != ui32_fromPosOverflow) || (ui32_fromNaN != ui32_fromNegOverflow)
+    if ( (exp == 0x7FF) && sig ) {
+#if (ui32_fromNaN == ui32_fromPosOverflow)
+        sign = 0;
+#elif (ui32_fromNaN == ui32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return ui32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= UINT64_C( 0x0010000000000000 );
+    shiftDist = 0x427 - exp;
+    if ( 0 < shiftDist ) sig = softfloat_shiftRightJam64( sig, shiftDist );
+    return softfloat_roundToUI32( sign, sig, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32_r_minMag.c
new file mode 100755
index 000000000..f6cb542df
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32_r_minMag.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f64_to_ui32_r_minMag( float64_t a, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    uint_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF64UI( uiA );
+    sig = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x433 - exp;
+    if ( 53 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF64UI( uiA );
+    if ( sign || (shiftDist < 21) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x7FF) && sig ? ui32_fromNaN
+                : sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig |= UINT64_C( 0x0010000000000000 );
+    z = sig>>shiftDist;
+    if ( exact && ((uint_fast64_t) z<<shiftDist != sig) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64.c
new file mode 100755
index 000000000..93097439b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64.c
@@ -0,0 +1,103 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f64_to_ui64( float64_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+#ifdef SOFTFLOAT_FAST_INT64
+    struct uint64_extra sigExtra;
+#else
+    uint32_t extSig[3];
+#endif
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    sig  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= UINT64_C( 0x0010000000000000 );
+    shiftDist = 0x433 - exp;
+#ifdef SOFTFLOAT_FAST_INT64
+    if ( shiftDist <= 0 ) {
+        if ( shiftDist < -11 ) goto invalid;
+        sigExtra.v = sig<<-shiftDist;
+        sigExtra.extra = 0;
+    } else {
+        sigExtra = softfloat_shiftRightJam64Extra( sig, 0, shiftDist );
+    }
+    return
+        softfloat_roundToUI64(
+            sign, sigExtra.v, sigExtra.extra, roundingMode, exact );
+#else
+    extSig[indexWord( 3, 0 )] = 0;
+    if ( shiftDist <= 0 ) {
+        if ( shiftDist < -11 ) goto invalid;
+        sig <<= -shiftDist;
+        extSig[indexWord( 3, 2 )] = sig>>32;
+        extSig[indexWord( 3, 1 )] = sig;
+    } else {
+        extSig[indexWord( 3, 2 )] = sig>>32;
+        extSig[indexWord( 3, 1 )] = sig;
+        softfloat_shiftRightJam96M( extSig, shiftDist, extSig );
+    }
+    return softfloat_roundMToUI64( sign, extSig, roundingMode, exact );
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return
+        (exp == 0x7FF) && fracF64UI( uiA ) ? ui64_fromNaN
+            : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64_r_minMag.c
new file mode 100755
index 000000000..b8026022c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64_r_minMag.c
@@ -0,0 +1,93 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f64_to_ui64_r_minMag( float64_t a, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    uint_fast64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF64UI( uiA );
+    sig = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x433 - exp;
+    if ( 53 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF64UI( uiA );
+    if ( sign ) goto invalid;
+    if ( shiftDist <= 0 ) {
+        if ( shiftDist < -11 ) goto invalid;
+        z = (sig | UINT64_C( 0x0010000000000000 ))<<-shiftDist;
+    } else {
+        sig |= UINT64_C( 0x0010000000000000 );
+        z = sig>>shiftDist;
+        if ( exact && (uint64_t) (sig<<(-shiftDist & 63)) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return
+        (exp == 0x7FF) && sig ? ui64_fromNaN
+            : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/fall_maxmin.c b/arch/riscv/kernel/soft_vector/softfloat/fall_maxmin.c
new file mode 100755
index 000000000..064b7d555
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/fall_maxmin.c
@@ -0,0 +1,80 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+#define COMPARE_MAX(a, b, bits) \
+float ## bits ## _t f ## bits ## _max( float ## bits ## _t a, float ## bits ## _t b )          \
+{                                                                                              \
+    bool greater = f ## bits ## _lt_quiet(b, a) ||                                             \
+               (f ## bits ## _eq(b, a) && signF ## bits ## UI(b.v));                           \
+                                                                                               \
+    if (isNaNF ## bits ## UI(a.v) && isNaNF ## bits ## UI(b.v)) {                              \
+        union ui ## bits ## _f ## bits  ui;                                                    \
+        ui.ui = defaultNaNF ## bits ## UI;                                                     \
+        return ui.f;                                                                           \
+    } else {                                                                                   \
+        return greater || isNaNF ## bits ## UI((b).v) ? a : b;                                 \
+    }                                                                                          \
+}
+
+#define COMPARE_MIN(a, b, bits) \
+float ## bits ## _t f ## bits ## _min( float ## bits ## _t a, float ## bits ## _t b )          \
+{                                                                                              \
+    bool less = f ## bits ## _lt_quiet(a, b) ||                                                \
+               (f ## bits ## _eq(a, b) && signF ## bits ## UI(a.v));                           \
+                                                                                               \
+    if (isNaNF ## bits ## UI(a.v) && isNaNF ## bits ## UI(b.v)) {                              \
+        union ui ## bits ## _f ## bits  ui;                                                    \
+        ui.ui = defaultNaNF ## bits ## UI;                                                     \
+        return ui.f;                                                                           \
+    } else {                                                                                   \
+        return less || isNaNF ## bits ## UI((b).v) ? a : b;                                    \
+    }                                                                                          \
+}
+
+COMPARE_MAX(a, b, 16);
+COMPARE_MAX(a, b, 32);
+COMPARE_MAX(a, b, 64);
+
+COMPARE_MIN(a, b, 16);
+COMPARE_MIN(a, b, 32);
+COMPARE_MIN(a, b, 64);
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i32_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f128.c
new file mode 100755
index 000000000..8ad1b3a22
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f128.c
@@ -0,0 +1,64 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t i32_to_f128( int32_t a )
+{
+    uint_fast64_t uiZ64;
+    bool sign;
+    uint_fast32_t absA;
+    int_fast8_t shiftDist;
+    union ui128_f128 uZ;
+
+    uiZ64 = 0;
+    if ( a ) {
+        sign = (a < 0);
+        absA = sign ? -(uint_fast32_t) a : (uint_fast32_t) a;
+        shiftDist = softfloat_countLeadingZeros32( absA ) + 17;
+        uiZ64 =
+            packToF128UI64(
+                sign, 0x402E - shiftDist, (uint_fast64_t) absA<<shiftDist );
+    }
+    uZ.ui.v64 = uiZ64;
+    uZ.ui.v0  = 0;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i32_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f16.c
new file mode 100755
index 000000000..a2940d0ca
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f16.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t i32_to_f16( int32_t a )
+{
+    bool sign;
+    uint_fast32_t absA;
+    int_fast8_t shiftDist;
+    union ui16_f16 u;
+    uint_fast16_t sig;
+
+    sign = (a < 0);
+    absA = sign ? -(uint_fast32_t) a : (uint_fast32_t) a;
+    shiftDist = softfloat_countLeadingZeros32( absA ) - 21;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF16UI(
+                    sign, 0x18 - shiftDist, (uint_fast16_t) absA<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 4;
+        sig =
+            (shiftDist < 0)
+                ? absA>>(-shiftDist)
+                      | ((uint32_t) (absA<<(shiftDist & 31)) != 0)
+                : (uint_fast16_t) absA<<shiftDist;
+        return softfloat_roundPackToF16( sign, 0x1C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i32_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f32.c
new file mode 100755
index 000000000..15ada6cf8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f32.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t i32_to_f32( int32_t a )
+{
+    bool sign;
+    union ui32_f32 uZ;
+    uint_fast32_t absA;
+
+    sign = (a < 0);
+    if ( ! (a & 0x7FFFFFFF) ) {
+        uZ.ui = sign ? packToF32UI( 1, 0x9E, 0 ) : 0;
+        return uZ.f;
+    }
+    absA = sign ? -(uint_fast32_t) a : (uint_fast32_t) a;
+    return softfloat_normRoundPackToF32( sign, 0x9C, absA );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i32_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f64.c
new file mode 100755
index 000000000..17e4d7afb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f64.c
@@ -0,0 +1,65 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t i32_to_f64( int32_t a )
+{
+    uint_fast64_t uiZ;
+    bool sign;
+    uint_fast32_t absA;
+    int_fast8_t shiftDist;
+    union ui64_f64 uZ;
+
+    if ( ! a ) {
+        uiZ = 0;
+    } else {
+        sign = (a < 0);
+        absA = sign ? -(uint_fast32_t) a : (uint_fast32_t) a;
+        shiftDist = softfloat_countLeadingZeros32( absA ) + 21;
+        uiZ =
+            packToF64UI(
+                sign, 0x432 - shiftDist, (uint_fast64_t) absA<<shiftDist );
+    }
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i64_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f128.c
new file mode 100755
index 000000000..5d7307994
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f128.c
@@ -0,0 +1,72 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t i64_to_f128( int64_t a )
+{
+    uint_fast64_t uiZ64, uiZ0;
+    bool sign;
+    uint_fast64_t absA;
+    int_fast8_t shiftDist;
+    struct uint128 zSig;
+    union ui128_f128 uZ;
+
+    if ( ! a ) {
+        uiZ64 = 0;
+        uiZ0  = 0;
+    } else {
+        sign = (a < 0);
+        absA = sign ? -(uint_fast64_t) a : (uint_fast64_t) a;
+        shiftDist = softfloat_countLeadingZeros64( absA ) + 49;
+        if ( 64 <= shiftDist ) {
+            zSig.v64 = absA<<(shiftDist - 64);
+            zSig.v0  = 0;
+        } else {
+            zSig = softfloat_shortShiftLeft128( 0, absA, shiftDist );
+        }
+        uiZ64 = packToF128UI64( sign, 0x406E - shiftDist, zSig.v64 );
+        uiZ0  = zSig.v0;
+    }
+    uZ.ui.v64 = uiZ64;
+    uZ.ui.v0  = uiZ0;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i64_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f16.c
new file mode 100755
index 000000000..ba86b9b83
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f16.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t i64_to_f16( int64_t a )
+{
+    bool sign;
+    uint_fast64_t absA;
+    int_fast8_t shiftDist;
+    union ui16_f16 u;
+    uint_fast16_t sig;
+
+    sign = (a < 0);
+    absA = sign ? -(uint_fast64_t) a : (uint_fast64_t) a;
+    shiftDist = softfloat_countLeadingZeros64( absA ) - 53;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF16UI(
+                    sign, 0x18 - shiftDist, (uint_fast16_t) absA<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 4;
+        sig =
+            (shiftDist < 0)
+                ? softfloat_shortShiftRightJam64( absA, -shiftDist )
+                : (uint_fast16_t) absA<<shiftDist;
+        return softfloat_roundPackToF16( sign, 0x1C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i64_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f32.c
new file mode 100755
index 000000000..f2fc42c09
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f32.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t i64_to_f32( int64_t a )
+{
+    bool sign;
+    uint_fast64_t absA;
+    int_fast8_t shiftDist;
+    union ui32_f32 u;
+    uint_fast32_t sig;
+
+    sign = (a < 0);
+    absA = sign ? -(uint_fast64_t) a : (uint_fast64_t) a;
+    shiftDist = softfloat_countLeadingZeros64( absA ) - 40;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF32UI(
+                    sign, 0x95 - shiftDist, (uint_fast32_t) absA<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 7;
+        sig =
+            (shiftDist < 0)
+                ? softfloat_shortShiftRightJam64( absA, -shiftDist )
+                : (uint_fast32_t) absA<<shiftDist;
+        return softfloat_roundPackToF32( sign, 0x9C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i64_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f64.c
new file mode 100755
index 000000000..52df1129f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f64.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t i64_to_f64( int64_t a )
+{
+    bool sign;
+    union ui64_f64 uZ;
+    uint_fast64_t absA;
+
+    sign = (a < 0);
+    if ( ! (a & UINT64_C( 0x7FFFFFFFFFFFFFFF )) ) {
+        uZ.ui = sign ? packToF64UI( 1, 0x43E, 0 ) : 0;
+        return uZ.f;
+    }
+    absA = sign ? -(uint_fast64_t) a : (uint_fast64_t) a;
+    return softfloat_normRoundPackToF64( sign, 0x43C, absA );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/internals.h b/arch/riscv/kernel/soft_vector/softfloat/internals.h
new file mode 100755
index 000000000..16a848b2f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/internals.h
@@ -0,0 +1,286 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef internals_h
+#define internals_h 1
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "primitives.h"
+#include "softfloat_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+union ui16_f16 { uint16_t ui; float16_t f; };
+union ui32_f32 { uint32_t ui; float32_t f; };
+union ui64_f64 { uint64_t ui; float64_t f; };
+
+#ifdef SOFTFLOAT_FAST_INT64
+union extF80M_extF80 { struct extFloat80M fM; extFloat80_t f; };
+union ui128_f128 { struct uint128 ui; float128_t f; };
+#endif
+
+enum {
+    softfloat_mulAdd_subC    = 1,
+    softfloat_mulAdd_subProd = 2
+};
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+uint_fast32_t softfloat_roundToUI32( bool, uint_fast64_t, uint_fast8_t, bool );
+
+#ifdef SOFTFLOAT_FAST_INT64
+uint_fast64_t
+ softfloat_roundToUI64(
+     bool, uint_fast64_t, uint_fast64_t, uint_fast8_t, bool );
+#else
+uint_fast64_t softfloat_roundMToUI64( bool, uint32_t *, uint_fast8_t, bool );
+#endif
+
+int_fast32_t softfloat_roundToI32( bool, uint_fast64_t, uint_fast8_t, bool );
+
+#ifdef SOFTFLOAT_FAST_INT64
+int_fast64_t
+ softfloat_roundToI64(
+     bool, uint_fast64_t, uint_fast64_t, uint_fast8_t, bool );
+#else
+int_fast64_t softfloat_roundMToI64( bool, uint32_t *, uint_fast8_t, bool );
+#endif
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signF16UI( a ) ((bool) ((uint16_t) (a)>>15))
+#define expF16UI( a ) ((int_fast8_t) ((a)>>10) & 0x1F)
+#define fracF16UI( a ) ((a) & 0x03FF)
+#define packToF16UI( sign, exp, sig ) (((uint16_t) (sign)<<15) + ((uint16_t) (exp)<<10) + (sig))
+
+#define isNaNF16UI( a ) (((~(a) & 0x7C00) == 0) && ((a) & 0x03FF))
+
+struct exp8_sig16 { int_fast8_t exp; uint_fast16_t sig; };
+struct exp8_sig16 softfloat_normSubnormalF16Sig( uint_fast16_t );
+
+float16_t softfloat_roundPackToF16( bool, int_fast16_t, uint_fast16_t );
+float16_t softfloat_normRoundPackToF16( bool, int_fast16_t, uint_fast16_t );
+
+float16_t softfloat_addMagsF16( uint_fast16_t, uint_fast16_t );
+float16_t softfloat_subMagsF16( uint_fast16_t, uint_fast16_t );
+float16_t
+ softfloat_mulAddF16(
+     uint_fast16_t, uint_fast16_t, uint_fast16_t, uint_fast8_t );
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signF32UI( a ) ((bool) ((uint32_t) (a)>>31))
+#define expF32UI( a ) ((int_fast16_t) ((a)>>23) & 0xFF)
+#define fracF32UI( a ) ((a) & 0x007FFFFF)
+#define packToF32UI( sign, exp, sig ) (((uint32_t) (sign)<<31) + ((uint32_t) (exp)<<23) + (sig))
+
+#define isNaNF32UI( a ) (((~(a) & 0x7F800000) == 0) && ((a) & 0x007FFFFF))
+
+struct exp16_sig32 { int_fast16_t exp; uint_fast32_t sig; };
+struct exp16_sig32 softfloat_normSubnormalF32Sig( uint_fast32_t );
+
+float32_t softfloat_roundPackToF32( bool, int_fast16_t, uint_fast32_t );
+float32_t softfloat_normRoundPackToF32( bool, int_fast16_t, uint_fast32_t );
+
+float32_t softfloat_addMagsF32( uint_fast32_t, uint_fast32_t );
+float32_t softfloat_subMagsF32( uint_fast32_t, uint_fast32_t );
+float32_t
+ softfloat_mulAddF32(
+     uint_fast32_t, uint_fast32_t, uint_fast32_t, uint_fast8_t );
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signF64UI( a ) ((bool) ((uint64_t) (a)>>63))
+#define expF64UI( a ) ((int_fast16_t) ((a)>>52) & 0x7FF)
+#define fracF64UI( a ) ((a) & UINT64_C( 0x000FFFFFFFFFFFFF ))
+#define packToF64UI( sign, exp, sig ) ((uint64_t) (((uint_fast64_t) (sign)<<63) + ((uint_fast64_t) (exp)<<52) + (sig)))
+
+#define isNaNF64UI( a ) (((~(a) & UINT64_C( 0x7FF0000000000000 )) == 0) && ((a) & UINT64_C( 0x000FFFFFFFFFFFFF )))
+
+struct exp16_sig64 { int_fast16_t exp; uint_fast64_t sig; };
+struct exp16_sig64 softfloat_normSubnormalF64Sig( uint_fast64_t );
+
+float64_t softfloat_roundPackToF64( bool, int_fast16_t, uint_fast64_t );
+float64_t softfloat_normRoundPackToF64( bool, int_fast16_t, uint_fast64_t );
+
+float64_t softfloat_addMagsF64( uint_fast64_t, uint_fast64_t, bool );
+float64_t softfloat_subMagsF64( uint_fast64_t, uint_fast64_t, bool );
+float64_t
+ softfloat_mulAddF64(
+     uint_fast64_t, uint_fast64_t, uint_fast64_t, uint_fast8_t );
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signExtF80UI64( a64 ) ((bool) ((uint16_t) (a64)>>15))
+#define expExtF80UI64( a64 ) ((a64) & 0x7FFF)
+#define packToExtF80UI64( sign, exp ) ((uint_fast16_t) (sign)<<15 | (exp))
+
+#define isNaNExtF80UI( a64, a0 ) ((((a64) & 0x7FFF) == 0x7FFF) && ((a0) & UINT64_C( 0x7FFFFFFFFFFFFFFF )))
+
+#ifdef SOFTFLOAT_FAST_INT64
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+
+struct exp32_sig64 { int_fast32_t exp; uint64_t sig; };
+struct exp32_sig64 softfloat_normSubnormalExtF80Sig( uint_fast64_t );
+
+extFloat80_t
+ softfloat_roundPackToExtF80(
+     bool, int_fast32_t, uint_fast64_t, uint_fast64_t, uint_fast8_t );
+extFloat80_t
+ softfloat_normRoundPackToExtF80(
+     bool, int_fast32_t, uint_fast64_t, uint_fast64_t, uint_fast8_t );
+
+extFloat80_t
+ softfloat_addMagsExtF80(
+     uint_fast16_t, uint_fast64_t, uint_fast16_t, uint_fast64_t, bool );
+extFloat80_t
+ softfloat_subMagsExtF80(
+     uint_fast16_t, uint_fast64_t, uint_fast16_t, uint_fast64_t, bool );
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signF128UI64( a64 ) ((bool) ((uint64_t) (a64)>>63))
+#define expF128UI64( a64 ) ((int_fast32_t) ((a64)>>48) & 0x7FFF)
+#define fracF128UI64( a64 ) ((a64) & UINT64_C( 0x0000FFFFFFFFFFFF ))
+#define packToF128UI64( sign, exp, sig64 ) (((uint_fast64_t) (sign)<<63) + ((uint_fast64_t) (exp)<<48) + (sig64))
+
+#define isNaNF128UI( a64, a0 ) (((~(a64) & UINT64_C( 0x7FFF000000000000 )) == 0) && (a0 || ((a64) & UINT64_C( 0x0000FFFFFFFFFFFF ))))
+
+struct exp32_sig128 { int_fast32_t exp; struct uint128 sig; };
+struct exp32_sig128
+ softfloat_normSubnormalF128Sig( uint_fast64_t, uint_fast64_t );
+
+float128_t
+ softfloat_roundPackToF128(
+     bool, int_fast32_t, uint_fast64_t, uint_fast64_t, uint_fast64_t );
+float128_t
+ softfloat_normRoundPackToF128(
+     bool, int_fast32_t, uint_fast64_t, uint_fast64_t );
+
+float128_t
+ softfloat_addMagsF128(
+     uint_fast64_t, uint_fast64_t, uint_fast64_t, uint_fast64_t, bool );
+float128_t
+ softfloat_subMagsF128(
+     uint_fast64_t, uint_fast64_t, uint_fast64_t, uint_fast64_t, bool );
+float128_t
+ softfloat_mulAddF128(
+     uint_fast64_t,
+     uint_fast64_t,
+     uint_fast64_t,
+     uint_fast64_t,
+     uint_fast64_t,
+     uint_fast64_t,
+     uint_fast8_t
+ );
+
+#else
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+
+bool
+ softfloat_tryPropagateNaNExtF80M(
+     const struct extFloat80M *,
+     const struct extFloat80M *,
+     struct extFloat80M *
+ );
+void softfloat_invalidExtF80M( struct extFloat80M * );
+
+int softfloat_normExtF80SigM( uint64_t * );
+
+void
+ softfloat_roundPackMToExtF80M(
+     bool, int32_t, uint32_t *, uint_fast8_t, struct extFloat80M * );
+void
+ softfloat_normRoundPackMToExtF80M(
+     bool, int32_t, uint32_t *, uint_fast8_t, struct extFloat80M * );
+
+void
+ softfloat_addExtF80M(
+     const struct extFloat80M *,
+     const struct extFloat80M *,
+     struct extFloat80M *,
+     bool
+ );
+
+int
+ softfloat_compareNonnormExtF80M(
+     const struct extFloat80M *, const struct extFloat80M * );
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signF128UI96( a96 ) ((bool) ((uint32_t) (a96)>>31))
+#define expF128UI96( a96 ) ((int32_t) ((a96)>>16) & 0x7FFF)
+#define fracF128UI96( a96 ) ((a96) & 0x0000FFFF)
+#define packToF128UI96( sign, exp, sig96 ) (((uint32_t) (sign)<<31) + ((uint32_t) (exp)<<16) + (sig96))
+
+bool softfloat_isNaNF128M( const uint32_t * );
+
+bool
+ softfloat_tryPropagateNaNF128M(
+     const uint32_t *, const uint32_t *, uint32_t * );
+void softfloat_invalidF128M( uint32_t * );
+
+int softfloat_shiftNormSigF128M( const uint32_t *, uint_fast8_t, uint32_t * );
+
+void softfloat_roundPackMToF128M( bool, int32_t, uint32_t *, uint32_t * );
+void softfloat_normRoundPackMToF128M( bool, int32_t, uint32_t *, uint32_t * );
+
+void
+ softfloat_addF128M( const uint32_t *, const uint32_t *, uint32_t *, bool );
+void
+ softfloat_mulAddF128M(
+     const uint32_t *,
+     const uint32_t *,
+     const uint32_t *,
+     uint32_t *,
+     uint_fast8_t
+ );
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/platform.h b/arch/riscv/kernel/soft_vector/softfloat/platform.h
new file mode 100755
index 000000000..55de1941a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/platform.h
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#include "config.h"
+#ifndef WORDS_BIGENDIAN
+#define LITTLEENDIAN 1
+#endif
+
+#define INLINE_LEVEL 5
+#define SOFTFLOAT_FAST_INT64
+#define SOFTFLOAT_FAST_DIV64TO32
+#define SOFTFLOAT_ROUND_ODD
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define INLINE static inline
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/primitiveTypes.h b/arch/riscv/kernel/soft_vector/softfloat/primitiveTypes.h
new file mode 100755
index 000000000..93951bcd9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/primitiveTypes.h
@@ -0,0 +1,86 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef primitiveTypes_h
+#define primitiveTypes_h 1
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifdef SOFTFLOAT_FAST_INT64
+
+#ifdef LITTLEENDIAN
+struct uint128 { uint64_t v0, v64; };
+struct uint64_extra { uint64_t extra, v; };
+struct uint128_extra { uint64_t extra; struct uint128 v; };
+#else
+struct uint128 { uint64_t v64, v0; };
+struct uint64_extra { uint64_t v, extra; };
+struct uint128_extra { struct uint128 v; uint64_t extra; };
+#endif
+
+#endif
+
+/*----------------------------------------------------------------------------
+| These macros are used to isolate the differences in word order between big-
+| endian and little-endian platforms.
+*----------------------------------------------------------------------------*/
+#ifdef LITTLEENDIAN
+#define wordIncr 1
+#define indexWord( total, n ) (n)
+#define indexWordHi( total ) ((total) - 1)
+#define indexWordLo( total ) 0
+#define indexMultiword( total, m, n ) (n)
+#define indexMultiwordHi( total, n ) ((total) - (n))
+#define indexMultiwordLo( total, n ) 0
+#define indexMultiwordHiBut( total, n ) (n)
+#define indexMultiwordLoBut( total, n ) 0
+#define INIT_UINTM4( v3, v2, v1, v0 ) { v0, v1, v2, v3 }
+#else
+#define wordIncr -1
+#define indexWord( total, n ) ((total) - 1 - (n))
+#define indexWordHi( total ) 0
+#define indexWordLo( total ) ((total) - 1)
+#define indexMultiword( total, m, n ) ((total) - 1 - (m))
+#define indexMultiwordHi( total, n ) 0
+#define indexMultiwordLo( total, n ) ((total) - (n))
+#define indexMultiwordHiBut( total, n ) 0
+#define indexMultiwordLoBut( total, n ) (n)
+#define INIT_UINTM4( v3, v2, v1, v0 ) { v3, v2, v1, v0 }
+#endif
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/primitives.h b/arch/riscv/kernel/soft_vector/softfloat/primitives.h
new file mode 100755
index 000000000..b2bb4edbf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/primitives.h
@@ -0,0 +1,1168 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef primitives_h
+#define primitives_h 1
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "primitiveTypes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef softfloat_shortShiftRightJam64
+/*----------------------------------------------------------------------------
+| Shifts 'a' right by the number of bits given in 'dist', which must be in
+| the range 1 to 63.  If any nonzero bits are shifted off, they are "jammed"
+| into the least-significant bit of the shifted value by setting the least-
+| significant bit to 1.  This shifted-and-jammed value is returned.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+uint64_t softfloat_shortShiftRightJam64( uint64_t a, uint_fast8_t dist )
+    { return a>>dist | ((a & (((uint_fast64_t) 1<<dist) - 1)) != 0); }
+#else
+uint64_t softfloat_shortShiftRightJam64( uint64_t a, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shiftRightJam32
+/*----------------------------------------------------------------------------
+| Shifts 'a' right by the number of bits given in 'dist', which must not
+| be zero.  If any nonzero bits are shifted off, they are "jammed" into the
+| least-significant bit of the shifted value by setting the least-significant
+| bit to 1.  This shifted-and-jammed value is returned.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
+| greater than 32, the result will be either 0 or 1, depending on whether 'a'
+| is zero or nonzero.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE uint32_t softfloat_shiftRightJam32( uint32_t a, uint_fast16_t dist )
+{
+    return
+        (dist < 31) ? a>>dist | ((uint32_t) (a<<(-dist & 31)) != 0) : (a != 0);
+}
+#else
+uint32_t softfloat_shiftRightJam32( uint32_t a, uint_fast16_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shiftRightJam64
+/*----------------------------------------------------------------------------
+| Shifts 'a' right by the number of bits given in 'dist', which must not
+| be zero.  If any nonzero bits are shifted off, they are "jammed" into the
+| least-significant bit of the shifted value by setting the least-significant
+| bit to 1.  This shifted-and-jammed value is returned.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
+| greater than 64, the result will be either 0 or 1, depending on whether 'a'
+| is zero or nonzero.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (3 <= INLINE_LEVEL)
+INLINE uint64_t softfloat_shiftRightJam64( uint64_t a, uint_fast32_t dist )
+{
+    return
+        (dist < 63) ? a>>dist | ((uint64_t) (a<<(-dist & 63)) != 0) : (a != 0);
+}
+#else
+uint64_t softfloat_shiftRightJam64( uint64_t a, uint_fast32_t dist );
+#endif
+#endif
+
+/*----------------------------------------------------------------------------
+| A constant table that translates an 8-bit unsigned integer (the array index)
+| into the number of leading 0 bits before the most-significant 1 of that
+| integer.  For integer zero (index 0), the corresponding table element is 8.
+*----------------------------------------------------------------------------*/
+extern const uint_least8_t softfloat_countLeadingZeros8[256];
+
+#ifndef softfloat_countLeadingZeros16
+/*----------------------------------------------------------------------------
+| Returns the number of leading 0 bits before the most-significant 1 bit of
+| 'a'.  If 'a' is zero, 16 is returned.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE uint_fast8_t softfloat_countLeadingZeros16( uint16_t a )
+{
+    uint_fast8_t count = 8;
+    if ( 0x100 <= a ) {
+        count = 0;
+        a >>= 8;
+    }
+    count += softfloat_countLeadingZeros8[a];
+    return count;
+}
+#else
+uint_fast8_t softfloat_countLeadingZeros16( uint16_t a );
+#endif
+#endif
+
+#ifndef softfloat_countLeadingZeros32
+/*----------------------------------------------------------------------------
+| Returns the number of leading 0 bits before the most-significant 1 bit of
+| 'a'.  If 'a' is zero, 32 is returned.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (3 <= INLINE_LEVEL)
+INLINE uint_fast8_t softfloat_countLeadingZeros32( uint32_t a )
+{
+    uint_fast8_t count = 0;
+    if ( a < 0x10000 ) {
+        count = 16;
+        a <<= 16;
+    }
+    if ( a < 0x1000000 ) {
+        count += 8;
+        a <<= 8;
+    }
+    count += softfloat_countLeadingZeros8[a>>24];
+    return count;
+}
+#else
+uint_fast8_t softfloat_countLeadingZeros32( uint32_t a );
+#endif
+#endif
+
+#ifndef softfloat_countLeadingZeros64
+/*----------------------------------------------------------------------------
+| Returns the number of leading 0 bits before the most-significant 1 bit of
+| 'a'.  If 'a' is zero, 64 is returned.
+*----------------------------------------------------------------------------*/
+uint_fast8_t softfloat_countLeadingZeros64( uint64_t a );
+#endif
+
+extern const uint16_t softfloat_approxRecip_1k0s[16];
+extern const uint16_t softfloat_approxRecip_1k1s[16];
+
+#ifndef softfloat_approxRecip32_1
+/*----------------------------------------------------------------------------
+| Returns an approximation to the reciprocal of the number represented by 'a',
+| where 'a' is interpreted as an unsigned fixed-point number with one integer
+| bit and 31 fraction bits.  The 'a' input must be "normalized", meaning that
+| its most-significant bit (bit 31) must be 1.  Thus, if A is the value of
+| the fixed-point interpretation of 'a', then 1 <= A < 2.  The returned value
+| is interpreted as a pure unsigned fraction, having no integer bits and 32
+| fraction bits.  The approximation returned is never greater than the true
+| reciprocal 1/A, and it differs from the true reciprocal by at most 2.006 ulp
+| (units in the last place).
+*----------------------------------------------------------------------------*/
+#ifdef SOFTFLOAT_FAST_DIV64TO32
+#define softfloat_approxRecip32_1( a ) ((uint32_t) (UINT64_C( 0x7FFFFFFFFFFFFFFF ) / (uint32_t) (a)))
+#else
+uint32_t softfloat_approxRecip32_1( uint32_t a );
+#endif
+#endif
+
+extern const uint16_t softfloat_approxRecipSqrt_1k0s[16];
+extern const uint16_t softfloat_approxRecipSqrt_1k1s[16];
+
+#ifndef softfloat_approxRecipSqrt32_1
+/*----------------------------------------------------------------------------
+| Returns an approximation to the reciprocal of the square root of the number
+| represented by 'a', where 'a' is interpreted as an unsigned fixed-point
+| number either with one integer bit and 31 fraction bits or with two integer
+| bits and 30 fraction bits.  The format of 'a' is determined by 'oddExpA',
+| which must be either 0 or 1.  If 'oddExpA' is 1, 'a' is interpreted as
+| having one integer bit, and if 'oddExpA' is 0, 'a' is interpreted as having
+| two integer bits.  The 'a' input must be "normalized", meaning that its
+| most-significant bit (bit 31) must be 1.  Thus, if A is the value of the
+| fixed-point interpretation of 'a', it follows that 1 <= A < 2 when 'oddExpA'
+| is 1, and 2 <= A < 4 when 'oddExpA' is 0.
+|   The returned value is interpreted as a pure unsigned fraction, having
+| no integer bits and 32 fraction bits.  The approximation returned is never
+| greater than the true reciprocal 1/sqrt(A), and it differs from the true
+| reciprocal by at most 2.06 ulp (units in the last place).  The approximation
+| returned is also always within the range 0.5 to 1; thus, the most-
+| significant bit of the result is always set.
+*----------------------------------------------------------------------------*/
+uint32_t softfloat_approxRecipSqrt32_1( unsigned int oddExpA, uint32_t a );
+#endif
+
+#ifdef SOFTFLOAT_FAST_INT64
+
+/*----------------------------------------------------------------------------
+| The following functions are needed only when 'SOFTFLOAT_FAST_INT64' is
+| defined.
+*----------------------------------------------------------------------------*/
+
+#ifndef softfloat_eq128
+/*----------------------------------------------------------------------------
+| Returns true if the 128-bit unsigned integer formed by concatenating 'a64'
+| and 'a0' is equal to the 128-bit unsigned integer formed by concatenating
+| 'b64' and 'b0'.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (1 <= INLINE_LEVEL)
+INLINE
+bool softfloat_eq128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+    { return (a64 == b64) && (a0 == b0); }
+#else
+bool softfloat_eq128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 );
+#endif
+#endif
+
+#ifndef softfloat_le128
+/*----------------------------------------------------------------------------
+| Returns true if the 128-bit unsigned integer formed by concatenating 'a64'
+| and 'a0' is less than or equal to the 128-bit unsigned integer formed by
+| concatenating 'b64' and 'b0'.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+bool softfloat_le128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+    { return (a64 < b64) || ((a64 == b64) && (a0 <= b0)); }
+#else
+bool softfloat_le128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 );
+#endif
+#endif
+
+#ifndef softfloat_lt128
+/*----------------------------------------------------------------------------
+| Returns true if the 128-bit unsigned integer formed by concatenating 'a64'
+| and 'a0' is less than the 128-bit unsigned integer formed by concatenating
+| 'b64' and 'b0'.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+bool softfloat_lt128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+    { return (a64 < b64) || ((a64 == b64) && (a0 < b0)); }
+#else
+bool softfloat_lt128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftLeft128
+/*----------------------------------------------------------------------------
+| Shifts the 128 bits formed by concatenating 'a64' and 'a0' left by the
+| number of bits given in 'dist', which must be in the range 1 to 63.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+struct uint128
+ softfloat_shortShiftLeft128( uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    struct uint128 z;
+    z.v64 = a64<<dist | a0>>(-dist & 63);
+    z.v0 = a0<<dist;
+    return z;
+}
+#else
+struct uint128
+ softfloat_shortShiftLeft128( uint64_t a64, uint64_t a0, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftRight128
+/*----------------------------------------------------------------------------
+| Shifts the 128 bits formed by concatenating 'a64' and 'a0' right by the
+| number of bits given in 'dist', which must be in the range 1 to 63.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+struct uint128
+ softfloat_shortShiftRight128( uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    struct uint128 z;
+    z.v64 = a64>>dist;
+    z.v0 = a64<<(-dist & 63) | a0>>dist;
+    return z;
+}
+#else
+struct uint128
+ softfloat_shortShiftRight128( uint64_t a64, uint64_t a0, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftRightJam64Extra
+/*----------------------------------------------------------------------------
+| This function is the same as 'softfloat_shiftRightJam64Extra' (below),
+| except that 'dist' must be in the range 1 to 63.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+struct uint64_extra
+ softfloat_shortShiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast8_t dist )
+{
+    struct uint64_extra z;
+    z.v = a>>dist;
+    z.extra = a<<(-dist & 63) | (extra != 0);
+    return z;
+}
+#else
+struct uint64_extra
+ softfloat_shortShiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftRightJam128
+/*----------------------------------------------------------------------------
+| Shifts the 128 bits formed by concatenating 'a64' and 'a0' right by the
+| number of bits given in 'dist', which must be in the range 1 to 63.  If any
+| nonzero bits are shifted off, they are "jammed" into the least-significant
+| bit of the shifted value by setting the least-significant bit to 1.  This
+| shifted-and-jammed value is returned.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (3 <= INLINE_LEVEL)
+INLINE
+struct uint128
+ softfloat_shortShiftRightJam128(
+     uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    uint_fast8_t negDist = -dist;
+    struct uint128 z;
+    z.v64 = a64>>dist;
+    z.v0 =
+        a64<<(negDist & 63) | a0>>dist
+            | ((uint64_t) (a0<<(negDist & 63)) != 0);
+    return z;
+}
+#else
+struct uint128
+ softfloat_shortShiftRightJam128(
+     uint64_t a64, uint64_t a0, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftRightJam128Extra
+/*----------------------------------------------------------------------------
+| This function is the same as 'softfloat_shiftRightJam128Extra' (below),
+| except that 'dist' must be in the range 1 to 63.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (3 <= INLINE_LEVEL)
+INLINE
+struct uint128_extra
+ softfloat_shortShiftRightJam128Extra(
+     uint64_t a64, uint64_t a0, uint64_t extra, uint_fast8_t dist )
+{
+    uint_fast8_t negDist = -dist;
+    struct uint128_extra z;
+    z.v.v64 = a64>>dist;
+    z.v.v0 = a64<<(negDist & 63) | a0>>dist;
+    z.extra = a0<<(negDist & 63) | (extra != 0);
+    return z;
+}
+#else
+struct uint128_extra
+ softfloat_shortShiftRightJam128Extra(
+     uint64_t a64, uint64_t a0, uint64_t extra, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shiftRightJam64Extra
+/*----------------------------------------------------------------------------
+| Shifts the 128 bits formed by concatenating 'a' and 'extra' right by 64
+| _plus_ the number of bits given in 'dist', which must not be zero.  This
+| shifted value is at most 64 nonzero bits and is returned in the 'v' field
+| of the 'struct uint64_extra' result.  The 64-bit 'extra' field of the result
+| contains a value formed as follows from the bits that were shifted off:  The
+| _last_ bit shifted off is the most-significant bit of the 'extra' field, and
+| the other 63 bits of the 'extra' field are all zero if and only if _all_but_
+| _the_last_ bits shifted off were all zero.
+|   (This function makes more sense if 'a' and 'extra' are considered to form
+| an unsigned fixed-point number with binary point between 'a' and 'extra'.
+| This fixed-point value is shifted right by the number of bits given in
+| 'dist', and the integer part of this shifted value is returned in the 'v'
+| field of the result.  The fractional part of the shifted value is modified
+| as described above and returned in the 'extra' field of the result.)
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (4 <= INLINE_LEVEL)
+INLINE
+struct uint64_extra
+ softfloat_shiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast32_t dist )
+{
+    struct uint64_extra z;
+    if ( dist < 64 ) {
+        z.v = a>>dist;
+        z.extra = a<<(-dist & 63);
+    } else {
+        z.v = 0;
+        z.extra = (dist == 64) ? a : (a != 0);
+    }
+    z.extra |= (extra != 0);
+    return z;
+}
+#else
+struct uint64_extra
+ softfloat_shiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast32_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shiftRightJam128
+/*----------------------------------------------------------------------------
+| Shifts the 128 bits formed by concatenating 'a64' and 'a0' right by the
+| number of bits given in 'dist', which must not be zero.  If any nonzero bits
+| are shifted off, they are "jammed" into the least-significant bit of the
+| shifted value by setting the least-significant bit to 1.  This shifted-and-
+| jammed value is returned.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
+| greater than 128, the result will be either 0 or 1, depending on whether the
+| original 128 bits are all zeros.
+*----------------------------------------------------------------------------*/
+struct uint128
+ softfloat_shiftRightJam128( uint64_t a64, uint64_t a0, uint_fast32_t dist );
+#endif
+
+#ifndef softfloat_shiftRightJam128Extra
+/*----------------------------------------------------------------------------
+| Shifts the 192 bits formed by concatenating 'a64', 'a0', and 'extra' right
+| by 64 _plus_ the number of bits given in 'dist', which must not be zero.
+| This shifted value is at most 128 nonzero bits and is returned in the 'v'
+| field of the 'struct uint128_extra' result.  The 64-bit 'extra' field of the
+| result contains a value formed as follows from the bits that were shifted
+| off:  The _last_ bit shifted off is the most-significant bit of the 'extra'
+| field, and the other 63 bits of the 'extra' field are all zero if and only
+| if _all_but_the_last_ bits shifted off were all zero.
+|   (This function makes more sense if 'a64', 'a0', and 'extra' are considered
+| to form an unsigned fixed-point number with binary point between 'a0' and
+| 'extra'.  This fixed-point value is shifted right by the number of bits
+| given in 'dist', and the integer part of this shifted value is returned
+| in the 'v' field of the result.  The fractional part of the shifted value
+| is modified as described above and returned in the 'extra' field of the
+| result.)
+*----------------------------------------------------------------------------*/
+struct uint128_extra
+ softfloat_shiftRightJam128Extra(
+     uint64_t a64, uint64_t a0, uint64_t extra, uint_fast32_t dist );
+#endif
+
+#ifndef softfloat_shiftRightJam256M
+/*----------------------------------------------------------------------------
+| Shifts the 256-bit unsigned integer pointed to by 'aPtr' right by the number
+| of bits given in 'dist', which must not be zero.  If any nonzero bits are
+| shifted off, they are "jammed" into the least-significant bit of the shifted
+| value by setting the least-significant bit to 1.  This shifted-and-jammed
+| value is stored at the location pointed to by 'zPtr'.  Each of 'aPtr' and
+| 'zPtr' points to an array of four 64-bit elements that concatenate in the
+| platform's normal endian order to form a 256-bit integer.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist'
+| is greater than 256, the stored result will be either 0 or 1, depending on
+| whether the original 256 bits are all zeros.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shiftRightJam256M(
+     const uint64_t *aPtr, uint_fast32_t dist, uint64_t *zPtr );
+#endif
+
+#ifndef softfloat_add128
+/*----------------------------------------------------------------------------
+| Returns the sum of the 128-bit integer formed by concatenating 'a64' and
+| 'a0' and the 128-bit integer formed by concatenating 'b64' and 'b0'.  The
+| addition is modulo 2^128, so any carry out is lost.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+struct uint128
+ softfloat_add128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+    struct uint128 z;
+    z.v0 = a0 + b0;
+    z.v64 = a64 + b64 + (z.v0 < a0);
+    return z;
+}
+#else
+struct uint128
+ softfloat_add128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 );
+#endif
+#endif
+
+#ifndef softfloat_add256M
+/*----------------------------------------------------------------------------
+| Adds the two 256-bit integers pointed to by 'aPtr' and 'bPtr'.  The addition
+| is modulo 2^256, so any carry out is lost.  The sum is stored at the
+| location pointed to by 'zPtr'.  Each of 'aPtr', 'bPtr', and 'zPtr' points to
+| an array of four 64-bit elements that concatenate in the platform's normal
+| endian order to form a 256-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_add256M(
+     const uint64_t *aPtr, const uint64_t *bPtr, uint64_t *zPtr );
+#endif
+
+#ifndef softfloat_sub128
+/*----------------------------------------------------------------------------
+| Returns the difference of the 128-bit integer formed by concatenating 'a64'
+| and 'a0' and the 128-bit integer formed by concatenating 'b64' and 'b0'.
+| The subtraction is modulo 2^128, so any borrow out (carry out) is lost.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+struct uint128
+ softfloat_sub128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+    struct uint128 z;
+    z.v0 = a0 - b0;
+    z.v64 = a64 - b64;
+    z.v64 -= (a0 < b0);
+    return z;
+}
+#else
+struct uint128
+ softfloat_sub128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 );
+#endif
+#endif
+
+#ifndef softfloat_sub256M
+/*----------------------------------------------------------------------------
+| Subtracts the 256-bit integer pointed to by 'bPtr' from the 256-bit integer
+| pointed to by 'aPtr'.  The addition is modulo 2^256, so any borrow out
+| (carry out) is lost.  The difference is stored at the location pointed to
+| by 'zPtr'.  Each of 'aPtr', 'bPtr', and 'zPtr' points to an array of four
+| 64-bit elements that concatenate in the platform's normal endian order to
+| form a 256-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_sub256M(
+     const uint64_t *aPtr, const uint64_t *bPtr, uint64_t *zPtr );
+#endif
+
+#ifndef softfloat_mul64ByShifted32To128
+/*----------------------------------------------------------------------------
+| Returns the 128-bit product of 'a', 'b', and 2^32.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (3 <= INLINE_LEVEL)
+INLINE struct uint128 softfloat_mul64ByShifted32To128( uint64_t a, uint32_t b )
+{
+    uint_fast64_t mid;
+    struct uint128 z;
+    mid = (uint_fast64_t) (uint32_t) a * b;
+    z.v0 = mid<<32;
+    z.v64 = (uint_fast64_t) (uint32_t) (a>>32) * b + (mid>>32);
+    return z;
+}
+#else
+struct uint128 softfloat_mul64ByShifted32To128( uint64_t a, uint32_t b );
+#endif
+#endif
+
+#ifndef softfloat_mul64To128
+/*----------------------------------------------------------------------------
+| Returns the 128-bit product of 'a' and 'b'.
+*----------------------------------------------------------------------------*/
+struct uint128 softfloat_mul64To128( uint64_t a, uint64_t b );
+#endif
+
+#ifndef softfloat_mul128By32
+/*----------------------------------------------------------------------------
+| Returns the product of the 128-bit integer formed by concatenating 'a64' and
+| 'a0', multiplied by 'b'.  The multiplication is modulo 2^128; any overflow
+| bits are discarded.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (4 <= INLINE_LEVEL)
+INLINE
+struct uint128 softfloat_mul128By32( uint64_t a64, uint64_t a0, uint32_t b )
+{
+    struct uint128 z;
+    uint_fast64_t mid;
+    uint_fast32_t carry;
+    z.v0 = a0 * b;
+    mid = (uint_fast64_t) (uint32_t) (a0>>32) * b;
+    carry = (uint32_t) ((uint_fast32_t) (z.v0>>32) - (uint_fast32_t) mid);
+    z.v64 = a64 * b + (uint_fast32_t) ((mid + carry)>>32);
+    return z;
+}
+#else
+struct uint128 softfloat_mul128By32( uint64_t a64, uint64_t a0, uint32_t b );
+#endif
+#endif
+
+#ifndef softfloat_mul128To256M
+/*----------------------------------------------------------------------------
+| Multiplies the 128-bit unsigned integer formed by concatenating 'a64' and
+| 'a0' by the 128-bit unsigned integer formed by concatenating 'b64' and
+| 'b0'.  The 256-bit product is stored at the location pointed to by 'zPtr'.
+| Argument 'zPtr' points to an array of four 64-bit elements that concatenate
+| in the platform's normal endian order to form a 256-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_mul128To256M(
+     uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0, uint64_t *zPtr );
+#endif
+
+#else
+
+/*----------------------------------------------------------------------------
+| The following functions are needed only when 'SOFTFLOAT_FAST_INT64' is not
+| defined.
+*----------------------------------------------------------------------------*/
+
+#ifndef softfloat_compare96M
+/*----------------------------------------------------------------------------
+| Compares the two 96-bit unsigned integers pointed to by 'aPtr' and 'bPtr'.
+| Returns -1 if the first integer (A) is less than the second (B); returns 0
+| if the two integers are equal; and returns +1 if the first integer (A)
+| is greater than the second (B).  (The result is thus the signum of A - B.)
+| Each of 'aPtr' and 'bPtr' points to an array of three 32-bit elements that
+| concatenate in the platform's normal endian order to form a 96-bit integer.
+*----------------------------------------------------------------------------*/
+int_fast8_t softfloat_compare96M( const uint32_t *aPtr, const uint32_t *bPtr );
+#endif
+
+#ifndef softfloat_compare128M
+/*----------------------------------------------------------------------------
+| Compares the two 128-bit unsigned integers pointed to by 'aPtr' and 'bPtr'.
+| Returns -1 if the first integer (A) is less than the second (B); returns 0
+| if the two integers are equal; and returns +1 if the first integer (A)
+| is greater than the second (B).  (The result is thus the signum of A - B.)
+| Each of 'aPtr' and 'bPtr' points to an array of four 32-bit elements that
+| concatenate in the platform's normal endian order to form a 128-bit integer.
+*----------------------------------------------------------------------------*/
+int_fast8_t
+ softfloat_compare128M( const uint32_t *aPtr, const uint32_t *bPtr );
+#endif
+
+#ifndef softfloat_shortShiftLeft64To96M
+/*----------------------------------------------------------------------------
+| Extends 'a' to 96 bits and shifts the value left by the number of bits given
+| in 'dist', which must be in the range 1 to 31.  The result is stored at the
+| location pointed to by 'zPtr'.  Argument 'zPtr' points to an array of three
+| 32-bit elements that concatenate in the platform's normal endian order to
+| form a 96-bit integer.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+void
+ softfloat_shortShiftLeft64To96M(
+     uint64_t a, uint_fast8_t dist, uint32_t *zPtr )
+{
+    zPtr[indexWord( 3, 0 )] = (uint32_t) a<<dist;
+    a >>= 32 - dist;
+    zPtr[indexWord( 3, 2 )] = a>>32;
+    zPtr[indexWord( 3, 1 )] = a;
+}
+#else
+void
+ softfloat_shortShiftLeft64To96M(
+     uint64_t a, uint_fast8_t dist, uint32_t *zPtr );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftLeftM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' left by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must be in the range 1 to 31.  Any nonzero bits shifted off are lost.  The
+| shifted N-bit result is stored at the location pointed to by 'zPtr'.  Each
+| of 'aPtr' and 'zPtr' points to a 'size_words'-long array of 32-bit elements
+| that concatenate in the platform's normal endian order to form an N-bit
+| integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shortShiftLeftM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint_fast8_t dist,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_shortShiftLeft96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftLeftM' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftLeft96M( aPtr, dist, zPtr ) softfloat_shortShiftLeftM( 3, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shortShiftLeft128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftLeftM' with
+| 'size_words' = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftLeft128M( aPtr, dist, zPtr ) softfloat_shortShiftLeftM( 4, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shortShiftLeft160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftLeftM' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftLeft160M( aPtr, dist, zPtr ) softfloat_shortShiftLeftM( 5, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftLeftM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' left by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must not be zero.  Any nonzero bits shifted off are lost.  The shifted
+| N-bit result is stored at the location pointed to by 'zPtr'.  Each of 'aPtr'
+| and 'zPtr' points to a 'size_words'-long array of 32-bit elements that
+| concatenate in the platform's normal endian order to form an N-bit integer.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
+| greater than N, the stored result will be 0.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shiftLeftM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint32_t dist,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_shiftLeft96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftLeftM' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftLeft96M( aPtr, dist, zPtr ) softfloat_shiftLeftM( 3, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftLeft128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftLeftM' with
+| 'size_words' = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftLeft128M( aPtr, dist, zPtr ) softfloat_shiftLeftM( 4, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftLeft160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftLeftM' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftLeft160M( aPtr, dist, zPtr ) softfloat_shiftLeftM( 5, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shortShiftRightM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' right by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must be in the range 1 to 31.  Any nonzero bits shifted off are lost.  The
+| shifted N-bit result is stored at the location pointed to by 'zPtr'.  Each
+| of 'aPtr' and 'zPtr' points to a 'size_words'-long array of 32-bit elements
+| that concatenate in the platform's normal endian order to form an N-bit
+| integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shortShiftRightM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint_fast8_t dist,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_shortShiftRight128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftRightM' with
+| 'size_words' = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftRight128M( aPtr, dist, zPtr ) softfloat_shortShiftRightM( 4, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shortShiftRight160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftRightM' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftRight160M( aPtr, dist, zPtr ) softfloat_shortShiftRightM( 5, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shortShiftRightJamM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' right by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must be in the range 1 to 31.  If any nonzero bits are shifted off, they are
+| "jammed" into the least-significant bit of the shifted value by setting the
+| least-significant bit to 1.  This shifted-and-jammed N-bit result is stored
+| at the location pointed to by 'zPtr'.  Each of 'aPtr' and 'zPtr' points
+| to a 'size_words'-long array of 32-bit elements that concatenate in the
+| platform's normal endian order to form an N-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shortShiftRightJamM(
+     uint_fast8_t, const uint32_t *, uint_fast8_t, uint32_t * );
+#endif
+
+#ifndef softfloat_shortShiftRightJam160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftRightJamM' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftRightJam160M( aPtr, dist, zPtr ) softfloat_shortShiftRightJamM( 5, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftRightM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' right by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must not be zero.  Any nonzero bits shifted off are lost.  The shifted
+| N-bit result is stored at the location pointed to by 'zPtr'.  Each of 'aPtr'
+| and 'zPtr' points to a 'size_words'-long array of 32-bit elements that
+| concatenate in the platform's normal endian order to form an N-bit integer.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
+| greater than N, the stored result will be 0.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shiftRightM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint32_t dist,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_shiftRight96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftRightM' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftRight96M( aPtr, dist, zPtr ) softfloat_shiftRightM( 3, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftRightJamM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' right by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must not be zero.  If any nonzero bits are shifted off, they are "jammed"
+| into the least-significant bit of the shifted value by setting the least-
+| significant bit to 1.  This shifted-and-jammed N-bit result is stored
+| at the location pointed to by 'zPtr'.  Each of 'aPtr' and 'zPtr' points
+| to a 'size_words'-long array of 32-bit elements that concatenate in the
+| platform's normal endian order to form an N-bit integer.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist'
+| is greater than N, the stored result will be either 0 or 1, depending on
+| whether the original N bits are all zeros.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shiftRightJamM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint32_t dist,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_shiftRightJam96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftRightJamM' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftRightJam96M( aPtr, dist, zPtr ) softfloat_shiftRightJamM( 3, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftRightJam128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftRightJamM' with
+| 'size_words' = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftRightJam128M( aPtr, dist, zPtr ) softfloat_shiftRightJamM( 4, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftRightJam160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftRightJamM' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftRightJam160M( aPtr, dist, zPtr ) softfloat_shiftRightJamM( 5, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_addM
+/*----------------------------------------------------------------------------
+| Adds the two N-bit integers pointed to by 'aPtr' and 'bPtr', where N =
+| 'size_words' * 32.  The addition is modulo 2^N, so any carry out is lost.
+| The N-bit sum is stored at the location pointed to by 'zPtr'.  Each of
+| 'aPtr', 'bPtr', and 'zPtr' points to a 'size_words'-long array of 32-bit
+| elements that concatenate in the platform's normal endian order to form an
+| N-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_addM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_add96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_addM' with 'size_words'
+| = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_add96M( aPtr, bPtr, zPtr ) softfloat_addM( 3, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_add128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_addM' with 'size_words'
+| = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_add128M( aPtr, bPtr, zPtr ) softfloat_addM( 4, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_add160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_addM' with 'size_words'
+| = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_add160M( aPtr, bPtr, zPtr ) softfloat_addM( 5, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_addCarryM
+/*----------------------------------------------------------------------------
+| Adds the two N-bit unsigned integers pointed to by 'aPtr' and 'bPtr', where
+| N = 'size_words' * 32, plus 'carry', which must be either 0 or 1.  The N-bit
+| sum (modulo 2^N) is stored at the location pointed to by 'zPtr', and any
+| carry out is returned as the result.  Each of 'aPtr', 'bPtr', and 'zPtr'
+| points to a 'size_words'-long array of 32-bit elements that concatenate in
+| the platform's normal endian order to form an N-bit integer.
+*----------------------------------------------------------------------------*/
+uint_fast8_t
+ softfloat_addCarryM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint_fast8_t carry,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_addComplCarryM
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_addCarryM', except that
+| the value of the unsigned integer pointed to by 'bPtr' is bit-wise completed
+| before the addition.
+*----------------------------------------------------------------------------*/
+uint_fast8_t
+ softfloat_addComplCarryM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint_fast8_t carry,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_addComplCarry96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_addComplCarryM' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_addComplCarry96M( aPtr, bPtr, carry, zPtr ) softfloat_addComplCarryM( 3, aPtr, bPtr, carry, zPtr )
+#endif
+
+#ifndef softfloat_negXM
+/*----------------------------------------------------------------------------
+| Replaces the N-bit unsigned integer pointed to by 'zPtr' by the
+| 2s-complement of itself, where N = 'size_words' * 32.  Argument 'zPtr'
+| points to a 'size_words'-long array of 32-bit elements that concatenate in
+| the platform's normal endian order to form an N-bit integer.
+*----------------------------------------------------------------------------*/
+void softfloat_negXM( uint_fast8_t size_words, uint32_t *zPtr );
+#endif
+
+#ifndef softfloat_negX96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_negXM' with 'size_words'
+| = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_negX96M( zPtr ) softfloat_negXM( 3, zPtr )
+#endif
+
+#ifndef softfloat_negX128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_negXM' with 'size_words'
+| = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_negX128M( zPtr ) softfloat_negXM( 4, zPtr )
+#endif
+
+#ifndef softfloat_negX160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_negXM' with 'size_words'
+| = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_negX160M( zPtr ) softfloat_negXM( 5, zPtr )
+#endif
+
+#ifndef softfloat_negX256M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_negXM' with 'size_words'
+| = 8 (N = 256).
+*----------------------------------------------------------------------------*/
+#define softfloat_negX256M( zPtr ) softfloat_negXM( 8, zPtr )
+#endif
+
+#ifndef softfloat_sub1XM
+/*----------------------------------------------------------------------------
+| Subtracts 1 from the N-bit integer pointed to by 'zPtr', where N =
+| 'size_words' * 32.  The subtraction is modulo 2^N, so any borrow out (carry
+| out) is lost.  Argument 'zPtr' points to a 'size_words'-long array of 32-bit
+| elements that concatenate in the platform's normal endian order to form an
+| N-bit integer.
+*----------------------------------------------------------------------------*/
+void softfloat_sub1XM( uint_fast8_t size_words, uint32_t *zPtr );
+#endif
+
+#ifndef softfloat_sub1X96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_sub1XM' with 'size_words'
+| = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_sub1X96M( zPtr ) softfloat_sub1XM( 3, zPtr )
+#endif
+
+#ifndef softfloat_sub1X160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_sub1XM' with 'size_words'
+| = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_sub1X160M( zPtr ) softfloat_sub1XM( 5, zPtr )
+#endif
+
+#ifndef softfloat_subM
+/*----------------------------------------------------------------------------
+| Subtracts the two N-bit integers pointed to by 'aPtr' and 'bPtr', where N =
+| 'size_words' * 32.  The subtraction is modulo 2^N, so any borrow out (carry
+| out) is lost.  The N-bit difference is stored at the location pointed to by
+| 'zPtr'.  Each of 'aPtr', 'bPtr', and 'zPtr' points to a 'size_words'-long
+| array of 32-bit elements that concatenate in the platform's normal endian
+| order to form an N-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_subM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_sub96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_subM' with 'size_words'
+| = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_sub96M( aPtr, bPtr, zPtr ) softfloat_subM( 3, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_sub128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_subM' with 'size_words'
+| = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_sub128M( aPtr, bPtr, zPtr ) softfloat_subM( 4, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_sub160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_subM' with 'size_words'
+| = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_sub160M( aPtr, bPtr, zPtr ) softfloat_subM( 5, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_mul64To128M
+/*----------------------------------------------------------------------------
+| Multiplies 'a' and 'b' and stores the 128-bit product at the location
+| pointed to by 'zPtr'.  Argument 'zPtr' points to an array of four 32-bit
+| elements that concatenate in the platform's normal endian order to form a
+| 128-bit integer.
+*----------------------------------------------------------------------------*/
+void softfloat_mul64To128M( uint64_t a, uint64_t b, uint32_t *zPtr );
+#endif
+
+#ifndef softfloat_mul128MTo256M
+/*----------------------------------------------------------------------------
+| Multiplies the two 128-bit unsigned integers pointed to by 'aPtr' and
+| 'bPtr', and stores the 256-bit product at the location pointed to by 'zPtr'.
+| Each of 'aPtr' and 'bPtr' points to an array of four 32-bit elements that
+| concatenate in the platform's normal endian order to form a 128-bit integer.
+| Argument 'zPtr' points to an array of eight 32-bit elements that concatenate
+| to form a 256-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_mul128MTo256M(
+     const uint32_t *aPtr, const uint32_t *bPtr, uint32_t *zPtr );
+#endif
+
+#ifndef softfloat_remStepMBy32
+/*----------------------------------------------------------------------------
+| Performs a "remainder reduction step" as follows:  Arguments 'remPtr' and
+| 'bPtr' both point to N-bit unsigned integers, where N = 'size_words' * 32.
+| Defining R and B as the values of those integers, the expression (R<<'dist')
+| - B * q is computed modulo 2^N, and the N-bit result is stored at the
+| location pointed to by 'zPtr'.  Each of 'remPtr', 'bPtr', and 'zPtr' points
+| to a 'size_words'-long array of 32-bit elements that concatenate in the
+| platform's normal endian order to form an N-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_remStepMBy32(
+     uint_fast8_t size_words,
+     const uint32_t *remPtr,
+     uint_fast8_t dist,
+     const uint32_t *bPtr,
+     uint32_t q,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_remStep96MBy32
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_remStepMBy32' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_remStep96MBy32( remPtr, dist, bPtr, q, zPtr ) softfloat_remStepMBy32( 3, remPtr, dist, bPtr, q, zPtr )
+#endif
+
+#ifndef softfloat_remStep128MBy32
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_remStepMBy32' with
+| 'size_words' = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_remStep128MBy32( remPtr, dist, bPtr, q, zPtr ) softfloat_remStepMBy32( 4, remPtr, dist, bPtr, q, zPtr )
+#endif
+
+#ifndef softfloat_remStep160MBy32
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_remStepMBy32' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_remStep160MBy32( remPtr, dist, bPtr, q, zPtr ) softfloat_remStepMBy32( 5, remPtr, dist, bPtr, q, zPtr )
+#endif
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_add128.c b/arch/riscv/kernel/soft_vector/softfloat/s_add128.c
new file mode 100755
index 000000000..216309912
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_add128.c
@@ -0,0 +1,55 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_add128
+
+struct uint128
+ softfloat_add128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+    struct uint128 z;
+
+    z.v0 = a0 + b0;
+    z.v64 = a64 + b64 + (z.v0 < a0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_add256M.c b/arch/riscv/kernel/soft_vector/softfloat/s_add256M.c
new file mode 100755
index 000000000..6dfff2fe9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_add256M.c
@@ -0,0 +1,65 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_add256M
+
+void
+ softfloat_add256M(
+     const uint64_t *aPtr, const uint64_t *bPtr, uint64_t *zPtr )
+{
+    unsigned int index;
+    uint_fast8_t carry;
+    uint64_t wordA, wordZ;
+
+    index = indexWordLo( 4 );
+    carry = 0;
+    for (;;) {
+        wordA = aPtr[index];
+        wordZ = wordA + bPtr[index] + carry;
+        zPtr[index] = wordZ;
+        if ( index == indexWordHi( 4 ) ) break;
+        if ( wordZ != wordA ) carry = (wordZ < wordA);
+        index += wordIncr;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addCarryM.c b/arch/riscv/kernel/soft_vector/softfloat/s_addCarryM.c
new file mode 100755
index 000000000..caa595254
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addCarryM.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_addCarryM
+
+uint_fast8_t
+ softfloat_addCarryM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint_fast8_t carry,
+     uint32_t *zPtr
+ )
+{
+    unsigned int index, lastIndex;
+    uint32_t wordA, wordZ;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    for (;;) {
+        wordA = aPtr[index];
+        wordZ = wordA + bPtr[index] + carry;
+        zPtr[index] = wordZ;
+        if ( wordZ != wordA ) carry = (wordZ < wordA);
+        if ( index == lastIndex ) break;
+        index += wordIncr;
+    }
+    return carry;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addComplCarryM.c b/arch/riscv/kernel/soft_vector/softfloat/s_addComplCarryM.c
new file mode 100755
index 000000000..6f350ca2a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addComplCarryM.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_addComplCarryM
+
+uint_fast8_t
+ softfloat_addComplCarryM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint_fast8_t carry,
+     uint32_t *zPtr
+ )
+{
+    unsigned int index, lastIndex;
+    uint32_t wordA, wordZ;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    for (;;) {
+        wordA = aPtr[index];
+        wordZ = wordA + ~bPtr[index] + carry;
+        zPtr[index] = wordZ;
+        if ( wordZ != wordA ) carry = (wordZ < wordA);
+        if ( index == lastIndex ) break;
+        index += wordIncr;
+    }
+    return carry;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addM.c b/arch/riscv/kernel/soft_vector/softfloat/s_addM.c
new file mode 100755
index 000000000..e114815e8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addM.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_addM
+
+void
+ softfloat_addM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint32_t *zPtr
+ )
+{
+    unsigned int index, lastIndex;
+    uint_fast8_t carry;
+    uint32_t wordA, wordZ;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    carry = 0;
+    for (;;) {
+        wordA = aPtr[index];
+        wordZ = wordA + bPtr[index] + carry;
+        zPtr[index] = wordZ;
+        if ( index == lastIndex ) break;
+        if ( wordZ != wordA ) carry = (wordZ < wordA);
+        index += wordIncr;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF128.c b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF128.c
new file mode 100755
index 000000000..273753b1a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF128.c
@@ -0,0 +1,154 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+
+float128_t
+ softfloat_addMagsF128(
+     uint_fast64_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast64_t uiB64,
+     uint_fast64_t uiB0,
+     bool signZ
+ )
+{
+    int_fast32_t expA;
+    struct uint128 sigA;
+    int_fast32_t expB;
+    struct uint128 sigB;
+    int_fast32_t expDiff;
+    struct uint128 uiZ, sigZ;
+    int_fast32_t expZ;
+    uint_fast64_t sigZExtra;
+    struct uint128_extra sig128Extra;
+    union ui128_f128 uZ;
+
+    expA = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    expB = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        if ( expA == 0x7FFF ) {
+            if ( sigA.v64 | sigA.v0 | sigB.v64 | sigB.v0 ) goto propagateNaN;
+            uiZ.v64 = uiA64;
+            uiZ.v0  = uiA0;
+            goto uiZ;
+        }
+        sigZ = softfloat_add128( sigA.v64, sigA.v0, sigB.v64, sigB.v0 );
+        if ( ! expA ) {
+            uiZ.v64 = packToF128UI64( signZ, 0, sigZ.v64 );
+            uiZ.v0  = sigZ.v0;
+            goto uiZ;
+        }
+        expZ = expA;
+        sigZ.v64 |= UINT64_C( 0x0002000000000000 );
+        sigZExtra = 0;
+        goto shiftRight1;
+    }
+    if ( expDiff < 0 ) {
+        if ( expB == 0x7FFF ) {
+            if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+            uiZ.v64 = packToF128UI64( signZ, 0x7FFF, 0 );
+            uiZ.v0  = 0;
+            goto uiZ;
+        }
+        expZ = expB;
+        if ( expA ) {
+            sigA.v64 |= UINT64_C( 0x0001000000000000 );
+        } else {
+            ++expDiff;
+            sigZExtra = 0;
+            if ( ! expDiff ) goto newlyAligned;
+        }
+        sig128Extra =
+            softfloat_shiftRightJam128Extra( sigA.v64, sigA.v0, 0, -expDiff );
+        sigA = sig128Extra.v;
+        sigZExtra = sig128Extra.extra;
+    } else {
+        if ( expA == 0x7FFF ) {
+            if ( sigA.v64 | sigA.v0 ) goto propagateNaN;
+            uiZ.v64 = uiA64;
+            uiZ.v0  = uiA0;
+            goto uiZ;
+        }
+        expZ = expA;
+        if ( expB ) {
+            sigB.v64 |= UINT64_C( 0x0001000000000000 );
+        } else {
+            --expDiff;
+            sigZExtra = 0;
+            if ( ! expDiff ) goto newlyAligned;
+        }
+        sig128Extra =
+            softfloat_shiftRightJam128Extra( sigB.v64, sigB.v0, 0, expDiff );
+        sigB = sig128Extra.v;
+        sigZExtra = sig128Extra.extra;
+    }
+ newlyAligned:
+    sigZ =
+        softfloat_add128(
+            sigA.v64 | UINT64_C( 0x0001000000000000 ),
+            sigA.v0,
+            sigB.v64,
+            sigB.v0
+        );
+    --expZ;
+    if ( sigZ.v64 < UINT64_C( 0x0002000000000000 ) ) goto roundAndPack;
+    ++expZ;
+ shiftRight1:
+    sig128Extra =
+        softfloat_shortShiftRightJam128Extra(
+            sigZ.v64, sigZ.v0, sigZExtra, 1 );
+    sigZ = sig128Extra.v;
+    sigZExtra = sig128Extra.extra;
+ roundAndPack:
+    return
+        softfloat_roundPackToF128( signZ, expZ, sigZ.v64, sigZ.v0, sigZExtra );
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF16.c b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF16.c
new file mode 100755
index 000000000..58d42f5a0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF16.c
@@ -0,0 +1,183 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t softfloat_addMagsF16( uint_fast16_t uiA, uint_fast16_t uiB )
+{
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    int_fast8_t expDiff;
+    uint_fast16_t uiZ;
+    bool signZ;
+    int_fast8_t expZ;
+    uint_fast16_t sigZ;
+    uint_fast16_t sigX, sigY;
+    int_fast8_t shiftDist;
+    uint_fast32_t sig32Z;
+    int_fast8_t roundingMode;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF16UI( uiA );
+    sigA = fracF16UI( uiA );
+    expB = expF16UI( uiB );
+    sigB = fracF16UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( ! expA ) {
+            uiZ = uiA + sigB;
+            goto uiZ;
+        }
+        if ( expA == 0x1F ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            uiZ = uiA;
+            goto uiZ;
+        }
+        signZ = signF16UI( uiA );
+        expZ = expA;
+        sigZ = 0x0800 + sigA + sigB;
+        if ( ! (sigZ & 1) && (expZ < 0x1E) ) {
+            sigZ >>= 1;
+            goto pack;
+        }
+        sigZ <<= 3;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        signZ = signF16UI( uiA );
+        if ( expDiff < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            if ( expB == 0x1F ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF16UI( signZ, 0x1F, 0 );
+                goto uiZ;
+            }
+            if ( expDiff <= -13 ) {
+                uiZ = packToF16UI( signZ, expB, sigB );
+                if ( expA | sigA ) goto addEpsilon;
+                goto uiZ;
+            }
+            expZ = expB;
+            sigX = sigB | 0x0400;
+            sigY = sigA + (expA ? 0x0400 : sigA);
+            shiftDist = 19 + expDiff;
+        } else {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            uiZ = uiA;
+            if ( expA == 0x1F ) {
+                if ( sigA ) goto propagateNaN;
+                goto uiZ;
+            }
+            if ( 13 <= expDiff ) {
+                if ( expB | sigB ) goto addEpsilon;
+                goto uiZ;
+            }
+            expZ = expA;
+            sigX = sigA | 0x0400;
+            sigY = sigB + (expB ? 0x0400 : sigB);
+            shiftDist = 19 - expDiff;
+        }
+        sig32Z =
+            ((uint_fast32_t) sigX<<19) + ((uint_fast32_t) sigY<<shiftDist);
+        if ( sig32Z < 0x40000000 ) {
+            --expZ;
+            sig32Z <<= 1;
+        }
+        sigZ = sig32Z>>16;
+        if ( sig32Z & 0xFFFF ) {
+            sigZ |= 1;
+        } else {
+            if ( ! (sigZ & 0xF) && (expZ < 0x1E) ) {
+                sigZ >>= 4;
+                goto pack;
+            }
+        }
+    }
+    return softfloat_roundPackToF16( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ addEpsilon:
+    roundingMode = softfloat_roundingMode;
+    if ( roundingMode != softfloat_round_near_even ) {
+        if (
+            roundingMode
+                == (signF16UI( uiZ ) ? softfloat_round_min
+                        : softfloat_round_max)
+        ) {
+            ++uiZ;
+            if ( (uint16_t) (uiZ<<1) == 0xF800 ) {
+                softfloat_raiseFlags(
+                    softfloat_flag_overflow | softfloat_flag_inexact );
+            }
+        }
+#ifdef SOFTFLOAT_ROUND_ODD
+        else if ( roundingMode == softfloat_round_odd ) {
+            uiZ |= 1;
+        }
+#endif
+    }
+    softfloat_exceptionFlags |= softfloat_flag_inexact;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ pack:
+    uiZ = packToF16UI( signZ, expZ, sigZ );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF32.c b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF32.c
new file mode 100755
index 000000000..a96d0001d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF32.c
@@ -0,0 +1,126 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+
+float32_t softfloat_addMagsF32( uint_fast32_t uiA, uint_fast32_t uiB )
+{
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    int_fast16_t expDiff;
+    uint_fast32_t uiZ;
+    bool signZ;
+    int_fast16_t expZ;
+    uint_fast32_t sigZ;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF32UI( uiA );
+    sigA = fracF32UI( uiA );
+    expB = expF32UI( uiB );
+    sigB = fracF32UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( ! expA ) {
+            uiZ = uiA + sigB;
+            goto uiZ;
+        }
+        if ( expA == 0xFF ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            uiZ = uiA;
+            goto uiZ;
+        }
+        signZ = signF32UI( uiA );
+        expZ = expA;
+        sigZ = 0x01000000 + sigA + sigB;
+        if ( ! (sigZ & 1) && (expZ < 0xFE) ) {
+            uiZ = packToF32UI( signZ, expZ, sigZ>>1 );
+            goto uiZ;
+        }
+        sigZ <<= 6;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        signZ = signF32UI( uiA );
+        sigA <<= 6;
+        sigB <<= 6;
+        if ( expDiff < 0 ) {
+            if ( expB == 0xFF ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF32UI( signZ, 0xFF, 0 );
+                goto uiZ;
+            }
+            expZ = expB;
+            sigA += expA ? 0x20000000 : sigA;
+            sigA = softfloat_shiftRightJam32( sigA, -expDiff );
+        } else {
+            if ( expA == 0xFF ) {
+                if ( sigA ) goto propagateNaN;
+                uiZ = uiA;
+                goto uiZ;
+            }
+            expZ = expA;
+            sigB += expB ? 0x20000000 : sigB;
+            sigB = softfloat_shiftRightJam32( sigB, expDiff );
+        }
+        sigZ = 0x20000000 + sigA + sigB;
+        if ( sigZ < 0x40000000 ) {
+            --expZ;
+            sigZ <<= 1;
+        }
+    }
+    return softfloat_roundPackToF32( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF64.c b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF64.c
new file mode 100755
index 000000000..f3ade9dd7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF64.c
@@ -0,0 +1,128 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+
+float64_t
+ softfloat_addMagsF64( uint_fast64_t uiA, uint_fast64_t uiB, bool signZ )
+{
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    int_fast16_t expDiff;
+    uint_fast64_t uiZ;
+    int_fast16_t expZ;
+    uint_fast64_t sigZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF64UI( uiA );
+    sigA = fracF64UI( uiA );
+    expB = expF64UI( uiB );
+    sigB = fracF64UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( ! expA ) {
+            uiZ = uiA + sigB;
+            goto uiZ;
+        }
+        if ( expA == 0x7FF ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            uiZ = uiA;
+            goto uiZ;
+        }
+        expZ = expA;
+        sigZ = UINT64_C( 0x0020000000000000 ) + sigA + sigB;
+        sigZ <<= 9;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sigA <<= 9;
+        sigB <<= 9;
+        if ( expDiff < 0 ) {
+            if ( expB == 0x7FF ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF64UI( signZ, 0x7FF, 0 );
+                goto uiZ;
+            }
+            expZ = expB;
+            if ( expA ) {
+                sigA += UINT64_C( 0x2000000000000000 );
+            } else {
+                sigA <<= 1;
+            }
+            sigA = softfloat_shiftRightJam64( sigA, -expDiff );
+        } else {
+            if ( expA == 0x7FF ) {
+                if ( sigA ) goto propagateNaN;
+                uiZ = uiA;
+                goto uiZ;
+            }
+            expZ = expA;
+            if ( expB ) {
+                sigB += UINT64_C( 0x2000000000000000 );
+            } else {
+                sigB <<= 1;
+            }
+            sigB = softfloat_shiftRightJam64( sigB, expDiff );
+        }
+        sigZ = UINT64_C( 0x2000000000000000 ) + sigA + sigB;
+        if ( sigZ < UINT64_C( 0x4000000000000000 ) ) {
+            --expZ;
+            sigZ <<= 1;
+        }
+    }
+    return softfloat_roundPackToF64( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip32_1.c b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip32_1.c
new file mode 100755
index 000000000..913307111
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip32_1.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_approxRecip32_1
+
+extern const uint16_t softfloat_approxRecip_1k0s[16];
+extern const uint16_t softfloat_approxRecip_1k1s[16];
+
+uint32_t softfloat_approxRecip32_1( uint32_t a )
+{
+    int index;
+    uint16_t eps, r0;
+    uint32_t sigma0;
+    uint_fast32_t r;
+    uint32_t sqrSigma0;
+
+    index = a>>27 & 0xF;
+    eps = (uint16_t) (a>>11);
+    r0 = softfloat_approxRecip_1k0s[index]
+             - ((softfloat_approxRecip_1k1s[index] * (uint_fast32_t) eps)>>20);
+    sigma0 = ~(uint_fast32_t) ((r0 * (uint_fast64_t) a)>>7);
+    r = ((uint_fast32_t) r0<<16) + ((r0 * (uint_fast64_t) sigma0)>>24);
+    sqrSigma0 = ((uint_fast64_t) sigma0 * sigma0)>>32;
+    r += ((uint32_t) r * (uint_fast64_t) sqrSigma0)>>48;
+    return r;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt32_1.c b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt32_1.c
new file mode 100755
index 000000000..c95d4ef81
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt32_1.c
@@ -0,0 +1,73 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_approxRecipSqrt32_1
+
+extern const uint16_t softfloat_approxRecipSqrt_1k0s[];
+extern const uint16_t softfloat_approxRecipSqrt_1k1s[];
+
+uint32_t softfloat_approxRecipSqrt32_1( unsigned int oddExpA, uint32_t a )
+{
+    int index;
+    uint16_t eps, r0;
+    uint_fast32_t ESqrR0;
+    uint32_t sigma0;
+    uint_fast32_t r;
+    uint32_t sqrSigma0;
+
+    index = (a>>27 & 0xE) + oddExpA;
+    eps = (uint16_t) (a>>12);
+    r0 = softfloat_approxRecipSqrt_1k0s[index]
+             - ((softfloat_approxRecipSqrt_1k1s[index] * (uint_fast32_t) eps)
+                    >>20);
+    ESqrR0 = (uint_fast32_t) r0 * r0;
+    if ( ! oddExpA ) ESqrR0 <<= 1;
+    sigma0 = ~(uint_fast32_t) (((uint32_t) ESqrR0 * (uint_fast64_t) a)>>23);
+    r = ((uint_fast32_t) r0<<16) + ((r0 * (uint_fast64_t) sigma0)>>25);
+    sqrSigma0 = ((uint_fast64_t) sigma0 * sigma0)>>32;
+    r += ((uint32_t) ((r>>1) + (r>>3) - ((uint_fast32_t) r0<<14))
+              * (uint_fast64_t) sqrSigma0)
+             >>48;
+    if ( ! (r & 0x80000000) ) r = 0x80000000;
+    return r;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt_1Ks.c b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt_1Ks.c
new file mode 100755
index 000000000..6923b42e1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt_1Ks.c
@@ -0,0 +1,49 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitives.h"
+
+const uint16_t softfloat_approxRecipSqrt_1k0s[16] = {
+    0xB4C9, 0xFFAB, 0xAA7D, 0xF11C, 0xA1C5, 0xE4C7, 0x9A43, 0xDA29,
+    0x93B5, 0xD0E5, 0x8DED, 0xC8B7, 0x88C6, 0xC16D, 0x8424, 0xBAE1
+};
+const uint16_t softfloat_approxRecipSqrt_1k1s[16] = {
+    0xA5A5, 0xEA42, 0x8C21, 0xC62D, 0x788F, 0xAA7F, 0x6928, 0x94B6,
+    0x5CC7, 0x8335, 0x52A6, 0x74E2, 0x4A3E, 0x68FE, 0x432B, 0x5EFD
+};
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip_1Ks.c b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip_1Ks.c
new file mode 100755
index 000000000..e296bd44b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip_1Ks.c
@@ -0,0 +1,49 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitives.h"
+
+const uint16_t softfloat_approxRecip_1k0s[16] = {
+    0xFFC4, 0xF0BE, 0xE363, 0xD76F, 0xCCAD, 0xC2F0, 0xBA16, 0xB201,
+    0xAA97, 0xA3C6, 0x9D7A, 0x97A6, 0x923C, 0x8D32, 0x887E, 0x8417
+};
+const uint16_t softfloat_approxRecip_1k1s[16] = {
+    0xF0F1, 0xD62C, 0xBFA1, 0xAC77, 0x9C0A, 0x8DDB, 0x8185, 0x76BA,
+    0x6D3B, 0x64D4, 0x5D5C, 0x56B1, 0x50B6, 0x4B55, 0x4679, 0x4211
+};
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF128UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF128UI.c
new file mode 100755
index 000000000..9b97f3437
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF128UI.c
@@ -0,0 +1,56 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#define softfloat_commonNaNToF128UI softfloat_commonNaNToF128UI
+#include "specialize.h"
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 128-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+struct uint128 softfloat_commonNaNToF128UI( const struct commonNaN *aPtr )
+{
+    struct uint128 uiZ;
+
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+    return uiZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF16UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF16UI.c
new file mode 100755
index 000000000..861b26965
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF16UI.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF32UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF32UI.c
new file mode 100755
index 000000000..861b26965
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF32UI.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF64UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF64UI.c
new file mode 100755
index 000000000..861b26965
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF64UI.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_compare128M.c b/arch/riscv/kernel/soft_vector/softfloat/s_compare128M.c
new file mode 100755
index 000000000..205f31454
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_compare128M.c
@@ -0,0 +1,62 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_compare128M
+
+int_fast8_t softfloat_compare128M( const uint32_t *aPtr, const uint32_t *bPtr )
+{
+    unsigned int index, lastIndex;
+    uint32_t wordA, wordB;
+
+    index = indexWordHi( 4 );
+    lastIndex = indexWordLo( 4 );
+    for (;;) {
+        wordA = aPtr[index];
+        wordB = bPtr[index];
+        if ( wordA != wordB ) return (wordA < wordB) ? -1 : 1;
+        if ( index == lastIndex ) break;
+        index -= wordIncr;
+    }
+    return 0;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_compare96M.c b/arch/riscv/kernel/soft_vector/softfloat/s_compare96M.c
new file mode 100755
index 000000000..d92845e9e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_compare96M.c
@@ -0,0 +1,62 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_compare96M
+
+int_fast8_t softfloat_compare96M( const uint32_t *aPtr, const uint32_t *bPtr )
+{
+    unsigned int index, lastIndex;
+    uint32_t wordA, wordB;
+
+    index = indexWordHi( 3 );
+    lastIndex = indexWordLo( 3 );
+    for (;;) {
+        wordA = aPtr[index];
+        wordB = bPtr[index];
+        if ( wordA != wordB ) return (wordA < wordB) ? -1 : 1;
+        if ( index == lastIndex ) break;
+        index -= wordIncr;
+    }
+    return 0;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros16.c b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros16.c
new file mode 100755
index 000000000..2b5087aa9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros16.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_countLeadingZeros16
+
+#define softfloat_countLeadingZeros16 softfloat_countLeadingZeros16
+#include "primitives.h"
+
+uint_fast8_t softfloat_countLeadingZeros16( uint16_t a )
+{
+    uint_fast8_t count;
+
+    count = 8;
+    if ( 0x100 <= a ) {
+        count = 0;
+        a >>= 8;
+    }
+    count += softfloat_countLeadingZeros8[a];
+    return count;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros32.c b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros32.c
new file mode 100755
index 000000000..4c18a6e93
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros32.c
@@ -0,0 +1,64 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_countLeadingZeros32
+
+#define softfloat_countLeadingZeros32 softfloat_countLeadingZeros32
+#include "primitives.h"
+
+uint_fast8_t softfloat_countLeadingZeros32( uint32_t a )
+{
+    uint_fast8_t count;
+
+    count = 0;
+    if ( a < 0x10000 ) {
+        count = 16;
+        a <<= 16;
+    }
+    if ( a < 0x1000000 ) {
+        count += 8;
+        a <<= 8;
+    }
+    count += softfloat_countLeadingZeros8[a>>24];
+    return count;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros64.c b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros64.c
new file mode 100755
index 000000000..f9286c8d6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros64.c
@@ -0,0 +1,73 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_countLeadingZeros64
+
+#define softfloat_countLeadingZeros64 softfloat_countLeadingZeros64
+#include "primitives.h"
+
+uint_fast8_t softfloat_countLeadingZeros64( uint64_t a )
+{
+    uint_fast8_t count;
+    uint32_t a32;
+
+    count = 0;
+    a32 = a>>32;
+    if ( ! a32 ) {
+        count = 32;
+        a32 = a;
+    }
+    /*------------------------------------------------------------------------
+    | From here, result is current count + count leading zeros of `a32'.
+    *------------------------------------------------------------------------*/
+    if ( a32 < 0x10000 ) {
+        count += 16;
+        a32 <<= 16;
+    }
+    if ( a32 < 0x1000000 ) {
+        count += 8;
+        a32 <<= 8;
+    }
+    count += softfloat_countLeadingZeros8[a32>>24];
+    return count;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros8.c b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros8.c
new file mode 100755
index 000000000..4a50ce438
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros8.c
@@ -0,0 +1,59 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitives.h"
+
+const uint_least8_t softfloat_countLeadingZeros8[256] = {
+    8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_eq128.c b/arch/riscv/kernel/soft_vector/softfloat/s_eq128.c
new file mode 100755
index 000000000..1e72a165a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_eq128.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_eq128
+
+bool softfloat_eq128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+
+    return (a64 == b64) && (a0 == b0);
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_f128UIToCommonNaN.c b/arch/riscv/kernel/soft_vector/softfloat/s_f128UIToCommonNaN.c
new file mode 100755
index 000000000..861b26965
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_f128UIToCommonNaN.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_f16UIToCommonNaN.c b/arch/riscv/kernel/soft_vector/softfloat/s_f16UIToCommonNaN.c
new file mode 100755
index 000000000..861b26965
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_f16UIToCommonNaN.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_f32UIToCommonNaN.c b/arch/riscv/kernel/soft_vector/softfloat/s_f32UIToCommonNaN.c
new file mode 100755
index 000000000..861b26965
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_f32UIToCommonNaN.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_f64UIToCommonNaN.c b/arch/riscv/kernel/soft_vector/softfloat/s_f64UIToCommonNaN.c
new file mode 100755
index 000000000..861b26965
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_f64UIToCommonNaN.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_le128.c b/arch/riscv/kernel/soft_vector/softfloat/s_le128.c
new file mode 100755
index 000000000..23c1cadd2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_le128.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_le128
+
+bool softfloat_le128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+
+    return (a64 < b64) || ((a64 == b64) && (a0 <= b0));
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_lt128.c b/arch/riscv/kernel/soft_vector/softfloat/s_lt128.c
new file mode 100755
index 000000000..93c275b7f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_lt128.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_lt128
+
+bool softfloat_lt128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+
+    return (a64 < b64) || ((a64 == b64) && (a0 < b0));
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul128By32.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul128By32.c
new file mode 100755
index 000000000..4274612ff
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul128By32.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_mul128By32
+
+struct uint128 softfloat_mul128By32( uint64_t a64, uint64_t a0, uint32_t b )
+{
+    struct uint128 z;
+    uint_fast64_t mid;
+    uint_fast32_t carry;
+
+    z.v0 = a0 * b;
+    mid = (uint_fast64_t) (uint32_t) (a0>>32) * b;
+    carry = (uint32_t) ((uint_fast32_t) (z.v0>>32) - (uint_fast32_t) mid);
+    z.v64 = a64 * b + (uint_fast32_t) ((mid + carry)>>32);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul128MTo256M.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul128MTo256M.c
new file mode 100755
index 000000000..c4a666437
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul128MTo256M.c
@@ -0,0 +1,100 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_mul128MTo256M
+
+void
+ softfloat_mul128MTo256M(
+     const uint32_t *aPtr, const uint32_t *bPtr, uint32_t *zPtr )
+{
+    uint32_t *lastZPtr, wordB;
+    uint64_t dwordProd;
+    uint32_t wordZ;
+    uint_fast8_t carry;
+
+    bPtr += indexWordLo( 4 );
+    lastZPtr = zPtr + indexMultiwordHi( 8, 5 );
+    zPtr += indexMultiwordLo( 8, 5 );
+    wordB = *bPtr;
+    dwordProd = (uint64_t) aPtr[indexWord( 4, 0 )] * wordB;
+    zPtr[indexWord( 5, 0 )] = dwordProd;
+    dwordProd = (uint64_t) aPtr[indexWord( 4, 1 )] * wordB + (dwordProd>>32);
+    zPtr[indexWord( 5, 1 )] = dwordProd;
+    dwordProd = (uint64_t) aPtr[indexWord( 4, 2 )] * wordB + (dwordProd>>32);
+    zPtr[indexWord( 5, 2 )] = dwordProd;
+    dwordProd = (uint64_t) aPtr[indexWord( 4, 3 )] * wordB + (dwordProd>>32);
+    zPtr[indexWord( 5, 3 )] = dwordProd;
+    zPtr[indexWord( 5, 4 )] = dwordProd>>32;
+    do {
+        bPtr += wordIncr;
+        zPtr += wordIncr;
+        wordB = *bPtr;
+        dwordProd = (uint64_t) aPtr[indexWord( 4, 0 )] * wordB;
+        wordZ = zPtr[indexWord( 5, 0 )] + (uint32_t) dwordProd;
+        zPtr[indexWord( 5, 0 )] = wordZ;
+        carry = (wordZ < (uint32_t) dwordProd);
+        dwordProd =
+            (uint64_t) aPtr[indexWord( 4, 1 )] * wordB + (dwordProd>>32);
+        wordZ = zPtr[indexWord( 5, 1 )] + (uint32_t) dwordProd + carry;
+        zPtr[indexWord( 5, 1 )] = wordZ;
+        if ( wordZ != (uint32_t) dwordProd ) {
+            carry = (wordZ < (uint32_t) dwordProd);
+        }
+        dwordProd =
+            (uint64_t) aPtr[indexWord( 4, 2 )] * wordB + (dwordProd>>32);
+        wordZ = zPtr[indexWord( 5, 2 )] + (uint32_t) dwordProd + carry;
+        zPtr[indexWord( 5, 2 )] = wordZ;
+        if ( wordZ != (uint32_t) dwordProd ) {
+            carry = (wordZ < (uint32_t) dwordProd);
+        }
+        dwordProd =
+            (uint64_t) aPtr[indexWord( 4, 3 )] * wordB + (dwordProd>>32);
+        wordZ = zPtr[indexWord( 5, 3 )] + (uint32_t) dwordProd + carry;
+        zPtr[indexWord( 5, 3 )] = wordZ;
+        if ( wordZ != (uint32_t) dwordProd ) {
+            carry = (wordZ < (uint32_t) dwordProd);
+        }
+        zPtr[indexWord( 5, 4 )] = (dwordProd>>32) + carry;
+    } while ( zPtr != lastZPtr );
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul128To256M.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul128To256M.c
new file mode 100755
index 000000000..8fd2ce00e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul128To256M.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_mul128To256M
+
+#define softfloat_mul128To256M softfloat_mul128To256M
+#include "primitives.h"
+
+void
+ softfloat_mul128To256M(
+     uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0, uint64_t *zPtr )
+{
+    struct uint128 p0, p64, p128;
+    uint_fast64_t z64, z128, z192;
+
+    p0 = softfloat_mul64To128( a0, b0 );
+    zPtr[indexWord( 4, 0 )] = p0.v0;
+    p64 = softfloat_mul64To128( a64, b0 );
+    z64 = p64.v0 + p0.v64;
+    z128 = p64.v64 + (z64 < p64.v0);
+    p128 = softfloat_mul64To128( a64, b64 );
+    z128 += p128.v0;
+    z192 = p128.v64 + (z128 < p128.v0);
+    p64 = softfloat_mul64To128( a0, b64 );
+    z64 += p64.v0;
+    zPtr[indexWord( 4, 1 )] = z64;
+    p64.v64 += (z64 < p64.v0);
+    z128 += p64.v64;
+    zPtr[indexWord( 4, 2 )] = z128;
+    zPtr[indexWord( 4, 3 )] = z192 + (z128 < p64.v64);
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul64ByShifted32To128.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul64ByShifted32To128.c
new file mode 100755
index 000000000..8439dec33
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul64ByShifted32To128.c
@@ -0,0 +1,56 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_mul64ByShifted32To128
+
+struct uint128 softfloat_mul64ByShifted32To128( uint64_t a, uint32_t b )
+{
+    uint_fast64_t mid;
+    struct uint128 z;
+
+    mid = (uint_fast64_t) (uint32_t) a * b;
+    z.v0 = mid<<32;
+    z.v64 = (uint_fast64_t) (uint32_t) (a>>32) * b + (mid>>32);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128.c
new file mode 100755
index 000000000..3dbebd334
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_mul64To128
+
+struct uint128 softfloat_mul64To128( uint64_t a, uint64_t b )
+{
+    uint32_t a32, a0, b32, b0;
+    struct uint128 z;
+    uint64_t mid1, mid;
+
+    a32 = a>>32;
+    a0 = a;
+    b32 = b>>32;
+    b0 = b;
+    z.v0 = (uint_fast64_t) a0 * b0;
+    mid1 = (uint_fast64_t) a32 * b0;
+    mid = mid1 + (uint_fast64_t) a0 * b32;
+    z.v64 = (uint_fast64_t) a32 * b32;
+    z.v64 += (uint_fast64_t) (mid < mid1)<<32 | mid>>32;
+    mid <<= 32;
+    z.v0 += mid;
+    z.v64 += (z.v0 < mid);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128M.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128M.c
new file mode 100755
index 000000000..fa8549515
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128M.c
@@ -0,0 +1,68 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_mul64To128M
+
+void softfloat_mul64To128M( uint64_t a, uint64_t b, uint32_t *zPtr )
+{
+    uint32_t a32, a0, b32, b0;
+    uint64_t z0, mid1, z64, mid;
+
+    a32 = a>>32;
+    a0 = a;
+    b32 = b>>32;
+    b0 = b;
+    z0 = (uint64_t) a0 * b0;
+    mid1 = (uint64_t) a32 * b0;
+    mid = mid1 + (uint64_t) a0 * b32;
+    z64 = (uint64_t) a32 * b32;
+    z64 += (uint64_t) (mid < mid1)<<32 | mid>>32;
+    mid <<= 32;
+    z0 += mid;
+    zPtr[indexWord( 4, 1 )] = z0>>32;
+    zPtr[indexWord( 4, 0 )] = z0;
+    z64 += (z0 < mid);
+    zPtr[indexWord( 4, 3 )] = z64>>32;
+    zPtr[indexWord( 4, 2 )] = z64;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF128.c b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF128.c
new file mode 100755
index 000000000..cc8541372
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF128.c
@@ -0,0 +1,350 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t
+ softfloat_mulAddF128(
+     uint_fast64_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast64_t uiB64,
+     uint_fast64_t uiB0,
+     uint_fast64_t uiC64,
+     uint_fast64_t uiC0,
+     uint_fast8_t op
+ )
+{
+    bool signA;
+    int_fast32_t expA;
+    struct uint128 sigA;
+    bool signB;
+    int_fast32_t expB;
+    struct uint128 sigB;
+    bool signC;
+    int_fast32_t expC;
+    struct uint128 sigC;
+    bool signZ;
+    uint_fast64_t magBits;
+    struct uint128 uiZ;
+    struct exp32_sig128 normExpSig;
+    int_fast32_t expZ;
+    uint64_t sig256Z[4];
+    struct uint128 sigZ;
+    int_fast32_t shiftDist, expDiff;
+    struct uint128 x128;
+    uint64_t sig256C[4];
+    static uint64_t zero256[4] = INIT_UINTM4( 0, 0, 0, 0 );
+    uint_fast64_t sigZExtra, sig256Z0;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    signA = signF128UI64( uiA64 );
+    expA  = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    signB = signF128UI64( uiB64 );
+    expB  = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    signC = signF128UI64( uiC64 ) ^ (op == softfloat_mulAdd_subC);
+    expC  = expF128UI64( uiC64 );
+    sigC.v64 = fracF128UI64( uiC64 );
+    sigC.v0  = uiC0;
+    signZ = signA ^ signB ^ (op == softfloat_mulAdd_subProd);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FFF ) {
+        if (
+            (sigA.v64 | sigA.v0) || ((expB == 0x7FFF) && (sigB.v64 | sigB.v0))
+        ) {
+            goto propagateNaN_ABC;
+        }
+        magBits = expB | sigB.v64 | sigB.v0;
+        goto infProdArg;
+    }
+    if ( expB == 0x7FFF ) {
+        if ( sigB.v64 | sigB.v0 ) goto propagateNaN_ABC;
+        magBits = expA | sigA.v64 | sigA.v0;
+        goto infProdArg;
+    }
+    if ( expC == 0x7FFF ) {
+        if ( sigC.v64 | sigC.v0 ) {
+            uiZ.v64 = 0;
+            uiZ.v0  = 0;
+            goto propagateNaN_ZC;
+        }
+        uiZ.v64 = uiC64;
+        uiZ.v0  = uiC0;
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! (sigA.v64 | sigA.v0) ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF128Sig( sigA.v64, sigA.v0 );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! (sigB.v64 | sigB.v0) ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF128Sig( sigB.v64, sigB.v0 );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x3FFE;
+    sigA.v64 |= UINT64_C( 0x0001000000000000 );
+    sigB.v64 |= UINT64_C( 0x0001000000000000 );
+    sigA = softfloat_shortShiftLeft128( sigA.v64, sigA.v0, 8 );
+    sigB = softfloat_shortShiftLeft128( sigB.v64, sigB.v0, 15 );
+    softfloat_mul128To256M( sigA.v64, sigA.v0, sigB.v64, sigB.v0, sig256Z );
+    sigZ.v64 = sig256Z[indexWord( 4, 3 )];
+    sigZ.v0  = sig256Z[indexWord( 4, 2 )];
+    shiftDist = 0;
+    if ( ! (sigZ.v64 & UINT64_C( 0x0100000000000000 )) ) {
+        --expZ;
+        shiftDist = -1;
+    }
+    if ( ! expC ) {
+        if ( ! (sigC.v64 | sigC.v0) ) {
+            shiftDist += 8;
+            goto sigZ;
+        }
+        normExpSig = softfloat_normSubnormalF128Sig( sigC.v64, sigC.v0 );
+        expC = normExpSig.exp;
+        sigC = normExpSig.sig;
+    }
+    sigC.v64 |= UINT64_C( 0x0001000000000000 );
+    sigC = softfloat_shortShiftLeft128( sigC.v64, sigC.v0, 8 );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expZ - expC;
+    if ( expDiff < 0 ) {
+        expZ = expC;
+        if ( (signZ == signC) || (expDiff < -1) ) {
+            shiftDist -= expDiff;
+            if ( shiftDist ) {
+                sigZ =
+                    softfloat_shiftRightJam128( sigZ.v64, sigZ.v0, shiftDist );
+            }
+        } else {
+            if ( ! shiftDist ) {
+                x128 =
+                    softfloat_shortShiftRight128(
+                        sig256Z[indexWord( 4, 1 )], sig256Z[indexWord( 4, 0 )],
+                        1
+                    );
+                sig256Z[indexWord( 4, 1 )] = (sigZ.v0<<63) | x128.v64;
+                sig256Z[indexWord( 4, 0 )] = x128.v0;
+                sigZ = softfloat_shortShiftRight128( sigZ.v64, sigZ.v0, 1 );
+                sig256Z[indexWord( 4, 3 )] = sigZ.v64;
+                sig256Z[indexWord( 4, 2 )] = sigZ.v0;
+            }
+        }
+    } else {
+        if ( shiftDist ) softfloat_add256M( sig256Z, sig256Z, sig256Z );
+        if ( ! expDiff ) {
+            sigZ.v64 = sig256Z[indexWord( 4, 3 )];
+            sigZ.v0  = sig256Z[indexWord( 4, 2 )];
+        } else {
+            sig256C[indexWord( 4, 3 )] = sigC.v64;
+            sig256C[indexWord( 4, 2 )] = sigC.v0;
+            sig256C[indexWord( 4, 1 )] = 0;
+            sig256C[indexWord( 4, 0 )] = 0;
+            softfloat_shiftRightJam256M( sig256C, expDiff, sig256C );
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 8;
+    if ( signZ == signC ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff <= 0 ) {
+            sigZ = softfloat_add128( sigC.v64, sigC.v0, sigZ.v64, sigZ.v0 );
+        } else {
+            softfloat_add256M( sig256Z, sig256C, sig256Z );
+            sigZ.v64 = sig256Z[indexWord( 4, 3 )];
+            sigZ.v0  = sig256Z[indexWord( 4, 2 )];
+        }
+        if ( sigZ.v64 & UINT64_C( 0x0200000000000000 ) ) {
+            ++expZ;
+            shiftDist = 9;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff < 0 ) {
+            signZ = signC;
+            if ( expDiff < -1 ) {
+                sigZ =
+                    softfloat_sub128( sigC.v64, sigC.v0, sigZ.v64, sigZ.v0 );
+                sigZExtra =
+                    sig256Z[indexWord( 4, 1 )] | sig256Z[indexWord( 4, 0 )];
+                if ( sigZExtra ) {
+                    sigZ = softfloat_sub128( sigZ.v64, sigZ.v0, 0, 1 );
+                }
+                if ( ! (sigZ.v64 & UINT64_C( 0x0100000000000000 )) ) {
+                    --expZ;
+                    shiftDist = 7;
+                }
+                goto shiftRightRoundPack;
+            } else {
+                sig256C[indexWord( 4, 3 )] = sigC.v64;
+                sig256C[indexWord( 4, 2 )] = sigC.v0;
+                sig256C[indexWord( 4, 1 )] = 0;
+                sig256C[indexWord( 4, 0 )] = 0;
+                softfloat_sub256M( sig256C, sig256Z, sig256Z );
+            }
+        } else if ( ! expDiff ) {
+            sigZ = softfloat_sub128( sigZ.v64, sigZ.v0, sigC.v64, sigC.v0 );
+            if (
+                ! (sigZ.v64 | sigZ.v0) && ! sig256Z[indexWord( 4, 1 )]
+                    && ! sig256Z[indexWord( 4, 0 )]
+            ) {
+                goto completeCancellation;
+            }
+            sig256Z[indexWord( 4, 3 )] = sigZ.v64;
+            sig256Z[indexWord( 4, 2 )] = sigZ.v0;
+            if ( sigZ.v64 & UINT64_C( 0x8000000000000000 ) ) {
+                signZ = ! signZ;
+                softfloat_sub256M( zero256, sig256Z, sig256Z );
+            }
+        } else {
+            softfloat_sub256M( sig256Z, sig256C, sig256Z );
+            if ( 1 < expDiff ) {
+                sigZ.v64 = sig256Z[indexWord( 4, 3 )];
+                sigZ.v0  = sig256Z[indexWord( 4, 2 )];
+                if ( ! (sigZ.v64 & UINT64_C( 0x0100000000000000 )) ) {
+                    --expZ;
+                    shiftDist = 7;
+                }
+                goto sigZ;
+            }
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sigZ.v64  = sig256Z[indexWord( 4, 3 )];
+        sigZ.v0   = sig256Z[indexWord( 4, 2 )];
+        sigZExtra = sig256Z[indexWord( 4, 1 )];
+        sig256Z0  = sig256Z[indexWord( 4, 0 )];
+        if ( sigZ.v64 ) {
+            if ( sig256Z0 ) sigZExtra |= 1;
+        } else {
+            expZ -= 64;
+            sigZ.v64  = sigZ.v0;
+            sigZ.v0   = sigZExtra;
+            sigZExtra = sig256Z0;
+            if ( ! sigZ.v64 ) {
+                expZ -= 64;
+                sigZ.v64  = sigZ.v0;
+                sigZ.v0   = sigZExtra;
+                sigZExtra = 0;
+                if ( ! sigZ.v64 ) {
+                    expZ -= 64;
+                    sigZ.v64 = sigZ.v0;
+                    sigZ.v0  = 0;
+                }
+            }
+        }
+        shiftDist = softfloat_countLeadingZeros64( sigZ.v64 );
+        expZ += 7 - shiftDist;
+        shiftDist = 15 - shiftDist;
+        if ( 0 < shiftDist ) goto shiftRightRoundPack;
+        if ( shiftDist ) {
+            shiftDist = -shiftDist;
+            sigZ = softfloat_shortShiftLeft128( sigZ.v64, sigZ.v0, shiftDist );
+            x128 = softfloat_shortShiftLeft128( 0, sigZExtra, shiftDist );
+            sigZ.v0 |= x128.v64;
+            sigZExtra = x128.v0;
+        }
+        goto roundPack;
+    }
+ sigZ:
+    sigZExtra = sig256Z[indexWord( 4, 1 )] | sig256Z[indexWord( 4, 0 )];
+ shiftRightRoundPack:
+    sigZExtra = (uint64_t) (sigZ.v0<<(64 - shiftDist)) | (sigZExtra != 0);
+    sigZ = softfloat_shortShiftRight128( sigZ.v64, sigZ.v0, shiftDist );
+ roundPack:
+    return
+        softfloat_roundPackToF128(
+            signZ, expZ - 1, sigZ.v64, sigZ.v0, sigZExtra );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN_ABC:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+    goto propagateNaN_ZC;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infProdArg:
+    if ( magBits ) {
+        uiZ.v64 = packToF128UI64( signZ, 0x7FFF, 0 );
+        uiZ.v0 = 0;
+        if ( expC != 0x7FFF ) goto uiZ;
+        if ( sigC.v64 | sigC.v0 ) goto propagateNaN_ZC;
+        if ( signZ == signC ) goto uiZ;
+    }
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+ propagateNaN_ZC:
+    uiZ = softfloat_propagateNaNF128UI( uiZ.v64, uiZ.v0, uiC64, uiC0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zeroProd:
+    uiZ.v64 = uiC64;
+    uiZ.v0  = uiC0;
+    if ( ! (expC | sigC.v64 | sigC.v0) && (signZ != signC) ) {
+ completeCancellation:
+        uiZ.v64 =
+            packToF128UI64(
+                (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+        uiZ.v0 = 0;
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF16.c b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF16.c
new file mode 100755
index 000000000..e4550fe34
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF16.c
@@ -0,0 +1,226 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t
+ softfloat_mulAddF16(
+     uint_fast16_t uiA, uint_fast16_t uiB, uint_fast16_t uiC, uint_fast8_t op )
+{
+    bool signA;
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    bool signB;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    bool signC;
+    int_fast8_t expC;
+    uint_fast16_t sigC;
+    bool signProd;
+    uint_fast16_t magBits, uiZ;
+    struct exp8_sig16 normExpSig;
+    int_fast8_t expProd;
+    uint_fast32_t sigProd;
+    bool signZ;
+    int_fast8_t expZ;
+    uint_fast16_t sigZ;
+    int_fast8_t expDiff;
+    uint_fast32_t sig32Z, sig32C;
+    int_fast8_t shiftDist;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    signA = signF16UI( uiA );
+    expA  = expF16UI( uiA );
+    sigA  = fracF16UI( uiA );
+    signB = signF16UI( uiB );
+    expB  = expF16UI( uiB );
+    sigB  = fracF16UI( uiB );
+    signC = signF16UI( uiC ) ^ (op == softfloat_mulAdd_subC);
+    expC  = expF16UI( uiC );
+    sigC  = fracF16UI( uiC );
+    signProd = signA ^ signB ^ (op == softfloat_mulAdd_subProd);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x1F ) {
+        if ( sigA || ((expB == 0x1F) && sigB) ) goto propagateNaN_ABC;
+        magBits = expB | sigB;
+        goto infProdArg;
+    }
+    if ( expB == 0x1F ) {
+        if ( sigB ) goto propagateNaN_ABC;
+        magBits = expA | sigA;
+        goto infProdArg;
+    }
+    if ( expC == 0x1F ) {
+        if ( sigC ) {
+            uiZ = 0;
+            goto propagateNaN_ZC;
+        }
+        uiZ = uiC;
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF16Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF16Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expProd = expA + expB - 0xE;
+    sigA = (sigA | 0x0400)<<4;
+    sigB = (sigB | 0x0400)<<4;
+    sigProd = (uint_fast32_t) sigA * sigB;
+    if ( sigProd < 0x20000000 ) {
+        --expProd;
+        sigProd <<= 1;
+    }
+    signZ = signProd;
+    if ( ! expC ) {
+        if ( ! sigC ) {
+            expZ = expProd - 1;
+            sigZ = sigProd>>15 | ((sigProd & 0x7FFF) != 0);
+            goto roundPack;
+        }
+        normExpSig = softfloat_normSubnormalF16Sig( sigC );
+        expC = normExpSig.exp;
+        sigC = normExpSig.sig;
+    }
+    sigC = (sigC | 0x0400)<<3;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expProd - expC;
+    if ( signProd == signC ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff <= 0 ) {
+            expZ = expC;
+            sigZ = sigC + softfloat_shiftRightJam32( sigProd, 16 - expDiff );
+        } else {
+            expZ = expProd;
+            sig32Z =
+                sigProd
+                    + softfloat_shiftRightJam32(
+                          (uint_fast32_t) sigC<<16, expDiff );
+            sigZ = sig32Z>>16 | ((sig32Z & 0xFFFF) != 0 );
+        }
+        if ( sigZ < 0x4000 ) {
+            --expZ;
+            sigZ <<= 1;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig32C = (uint_fast32_t) sigC<<16;
+        if ( expDiff < 0 ) {
+            signZ = signC;
+            expZ = expC;
+            sig32Z = sig32C - softfloat_shiftRightJam32( sigProd, -expDiff );
+        } else if ( ! expDiff ) {
+            expZ = expProd;
+            sig32Z = sigProd - sig32C;
+            if ( ! sig32Z ) goto completeCancellation;
+            if ( sig32Z & 0x80000000 ) {
+                signZ = ! signZ;
+                sig32Z = -sig32Z;
+            }
+        } else {
+            expZ = expProd;
+            sig32Z = sigProd - softfloat_shiftRightJam32( sig32C, expDiff );
+        }
+        shiftDist = softfloat_countLeadingZeros32( sig32Z ) - 1;
+        expZ -= shiftDist;
+        shiftDist -= 16;
+        if ( shiftDist < 0 ) {
+            sigZ =
+                sig32Z>>(-shiftDist)
+                    | ((uint32_t) (sig32Z<<(shiftDist & 31)) != 0);
+        } else {
+            sigZ = (uint_fast16_t) sig32Z<<shiftDist;
+        }
+    }
+ roundPack:
+    return softfloat_roundPackToF16( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN_ABC:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto propagateNaN_ZC;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infProdArg:
+    if ( magBits ) {
+        uiZ = packToF16UI( signProd, 0x1F, 0 );
+        if ( expC != 0x1F ) goto uiZ;
+        if ( sigC ) goto propagateNaN_ZC;
+        if ( signProd == signC ) goto uiZ;
+    }
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF16UI;
+ propagateNaN_ZC:
+    uiZ = softfloat_propagateNaNF16UI( uiZ, uiC );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zeroProd:
+    uiZ = uiC;
+    if ( ! (expC | sigC) && (signProd != signC) ) {
+ completeCancellation:
+        uiZ =
+            packToF16UI(
+                (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF32.c b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF32.c
new file mode 100755
index 000000000..90face073
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF32.c
@@ -0,0 +1,224 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t
+ softfloat_mulAddF32(
+     uint_fast32_t uiA, uint_fast32_t uiB, uint_fast32_t uiC, uint_fast8_t op )
+{
+    bool signA;
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    bool signC;
+    int_fast16_t expC;
+    uint_fast32_t sigC;
+    bool signProd;
+    uint_fast32_t magBits, uiZ;
+    struct exp16_sig32 normExpSig;
+    int_fast16_t expProd;
+    uint_fast64_t sigProd;
+    bool signZ;
+    int_fast16_t expZ;
+    uint_fast32_t sigZ;
+    int_fast16_t expDiff;
+    uint_fast64_t sig64Z, sig64C;
+    int_fast8_t shiftDist;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    signA = signF32UI( uiA );
+    expA  = expF32UI( uiA );
+    sigA  = fracF32UI( uiA );
+    signB = signF32UI( uiB );
+    expB  = expF32UI( uiB );
+    sigB  = fracF32UI( uiB );
+    signC = signF32UI( uiC ) ^ (op == softfloat_mulAdd_subC);
+    expC  = expF32UI( uiC );
+    sigC  = fracF32UI( uiC );
+    signProd = signA ^ signB ^ (op == softfloat_mulAdd_subProd);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0xFF ) {
+        if ( sigA || ((expB == 0xFF) && sigB) ) goto propagateNaN_ABC;
+        magBits = expB | sigB;
+        goto infProdArg;
+    }
+    if ( expB == 0xFF ) {
+        if ( sigB ) goto propagateNaN_ABC;
+        magBits = expA | sigA;
+        goto infProdArg;
+    }
+    if ( expC == 0xFF ) {
+        if ( sigC ) {
+            uiZ = 0;
+            goto propagateNaN_ZC;
+        }
+        uiZ = uiC;
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF32Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF32Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expProd = expA + expB - 0x7E;
+    sigA = (sigA | 0x00800000)<<7;
+    sigB = (sigB | 0x00800000)<<7;
+    sigProd = (uint_fast64_t) sigA * sigB;
+    if ( sigProd < UINT64_C( 0x2000000000000000 ) ) {
+        --expProd;
+        sigProd <<= 1;
+    }
+    signZ = signProd;
+    if ( ! expC ) {
+        if ( ! sigC ) {
+            expZ = expProd - 1;
+            sigZ = softfloat_shortShiftRightJam64( sigProd, 31 );
+            goto roundPack;
+        }
+        normExpSig = softfloat_normSubnormalF32Sig( sigC );
+        expC = normExpSig.exp;
+        sigC = normExpSig.sig;
+    }
+    sigC = (sigC | 0x00800000)<<6;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expProd - expC;
+    if ( signProd == signC ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff <= 0 ) {
+            expZ = expC;
+            sigZ = sigC + softfloat_shiftRightJam64( sigProd, 32 - expDiff );
+        } else {
+            expZ = expProd;
+            sig64Z =
+                sigProd
+                    + softfloat_shiftRightJam64(
+                          (uint_fast64_t) sigC<<32, expDiff );
+            sigZ = softfloat_shortShiftRightJam64( sig64Z, 32 );
+        }
+        if ( sigZ < 0x40000000 ) {
+            --expZ;
+            sigZ <<= 1;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig64C = (uint_fast64_t) sigC<<32;
+        if ( expDiff < 0 ) {
+            signZ = signC;
+            expZ = expC;
+            sig64Z = sig64C - softfloat_shiftRightJam64( sigProd, -expDiff );
+        } else if ( ! expDiff ) {
+            expZ = expProd;
+            sig64Z = sigProd - sig64C;
+            if ( ! sig64Z ) goto completeCancellation;
+            if ( sig64Z & UINT64_C( 0x8000000000000000 ) ) {
+                signZ = ! signZ;
+                sig64Z = -sig64Z;
+            }
+        } else {
+            expZ = expProd;
+            sig64Z = sigProd - softfloat_shiftRightJam64( sig64C, expDiff );
+        }
+        shiftDist = softfloat_countLeadingZeros64( sig64Z ) - 1;
+        expZ -= shiftDist;
+        shiftDist -= 32;
+        if ( shiftDist < 0 ) {
+            sigZ = softfloat_shortShiftRightJam64( sig64Z, -shiftDist );
+        } else {
+            sigZ = (uint_fast32_t) sig64Z<<shiftDist;
+        }
+    }
+ roundPack:
+    return softfloat_roundPackToF32( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN_ABC:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+    goto propagateNaN_ZC;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infProdArg:
+    if ( magBits ) {
+        uiZ = packToF32UI( signProd, 0xFF, 0 );
+        if ( expC != 0xFF ) goto uiZ;
+        if ( sigC ) goto propagateNaN_ZC;
+        if ( signProd == signC ) goto uiZ;
+    }
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF32UI;
+ propagateNaN_ZC:
+    uiZ = softfloat_propagateNaNF32UI( uiZ, uiC );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zeroProd:
+    uiZ = uiC;
+    if ( ! (expC | sigC) && (signProd != signC) ) {
+ completeCancellation:
+        uiZ =
+            packToF32UI(
+                (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF64.c b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF64.c
new file mode 100755
index 000000000..f6e7c5c51
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF64.c
@@ -0,0 +1,496 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+#ifdef SOFTFLOAT_FAST_INT64
+
+float64_t
+ softfloat_mulAddF64(
+     uint_fast64_t uiA, uint_fast64_t uiB, uint_fast64_t uiC, uint_fast8_t op )
+{
+    bool signA;
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    bool signC;
+    int_fast16_t expC;
+    uint_fast64_t sigC;
+    bool signZ;
+    uint_fast64_t magBits, uiZ;
+    struct exp16_sig64 normExpSig;
+    int_fast16_t expZ;
+    struct uint128 sig128Z;
+    uint_fast64_t sigZ;
+    int_fast16_t expDiff;
+    struct uint128 sig128C;
+    int_fast8_t shiftDist;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    signB = signF64UI( uiB );
+    expB  = expF64UI( uiB );
+    sigB  = fracF64UI( uiB );
+    signC = signF64UI( uiC ) ^ (op == softfloat_mulAdd_subC);
+    expC  = expF64UI( uiC );
+    sigC  = fracF64UI( uiC );
+    signZ = signA ^ signB ^ (op == softfloat_mulAdd_subProd);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA || ((expB == 0x7FF) && sigB) ) goto propagateNaN_ABC;
+        magBits = expB | sigB;
+        goto infProdArg;
+    }
+    if ( expB == 0x7FF ) {
+        if ( sigB ) goto propagateNaN_ABC;
+        magBits = expA | sigA;
+        goto infProdArg;
+    }
+    if ( expC == 0x7FF ) {
+        if ( sigC ) {
+            uiZ = 0;
+            goto propagateNaN_ZC;
+        }
+        uiZ = uiC;
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF64Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x3FE;
+    sigA = (sigA | UINT64_C( 0x0010000000000000 ))<<10;
+    sigB = (sigB | UINT64_C( 0x0010000000000000 ))<<10;
+    sig128Z = softfloat_mul64To128( sigA, sigB );
+    if ( sig128Z.v64 < UINT64_C( 0x2000000000000000 ) ) {
+        --expZ;
+        sig128Z =
+            softfloat_add128(
+                sig128Z.v64, sig128Z.v0, sig128Z.v64, sig128Z.v0 );
+    }
+    if ( ! expC ) {
+        if ( ! sigC ) {
+            --expZ;
+            sigZ = sig128Z.v64<<1 | (sig128Z.v0 != 0);
+            goto roundPack;
+        }
+        normExpSig = softfloat_normSubnormalF64Sig( sigC );
+        expC = normExpSig.exp;
+        sigC = normExpSig.sig;
+    }
+    sigC = (sigC | UINT64_C( 0x0010000000000000 ))<<9;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expZ - expC;
+    if ( expDiff < 0 ) {
+        expZ = expC;
+        if ( (signZ == signC) || (expDiff < -1) ) {
+            sig128Z.v64 = softfloat_shiftRightJam64( sig128Z.v64, -expDiff );
+        } else {
+            sig128Z =
+                softfloat_shortShiftRightJam128( sig128Z.v64, sig128Z.v0, 1 );
+        }
+    } else if ( expDiff ) {
+        sig128C = softfloat_shiftRightJam128( sigC, 0, expDiff );
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signZ == signC ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff <= 0 ) {
+            sigZ = (sigC + sig128Z.v64) | (sig128Z.v0 != 0);
+        } else {
+            sig128Z =
+                softfloat_add128(
+                    sig128Z.v64, sig128Z.v0, sig128C.v64, sig128C.v0 );
+            sigZ = sig128Z.v64 | (sig128Z.v0 != 0);
+        }
+        if ( sigZ < UINT64_C( 0x4000000000000000 ) ) {
+            --expZ;
+            sigZ <<= 1;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff < 0 ) {
+            signZ = signC;
+            sig128Z = softfloat_sub128( sigC, 0, sig128Z.v64, sig128Z.v0 );
+        } else if ( ! expDiff ) {
+            sig128Z.v64 = sig128Z.v64 - sigC;
+            if ( ! (sig128Z.v64 | sig128Z.v0) ) goto completeCancellation;
+            if ( sig128Z.v64 & UINT64_C( 0x8000000000000000 ) ) {
+                signZ = ! signZ;
+                sig128Z = softfloat_sub128( 0, 0, sig128Z.v64, sig128Z.v0 );
+            }
+        } else {
+            sig128Z =
+                softfloat_sub128(
+                    sig128Z.v64, sig128Z.v0, sig128C.v64, sig128C.v0 );
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( ! sig128Z.v64 ) {
+            expZ -= 64;
+            sig128Z.v64 = sig128Z.v0;
+            sig128Z.v0 = 0;
+        }
+        shiftDist = softfloat_countLeadingZeros64( sig128Z.v64 ) - 1;
+        expZ -= shiftDist;
+        if ( shiftDist < 0 ) {
+            sigZ = softfloat_shortShiftRightJam64( sig128Z.v64, -shiftDist );
+        } else {
+            sig128Z =
+                softfloat_shortShiftLeft128(
+                    sig128Z.v64, sig128Z.v0, shiftDist );
+            sigZ = sig128Z.v64;
+        }
+        sigZ |= (sig128Z.v0 != 0);
+    }
+ roundPack:
+    return softfloat_roundPackToF64( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN_ABC:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+    goto propagateNaN_ZC;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infProdArg:
+    if ( magBits ) {
+        uiZ = packToF64UI( signZ, 0x7FF, 0 );
+        if ( expC != 0x7FF ) goto uiZ;
+        if ( sigC ) goto propagateNaN_ZC;
+        if ( signZ == signC ) goto uiZ;
+    }
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF64UI;
+ propagateNaN_ZC:
+    uiZ = softfloat_propagateNaNF64UI( uiZ, uiC );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zeroProd:
+    uiZ = uiC;
+    if ( ! (expC | sigC) && (signZ != signC) ) {
+ completeCancellation:
+        uiZ =
+            packToF64UI(
+                (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
+#else
+
+float64_t
+ softfloat_mulAddF64(
+     uint_fast64_t uiA, uint_fast64_t uiB, uint_fast64_t uiC, uint_fast8_t op )
+{
+    bool signA;
+    int_fast16_t expA;
+    uint64_t sigA;
+    bool signB;
+    int_fast16_t expB;
+    uint64_t sigB;
+    bool signC;
+    int_fast16_t expC;
+    uint64_t sigC;
+    bool signZ;
+    uint64_t magBits, uiZ;
+    struct exp16_sig64 normExpSig;
+    int_fast16_t expZ;
+    uint32_t sig128Z[4];
+    uint64_t sigZ;
+    int_fast16_t shiftDist, expDiff;
+    uint32_t sig128C[4];
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    signB = signF64UI( uiB );
+    expB  = expF64UI( uiB );
+    sigB  = fracF64UI( uiB );
+    signC = signF64UI( uiC ) ^ (op == softfloat_mulAdd_subC);
+    expC  = expF64UI( uiC );
+    sigC  = fracF64UI( uiC );
+    signZ = signA ^ signB ^ (op == softfloat_mulAdd_subProd);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA || ((expB == 0x7FF) && sigB) ) goto propagateNaN_ABC;
+        magBits = expB | sigB;
+        goto infProdArg;
+    }
+    if ( expB == 0x7FF ) {
+        if ( sigB ) goto propagateNaN_ABC;
+        magBits = expA | sigA;
+        goto infProdArg;
+    }
+    if ( expC == 0x7FF ) {
+        if ( sigC ) {
+            uiZ = 0;
+            goto propagateNaN_ZC;
+        }
+        uiZ = uiC;
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF64Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x3FE;
+    sigA = (sigA | UINT64_C( 0x0010000000000000 ))<<10;
+    sigB = (sigB | UINT64_C( 0x0010000000000000 ))<<11;
+    softfloat_mul64To128M( sigA, sigB, sig128Z );
+    sigZ =
+        (uint64_t) sig128Z[indexWord( 4, 3 )]<<32 | sig128Z[indexWord( 4, 2 )];
+    shiftDist = 0;
+    if ( ! (sigZ & UINT64_C( 0x4000000000000000 )) ) {
+        --expZ;
+        shiftDist = -1;
+    }
+    if ( ! expC ) {
+        if ( ! sigC ) {
+            if ( shiftDist ) sigZ <<= 1;
+            goto sigZ;
+        }
+        normExpSig = softfloat_normSubnormalF64Sig( sigC );
+        expC = normExpSig.exp;
+        sigC = normExpSig.sig;
+    }
+    sigC = (sigC | UINT64_C( 0x0010000000000000 ))<<10;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expZ - expC;
+    if ( expDiff < 0 ) {
+        expZ = expC;
+        if ( (signZ == signC) || (expDiff < -1) ) {
+            shiftDist -= expDiff;
+            if ( shiftDist) {
+                sigZ = softfloat_shiftRightJam64( sigZ, shiftDist );
+            }
+        } else {
+            if ( ! shiftDist ) {
+                softfloat_shortShiftRight128M( sig128Z, 1, sig128Z );
+            }
+        }
+    } else {
+        if ( shiftDist ) softfloat_add128M( sig128Z, sig128Z, sig128Z );
+        if ( ! expDiff ) {
+            sigZ =
+                (uint64_t) sig128Z[indexWord( 4, 3 )]<<32
+                    | sig128Z[indexWord( 4, 2 )];
+        } else {
+            sig128C[indexWord( 4, 3 )] = sigC>>32;
+            sig128C[indexWord( 4, 2 )] = sigC;
+            sig128C[indexWord( 4, 1 )] = 0;
+            sig128C[indexWord( 4, 0 )] = 0;
+            softfloat_shiftRightJam128M( sig128C, expDiff, sig128C );
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signZ == signC ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff <= 0 ) {
+            sigZ += sigC;
+        } else {
+            softfloat_add128M( sig128Z, sig128C, sig128Z );
+            sigZ =
+                (uint64_t) sig128Z[indexWord( 4, 3 )]<<32
+                    | sig128Z[indexWord( 4, 2 )];
+        }
+        if ( sigZ & UINT64_C( 0x8000000000000000 ) ) {
+            ++expZ;
+            sigZ = softfloat_shortShiftRightJam64( sigZ, 1 );
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff < 0 ) {
+            signZ = signC;
+            if ( expDiff < -1 ) {
+                sigZ = sigC - sigZ;
+                if (
+                    sig128Z[indexWord( 4, 1 )] || sig128Z[indexWord( 4, 0 )]
+                ) {
+                    sigZ = (sigZ - 1) | 1;
+                }
+                if ( ! (sigZ & UINT64_C( 0x4000000000000000 )) ) {
+                    --expZ;
+                    sigZ <<= 1;
+                }
+                goto roundPack;
+            } else {
+                sig128C[indexWord( 4, 3 )] = sigC>>32;
+                sig128C[indexWord( 4, 2 )] = sigC;
+                sig128C[indexWord( 4, 1 )] = 0;
+                sig128C[indexWord( 4, 0 )] = 0;
+                softfloat_sub128M( sig128C, sig128Z, sig128Z );
+            }
+        } else if ( ! expDiff ) {
+            sigZ -= sigC;
+            if (
+                ! sigZ && ! sig128Z[indexWord( 4, 1 )]
+                    && ! sig128Z[indexWord( 4, 0 )]
+            ) {
+                goto completeCancellation;
+            }
+            sig128Z[indexWord( 4, 3 )] = sigZ>>32;
+            sig128Z[indexWord( 4, 2 )] = sigZ;
+            if ( sigZ & UINT64_C( 0x8000000000000000 ) ) {
+                signZ = ! signZ;
+                softfloat_negX128M( sig128Z );
+            }
+        } else {
+            softfloat_sub128M( sig128Z, sig128C, sig128Z );
+            if ( 1 < expDiff ) {
+                sigZ =
+                    (uint64_t) sig128Z[indexWord( 4, 3 )]<<32
+                        | sig128Z[indexWord( 4, 2 )];
+                if ( ! (sigZ & UINT64_C( 0x4000000000000000 )) ) {
+                    --expZ;
+                    sigZ <<= 1;
+                }
+                goto sigZ;
+            }
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        shiftDist = 0;
+        sigZ =
+            (uint64_t) sig128Z[indexWord( 4, 3 )]<<32
+                | sig128Z[indexWord( 4, 2 )];
+        if ( ! sigZ ) {
+            shiftDist = 64;
+            sigZ =
+                (uint64_t) sig128Z[indexWord( 4, 1 )]<<32
+                    | sig128Z[indexWord( 4, 0 )];
+        }
+        shiftDist += softfloat_countLeadingZeros64( sigZ ) - 1;
+        if ( shiftDist ) {
+            expZ -= shiftDist;
+            softfloat_shiftLeft128M( sig128Z, shiftDist, sig128Z );
+            sigZ =
+                (uint64_t) sig128Z[indexWord( 4, 3 )]<<32
+                    | sig128Z[indexWord( 4, 2 )];
+        }
+    }
+ sigZ:
+    if ( sig128Z[indexWord( 4, 1 )] || sig128Z[indexWord( 4, 0 )] ) sigZ |= 1;
+ roundPack:
+    return softfloat_roundPackToF64( signZ, expZ - 1, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN_ABC:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+    goto propagateNaN_ZC;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infProdArg:
+    if ( magBits ) {
+        uiZ = packToF64UI( signZ, 0x7FF, 0 );
+        if ( expC != 0x7FF ) goto uiZ;
+        if ( sigC ) goto propagateNaN_ZC;
+        if ( signZ == signC ) goto uiZ;
+    }
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF64UI;
+ propagateNaN_ZC:
+    uiZ = softfloat_propagateNaNF64UI( uiZ, uiC );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zeroProd:
+    uiZ = uiC;
+    if ( ! (expC | sigC) && (signZ != signC) ) {
+ completeCancellation:
+        uiZ =
+            packToF64UI(
+                (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_negXM.c b/arch/riscv/kernel/soft_vector/softfloat/s_negXM.c
new file mode 100755
index 000000000..73fe71ecc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_negXM.c
@@ -0,0 +1,63 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_negXM
+
+void softfloat_negXM( uint_fast8_t size_words, uint32_t *zPtr )
+{
+    unsigned int index, lastIndex;
+    uint_fast8_t carry;
+    uint32_t word;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    carry = 1;
+    for (;;) {
+        word = ~zPtr[index] + carry;
+        zPtr[index] = word;
+        if ( index == lastIndex ) break;
+        index += wordIncr;
+        if ( word ) carry = 0;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF128.c b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF128.c
new file mode 100755
index 000000000..9b3fb7706
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF128.c
@@ -0,0 +1,81 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+float128_t
+ softfloat_normRoundPackToF128(
+     bool sign, int_fast32_t exp, uint_fast64_t sig64, uint_fast64_t sig0 )
+{
+    int_fast8_t shiftDist;
+    struct uint128 sig128;
+    union ui128_f128 uZ;
+    uint_fast64_t sigExtra;
+    struct uint128_extra sig128Extra;
+
+    if ( ! sig64 ) {
+        exp -= 64;
+        sig64 = sig0;
+        sig0 = 0;
+    }
+    shiftDist = softfloat_countLeadingZeros64( sig64 ) - 15;
+    exp -= shiftDist;
+    if ( 0 <= shiftDist ) {
+        if ( shiftDist ) {
+            sig128 = softfloat_shortShiftLeft128( sig64, sig0, shiftDist );
+            sig64 = sig128.v64;
+            sig0  = sig128.v0;
+        }
+        if ( (uint32_t) exp < 0x7FFD ) {
+            uZ.ui.v64 = packToF128UI64( sign, sig64 | sig0 ? exp : 0, sig64 );
+            uZ.ui.v0  = sig0;
+            return uZ.f;
+        }
+        sigExtra = 0;
+    } else {
+        sig128Extra =
+            softfloat_shortShiftRightJam128Extra( sig64, sig0, 0, -shiftDist );
+        sig64 = sig128Extra.v.v64;
+        sig0  = sig128Extra.v.v0;
+        sigExtra = sig128Extra.extra;
+    }
+    return softfloat_roundPackToF128( sign, exp, sig64, sig0, sigExtra );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF16.c b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF16.c
new file mode 100755
index 000000000..e4f9e6472
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF16.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+float16_t
+ softfloat_normRoundPackToF16( bool sign, int_fast16_t exp, uint_fast16_t sig )
+{
+    int_fast8_t shiftDist;
+    union ui16_f16 uZ;
+
+    shiftDist = softfloat_countLeadingZeros16( sig ) - 1;
+    exp -= shiftDist;
+    if ( (4 <= shiftDist) && ((unsigned int) exp < 0x1D) ) {
+        uZ.ui = packToF16UI( sign, sig ? exp : 0, sig<<(shiftDist - 4) );
+        return uZ.f;
+    } else {
+        return softfloat_roundPackToF16( sign, exp, sig<<shiftDist );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF32.c b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF32.c
new file mode 100755
index 000000000..41128ed78
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF32.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+float32_t
+ softfloat_normRoundPackToF32( bool sign, int_fast16_t exp, uint_fast32_t sig )
+{
+    int_fast8_t shiftDist;
+    union ui32_f32 uZ;
+
+    shiftDist = softfloat_countLeadingZeros32( sig ) - 1;
+    exp -= shiftDist;
+    if ( (7 <= shiftDist) && ((unsigned int) exp < 0xFD) ) {
+        uZ.ui = packToF32UI( sign, sig ? exp : 0, sig<<(shiftDist - 7) );
+        return uZ.f;
+    } else {
+        return softfloat_roundPackToF32( sign, exp, sig<<shiftDist );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF64.c b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF64.c
new file mode 100755
index 000000000..1222479cd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF64.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+float64_t
+ softfloat_normRoundPackToF64( bool sign, int_fast16_t exp, uint_fast64_t sig )
+{
+    int_fast8_t shiftDist;
+    union ui64_f64 uZ;
+
+    shiftDist = softfloat_countLeadingZeros64( sig ) - 1;
+    exp -= shiftDist;
+    if ( (10 <= shiftDist) && ((unsigned int) exp < 0x7FD) ) {
+        uZ.ui = packToF64UI( sign, sig ? exp : 0, sig<<(shiftDist - 10) );
+        return uZ.f;
+    } else {
+        return softfloat_roundPackToF64( sign, exp, sig<<shiftDist );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF128Sig.c b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF128Sig.c
new file mode 100755
index 000000000..d14cbff7c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF128Sig.c
@@ -0,0 +1,65 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+struct exp32_sig128
+ softfloat_normSubnormalF128Sig( uint_fast64_t sig64, uint_fast64_t sig0 )
+{
+    int_fast8_t shiftDist;
+    struct exp32_sig128 z;
+
+    if ( ! sig64 ) {
+        shiftDist = softfloat_countLeadingZeros64( sig0 ) - 15;
+        z.exp = -63 - shiftDist;
+        if ( shiftDist < 0 ) {
+            z.sig.v64 = sig0>>-shiftDist;
+            z.sig.v0  = sig0<<(shiftDist & 63);
+        } else {
+            z.sig.v64 = sig0<<shiftDist;
+            z.sig.v0  = 0;
+        }
+    } else {
+        shiftDist = softfloat_countLeadingZeros64( sig64 ) - 15;
+        z.exp = 1 - shiftDist;
+        z.sig = softfloat_shortShiftLeft128( sig64, sig0, shiftDist );
+    }
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF16Sig.c b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF16Sig.c
new file mode 100755
index 000000000..9738b5ab2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF16Sig.c
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+struct exp8_sig16 softfloat_normSubnormalF16Sig( uint_fast16_t sig )
+{
+    int_fast8_t shiftDist;
+    struct exp8_sig16 z;
+
+    shiftDist = softfloat_countLeadingZeros16( sig ) - 5;
+    z.exp = 1 - shiftDist;
+    z.sig = sig<<shiftDist;
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF32Sig.c b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF32Sig.c
new file mode 100755
index 000000000..5fd077f96
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF32Sig.c
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+struct exp16_sig32 softfloat_normSubnormalF32Sig( uint_fast32_t sig )
+{
+    int_fast8_t shiftDist;
+    struct exp16_sig32 z;
+
+    shiftDist = softfloat_countLeadingZeros32( sig ) - 8;
+    z.exp = 1 - shiftDist;
+    z.sig = sig<<shiftDist;
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF64Sig.c b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF64Sig.c
new file mode 100755
index 000000000..e1d061992
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF64Sig.c
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+struct exp16_sig64 softfloat_normSubnormalF64Sig( uint_fast64_t sig )
+{
+    int_fast8_t shiftDist;
+    struct exp16_sig64 z;
+
+    shiftDist = softfloat_countLeadingZeros64( sig ) - 11;
+    z.exp = 1 - shiftDist;
+    z.sig = sig<<shiftDist;
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF128UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF128UI.c
new file mode 100755
index 000000000..99cc198a8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF128UI.c
@@ -0,0 +1,73 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+/*----------------------------------------------------------------------------
+| Interpreting the unsigned integer formed from concatenating `uiA64' and
+| `uiA0' as a 128-bit floating-point value, and likewise interpreting the
+| unsigned integer formed from concatenating `uiB64' and `uiB0' as another
+| 128-bit floating-point value, and assuming at least on of these floating-
+| point values is a NaN, returns the bit pattern of the combined NaN result.
+| If either original floating-point value is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+struct uint128
+ softfloat_propagateNaNF128UI(
+     uint_fast64_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast64_t uiB64,
+     uint_fast64_t uiB0
+ )
+{
+    struct uint128 uiZ;
+
+    if (
+           softfloat_isSigNaNF128UI( uiA64, uiA0 )
+        || softfloat_isSigNaNF128UI( uiB64, uiB0 )
+    ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+    }
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+    return uiZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF16UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF16UI.c
new file mode 100755
index 000000000..a16691338
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF16UI.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 16-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast16_t
+ softfloat_propagateNaNF16UI( uint_fast16_t uiA, uint_fast16_t uiB )
+{
+
+    if ( softfloat_isSigNaNF16UI( uiA ) || softfloat_isSigNaNF16UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+    }
+    return defaultNaNF16UI;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF32UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF32UI.c
new file mode 100755
index 000000000..d815c278d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF32UI.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 32-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast32_t
+ softfloat_propagateNaNF32UI( uint_fast32_t uiA, uint_fast32_t uiB )
+{
+
+    if ( softfloat_isSigNaNF32UI( uiA ) || softfloat_isSigNaNF32UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+    }
+    return defaultNaNF32UI;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF64UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF64UI.c
new file mode 100755
index 000000000..679432f9d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF64UI.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 64-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast64_t
+ softfloat_propagateNaNF64UI( uint_fast64_t uiA, uint_fast64_t uiB )
+{
+
+    if ( softfloat_isSigNaNF64UI( uiA ) || softfloat_isSigNaNF64UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+    }
+    return defaultNaNF64UI;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_remStepMBy32.c b/arch/riscv/kernel/soft_vector/softfloat/s_remStepMBy32.c
new file mode 100755
index 000000000..02d7acd4d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_remStepMBy32.c
@@ -0,0 +1,86 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_remStepMBy32
+
+void
+ softfloat_remStepMBy32(
+     uint_fast8_t size_words,
+     const uint32_t *remPtr,
+     uint_fast8_t dist,
+     const uint32_t *bPtr,
+     uint32_t q,
+     uint32_t *zPtr
+ )
+{
+    unsigned int index, lastIndex;
+    uint64_t dwordProd;
+    uint32_t wordRem, wordShiftedRem, wordProd;
+    uint_fast8_t uNegDist, borrow;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    dwordProd = (uint64_t) bPtr[index] * q;
+    wordRem = remPtr[index];
+    wordShiftedRem = wordRem<<dist;
+    wordProd = dwordProd;
+    zPtr[index] = wordShiftedRem - wordProd;
+    if ( index != lastIndex ) {
+        uNegDist = -dist;
+        borrow = (wordShiftedRem < wordProd);
+        for (;;) {
+            wordShiftedRem = wordRem>>(uNegDist & 31);
+            index += wordIncr;
+            dwordProd = (uint64_t) bPtr[index] * q + (dwordProd>>32);
+            wordRem = remPtr[index];
+            wordShiftedRem |= wordRem<<dist;
+            wordProd = dwordProd;
+            zPtr[index] = wordShiftedRem - wordProd - borrow;
+            if ( index == lastIndex ) break;
+            borrow =
+                borrow ? (wordShiftedRem <= wordProd)
+                    : (wordShiftedRem < wordProd);
+        }
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundMToI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundMToI64.c
new file mode 100755
index 000000000..791cc01d4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundMToI64.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t
+ softfloat_roundMToI64(
+     bool sign, uint32_t *extSigPtr, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint32_t sigExtra;
+    bool doIncrement;
+    uint64_t sig;
+    union { uint64_t ui; int64_t i; } uZ;
+    int64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    sigExtra = extSigPtr[indexWordLo( 3 )];
+    doIncrement = (0x80000000 <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    sig =
+        (uint64_t) extSigPtr[indexWord( 3, 2 )]<<32
+            | extSigPtr[indexWord( 3, 1 )];
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        if ( ! (sigExtra & 0x7FFFFFFF) && roundNearEven ) sig &= ~1;
+    }
+    uZ.ui = sign ? -sig : sig;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundMToUI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundMToUI64.c
new file mode 100755
index 000000000..7f5ecdc09
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundMToUI64.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t
+ softfloat_roundMToUI64(
+     bool sign, uint32_t *extSigPtr, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint32_t sigExtra;
+    bool doIncrement;
+    uint64_t sig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    sigExtra = extSigPtr[indexWordLo( 3 )];
+    doIncrement = (0x80000000 <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    sig =
+        (uint64_t) extSigPtr[indexWord( 3, 2 )]<<32
+            | extSigPtr[indexWord( 3, 1 )];
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        if ( ! (sigExtra & 0x7FFFFFFF) && roundNearEven ) sig &= ~1;
+    }
+    if ( sign && sig ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sig;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToI64.c
new file mode 100755
index 000000000..4f6bf0c90
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToI64.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t
+ softfloat_roundPackMToI64(
+     bool sign, uint32_t *extSigPtr, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint32_t sigExtra;
+    bool doIncrement;
+    uint64_t sig;
+    union { uint64_t ui; int64_t i; } uZ;
+    int64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    sigExtra = extSigPtr[indexWordLo( 3 )];
+    doIncrement = (0x80000000 <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    sig =
+        (uint64_t) extSigPtr[indexWord( 3, 2 )]<<32
+            | extSigPtr[indexWord( 3, 1 )];
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        if ( ! (sigExtra & 0x7FFFFFFF) && roundNearEven ) sig &= ~1;
+    }
+    uZ.ui = sign ? -sig : sig;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToUI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToUI64.c
new file mode 100755
index 000000000..7db00901d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToUI64.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t
+ softfloat_roundPackMToUI64(
+     bool sign, uint32_t *extSigPtr, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint32_t sigExtra;
+    bool doIncrement;
+    uint64_t sig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    sigExtra = extSigPtr[indexWordLo( 3 )];
+    doIncrement = (0x80000000 <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    sig =
+        (uint64_t) extSigPtr[indexWord( 3, 2 )]<<32
+            | extSigPtr[indexWord( 3, 1 )];
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        if ( ! (sigExtra & 0x7FFFFFFF) && roundNearEven ) sig &= ~1;
+    }
+    if ( sign && sig ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sig;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF128.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF128.c
new file mode 100755
index 000000000..820914ef4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF128.c
@@ -0,0 +1,171 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t
+ softfloat_roundPackToF128(
+     bool sign,
+     int_fast32_t exp,
+     uint_fast64_t sig64,
+     uint_fast64_t sig0,
+     uint_fast64_t sigExtra
+ )
+{
+    uint_fast8_t roundingMode;
+    bool roundNearEven, doIncrement, isTiny;
+    struct uint128_extra sig128Extra;
+    uint_fast64_t uiZ64, uiZ0;
+    struct uint128 sig128;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundingMode = softfloat_roundingMode;
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x7FFD <= (uint32_t) exp ) {
+        if ( exp < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            isTiny =
+                   (softfloat_detectTininess
+                        == softfloat_tininess_beforeRounding)
+                || (exp < -1)
+                || ! doIncrement
+                || softfloat_lt128(
+                       sig64,
+                       sig0,
+                       UINT64_C( 0x0001FFFFFFFFFFFF ),
+                       UINT64_C( 0xFFFFFFFFFFFFFFFF )
+                   );
+            sig128Extra =
+                softfloat_shiftRightJam128Extra( sig64, sig0, sigExtra, -exp );
+            sig64 = sig128Extra.v.v64;
+            sig0  = sig128Extra.v.v0;
+            sigExtra = sig128Extra.extra;
+            exp = 0;
+            if ( isTiny && sigExtra ) {
+                softfloat_raiseFlags( softfloat_flag_underflow );
+            }
+            doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+            if (
+                   ! roundNearEven
+                && (roundingMode != softfloat_round_near_maxMag)
+            ) {
+                doIncrement =
+                    (roundingMode
+                         == (sign ? softfloat_round_min : softfloat_round_max))
+                        && sigExtra;
+            }
+        } else if (
+               (0x7FFD < exp)
+            || ((exp == 0x7FFD)
+                    && softfloat_eq128( 
+                           sig64,
+                           sig0,
+                           UINT64_C( 0x0001FFFFFFFFFFFF ),
+                           UINT64_C( 0xFFFFFFFFFFFFFFFF )
+                       )
+                    && doIncrement)
+        ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            softfloat_raiseFlags(
+                softfloat_flag_overflow | softfloat_flag_inexact );
+            if (
+                   roundNearEven
+                || (roundingMode == softfloat_round_near_maxMag)
+                || (roundingMode
+                        == (sign ? softfloat_round_min : softfloat_round_max))
+            ) {
+                uiZ64 = packToF128UI64( sign, 0x7FFF, 0 );
+                uiZ0  = 0;
+            } else {
+                uiZ64 =
+                    packToF128UI64(
+                        sign, 0x7FFE, UINT64_C( 0x0000FFFFFFFFFFFF ) );
+                uiZ0 = UINT64_C( 0xFFFFFFFFFFFFFFFF );
+            }
+            goto uiZ;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+#ifdef SOFTFLOAT_ROUND_ODD
+        if ( roundingMode == softfloat_round_odd ) {
+            sig0 |= 1;
+            goto packReturn;
+        }
+#endif
+    }
+    if ( doIncrement ) {
+        sig128 = softfloat_add128( sig64, sig0, 0, 1 );
+        sig64 = sig128.v64;
+        sig0 =
+            sig128.v0
+                & ~(uint64_t)
+                       (! (sigExtra & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                            & roundNearEven);
+    } else {
+        if ( ! (sig64 | sig0) ) exp = 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ packReturn:
+    uiZ64 = packToF128UI64( sign, exp, sig64 );
+    uiZ0  = sig0;
+ uiZ:
+    uZ.ui.v64 = uiZ64;
+    uZ.ui.v0  = uiZ0;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF16.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF16.c
new file mode 100755
index 000000000..fccc449b4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF16.c
@@ -0,0 +1,113 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t
+ softfloat_roundPackToF16( bool sign, int_fast16_t exp, uint_fast16_t sig )
+{
+    uint_fast8_t roundingMode;
+    bool roundNearEven;
+    uint_fast8_t roundIncrement, roundBits;
+    bool isTiny;
+    uint_fast16_t uiZ;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundingMode = softfloat_roundingMode;
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x8;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0xF
+                : 0;
+    }
+    roundBits = sig & 0xF;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x1D <= (unsigned int) exp ) {
+        if ( exp < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            isTiny =
+                (softfloat_detectTininess == softfloat_tininess_beforeRounding)
+                    || (exp < -1) || (sig + roundIncrement < 0x8000);
+            sig = softfloat_shiftRightJam32( sig, -exp );
+            exp = 0;
+            roundBits = sig & 0xF;
+            if ( isTiny && roundBits ) {
+                softfloat_raiseFlags( softfloat_flag_underflow );
+            }
+        } else if ( (0x1D < exp) || (0x8000 <= sig + roundIncrement) ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            softfloat_raiseFlags(
+                softfloat_flag_overflow | softfloat_flag_inexact );
+            uiZ = packToF16UI( sign, 0x1F, 0 ) - ! roundIncrement;
+            goto uiZ;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig = (sig + roundIncrement)>>4;
+    if ( roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+#ifdef SOFTFLOAT_ROUND_ODD
+        if ( roundingMode == softfloat_round_odd ) {
+            sig |= 1;
+            goto packReturn;
+        }
+#endif
+    }
+    sig &= ~(uint_fast16_t) (! (roundBits ^ 8) & roundNearEven);
+    if ( ! sig ) exp = 0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ packReturn:
+    uiZ = packToF16UI( sign, exp, sig );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF32.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF32.c
new file mode 100755
index 000000000..fa2207650
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF32.c
@@ -0,0 +1,113 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t
+ softfloat_roundPackToF32( bool sign, int_fast16_t exp, uint_fast32_t sig )
+{
+    uint_fast8_t roundingMode;
+    bool roundNearEven;
+    uint_fast8_t roundIncrement, roundBits;
+    bool isTiny;
+    uint_fast32_t uiZ;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundingMode = softfloat_roundingMode;
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x40;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0x7F
+                : 0;
+    }
+    roundBits = sig & 0x7F;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0xFD <= (unsigned int) exp ) {
+        if ( exp < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            isTiny =
+                (softfloat_detectTininess == softfloat_tininess_beforeRounding)
+                    || (exp < -1) || (sig + roundIncrement < 0x80000000);
+            sig = softfloat_shiftRightJam32( sig, -exp );
+            exp = 0;
+            roundBits = sig & 0x7F;
+            if ( isTiny && roundBits ) {
+                softfloat_raiseFlags( softfloat_flag_underflow );
+            }
+        } else if ( (0xFD < exp) || (0x80000000 <= sig + roundIncrement) ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            softfloat_raiseFlags(
+                softfloat_flag_overflow | softfloat_flag_inexact );
+            uiZ = packToF32UI( sign, 0xFF, 0 ) - ! roundIncrement;
+            goto uiZ;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig = (sig + roundIncrement)>>7;
+    if ( roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+#ifdef SOFTFLOAT_ROUND_ODD
+        if ( roundingMode == softfloat_round_odd ) {
+            sig |= 1;
+            goto packReturn;
+        }
+#endif
+    }
+    sig &= ~(uint_fast32_t) (! (roundBits ^ 0x40) & roundNearEven);
+    if ( ! sig ) exp = 0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ packReturn:
+    uiZ = packToF32UI( sign, exp, sig );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF64.c
new file mode 100755
index 000000000..1a3b8debb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF64.c
@@ -0,0 +1,117 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t
+ softfloat_roundPackToF64( bool sign, int_fast16_t exp, uint_fast64_t sig )
+{
+    uint_fast8_t roundingMode;
+    bool roundNearEven;
+    uint_fast16_t roundIncrement, roundBits;
+    bool isTiny;
+    uint_fast64_t uiZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundingMode = softfloat_roundingMode;
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x200;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0x3FF
+                : 0;
+    }
+    roundBits = sig & 0x3FF;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x7FD <= (uint16_t) exp ) {
+        if ( exp < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            isTiny =
+                (softfloat_detectTininess == softfloat_tininess_beforeRounding)
+                    || (exp < -1)
+                    || (sig + roundIncrement < UINT64_C( 0x8000000000000000 ));
+            sig = softfloat_shiftRightJam64( sig, -exp );
+            exp = 0;
+            roundBits = sig & 0x3FF;
+            if ( isTiny && roundBits ) {
+                softfloat_raiseFlags( softfloat_flag_underflow );
+            }
+        } else if (
+            (0x7FD < exp)
+                || (UINT64_C( 0x8000000000000000 ) <= sig + roundIncrement)
+        ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            softfloat_raiseFlags(
+                softfloat_flag_overflow | softfloat_flag_inexact );
+            uiZ = packToF64UI( sign, 0x7FF, 0 ) - ! roundIncrement;
+            goto uiZ;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig = (sig + roundIncrement)>>10;
+    if ( roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+#ifdef SOFTFLOAT_ROUND_ODD
+        if ( roundingMode == softfloat_round_odd ) {
+            sig |= 1;
+            goto packReturn;
+        }
+#endif
+    }
+    sig &= ~(uint_fast64_t) (! (roundBits ^ 0x200) & roundNearEven);
+    if ( ! sig ) exp = 0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ packReturn:
+    uiZ = packToF64UI( sign, exp, sig );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI32.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI32.c
new file mode 100755
index 000000000..e29d8b3f1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI32.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t
+ softfloat_roundPackToI32(
+     bool sign, uint_fast64_t sig, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint_fast8_t roundIncrement, roundBits;
+    uint_fast32_t sig32;
+    union { uint32_t ui; int32_t i; } uZ;
+    int_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x40;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0x7F
+                : 0;
+    }
+    roundBits = sig & 0x7F;
+    sig += roundIncrement;
+    if ( sig & UINT64_C( 0xFFFFFF8000000000 ) ) goto invalid;
+    sig32 = sig>>7;
+    sig32 &= ~(uint_fast32_t) (! (roundBits ^ 0x40) & roundNearEven);
+    uZ.ui = sign ? -sig32 : sig32;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI64.c
new file mode 100755
index 000000000..7a4af767f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI64.c
@@ -0,0 +1,89 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t
+ softfloat_roundPackToI64(
+     bool sign,
+     uint_fast64_t sig,
+     uint_fast64_t sigExtra,
+     uint_fast8_t roundingMode,
+     bool exact
+ )
+{
+    bool roundNearEven, doIncrement;
+    union { uint64_t ui; int64_t i; } uZ;
+    int_fast64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        sig &=
+            ~(uint_fast64_t)
+                 (! (sigExtra & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                      & roundNearEven);
+    }
+    uZ.ui = sign ? -sig : sig;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI32.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI32.c
new file mode 100755
index 000000000..43a5fbbdf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI32.c
@@ -0,0 +1,80 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t
+ softfloat_roundPackToUI32(
+     bool sign, uint_fast64_t sig, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint_fast8_t roundIncrement, roundBits;
+    uint_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x40;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0x7F
+                : 0;
+    }
+    roundBits = sig & 0x7F;
+    sig += roundIncrement;
+    if ( sig & UINT64_C( 0xFFFFFF8000000000 ) ) goto invalid;
+    z = sig>>7;
+    z &= ~(uint_fast32_t) (! (roundBits ^ 0x40) & roundNearEven);
+    if ( sign && z ) goto invalid;
+    if ( exact && roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI64.c
new file mode 100755
index 000000000..e6a748244
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI64.c
@@ -0,0 +1,85 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t
+ softfloat_roundPackToUI64(
+     bool sign,
+     uint_fast64_t sig,
+     uint_fast64_t sigExtra,
+     uint_fast8_t roundingMode,
+     bool exact
+ )
+{
+    bool roundNearEven, doIncrement;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        sig &=
+            ~(uint_fast64_t)
+                 (! (sigExtra & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                      & roundNearEven);
+    }
+    if ( sign && sig ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sig;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundToI32.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundToI32.c
new file mode 100755
index 000000000..a9e186c08
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundToI32.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t
+ softfloat_roundToI32(
+     bool sign, uint_fast64_t sig, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint_fast16_t roundIncrement, roundBits;
+    uint_fast32_t sig32;
+    union { uint32_t ui; int32_t i; } uZ;
+    int_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x800;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0xFFF
+                : 0;
+    }
+    roundBits = sig & 0xFFF;
+    sig += roundIncrement;
+    if ( sig & UINT64_C( 0xFFFFF00000000000 ) ) goto invalid;
+    sig32 = sig>>12;
+    sig32 &= ~(uint_fast32_t) (! (roundBits ^ 0x800) & roundNearEven);
+    uZ.ui = sign ? -sig32 : sig32;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundToI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundToI64.c
new file mode 100755
index 000000000..6ac4daa99
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundToI64.c
@@ -0,0 +1,89 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t
+ softfloat_roundToI64(
+     bool sign,
+     uint_fast64_t sig,
+     uint_fast64_t sigExtra,
+     uint_fast8_t roundingMode,
+     bool exact
+ )
+{
+    bool roundNearEven, doIncrement;
+    union { uint64_t ui; int64_t i; } uZ;
+    int_fast64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        sig &=
+            ~(uint_fast64_t)
+                 (! (sigExtra & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                      & roundNearEven);
+    }
+    uZ.ui = sign ? -sig : sig;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI32.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI32.c
new file mode 100755
index 000000000..fabd74552
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI32.c
@@ -0,0 +1,80 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t
+ softfloat_roundToUI32(
+     bool sign, uint_fast64_t sig, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint_fast16_t roundIncrement, roundBits;
+    uint_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x800;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0xFFF
+                : 0;
+    }
+    roundBits = sig & 0xFFF;
+    sig += roundIncrement;
+    if ( sig & UINT64_C( 0xFFFFF00000000000 ) ) goto invalid;
+    z = sig>>12;
+    z &= ~(uint_fast32_t) (! (roundBits ^ 0x800) & roundNearEven);
+    if ( sign && z ) goto invalid;
+    if ( exact && roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI64.c
new file mode 100755
index 000000000..fe6c52968
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI64.c
@@ -0,0 +1,85 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t
+ softfloat_roundToUI64(
+     bool sign,
+     uint_fast64_t sig,
+     uint_fast64_t sigExtra,
+     uint_fast8_t roundingMode,
+     bool exact
+ )
+{
+    bool roundNearEven, doIncrement;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        sig &=
+            ~(uint_fast64_t)
+                 (! (sigExtra & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                      & roundNearEven);
+    }
+    if ( sign && sig ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sig;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128.c
new file mode 100755
index 000000000..3c5127ac2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128.c
@@ -0,0 +1,69 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shiftRightJam128
+
+struct uint128
+ softfloat_shiftRightJam128( uint64_t a64, uint64_t a0, uint_fast32_t dist )
+{
+    uint_fast8_t u8NegDist;
+    struct uint128 z;
+
+    if ( dist < 64 ) {
+        u8NegDist = -dist;
+        z.v64 = a64>>dist;
+        z.v0 =
+            a64<<(u8NegDist & 63) | a0>>dist
+                | ((uint64_t) (a0<<(u8NegDist & 63)) != 0);
+    } else {
+        z.v64 = 0;
+        z.v0 =
+            (dist < 127)
+                ? a64>>(dist & 63)
+                      | (((a64 & (((uint_fast64_t) 1<<(dist & 63)) - 1)) | a0)
+                             != 0)
+                : ((a64 | a0) != 0);
+    }
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128Extra.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128Extra.c
new file mode 100755
index 000000000..2fa0d1de2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128Extra.c
@@ -0,0 +1,77 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shiftRightJam128Extra
+
+struct uint128_extra
+ softfloat_shiftRightJam128Extra(
+     uint64_t a64, uint64_t a0, uint64_t extra, uint_fast32_t dist )
+{
+    uint_fast8_t u8NegDist;
+    struct uint128_extra z;
+
+    u8NegDist = -dist;
+    if ( dist < 64 ) {
+        z.v.v64 = a64>>dist;
+        z.v.v0 = a64<<(u8NegDist & 63) | a0>>dist;
+        z.extra = a0<<(u8NegDist & 63);
+    } else {
+        z.v.v64 = 0;
+        if ( dist == 64 ) {
+            z.v.v0 = a64;
+            z.extra = a0;
+        } else {
+            extra |= a0;
+            if ( dist < 128 ) {
+                z.v.v0 = a64>>(dist & 63);
+                z.extra = a64<<(u8NegDist & 63);
+            } else {
+                z.v.v0 = 0;
+                z.extra = (dist == 128) ? a64 : (a64 != 0);
+            }
+        }
+    }
+    z.extra |= (extra != 0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam256M.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam256M.c
new file mode 100755
index 000000000..7080209cf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam256M.c
@@ -0,0 +1,126 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shiftRightJam256M
+
+static
+ void
+  softfloat_shortShiftRightJamM(
+      uint_fast8_t size_words,
+      const uint64_t *aPtr,
+      uint_fast8_t dist,
+      uint64_t *zPtr
+  )
+{
+    uint_fast8_t uNegDist;
+    unsigned int index, lastIndex;
+    uint64_t partWordZ, wordA;
+
+    uNegDist = -dist;
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    wordA = aPtr[index];
+    partWordZ = wordA>>dist;
+    if ( partWordZ<<dist != wordA ) partWordZ |= 1;
+    while ( index != lastIndex ) {
+        wordA = aPtr[index + wordIncr];
+        zPtr[index] = wordA<<(uNegDist & 63) | partWordZ;
+        index += wordIncr;
+        partWordZ = wordA>>dist;
+    }
+    zPtr[index] = partWordZ;
+
+}
+
+void
+ softfloat_shiftRightJam256M(
+     const uint64_t *aPtr, uint_fast32_t dist, uint64_t *zPtr )
+{
+    uint64_t wordJam;
+    uint_fast32_t wordDist;
+    uint64_t *ptr;
+    uint_fast8_t i, innerDist;
+
+    wordJam = 0;
+    wordDist = dist>>6;
+    if ( wordDist ) {
+        if ( 4 < wordDist ) wordDist = 4;
+        ptr = (uint64_t *) (aPtr + indexMultiwordLo( 4, wordDist ));
+        i = wordDist;
+        do {
+            wordJam = *ptr++;
+            if ( wordJam ) break;
+            --i;
+        } while ( i );
+        ptr = zPtr;
+    }
+    if ( wordDist < 4 ) {
+        aPtr += indexMultiwordHiBut( 4, wordDist );
+        innerDist = dist & 63;
+        if ( innerDist ) {
+            softfloat_shortShiftRightJamM(
+                4 - wordDist,
+                aPtr,
+                innerDist,
+                zPtr + indexMultiwordLoBut( 4, wordDist )
+            );
+            if ( ! wordDist ) goto wordJam;
+        } else {
+            aPtr += indexWordLo( 4 - wordDist );
+            ptr = zPtr + indexWordLo( 4 );
+            for ( i = 4 - wordDist; i; --i ) {
+                *ptr = *aPtr;
+                aPtr += wordIncr;
+                ptr += wordIncr;
+            }
+        }
+        ptr = zPtr + indexMultiwordHi( 4, wordDist );
+    }
+    do {
+        *ptr++ = 0;
+        --wordDist;
+    } while ( wordDist );
+ wordJam:
+    if ( wordJam ) zPtr[indexWordLo( 4 )] |= 1;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam32.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam32.c
new file mode 100755
index 000000000..291c5db8f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam32.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_shiftRightJam32
+
+uint32_t softfloat_shiftRightJam32( uint32_t a, uint_fast16_t dist )
+{
+
+    return
+        (dist < 31) ? a>>dist | ((uint32_t) (a<<(-dist & 31)) != 0) : (a != 0);
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64.c
new file mode 100755
index 000000000..1d5d94d70
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_shiftRightJam64
+
+uint64_t softfloat_shiftRightJam64( uint64_t a, uint_fast32_t dist )
+{
+
+    return
+        (dist < 63) ? a>>dist | ((uint64_t) (a<<(-dist & 63)) != 0) : (a != 0);
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64Extra.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64Extra.c
new file mode 100755
index 000000000..891479045
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64Extra.c
@@ -0,0 +1,62 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shiftRightJam64Extra
+
+struct uint64_extra
+ softfloat_shiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast32_t dist )
+{
+    struct uint64_extra z;
+
+    if ( dist < 64 ) {
+        z.v = a>>dist;
+        z.extra = a<<(-dist & 63);
+    } else {
+        z.v = 0;
+        z.extra = (dist == 64) ? a : (a != 0);
+    }
+    z.extra |= (extra != 0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft128.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft128.c
new file mode 100755
index 000000000..ba0716e73
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft128.c
@@ -0,0 +1,55 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftLeft128
+
+struct uint128
+ softfloat_shortShiftLeft128( uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    struct uint128 z;
+
+    z.v64 = a64<<dist | a0>>(-dist & 63);
+    z.v0 = a0<<dist;
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft64To96M.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft64To96M.c
new file mode 100755
index 000000000..725503e46
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft64To96M.c
@@ -0,0 +1,56 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftLeft64To96M
+
+void
+ softfloat_shortShiftLeft64To96M(
+     uint64_t a, uint_fast8_t dist, uint32_t *zPtr )
+{
+
+    zPtr[indexWord( 3, 0 )] = (uint32_t) a<<dist;
+    a >>= 32 - dist;
+    zPtr[indexWord( 3, 2 )] = a>>32;
+    zPtr[indexWord( 3, 1 )] = a;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRight128.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRight128.c
new file mode 100755
index 000000000..6b1894f72
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRight128.c
@@ -0,0 +1,55 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRight128
+
+struct uint128
+ softfloat_shortShiftRight128( uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    struct uint128 z;
+
+    z.v64 = a64>>dist;
+    z.v0 = a64<<(-dist & 63) | a0>>dist;
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightExtendM.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightExtendM.c
new file mode 100755
index 000000000..ad793318b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightExtendM.c
@@ -0,0 +1,73 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRightExtendM
+
+void
+ softfloat_shortShiftRightExtendM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint_fast8_t dist,
+     uint32_t *zPtr
+ )
+{
+    uint_fast8_t uNegDist;
+    unsigned int indexA, lastIndexA;
+    uint32_t partWordZ, wordA;
+
+    uNegDist = -dist;
+    indexA = indexWordLo( size_words );
+    lastIndexA = indexWordHi( size_words );
+    zPtr += indexWordLo( size_words + 1 );
+    partWordZ = 0;
+    for (;;) {
+        wordA = aPtr[indexA];
+        *zPtr = wordA<<(uNegDist & 31) | partWordZ;
+        zPtr += wordIncr;
+        partWordZ = wordA>>dist;
+        if ( indexA == lastIndexA ) break;
+        indexA += wordIncr;
+    }
+    *zPtr = partWordZ;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128.c
new file mode 100755
index 000000000..61b0836e2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRightJam128
+
+struct uint128
+ softfloat_shortShiftRightJam128(
+     uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    uint_fast8_t uNegDist;
+    struct uint128 z;
+
+    uNegDist = -dist;
+    z.v64 = a64>>dist;
+    z.v0 =
+        a64<<(uNegDist & 63) | a0>>dist
+            | ((uint64_t) (a0<<(uNegDist & 63)) != 0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128Extra.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128Extra.c
new file mode 100755
index 000000000..336e5d116
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128Extra.c
@@ -0,0 +1,59 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRightJam128Extra
+
+struct uint128_extra
+ softfloat_shortShiftRightJam128Extra(
+     uint64_t a64, uint64_t a0, uint64_t extra, uint_fast8_t dist )
+{
+    uint_fast8_t uNegDist;
+    struct uint128_extra z;
+
+    uNegDist = -dist;
+    z.v.v64 = a64>>dist;
+    z.v.v0 = a64<<(uNegDist & 63) | a0>>dist;
+    z.extra = a0<<(uNegDist & 63) | (extra != 0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64.c
new file mode 100755
index 000000000..bb7dd375a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64.c
@@ -0,0 +1,50 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_shortShiftRightJam64
+
+uint64_t softfloat_shortShiftRightJam64( uint64_t a, uint_fast8_t dist )
+{
+
+    return a>>dist | ((a & (((uint_fast64_t) 1<<dist) - 1)) != 0);
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64Extra.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64Extra.c
new file mode 100755
index 000000000..3bfe6720d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64Extra.c
@@ -0,0 +1,56 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRightJam64Extra
+
+struct uint64_extra
+ softfloat_shortShiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast8_t dist )
+{
+    struct uint64_extra z;
+
+    z.v = a>>dist;
+    z.extra = a<<(-dist & 63) | (extra != 0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightM.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightM.c
new file mode 100755
index 000000000..d972fcc42
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightM.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRightM
+
+void
+ softfloat_shortShiftRightM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint_fast8_t dist,
+     uint32_t *zPtr
+ )
+{
+    uint_fast8_t uNegDist;
+    unsigned int index, lastIndex;
+    uint32_t partWordZ, wordA;
+
+    uNegDist = -dist;
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    partWordZ = aPtr[index]>>dist;
+    while ( index != lastIndex ) {
+        wordA = aPtr[index + wordIncr];
+        zPtr[index] = wordA<<(uNegDist & 31) | partWordZ;
+        index += wordIncr;
+        partWordZ = wordA>>dist;
+    }
+    zPtr[index] = partWordZ;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_sub128.c b/arch/riscv/kernel/soft_vector/softfloat/s_sub128.c
new file mode 100755
index 000000000..19bdff75b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_sub128.c
@@ -0,0 +1,55 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_sub128
+
+struct uint128
+ softfloat_sub128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+    struct uint128 z;
+
+    z.v0 = a0 - b0;
+    z.v64 = a64 - b64 - (a0 < b0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_sub1XM.c b/arch/riscv/kernel/soft_vector/softfloat/s_sub1XM.c
new file mode 100755
index 000000000..a700a6348
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_sub1XM.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_sub1XM
+
+void softfloat_sub1XM( uint_fast8_t size_words, uint32_t *zPtr )
+{
+    unsigned int index, lastIndex;
+    uint32_t wordA;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    for (;;) {
+        wordA = zPtr[index];
+        zPtr[index] = wordA - 1;
+        if ( wordA || (index == lastIndex) ) break;
+        index += wordIncr;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_sub256M.c b/arch/riscv/kernel/soft_vector/softfloat/s_sub256M.c
new file mode 100755
index 000000000..f6b5a0219
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_sub256M.c
@@ -0,0 +1,65 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_sub256M
+
+void
+ softfloat_sub256M(
+     const uint64_t *aPtr, const uint64_t *bPtr, uint64_t *zPtr )
+{
+    unsigned int index;
+    uint_fast8_t borrow;
+    uint64_t wordA, wordB;
+
+    index = indexWordLo( 4 );
+    borrow = 0;
+    for (;;) {
+        wordA = aPtr[index];
+        wordB = bPtr[index];
+        zPtr[index] = wordA - wordB - borrow;
+        if ( index == indexWordHi( 4 ) ) break;
+        borrow = borrow ? (wordA <= wordB) : (wordA < wordB);
+        index += wordIncr;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_subM.c b/arch/riscv/kernel/soft_vector/softfloat/s_subM.c
new file mode 100755
index 000000000..6c19f92a1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_subM.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_subM
+
+void
+ softfloat_subM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint32_t *zPtr
+ )
+{
+    unsigned int index, lastIndex;
+    uint_fast8_t borrow;
+    uint32_t wordA, wordB;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    borrow = 0;
+    for (;;) {
+        wordA = aPtr[index];
+        wordB = bPtr[index];
+        zPtr[index] = wordA - wordB - borrow;
+        if ( index == lastIndex ) break;
+        borrow = borrow ? (wordA <= wordB) : (wordA < wordB);
+        index += wordIncr;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF128.c b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF128.c
new file mode 100755
index 000000000..a79ebc898
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF128.c
@@ -0,0 +1,139 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t
+ softfloat_subMagsF128(
+     uint_fast64_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast64_t uiB64,
+     uint_fast64_t uiB0,
+     bool signZ
+ )
+{
+    int_fast32_t expA;
+    struct uint128 sigA;
+    int_fast32_t expB;
+    struct uint128 sigB, sigZ;
+    int_fast32_t expDiff, expZ;
+    struct uint128 uiZ;
+    union ui128_f128 uZ;
+
+    expA = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    expB = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    sigA = softfloat_shortShiftLeft128( sigA.v64, sigA.v0, 4 );
+    sigB = softfloat_shortShiftLeft128( sigB.v64, sigB.v0, 4 );
+    expDiff = expA - expB;
+    if ( 0 < expDiff ) goto expABigger;
+    if ( expDiff < 0 ) goto expBBigger;
+    if ( expA == 0x7FFF ) {
+        if ( sigA.v64 | sigA.v0 | sigB.v64 | sigB.v0 ) goto propagateNaN;
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        uiZ.v64 = defaultNaNF128UI64;
+        uiZ.v0  = defaultNaNF128UI0;
+        goto uiZ;
+    }
+    expZ = expA;
+    if ( ! expZ ) expZ = 1;
+    if ( sigB.v64 < sigA.v64 ) goto aBigger;
+    if ( sigA.v64 < sigB.v64 ) goto bBigger;
+    if ( sigB.v0 < sigA.v0 ) goto aBigger;
+    if ( sigA.v0 < sigB.v0 ) goto bBigger;
+    uiZ.v64 =
+        packToF128UI64(
+            (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+    uiZ.v0 = 0;
+    goto uiZ;
+ expBBigger:
+    if ( expB == 0x7FFF ) {
+        if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+        uiZ.v64 = packToF128UI64( signZ ^ 1, 0x7FFF, 0 );
+        uiZ.v0  = 0;
+        goto uiZ;
+    }
+    if ( expA ) {
+        sigA.v64 |= UINT64_C( 0x0010000000000000 );
+    } else {
+        ++expDiff;
+        if ( ! expDiff ) goto newlyAlignedBBigger;
+    }
+    sigA = softfloat_shiftRightJam128( sigA.v64, sigA.v0, -expDiff );
+ newlyAlignedBBigger:
+    expZ = expB;
+    sigB.v64 |= UINT64_C( 0x0010000000000000 );
+ bBigger:
+    signZ = ! signZ;
+    sigZ = softfloat_sub128( sigB.v64, sigB.v0, sigA.v64, sigA.v0 );
+    goto normRoundPack;
+ expABigger:
+    if ( expA == 0x7FFF ) {
+        if ( sigA.v64 | sigA.v0 ) goto propagateNaN;
+        uiZ.v64 = uiA64;
+        uiZ.v0  = uiA0;
+        goto uiZ;
+    }
+    if ( expB ) {
+        sigB.v64 |= UINT64_C( 0x0010000000000000 );
+    } else {
+        --expDiff;
+        if ( ! expDiff ) goto newlyAlignedABigger;
+    }
+    sigB = softfloat_shiftRightJam128( sigB.v64, sigB.v0, expDiff );
+ newlyAlignedABigger:
+    expZ = expA;
+    sigA.v64 |= UINT64_C( 0x0010000000000000 );
+ aBigger:
+    sigZ = softfloat_sub128( sigA.v64, sigA.v0, sigB.v64, sigB.v0 );
+ normRoundPack:
+    return softfloat_normRoundPackToF128( signZ, expZ - 5, sigZ.v64, sigZ.v0 );
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF16.c b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF16.c
new file mode 100755
index 000000000..09bd1cfa6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF16.c
@@ -0,0 +1,187 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t softfloat_subMagsF16( uint_fast16_t uiA, uint_fast16_t uiB )
+{
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    int_fast8_t expDiff;
+    uint_fast16_t uiZ;
+    int_fast16_t sigDiff;
+    bool signZ;
+    int_fast8_t shiftDist, expZ;
+    uint_fast16_t sigZ, sigX, sigY;
+    uint_fast32_t sig32Z;
+    int_fast8_t roundingMode;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF16UI( uiA );
+    sigA = fracF16UI( uiA );
+    expB = expF16UI( uiB );
+    sigB = fracF16UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expA == 0x1F ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            uiZ = defaultNaNF16UI;
+            goto uiZ;
+        }
+        sigDiff = sigA - sigB;
+        if ( ! sigDiff ) {
+            uiZ =
+                packToF16UI(
+                    (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+            goto uiZ;
+        }
+        if ( expA ) --expA;
+        signZ = signF16UI( uiA );
+        if ( sigDiff < 0 ) {
+            signZ = ! signZ;
+            sigDiff = -sigDiff;
+        }
+        shiftDist = softfloat_countLeadingZeros16( sigDiff ) - 5;
+        expZ = expA - shiftDist;
+        if ( expZ < 0 ) {
+            shiftDist = expA;
+            expZ = 0;
+        }
+        sigZ = sigDiff<<shiftDist;
+        goto pack;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        signZ = signF16UI( uiA );
+        if ( expDiff < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            signZ = ! signZ;
+            if ( expB == 0x1F ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF16UI( signZ, 0x1F, 0 );
+                goto uiZ;
+            }
+            if ( expDiff <= -13 ) {
+                uiZ = packToF16UI( signZ, expB, sigB );
+                if ( expA | sigA ) goto subEpsilon;
+                goto uiZ;
+            }
+            expZ = expA + 19;
+            sigX = sigB | 0x0400;
+            sigY = sigA + (expA ? 0x0400 : sigA);
+            expDiff = -expDiff;
+        } else {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            uiZ = uiA;
+            if ( expA == 0x1F ) {
+                if ( sigA ) goto propagateNaN;
+                goto uiZ;
+            }
+            if ( 13 <= expDiff ) {
+                if ( expB | sigB ) goto subEpsilon;
+                goto uiZ;
+            }
+            expZ = expB + 19;
+            sigX = sigA | 0x0400;
+            sigY = sigB + (expB ? 0x0400 : sigB);
+        }
+        sig32Z = ((uint_fast32_t) sigX<<expDiff) - sigY;
+        shiftDist = softfloat_countLeadingZeros32( sig32Z ) - 1;
+        sig32Z <<= shiftDist;
+        expZ -= shiftDist;
+        sigZ = sig32Z>>16;
+        if ( sig32Z & 0xFFFF ) {
+            sigZ |= 1;
+        } else {
+            if ( ! (sigZ & 0xF) && ((unsigned int) expZ < 0x1E) ) {
+                sigZ >>= 4;
+                goto pack;
+            }
+        }
+        return softfloat_roundPackToF16( signZ, expZ, sigZ );
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ subEpsilon:
+    roundingMode = softfloat_roundingMode;
+    if ( roundingMode != softfloat_round_near_even ) {
+        if (
+            (roundingMode == softfloat_round_minMag)
+                || (roundingMode
+                        == (signF16UI( uiZ ) ? softfloat_round_max
+                                : softfloat_round_min))
+        ) {
+            --uiZ;
+        }
+#ifdef SOFTFLOAT_ROUND_ODD
+        else if ( roundingMode == softfloat_round_odd ) {
+            uiZ = (uiZ - 1) | 1;
+        }
+#endif
+    }
+    softfloat_exceptionFlags |= softfloat_flag_inexact;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ pack:
+    uiZ = packToF16UI( signZ, expZ, sigZ );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF32.c b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF32.c
new file mode 100755
index 000000000..539f7b7fc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF32.c
@@ -0,0 +1,143 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t softfloat_subMagsF32( uint_fast32_t uiA, uint_fast32_t uiB )
+{
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    int_fast16_t expDiff;
+    uint_fast32_t uiZ;
+    int_fast32_t sigDiff;
+    bool signZ;
+    int_fast8_t shiftDist;
+    int_fast16_t expZ;
+    uint_fast32_t sigX, sigY;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF32UI( uiA );
+    sigA = fracF32UI( uiA );
+    expB = expF32UI( uiB );
+    sigB = fracF32UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expA == 0xFF ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            uiZ = defaultNaNF32UI;
+            goto uiZ;
+        }
+        sigDiff = sigA - sigB;
+        if ( ! sigDiff ) {
+            uiZ =
+                packToF32UI(
+                    (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+            goto uiZ;
+        }
+        if ( expA ) --expA;
+        signZ = signF32UI( uiA );
+        if ( sigDiff < 0 ) {
+            signZ = ! signZ;
+            sigDiff = -sigDiff;
+        }
+        shiftDist = softfloat_countLeadingZeros32( sigDiff ) - 8;
+        expZ = expA - shiftDist;
+        if ( expZ < 0 ) {
+            shiftDist = expA;
+            expZ = 0;
+        }
+        uiZ = packToF32UI( signZ, expZ, sigDiff<<shiftDist );
+        goto uiZ;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        signZ = signF32UI( uiA );
+        sigA <<= 7;
+        sigB <<= 7;
+        if ( expDiff < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            signZ = ! signZ;
+            if ( expB == 0xFF ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF32UI( signZ, 0xFF, 0 );
+                goto uiZ;
+            }
+            expZ = expB - 1;
+            sigX = sigB | 0x40000000;
+            sigY = sigA + (expA ? 0x40000000 : sigA);
+            expDiff = -expDiff;
+        } else {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            if ( expA == 0xFF ) {
+                if ( sigA ) goto propagateNaN;
+                uiZ = uiA;
+                goto uiZ;
+            }
+            expZ = expA - 1;
+            sigX = sigA | 0x40000000;
+            sigY = sigB + (expB ? 0x40000000 : sigB);
+        }
+        return
+            softfloat_normRoundPackToF32(
+                signZ, expZ, sigX - softfloat_shiftRightJam32( sigY, expDiff )
+            );
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF64.c b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF64.c
new file mode 100755
index 000000000..c9a94c9d1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF64.c
@@ -0,0 +1,141 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t
+ softfloat_subMagsF64( uint_fast64_t uiA, uint_fast64_t uiB, bool signZ )
+{
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    int_fast16_t expDiff;
+    uint_fast64_t uiZ;
+    int_fast64_t sigDiff;
+    int_fast8_t shiftDist;
+    int_fast16_t expZ;
+    uint_fast64_t sigZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF64UI( uiA );
+    sigA = fracF64UI( uiA );
+    expB = expF64UI( uiB );
+    sigB = fracF64UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expA == 0x7FF ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            uiZ = defaultNaNF64UI;
+            goto uiZ;
+        }
+        sigDiff = sigA - sigB;
+        if ( ! sigDiff ) {
+            uiZ =
+                packToF64UI(
+                    (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+            goto uiZ;
+        }
+        if ( expA ) --expA;
+        if ( sigDiff < 0 ) {
+            signZ = ! signZ;
+            sigDiff = -sigDiff;
+        }
+        shiftDist = softfloat_countLeadingZeros64( sigDiff ) - 11;
+        expZ = expA - shiftDist;
+        if ( expZ < 0 ) {
+            shiftDist = expA;
+            expZ = 0;
+        }
+        uiZ = packToF64UI( signZ, expZ, sigDiff<<shiftDist );
+        goto uiZ;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sigA <<= 10;
+        sigB <<= 10;
+        if ( expDiff < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            signZ = ! signZ;
+            if ( expB == 0x7FF ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF64UI( signZ, 0x7FF, 0 );
+                goto uiZ;
+            }
+            sigA += expA ? UINT64_C( 0x4000000000000000 ) : sigA;
+            sigA = softfloat_shiftRightJam64( sigA, -expDiff );
+            sigB |= UINT64_C( 0x4000000000000000 );
+            expZ = expB;
+            sigZ = sigB - sigA;
+        } else {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            if ( expA == 0x7FF ) {
+                if ( sigA ) goto propagateNaN;
+                uiZ = uiA;
+                goto uiZ;
+            }
+            sigB += expB ? UINT64_C( 0x4000000000000000 ) : sigB;
+            sigB = softfloat_shiftRightJam64( sigB, expDiff );
+            sigA |= UINT64_C( 0x4000000000000000 );
+            expZ = expA;
+            sigZ = sigA - sigB;
+        }
+        return softfloat_normRoundPackToF64( signZ, expZ - 1, sigZ );
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/softfloat.h b/arch/riscv/kernel/soft_vector/softfloat/softfloat.h
new file mode 100755
index 000000000..f47cc6af2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/softfloat.h
@@ -0,0 +1,396 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+
+/*============================================================================
+| Note:  If SoftFloat is made available as a general library for programs to
+| use, it is strongly recommended that a platform-specific version of this
+| header, "softfloat.h", be created that folds in "softfloat_types.h" and that
+| eliminates all dependencies on compile-time macros.
+*============================================================================*/
+
+
+#ifndef softfloat_h
+#define softfloat_h 1
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "softfloat_types.h"
+
+#ifndef THREAD_LOCAL
+#define THREAD_LOCAL
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*----------------------------------------------------------------------------
+| Software floating-point underflow tininess-detection mode.
+*----------------------------------------------------------------------------*/
+extern THREAD_LOCAL uint_fast8_t softfloat_detectTininess;
+enum {
+    softfloat_tininess_beforeRounding = 0,
+    softfloat_tininess_afterRounding  = 1
+};
+
+/*----------------------------------------------------------------------------
+| Software floating-point rounding mode.  (Mode "odd" is supported only if
+| SoftFloat is compiled with macro 'SOFTFLOAT_ROUND_ODD' defined.)
+*----------------------------------------------------------------------------*/
+extern THREAD_LOCAL uint_fast8_t softfloat_roundingMode;
+enum {
+    softfloat_round_near_even   = 0,
+    softfloat_round_minMag      = 1,
+    softfloat_round_min         = 2,
+    softfloat_round_max         = 3,
+    softfloat_round_near_maxMag = 4,
+    softfloat_round_odd         = 5
+};
+
+/*----------------------------------------------------------------------------
+| Software floating-point exception flags.
+*----------------------------------------------------------------------------*/
+extern THREAD_LOCAL uint_fast8_t softfloat_exceptionFlags;
+enum {
+    softfloat_flag_inexact   =  1,
+    softfloat_flag_underflow =  2,
+    softfloat_flag_overflow  =  4,
+    softfloat_flag_infinite  =  8,
+    softfloat_flag_invalid   = 16
+};
+
+/*----------------------------------------------------------------------------
+| Routine to raise any or all of the software floating-point exception flags.
+*----------------------------------------------------------------------------*/
+void softfloat_raiseFlags( uint_fast8_t );
+
+/*----------------------------------------------------------------------------
+| Integer-to-floating-point conversion routines.
+*----------------------------------------------------------------------------*/
+float16_t ui32_to_f16( uint32_t );
+float32_t ui32_to_f32( uint32_t );
+float64_t ui32_to_f64( uint32_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t ui32_to_extF80( uint32_t );
+float128_t ui32_to_f128( uint32_t );
+#endif
+void ui32_to_extF80M( uint32_t, extFloat80_t * );
+void ui32_to_f128M( uint32_t, float128_t * );
+float16_t ui64_to_f16( uint64_t );
+float32_t ui64_to_f32( uint64_t );
+float64_t ui64_to_f64( uint64_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t ui64_to_extF80( uint64_t );
+float128_t ui64_to_f128( uint64_t );
+#endif
+void ui64_to_extF80M( uint64_t, extFloat80_t * );
+void ui64_to_f128M( uint64_t, float128_t * );
+float16_t i32_to_f16( int32_t );
+float32_t i32_to_f32( int32_t );
+float64_t i32_to_f64( int32_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t i32_to_extF80( int32_t );
+float128_t i32_to_f128( int32_t );
+#endif
+void i32_to_extF80M( int32_t, extFloat80_t * );
+void i32_to_f128M( int32_t, float128_t * );
+float16_t i64_to_f16( int64_t );
+float32_t i64_to_f32( int64_t );
+float64_t i64_to_f64( int64_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t i64_to_extF80( int64_t );
+float128_t i64_to_f128( int64_t );
+#endif
+void i64_to_extF80M( int64_t, extFloat80_t * );
+void i64_to_f128M( int64_t, float128_t * );
+
+/*----------------------------------------------------------------------------
+| 16-bit (half-precision) floating-point operations.
+*----------------------------------------------------------------------------*/
+uint_fast8_t f16_to_ui8( float16_t, uint_fast8_t, bool );
+uint_fast16_t f16_to_ui16( float16_t, uint_fast8_t, bool );
+uint_fast32_t f16_to_ui32( float16_t, uint_fast8_t, bool );
+uint_fast64_t f16_to_ui64( float16_t, uint_fast8_t, bool );
+int_fast8_t f16_to_i8( float16_t, uint_fast8_t, bool );
+int_fast16_t f16_to_i16( float16_t, uint_fast8_t, bool );
+int_fast32_t f16_to_i32( float16_t, uint_fast8_t, bool );
+int_fast64_t f16_to_i64( float16_t, uint_fast8_t, bool );
+uint_fast32_t f16_to_ui32_r_minMag( float16_t, bool );
+uint_fast64_t f16_to_ui64_r_minMag( float16_t, bool );
+int_fast32_t f16_to_i32_r_minMag( float16_t, bool );
+int_fast64_t f16_to_i64_r_minMag( float16_t, bool );
+float32_t f16_to_f32( float16_t );
+float64_t f16_to_f64( float16_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t f16_to_extF80( float16_t );
+float128_t f16_to_f128( float16_t );
+#endif
+void f16_to_extF80M( float16_t, extFloat80_t * );
+void f16_to_f128M( float16_t, float128_t * );
+float16_t f16_roundToInt( float16_t, uint_fast8_t, bool );
+float16_t f16_add( float16_t, float16_t );
+float16_t f16_sub( float16_t, float16_t );
+float16_t f16_max( float16_t, float16_t );
+float16_t f16_min( float16_t, float16_t );
+float16_t f16_mul( float16_t, float16_t );
+float16_t f16_mulAdd( float16_t, float16_t, float16_t );
+float16_t f16_div( float16_t, float16_t );
+float16_t f16_rem( float16_t, float16_t );
+float16_t f16_sqrt( float16_t );
+bool f16_eq( float16_t, float16_t );
+bool f16_le( float16_t, float16_t );
+bool f16_lt( float16_t, float16_t );
+bool f16_eq_signaling( float16_t, float16_t );
+bool f16_le_quiet( float16_t, float16_t );
+bool f16_lt_quiet( float16_t, float16_t );
+bool f16_isSignalingNaN( float16_t );
+uint_fast16_t f16_classify( float16_t );
+
+/*----------------------------------------------------------------------------
+| 32-bit (single-precision) floating-point operations.
+*----------------------------------------------------------------------------*/
+uint_fast16_t f32_to_ui16( float32_t, uint_fast8_t, bool );
+uint_fast32_t f32_to_ui32( float32_t, uint_fast8_t, bool );
+uint_fast64_t f32_to_ui64( float32_t, uint_fast8_t, bool );
+int_fast16_t f32_to_i16( float32_t, uint_fast8_t, bool );
+int_fast32_t f32_to_i32( float32_t, uint_fast8_t, bool );
+int_fast64_t f32_to_i64( float32_t, uint_fast8_t, bool );
+uint_fast32_t f32_to_ui32_r_minMag( float32_t, bool );
+uint_fast64_t f32_to_ui64_r_minMag( float32_t, bool );
+int_fast32_t f32_to_i32_r_minMag( float32_t, bool );
+int_fast64_t f32_to_i64_r_minMag( float32_t, bool );
+float16_t f32_to_f16( float32_t );
+float64_t f32_to_f64( float32_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t f32_to_extF80( float32_t );
+float128_t f32_to_f128( float32_t );
+#endif
+void f32_to_extF80M( float32_t, extFloat80_t * );
+void f32_to_f128M( float32_t, float128_t * );
+float32_t f32_roundToInt( float32_t, uint_fast8_t, bool );
+float32_t f32_add( float32_t, float32_t );
+float32_t f32_sub( float32_t, float32_t );
+float32_t f32_max( float32_t, float32_t );
+float32_t f32_min( float32_t, float32_t );
+float32_t f32_mul( float32_t, float32_t );
+float32_t f32_mulAdd( float32_t, float32_t, float32_t );
+float32_t f32_div( float32_t, float32_t );
+float32_t f32_rem( float32_t, float32_t );
+float32_t f32_sqrt( float32_t );
+bool f32_eq( float32_t, float32_t );
+bool f32_le( float32_t, float32_t );
+bool f32_lt( float32_t, float32_t );
+bool f32_eq_signaling( float32_t, float32_t );
+bool f32_le_quiet( float32_t, float32_t );
+bool f32_lt_quiet( float32_t, float32_t );
+bool f32_isSignalingNaN( float32_t );
+uint_fast16_t f32_classify( float32_t );
+
+/*----------------------------------------------------------------------------
+| 64-bit (double-precision) floating-point operations.
+*----------------------------------------------------------------------------*/
+uint_fast32_t f64_to_ui32( float64_t, uint_fast8_t, bool );
+uint_fast64_t f64_to_ui64( float64_t, uint_fast8_t, bool );
+int_fast32_t f64_to_i32( float64_t, uint_fast8_t, bool );
+int_fast64_t f64_to_i64( float64_t, uint_fast8_t, bool );
+uint_fast32_t f64_to_ui32_r_minMag( float64_t, bool );
+uint_fast64_t f64_to_ui64_r_minMag( float64_t, bool );
+int_fast32_t f64_to_i32_r_minMag( float64_t, bool );
+int_fast64_t f64_to_i64_r_minMag( float64_t, bool );
+float16_t f64_to_f16( float64_t );
+float32_t f64_to_f32( float64_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t f64_to_extF80( float64_t );
+float128_t f64_to_f128( float64_t );
+#endif
+void f64_to_extF80M( float64_t, extFloat80_t * );
+void f64_to_f128M( float64_t, float128_t * );
+float64_t f64_roundToInt( float64_t, uint_fast8_t, bool );
+float64_t f64_add( float64_t, float64_t );
+float64_t f64_sub( float64_t, float64_t );
+float64_t f64_max( float64_t, float64_t );
+float64_t f64_min( float64_t, float64_t );
+float64_t f64_mul( float64_t, float64_t );
+float64_t f64_mulAdd( float64_t, float64_t, float64_t );
+float64_t f64_div( float64_t, float64_t );
+float64_t f64_rem( float64_t, float64_t );
+float64_t f64_sqrt( float64_t );
+bool f64_eq( float64_t, float64_t );
+bool f64_le( float64_t, float64_t );
+bool f64_lt( float64_t, float64_t );
+bool f64_eq_signaling( float64_t, float64_t );
+bool f64_le_quiet( float64_t, float64_t );
+bool f64_lt_quiet( float64_t, float64_t );
+bool f64_isSignalingNaN( float64_t );
+uint_fast16_t f64_classify( float64_t );
+
+/*----------------------------------------------------------------------------
+| Rounding precision for 80-bit extended double-precision floating-point.
+| Valid values are 32, 64, and 80.
+*----------------------------------------------------------------------------*/
+extern THREAD_LOCAL uint_fast8_t extF80_roundingPrecision;
+
+/*----------------------------------------------------------------------------
+| 80-bit extended double-precision floating-point operations.
+*----------------------------------------------------------------------------*/
+#ifdef SOFTFLOAT_FAST_INT64
+uint_fast32_t extF80_to_ui32( extFloat80_t, uint_fast8_t, bool );
+uint_fast64_t extF80_to_ui64( extFloat80_t, uint_fast8_t, bool );
+int_fast32_t extF80_to_i32( extFloat80_t, uint_fast8_t, bool );
+int_fast64_t extF80_to_i64( extFloat80_t, uint_fast8_t, bool );
+uint_fast32_t extF80_to_ui32_r_minMag( extFloat80_t, bool );
+uint_fast64_t extF80_to_ui64_r_minMag( extFloat80_t, bool );
+int_fast32_t extF80_to_i32_r_minMag( extFloat80_t, bool );
+int_fast64_t extF80_to_i64_r_minMag( extFloat80_t, bool );
+float16_t extF80_to_f16( extFloat80_t );
+float32_t extF80_to_f32( extFloat80_t );
+float64_t extF80_to_f64( extFloat80_t );
+float128_t extF80_to_f128( extFloat80_t );
+extFloat80_t extF80_roundToInt( extFloat80_t, uint_fast8_t, bool );
+extFloat80_t extF80_add( extFloat80_t, extFloat80_t );
+extFloat80_t extF80_sub( extFloat80_t, extFloat80_t );
+extFloat80_t extF80_mul( extFloat80_t, extFloat80_t );
+extFloat80_t extF80_div( extFloat80_t, extFloat80_t );
+extFloat80_t extF80_rem( extFloat80_t, extFloat80_t );
+extFloat80_t extF80_sqrt( extFloat80_t );
+bool extF80_eq( extFloat80_t, extFloat80_t );
+bool extF80_le( extFloat80_t, extFloat80_t );
+bool extF80_lt( extFloat80_t, extFloat80_t );
+bool extF80_eq_signaling( extFloat80_t, extFloat80_t );
+bool extF80_le_quiet( extFloat80_t, extFloat80_t );
+bool extF80_lt_quiet( extFloat80_t, extFloat80_t );
+bool extF80_isSignalingNaN( extFloat80_t );
+#endif
+uint_fast32_t extF80M_to_ui32( const extFloat80_t *, uint_fast8_t, bool );
+uint_fast64_t extF80M_to_ui64( const extFloat80_t *, uint_fast8_t, bool );
+int_fast32_t extF80M_to_i32( const extFloat80_t *, uint_fast8_t, bool );
+int_fast64_t extF80M_to_i64( const extFloat80_t *, uint_fast8_t, bool );
+uint_fast32_t extF80M_to_ui32_r_minMag( const extFloat80_t *, bool );
+uint_fast64_t extF80M_to_ui64_r_minMag( const extFloat80_t *, bool );
+int_fast32_t extF80M_to_i32_r_minMag( const extFloat80_t *, bool );
+int_fast64_t extF80M_to_i64_r_minMag( const extFloat80_t *, bool );
+float16_t extF80M_to_f16( const extFloat80_t * );
+float32_t extF80M_to_f32( const extFloat80_t * );
+float64_t extF80M_to_f64( const extFloat80_t * );
+void extF80M_to_f128M( const extFloat80_t *, float128_t * );
+void
+ extF80M_roundToInt(
+     const extFloat80_t *, uint_fast8_t, bool, extFloat80_t * );
+void extF80M_add( const extFloat80_t *, const extFloat80_t *, extFloat80_t * );
+void extF80M_sub( const extFloat80_t *, const extFloat80_t *, extFloat80_t * );
+void extF80M_mul( const extFloat80_t *, const extFloat80_t *, extFloat80_t * );
+void extF80M_div( const extFloat80_t *, const extFloat80_t *, extFloat80_t * );
+void extF80M_rem( const extFloat80_t *, const extFloat80_t *, extFloat80_t * );
+void extF80M_sqrt( const extFloat80_t *, extFloat80_t * );
+bool extF80M_eq( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_le( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_lt( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_eq_signaling( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_le_quiet( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_lt_quiet( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_isSignalingNaN( const extFloat80_t * );
+
+/*----------------------------------------------------------------------------
+| 128-bit (quadruple-precision) floating-point operations.
+*----------------------------------------------------------------------------*/
+#ifdef SOFTFLOAT_FAST_INT64
+uint_fast32_t f128_to_ui32( float128_t, uint_fast8_t, bool );
+uint_fast64_t f128_to_ui64( float128_t, uint_fast8_t, bool );
+int_fast32_t f128_to_i32( float128_t, uint_fast8_t, bool );
+int_fast64_t f128_to_i64( float128_t, uint_fast8_t, bool );
+uint_fast32_t f128_to_ui32_r_minMag( float128_t, bool );
+uint_fast64_t f128_to_ui64_r_minMag( float128_t, bool );
+int_fast32_t f128_to_i32_r_minMag( float128_t, bool );
+int_fast64_t f128_to_i64_r_minMag( float128_t, bool );
+float16_t f128_to_f16( float128_t );
+float32_t f128_to_f32( float128_t );
+float64_t f128_to_f64( float128_t );
+extFloat80_t f128_to_extF80( float128_t );
+float128_t f128_roundToInt( float128_t, uint_fast8_t, bool );
+float128_t f128_add( float128_t, float128_t );
+float128_t f128_sub( float128_t, float128_t );
+float128_t f128_mul( float128_t, float128_t );
+float128_t f128_mulAdd( float128_t, float128_t, float128_t );
+float128_t f128_div( float128_t, float128_t );
+float128_t f128_rem( float128_t, float128_t );
+float128_t f128_sqrt( float128_t );
+bool f128_eq( float128_t, float128_t );
+bool f128_le( float128_t, float128_t );
+bool f128_lt( float128_t, float128_t );
+bool f128_eq_signaling( float128_t, float128_t );
+bool f128_le_quiet( float128_t, float128_t );
+bool f128_lt_quiet( float128_t, float128_t );
+bool f128_isSignalingNaN( float128_t );
+uint_fast16_t f128_classify( float128_t );
+#endif
+uint_fast32_t f128M_to_ui32( const float128_t *, uint_fast8_t, bool );
+uint_fast64_t f128M_to_ui64( const float128_t *, uint_fast8_t, bool );
+int_fast32_t f128M_to_i32( const float128_t *, uint_fast8_t, bool );
+int_fast64_t f128M_to_i64( const float128_t *, uint_fast8_t, bool );
+uint_fast32_t f128M_to_ui32_r_minMag( const float128_t *, bool );
+uint_fast64_t f128M_to_ui64_r_minMag( const float128_t *, bool );
+int_fast32_t f128M_to_i32_r_minMag( const float128_t *, bool );
+int_fast64_t f128M_to_i64_r_minMag( const float128_t *, bool );
+float16_t f128M_to_f16( const float128_t * );
+float32_t f128M_to_f32( const float128_t * );
+float64_t f128M_to_f64( const float128_t * );
+void f128M_to_extF80M( const float128_t *, extFloat80_t * );
+void f128M_roundToInt( const float128_t *, uint_fast8_t, bool, float128_t * );
+void f128M_add( const float128_t *, const float128_t *, float128_t * );
+void f128M_sub( const float128_t *, const float128_t *, float128_t * );
+void f128M_mul( const float128_t *, const float128_t *, float128_t * );
+void
+ f128M_mulAdd(
+     const float128_t *, const float128_t *, const float128_t *, float128_t *
+ );
+void f128M_div( const float128_t *, const float128_t *, float128_t * );
+void f128M_rem( const float128_t *, const float128_t *, float128_t * );
+void f128M_sqrt( const float128_t *, float128_t * );
+bool f128M_eq( const float128_t *, const float128_t * );
+bool f128M_le( const float128_t *, const float128_t * );
+bool f128M_lt( const float128_t *, const float128_t * );
+bool f128M_eq_signaling( const float128_t *, const float128_t * );
+bool f128M_le_quiet( const float128_t *, const float128_t * );
+bool f128M_lt_quiet( const float128_t *, const float128_t * );
+bool f128M_isSignalingNaN( const float128_t * );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/softfloat_raiseFlags.c b/arch/riscv/kernel/soft_vector/softfloat/softfloat_raiseFlags.c
new file mode 100755
index 000000000..f2c25adee
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/softfloat_raiseFlags.c
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "platform.h"
+#include "softfloat.h"
+
+/*----------------------------------------------------------------------------
+| Raises the exceptions specified by `flags'.  Floating-point traps can be
+| defined here if desired.  It is currently not possible for such a trap
+| to substitute a result value.  If traps are not implemented, this routine
+| should be simply `softfloat_exceptionFlags |= flags;'.
+*----------------------------------------------------------------------------*/
+void softfloat_raiseFlags( uint_fast8_t flags )
+{
+
+    softfloat_exceptionFlags |= flags;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/softfloat_state.c b/arch/riscv/kernel/soft_vector/softfloat/softfloat_state.c
new file mode 100755
index 000000000..d638a7225
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/softfloat_state.c
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+#ifndef THREAD_LOCAL
+#define THREAD_LOCAL
+#endif
+
+THREAD_LOCAL uint_fast8_t softfloat_roundingMode = softfloat_round_near_even;
+THREAD_LOCAL uint_fast8_t softfloat_detectTininess = init_detectTininess;
+THREAD_LOCAL uint_fast8_t softfloat_exceptionFlags = 0;
+
+THREAD_LOCAL uint_fast8_t extF80_roundingPrecision = 80;
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/softfloat_types.h b/arch/riscv/kernel/soft_vector/softfloat/softfloat_types.h
new file mode 100755
index 000000000..1f8c34525
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/softfloat_types.h
@@ -0,0 +1,81 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_types_h
+#define softfloat_types_h 1
+
+#include "stdint.h"
+
+/*----------------------------------------------------------------------------
+| Types used to pass 16-bit, 32-bit, 64-bit, and 128-bit floating-point
+| arguments and results to/from functions.  These types must be exactly
+| 16 bits, 32 bits, 64 bits, and 128 bits in size, respectively.  Where a
+| platform has "native" support for IEEE-Standard floating-point formats,
+| the types below may, if desired, be defined as aliases for the native types
+| (typically 'float' and 'double', and possibly 'long double').
+*----------------------------------------------------------------------------*/
+typedef struct { uint16_t v; } float16_t;
+typedef struct { uint32_t v; } float32_t;
+typedef struct { uint64_t v; } float64_t;
+typedef struct { uint64_t v[2]; } float128_t;
+
+/*----------------------------------------------------------------------------
+| The format of an 80-bit extended floating-point number in memory.  This
+| structure must contain a 16-bit field named 'signExp' and a 64-bit field
+| named 'signif'.
+*----------------------------------------------------------------------------*/
+#ifdef LITTLEENDIAN
+struct extFloat80M { uint64_t signif; uint16_t signExp; };
+#else
+struct extFloat80M { uint16_t signExp; uint64_t signif; };
+#endif
+
+/*----------------------------------------------------------------------------
+| The type used to pass 80-bit extended floating-point arguments and
+| results to/from functions.  This type must have size identical to
+| 'struct extFloat80M'.  Type 'extFloat80_t' can be defined as an alias for
+| 'struct extFloat80M'.  Alternatively, if a platform has "native" support
+| for IEEE-Standard 80-bit extended floating-point, it may be possible,
+| if desired, to define 'extFloat80_t' as an alias for the native type
+| (presumably either 'long double' or a nonstandard compiler-intrinsic type).
+| In that case, the 'signif' and 'signExp' fields of 'struct extFloat80M'
+| must align exactly with the locations in memory of the sign, exponent, and
+| significand of the native type.
+*----------------------------------------------------------------------------*/
+typedef struct extFloat80M extFloat80_t;
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/specialize.h b/arch/riscv/kernel/soft_vector/softfloat/specialize.h
new file mode 100755
index 000000000..ff0975beb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/specialize.h
@@ -0,0 +1,429 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef specialize_h
+#define specialize_h 1
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "primitiveTypes.h"
+#include "softfloat.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*----------------------------------------------------------------------------
+| Default value for `softfloat_detectTininess'.
+*----------------------------------------------------------------------------*/
+#define init_detectTininess softfloat_tininess_afterRounding
+
+/*----------------------------------------------------------------------------
+| The values to return on conversions to 32-bit integer formats that raise an
+| invalid exception.
+*----------------------------------------------------------------------------*/
+#define ui8_fromPosOverflow  0xFF
+#define ui8_fromNegOverflow  0
+#define ui8_fromNaN          0xFF
+#define i8_fromPosOverflow   0x7F
+#define i8_fromNegOverflow   (-0x7F - 1)
+#define i8_fromNaN           0x7F
+
+#define ui16_fromPosOverflow 0xFFFF
+#define ui16_fromNegOverflow 0
+#define ui16_fromNaN         0xFFFF
+#define i16_fromPosOverflow  0x7FFF
+#define i16_fromNegOverflow  (-0x7FFF - 1)
+#define i16_fromNaN          0x7FFF
+
+#define ui32_fromPosOverflow 0xFFFFFFFF
+#define ui32_fromNegOverflow 0
+#define ui32_fromNaN         0xFFFFFFFF
+#define i32_fromPosOverflow  0x7FFFFFFF
+#define i32_fromNegOverflow  (-0x7FFFFFFF - 1)
+#define i32_fromNaN          0x7FFFFFFF
+
+/*----------------------------------------------------------------------------
+| The values to return on conversions to 64-bit integer formats that raise an
+| invalid exception.
+*----------------------------------------------------------------------------*/
+#define ui64_fromPosOverflow UINT64_C( 0xFFFFFFFFFFFFFFFF )
+#define ui64_fromNegOverflow 0
+#define ui64_fromNaN         UINT64_C( 0xFFFFFFFFFFFFFFFF )
+#define i64_fromPosOverflow  UINT64_C( 0x7FFFFFFFFFFFFFFF )
+#define i64_fromNegOverflow  (-UINT64_C( 0x7FFFFFFFFFFFFFFF ) - 1)
+#define i64_fromNaN          UINT64_C( 0x7FFFFFFFFFFFFFFF )
+
+/*----------------------------------------------------------------------------
+| "Common NaN" structure, used to transfer NaN representations from one format
+| to another.
+*----------------------------------------------------------------------------*/
+struct commonNaN { char _unused; };
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 16-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF16UI 0x7E00
+
+/*----------------------------------------------------------------------------
+| Returns true when 16-bit unsigned integer `uiA' has the bit pattern of a
+| 16-bit floating-point signaling NaN.
+| Note:  This macro evaluates its argument more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF16UI( uiA ) ((((uiA) & 0x7E00) == 0x7C00) && ((uiA) & 0x01FF))
+
+/*----------------------------------------------------------------------------
+| Assuming `uiA' has the bit pattern of a 16-bit floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f16UIToCommonNaN( uiA, zPtr ) if ( ! ((uiA) & 0x0200) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 16-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+#define softfloat_commonNaNToF16UI( aPtr ) ((uint_fast16_t) defaultNaNF16UI)
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 16-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast16_t
+ softfloat_propagateNaNF16UI( uint_fast16_t uiA, uint_fast16_t uiB );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 32-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF32UI 0x7FC00000
+
+/*----------------------------------------------------------------------------
+| Returns true when 32-bit unsigned integer `uiA' has the bit pattern of a
+| 32-bit floating-point signaling NaN.
+| Note:  This macro evaluates its argument more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF32UI( uiA ) ((((uiA) & 0x7FC00000) == 0x7F800000) && ((uiA) & 0x003FFFFF))
+
+/*----------------------------------------------------------------------------
+| Assuming `uiA' has the bit pattern of a 32-bit floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f32UIToCommonNaN( uiA, zPtr ) if ( ! ((uiA) & 0x00400000) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 32-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+#define softfloat_commonNaNToF32UI( aPtr ) ((uint_fast32_t) defaultNaNF32UI)
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 32-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast32_t
+ softfloat_propagateNaNF32UI( uint_fast32_t uiA, uint_fast32_t uiB );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 64-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF64UI UINT64_C( 0x7FF8000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns true when 64-bit unsigned integer `uiA' has the bit pattern of a
+| 64-bit floating-point signaling NaN.
+| Note:  This macro evaluates its argument more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF64UI( uiA ) ((((uiA) & UINT64_C( 0x7FF8000000000000 )) == UINT64_C( 0x7FF0000000000000 )) && ((uiA) & UINT64_C( 0x0007FFFFFFFFFFFF )))
+
+/*----------------------------------------------------------------------------
+| Assuming `uiA' has the bit pattern of a 64-bit floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f64UIToCommonNaN( uiA, zPtr ) if ( ! ((uiA) & UINT64_C( 0x0008000000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 64-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+#define softfloat_commonNaNToF64UI( aPtr ) ((uint_fast64_t) defaultNaNF64UI)
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 64-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast64_t
+ softfloat_propagateNaNF64UI( uint_fast64_t uiA, uint_fast64_t uiB );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 80-bit extended floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNExtF80UI64 0x7FFF
+#define defaultNaNExtF80UI0  UINT64_C( 0xC000000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns true when the 80-bit unsigned integer formed from concatenating
+| 16-bit `uiA64' and 64-bit `uiA0' has the bit pattern of an 80-bit extended
+| floating-point signaling NaN.
+| Note:  This macro evaluates its arguments more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNExtF80UI( uiA64, uiA0 ) ((((uiA64) & 0x7FFF) == 0x7FFF) && ! ((uiA0) & UINT64_C( 0x4000000000000000 )) && ((uiA0) & UINT64_C( 0x3FFFFFFFFFFFFFFF )))
+
+#ifdef SOFTFLOAT_FAST_INT64
+
+/*----------------------------------------------------------------------------
+| The following functions are needed only when `SOFTFLOAT_FAST_INT64' is
+| defined.
+*----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+| Assuming the unsigned integer formed from concatenating `uiA64' and `uiA0'
+| has the bit pattern of an 80-bit extended floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_extF80UIToCommonNaN( uiA64, uiA0, zPtr ) if ( ! ((uiA0) & UINT64_C( 0x4000000000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into an 80-bit extended
+| floating-point NaN, and returns the bit pattern of this value as an unsigned
+| integer.
+*----------------------------------------------------------------------------*/
+#if defined INLINE && ! defined softfloat_commonNaNToExtF80UI
+INLINE
+struct uint128 softfloat_commonNaNToExtF80UI( const struct commonNaN *aPtr )
+{
+    struct uint128 uiZ;
+    uiZ.v64 = defaultNaNExtF80UI64;
+    uiZ.v0  = defaultNaNExtF80UI0;
+    return uiZ;
+}
+#else
+struct uint128 softfloat_commonNaNToExtF80UI( const struct commonNaN *aPtr );
+#endif
+
+/*----------------------------------------------------------------------------
+| Interpreting the unsigned integer formed from concatenating `uiA64' and
+| `uiA0' as an 80-bit extended floating-point value, and likewise interpreting
+| the unsigned integer formed from concatenating `uiB64' and `uiB0' as another
+| 80-bit extended floating-point value, and assuming at least on of these
+| floating-point values is a NaN, returns the bit pattern of the combined NaN
+| result.  If either original floating-point value is a signaling NaN, the
+| invalid exception is raised.
+*----------------------------------------------------------------------------*/
+struct uint128
+ softfloat_propagateNaNExtF80UI(
+     uint_fast16_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast16_t uiB64,
+     uint_fast64_t uiB0
+ );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 128-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF128UI64 UINT64_C( 0x7FFF800000000000 )
+#define defaultNaNF128UI0  UINT64_C( 0 )
+
+/*----------------------------------------------------------------------------
+| Returns true when the 128-bit unsigned integer formed from concatenating
+| 64-bit `uiA64' and 64-bit `uiA0' has the bit pattern of a 128-bit floating-
+| point signaling NaN.
+| Note:  This macro evaluates its arguments more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF128UI( uiA64, uiA0 ) ((((uiA64) & UINT64_C( 0x7FFF800000000000 )) == UINT64_C( 0x7FFF000000000000 )) && ((uiA0) || ((uiA64) & UINT64_C( 0x00007FFFFFFFFFFF ))))
+
+/*----------------------------------------------------------------------------
+| Assuming the unsigned integer formed from concatenating `uiA64' and `uiA0'
+| has the bit pattern of a 128-bit floating-point NaN, converts this NaN to
+| the common NaN form, and stores the resulting common NaN at the location
+| pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid exception
+| is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f128UIToCommonNaN( uiA64, uiA0, zPtr ) if ( ! ((uiA64) & UINT64_C( 0x0000800000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 128-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+#if defined INLINE && ! defined softfloat_commonNaNToF128UI
+INLINE
+struct uint128 softfloat_commonNaNToF128UI( const struct commonNaN *aPtr )
+{
+    struct uint128 uiZ;
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+    return uiZ;
+}
+#else
+struct uint128 softfloat_commonNaNToF128UI( const struct commonNaN * );
+#endif
+
+/*----------------------------------------------------------------------------
+| Interpreting the unsigned integer formed from concatenating `uiA64' and
+| `uiA0' as a 128-bit floating-point value, and likewise interpreting the
+| unsigned integer formed from concatenating `uiB64' and `uiB0' as another
+| 128-bit floating-point value, and assuming at least on of these floating-
+| point values is a NaN, returns the bit pattern of the combined NaN result.
+| If either original floating-point value is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+struct uint128
+ softfloat_propagateNaNF128UI(
+     uint_fast64_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast64_t uiB64,
+     uint_fast64_t uiB0
+ );
+
+#else
+
+/*----------------------------------------------------------------------------
+| The following functions are needed only when `SOFTFLOAT_FAST_INT64' is not
+| defined.
+*----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+| Assuming the 80-bit extended floating-point value pointed to by `aSPtr' is
+| a NaN, converts this NaN to the common NaN form, and stores the resulting
+| common NaN at the location pointed to by `zPtr'.  If the NaN is a signaling
+| NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_extF80MToCommonNaN( aSPtr, zPtr ) if ( ! ((aSPtr)->signif & UINT64_C( 0x4000000000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into an 80-bit extended
+| floating-point NaN, and stores this NaN at the location pointed to by
+| `zSPtr'.
+*----------------------------------------------------------------------------*/
+#if defined INLINE && ! defined softfloat_commonNaNToExtF80M
+INLINE
+void
+ softfloat_commonNaNToExtF80M(
+     const struct commonNaN *aPtr, struct extFloat80M *zSPtr )
+{
+    zSPtr->signExp = defaultNaNExtF80UI64;
+    zSPtr->signif  = defaultNaNExtF80UI0;
+}
+#else
+void
+ softfloat_commonNaNToExtF80M(
+     const struct commonNaN *aPtr, struct extFloat80M *zSPtr );
+#endif
+
+/*----------------------------------------------------------------------------
+| Assuming at least one of the two 80-bit extended floating-point values
+| pointed to by `aSPtr' and `bSPtr' is a NaN, stores the combined NaN result
+| at the location pointed to by `zSPtr'.  If either original floating-point
+| value is a signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_propagateNaNExtF80M(
+     const struct extFloat80M *aSPtr,
+     const struct extFloat80M *bSPtr,
+     struct extFloat80M *zSPtr
+ );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 128-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF128UI96 0x7FFF8000
+#define defaultNaNF128UI64 0
+#define defaultNaNF128UI32 0
+#define defaultNaNF128UI0  0
+
+/*----------------------------------------------------------------------------
+| Assuming the 128-bit floating-point value pointed to by `aWPtr' is a NaN,
+| converts this NaN to the common NaN form, and stores the resulting common
+| NaN at the location pointed to by `zPtr'.  If the NaN is a signaling NaN,
+| the invalid exception is raised.  Argument `aWPtr' points to an array of
+| four 32-bit elements that concatenate in the platform's normal endian order
+| to form a 128-bit floating-point value.
+*----------------------------------------------------------------------------*/
+#define softfloat_f128MToCommonNaN( aWPtr, zPtr ) if ( ! ((aWPtr)[indexWordHi( 4 )] & UINT64_C( 0x0000800000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 128-bit floating-point
+| NaN, and stores this NaN at the location pointed to by `zWPtr'.  Argument
+| `zWPtr' points to an array of four 32-bit elements that concatenate in the
+| platform's normal endian order to form a 128-bit floating-point value.
+*----------------------------------------------------------------------------*/
+#if defined INLINE && ! defined softfloat_commonNaNToF128M
+INLINE
+void
+ softfloat_commonNaNToF128M( const struct commonNaN *aPtr, uint32_t *zWPtr )
+{
+    zWPtr[indexWord( 4, 3 )] = defaultNaNF128UI96;
+    zWPtr[indexWord( 4, 2 )] = defaultNaNF128UI64;
+    zWPtr[indexWord( 4, 1 )] = defaultNaNF128UI32;
+    zWPtr[indexWord( 4, 0 )] = defaultNaNF128UI0;
+}
+#else
+void
+ softfloat_commonNaNToF128M( const struct commonNaN *aPtr, uint32_t *zWPtr );
+#endif
+
+/*----------------------------------------------------------------------------
+| Assuming at least one of the two 128-bit floating-point values pointed to by
+| `aWPtr' and `bWPtr' is a NaN, stores the combined NaN result at the location
+| pointed to by `zWPtr'.  If either original floating-point value is a
+| signaling NaN, the invalid exception is raised.  Each of `aWPtr', `bWPtr',
+| and `zWPtr' points to an array of four 32-bit elements that concatenate in
+| the platform's normal endian order to form a 128-bit floating-point value.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_propagateNaNF128M(
+     const uint32_t *aWPtr, const uint32_t *bWPtr, uint32_t *zWPtr );
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/stdbool.h b/arch/riscv/kernel/soft_vector/softfloat/stdbool.h
new file mode 100755
index 000000000..037d666dc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/stdbool.h
@@ -0,0 +1,7 @@
+
+
+#ifndef _STDBOOL_H
+#define _STDBOOL_H
+#include <linux/stddef.h>
+
+#endif	/* stdbool.h */
diff --git a/arch/riscv/kernel/soft_vector/softfloat/stdint.h b/arch/riscv/kernel/soft_vector/softfloat/stdint.h
new file mode 100755
index 000000000..78d268faf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/stdint.h
@@ -0,0 +1,338 @@
+/* Copyright (C) 2008-2018 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+/*
+ * ISO C Standard:  7.18  Integer types  <stdint.h>
+ */
+
+#ifndef _GCC_STDINT_H
+#define _GCC_STDINT_H
+#include <linux/types.h>
+
+/* 7.8.1.2 Minimum-width integer types */
+
+typedef __INT_LEAST8_TYPE__ int_least8_t;
+typedef __INT_LEAST16_TYPE__ int_least16_t;
+typedef __INT_LEAST32_TYPE__ int_least32_t;
+typedef __INT_LEAST64_TYPE__ int_least64_t;
+typedef __UINT_LEAST8_TYPE__ uint_least8_t;
+typedef __UINT_LEAST16_TYPE__ uint_least16_t;
+typedef __UINT_LEAST32_TYPE__ uint_least32_t;
+typedef __UINT_LEAST64_TYPE__ uint_least64_t;
+
+/* 7.8.1.3 Fastest minimum-width integer types */
+
+typedef __INT_FAST8_TYPE__ int_fast8_t;
+typedef __INT_FAST16_TYPE__ int_fast16_t;
+typedef __INT_FAST32_TYPE__ int_fast32_t;
+typedef __INT_FAST64_TYPE__ int_fast64_t;
+typedef __UINT_FAST8_TYPE__ uint_fast8_t;
+typedef __UINT_FAST16_TYPE__ uint_fast16_t;
+typedef __UINT_FAST32_TYPE__ uint_fast32_t;
+typedef __UINT_FAST64_TYPE__ uint_fast64_t;
+
+/* 7.8.1.4 Integer types capable of holding object pointers */
+
+#ifdef __INTPTR_TYPE__
+typedef __INTPTR_TYPE__ intptr_t;
+#endif
+#ifdef __UINTPTR_TYPE__
+typedef __UINTPTR_TYPE__ uintptr_t;
+#endif
+
+/* 7.8.1.5 Greatest-width integer types */
+
+typedef __INTMAX_TYPE__ intmax_t;
+typedef __UINTMAX_TYPE__ uintmax_t;
+
+#if (!defined __cplusplus || __cplusplus >= 201103L \
+     || defined __STDC_LIMIT_MACROS)
+
+/* 7.18.2 Limits of specified-width integer types */
+
+#ifdef __INT8_MAX__
+# undef INT8_MAX
+# define INT8_MAX __INT8_MAX__
+# undef INT8_MIN
+# define INT8_MIN (-INT8_MAX - 1)
+#endif
+#ifdef __UINT8_MAX__
+# undef UINT8_MAX
+# define UINT8_MAX __UINT8_MAX__
+#endif
+#ifdef __INT16_MAX__
+# undef INT16_MAX
+# define INT16_MAX __INT16_MAX__
+# undef INT16_MIN
+# define INT16_MIN (-INT16_MAX - 1)
+#endif
+#ifdef __UINT16_MAX__
+# undef UINT16_MAX
+# define UINT16_MAX __UINT16_MAX__
+#endif
+#ifdef __INT32_MAX__
+# undef INT32_MAX
+# define INT32_MAX __INT32_MAX__
+# undef INT32_MIN
+# define INT32_MIN (-INT32_MAX - 1)
+#endif
+#ifdef __UINT32_MAX__
+# undef UINT32_MAX
+# define UINT32_MAX __UINT32_MAX__
+#endif
+#ifdef __INT64_MAX__
+# undef INT64_MAX
+# define INT64_MAX __INT64_MAX__
+# undef INT64_MIN
+# define INT64_MIN (-INT64_MAX - 1)
+#endif
+#ifdef __UINT64_MAX__
+# undef UINT64_MAX
+# define UINT64_MAX __UINT64_MAX__
+#endif
+
+#undef INT_LEAST8_MAX
+#define INT_LEAST8_MAX __INT_LEAST8_MAX__
+#undef INT_LEAST8_MIN
+#define INT_LEAST8_MIN (-INT_LEAST8_MAX - 1)
+#undef UINT_LEAST8_MAX
+#define UINT_LEAST8_MAX __UINT_LEAST8_MAX__
+#undef INT_LEAST16_MAX
+#define INT_LEAST16_MAX __INT_LEAST16_MAX__
+#undef INT_LEAST16_MIN
+#define INT_LEAST16_MIN (-INT_LEAST16_MAX - 1)
+#undef UINT_LEAST16_MAX
+#define UINT_LEAST16_MAX __UINT_LEAST16_MAX__
+#undef INT_LEAST32_MAX
+#define INT_LEAST32_MAX __INT_LEAST32_MAX__
+#undef INT_LEAST32_MIN
+#define INT_LEAST32_MIN (-INT_LEAST32_MAX - 1)
+#undef UINT_LEAST32_MAX
+#define UINT_LEAST32_MAX __UINT_LEAST32_MAX__
+#undef INT_LEAST64_MAX
+#define INT_LEAST64_MAX __INT_LEAST64_MAX__
+#undef INT_LEAST64_MIN
+#define INT_LEAST64_MIN (-INT_LEAST64_MAX - 1)
+#undef UINT_LEAST64_MAX
+#define UINT_LEAST64_MAX __UINT_LEAST64_MAX__
+
+#undef INT_FAST8_MAX
+#define INT_FAST8_MAX __INT_FAST8_MAX__
+#undef INT_FAST8_MIN
+#define INT_FAST8_MIN (-INT_FAST8_MAX - 1)
+#undef UINT_FAST8_MAX
+#define UINT_FAST8_MAX __UINT_FAST8_MAX__
+#undef INT_FAST16_MAX
+#define INT_FAST16_MAX __INT_FAST16_MAX__
+#undef INT_FAST16_MIN
+#define INT_FAST16_MIN (-INT_FAST16_MAX - 1)
+#undef UINT_FAST16_MAX
+#define UINT_FAST16_MAX __UINT_FAST16_MAX__
+#undef INT_FAST32_MAX
+#define INT_FAST32_MAX __INT_FAST32_MAX__
+#undef INT_FAST32_MIN
+#define INT_FAST32_MIN (-INT_FAST32_MAX - 1)
+#undef UINT_FAST32_MAX
+#define UINT_FAST32_MAX __UINT_FAST32_MAX__
+#undef INT_FAST64_MAX
+#define INT_FAST64_MAX __INT_FAST64_MAX__
+#undef INT_FAST64_MIN
+#define INT_FAST64_MIN (-INT_FAST64_MAX - 1)
+#undef UINT_FAST64_MAX
+#define UINT_FAST64_MAX __UINT_FAST64_MAX__
+
+#ifdef __INTPTR_MAX__
+# undef INTPTR_MAX
+# define INTPTR_MAX __INTPTR_MAX__
+# undef INTPTR_MIN
+# define INTPTR_MIN (-INTPTR_MAX - 1)
+#endif
+#ifdef __UINTPTR_MAX__
+# undef UINTPTR_MAX
+# define UINTPTR_MAX __UINTPTR_MAX__
+#endif
+
+#undef INTMAX_MAX
+#define INTMAX_MAX __INTMAX_MAX__
+#undef INTMAX_MIN
+#define INTMAX_MIN (-INTMAX_MAX - 1)
+#undef UINTMAX_MAX
+#define UINTMAX_MAX __UINTMAX_MAX__
+
+/* 7.18.3 Limits of other integer types */
+
+#undef PTRDIFF_MAX
+#define PTRDIFF_MAX __PTRDIFF_MAX__
+#undef PTRDIFF_MIN
+#define PTRDIFF_MIN (-PTRDIFF_MAX - 1)
+
+#undef SIG_ATOMIC_MAX
+#define SIG_ATOMIC_MAX __SIG_ATOMIC_MAX__
+#undef SIG_ATOMIC_MIN
+#define SIG_ATOMIC_MIN __SIG_ATOMIC_MIN__
+
+#undef SIZE_MAX
+#define SIZE_MAX __SIZE_MAX__
+
+#undef WCHAR_MAX
+#define WCHAR_MAX __WCHAR_MAX__
+#undef WCHAR_MIN
+#define WCHAR_MIN __WCHAR_MIN__
+
+#undef WINT_MAX
+#define WINT_MAX __WINT_MAX__
+#undef WINT_MIN
+#define WINT_MIN __WINT_MIN__
+
+#endif /* (!defined __cplusplus || __cplusplus >= 201103L
+	   || defined __STDC_LIMIT_MACROS)  */
+
+#if (!defined __cplusplus || __cplusplus >= 201103L \
+     || defined __STDC_CONSTANT_MACROS)
+
+#undef INT8_C
+#define INT8_C(c) __INT8_C(c)
+#undef INT16_C
+#define INT16_C(c) __INT16_C(c)
+#undef INT32_C
+#define INT32_C(c) __INT32_C(c)
+#undef INT64_C
+#define INT64_C(c) __INT64_C(c)
+#undef UINT8_C
+#define UINT8_C(c) __UINT8_C(c)
+#undef UINT16_C
+#define UINT16_C(c) __UINT16_C(c)
+#undef UINT32_C
+#define UINT32_C(c) __UINT32_C(c)
+#undef UINT64_C
+#define UINT64_C(c) __UINT64_C(c)
+#undef INTMAX_C
+#define INTMAX_C(c) __INTMAX_C(c)
+#undef UINTMAX_C
+#define UINTMAX_C(c) __UINTMAX_C(c)
+
+#endif /* (!defined __cplusplus || __cplusplus >= 201103L
+	   || defined __STDC_CONSTANT_MACROS) */
+
+#ifdef __STDC_WANT_IEC_60559_BFP_EXT__
+/* TS 18661-1 widths of integer types.  */
+
+#ifdef __INT8_TYPE__
+# undef INT8_WIDTH
+# define INT8_WIDTH 8
+#endif
+#ifdef __UINT8_TYPE__
+# undef UINT8_WIDTH
+# define UINT8_WIDTH 8
+#endif
+#ifdef __INT16_TYPE__
+# undef INT16_WIDTH
+# define INT16_WIDTH 16
+#endif
+#ifdef __UINT16_TYPE__
+# undef UINT16_WIDTH
+# define UINT16_WIDTH 16
+#endif
+#ifdef __INT32_TYPE__
+# undef INT32_WIDTH
+# define INT32_WIDTH 32
+#endif
+#ifdef __UINT32_TYPE__
+# undef UINT32_WIDTH
+# define UINT32_WIDTH 32
+#endif
+#ifdef __INT64_TYPE__
+# undef INT64_WIDTH
+# define INT64_WIDTH 64
+#endif
+#ifdef __UINT64_TYPE__
+# undef UINT64_WIDTH
+# define UINT64_WIDTH 64
+#endif
+
+#undef INT_LEAST8_WIDTH
+#define INT_LEAST8_WIDTH __INT_LEAST8_WIDTH__
+#undef UINT_LEAST8_WIDTH
+#define UINT_LEAST8_WIDTH __INT_LEAST8_WIDTH__
+#undef INT_LEAST16_WIDTH
+#define INT_LEAST16_WIDTH __INT_LEAST16_WIDTH__
+#undef UINT_LEAST16_WIDTH
+#define UINT_LEAST16_WIDTH __INT_LEAST16_WIDTH__
+#undef INT_LEAST32_WIDTH
+#define INT_LEAST32_WIDTH __INT_LEAST32_WIDTH__
+#undef UINT_LEAST32_WIDTH
+#define UINT_LEAST32_WIDTH __INT_LEAST32_WIDTH__
+#undef INT_LEAST64_WIDTH
+#define INT_LEAST64_WIDTH __INT_LEAST64_WIDTH__
+#undef UINT_LEAST64_WIDTH
+#define UINT_LEAST64_WIDTH __INT_LEAST64_WIDTH__
+
+#undef INT_FAST8_WIDTH
+#define INT_FAST8_WIDTH __INT_FAST8_WIDTH__
+#undef UINT_FAST8_WIDTH
+#define UINT_FAST8_WIDTH __INT_FAST8_WIDTH__
+#undef INT_FAST16_WIDTH
+#define INT_FAST16_WIDTH __INT_FAST16_WIDTH__
+#undef UINT_FAST16_WIDTH
+#define UINT_FAST16_WIDTH __INT_FAST16_WIDTH__
+#undef INT_FAST32_WIDTH
+#define INT_FAST32_WIDTH __INT_FAST32_WIDTH__
+#undef UINT_FAST32_WIDTH
+#define UINT_FAST32_WIDTH __INT_FAST32_WIDTH__
+#undef INT_FAST64_WIDTH
+#define INT_FAST64_WIDTH __INT_FAST64_WIDTH__
+#undef UINT_FAST64_WIDTH
+#define UINT_FAST64_WIDTH __INT_FAST64_WIDTH__
+
+#ifdef __INTPTR_TYPE__
+# undef INTPTR_WIDTH
+# define INTPTR_WIDTH __INTPTR_WIDTH__
+#endif
+#ifdef __UINTPTR_TYPE__
+# undef UINTPTR_WIDTH
+# define UINTPTR_WIDTH __INTPTR_WIDTH__
+#endif
+
+#undef INTMAX_WIDTH
+#define INTMAX_WIDTH __INTMAX_WIDTH__
+#undef UINTMAX_WIDTH
+#define UINTMAX_WIDTH __INTMAX_WIDTH__
+
+#undef PTRDIFF_WIDTH
+#define PTRDIFF_WIDTH __PTRDIFF_WIDTH__
+
+#undef SIG_ATOMIC_WIDTH
+#define SIG_ATOMIC_WIDTH __SIG_ATOMIC_WIDTH__
+
+#undef SIZE_WIDTH
+#define SIZE_WIDTH __SIZE_WIDTH__
+
+#undef WCHAR_WIDTH
+#define WCHAR_WIDTH __WCHAR_WIDTH__
+
+#undef WINT_WIDTH
+#define WINT_WIDTH __WINT_WIDTH__
+
+#endif
+
+#endif /* _GCC_STDINT_H */
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f128.c
new file mode 100755
index 000000000..7cf21236b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f128.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t ui32_to_f128( uint32_t a )
+{
+    uint_fast64_t uiZ64;
+    int_fast8_t shiftDist;
+    union ui128_f128 uZ;
+
+    uiZ64 = 0;
+    if ( a ) {
+        shiftDist = softfloat_countLeadingZeros32( a ) + 17;
+        uiZ64 =
+            packToF128UI64(
+                0, 0x402E - shiftDist, (uint_fast64_t) a<<shiftDist );
+    }
+    uZ.ui.v64 = uiZ64;
+    uZ.ui.v0  = 0;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f16.c
new file mode 100755
index 000000000..5f29efb2e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f16.c
@@ -0,0 +1,65 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t ui32_to_f16( uint32_t a )
+{
+    int_fast8_t shiftDist;
+    union ui16_f16 u;
+    uint_fast16_t sig;
+
+    shiftDist = softfloat_countLeadingZeros32( a ) - 21;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF16UI(
+                    0, 0x18 - shiftDist, (uint_fast16_t) a<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 4;
+        sig =
+            (shiftDist < 0)
+                ? a>>(-shiftDist) | ((uint32_t) (a<<(shiftDist & 31)) != 0)
+                : (uint_fast16_t) a<<shiftDist;
+        return softfloat_roundPackToF16( 0, 0x1C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f32.c
new file mode 100755
index 000000000..cc976456e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f32.c
@@ -0,0 +1,57 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t ui32_to_f32( uint32_t a )
+{
+    union ui32_f32 uZ;
+
+    if ( ! a ) {
+        uZ.ui = 0;
+        return uZ.f;
+    }
+    if ( a & 0x80000000 ) {
+        return softfloat_roundPackToF32( 0, 0x9D, a>>1 | (a & 1) );
+    } else {
+        return softfloat_normRoundPackToF32( 0, 0x9C, a );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f64.c
new file mode 100755
index 000000000..c39d3d396
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f64.c
@@ -0,0 +1,59 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t ui32_to_f64( uint32_t a )
+{
+    uint_fast64_t uiZ;
+    int_fast8_t shiftDist;
+    union ui64_f64 uZ;
+
+    if ( ! a ) {
+        uiZ = 0;
+    } else {
+        shiftDist = softfloat_countLeadingZeros32( a ) + 21;
+        uiZ =
+            packToF64UI( 0, 0x432 - shiftDist, (uint_fast64_t) a<<shiftDist );
+    }
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f128.c
new file mode 100755
index 000000000..6e5bcdd3a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f128.c
@@ -0,0 +1,68 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t ui64_to_f128( uint64_t a )
+{
+    uint_fast64_t uiZ64, uiZ0;
+    int_fast8_t shiftDist;
+    struct uint128 zSig;
+    union ui128_f128 uZ;
+
+    if ( ! a ) {
+        uiZ64 = 0;
+        uiZ0  = 0;
+    } else {
+        shiftDist = softfloat_countLeadingZeros64( a ) + 49;
+        if ( 64 <= shiftDist ) {
+            zSig.v64 = a<<(shiftDist - 64);
+            zSig.v0  = 0;
+        } else {
+            zSig = softfloat_shortShiftLeft128( 0, a, shiftDist );
+        }
+        uiZ64 = packToF128UI64( 0, 0x406E - shiftDist, zSig.v64 );
+        uiZ0  = zSig.v0;
+    }
+    uZ.ui.v64 = uiZ64;
+    uZ.ui.v0  = uiZ0;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f16.c
new file mode 100755
index 000000000..b9faa59f1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f16.c
@@ -0,0 +1,64 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t ui64_to_f16( uint64_t a )
+{
+    int_fast8_t shiftDist;
+    union ui16_f16 u;
+    uint_fast16_t sig;
+
+    shiftDist = softfloat_countLeadingZeros64( a ) - 53;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF16UI(
+                    0, 0x18 - shiftDist, (uint_fast16_t) a<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 4;
+        sig =
+            (shiftDist < 0) ? softfloat_shortShiftRightJam64( a, -shiftDist )
+                : (uint_fast16_t) a<<shiftDist;
+        return softfloat_roundPackToF16( 0, 0x1C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f32.c
new file mode 100755
index 000000000..4053ce2ff
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f32.c
@@ -0,0 +1,64 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t ui64_to_f32( uint64_t a )
+{
+    int_fast8_t shiftDist;
+    union ui32_f32 u;
+    uint_fast32_t sig;
+
+    shiftDist = softfloat_countLeadingZeros64( a ) - 40;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF32UI(
+                    0, 0x95 - shiftDist, (uint_fast32_t) a<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 7;
+        sig =
+            (shiftDist < 0) ? softfloat_shortShiftRightJam64( a, -shiftDist )
+                : (uint_fast32_t) a<<shiftDist;
+        return softfloat_roundPackToF32( 0, 0x9C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f64.c
new file mode 100755
index 000000000..286fb9498
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f64.c
@@ -0,0 +1,59 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t ui64_to_f64( uint64_t a )
+{
+    union ui64_f64 uZ;
+
+    if ( ! a ) {
+        uZ.ui = 0;
+        return uZ.f;
+    }
+    if ( a & UINT64_C( 0x8000000000000000 ) ) {
+        return
+            softfloat_roundPackToF64(
+                0, 0x43D, softfloat_shortShiftRightJam64( a, 1 ) );
+    } else {
+        return softfloat_normRoundPackToF64( 0, 0x43C, a );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index 595342910..139ecae5e 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -21,8 +21,10 @@ struct stackframe {
 	unsigned long ra;
 };
 
+extern asmlinkage void ret_from_exception(void);
+
 void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
-			     bool (*fn)(unsigned long, void *), void *arg)
+			     bool (*fn)(unsigned long, unsigned long, void *), void *arg)
 {
 	unsigned long fp, sp, pc;
 
@@ -46,7 +48,7 @@ void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
 		unsigned long low, high;
 		struct stackframe *frame;
 
-		if (unlikely(!__kernel_text_address(pc) || fn(pc, arg)))
+		if (unlikely(!__kernel_text_address(pc) || fn(pc, 0, arg)))
 			break;
 
 		/* Validate frame pointer */
@@ -57,16 +59,29 @@ void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
 		/* Unwind stack frame */
 		frame = (struct stackframe *)fp - 1;
 		sp = fp;
+		if (regs && (regs->epc == pc) && (frame->fp & 0x7)) {
+			fp = frame->ra;
+			pc = regs->ra;
+		} else {
 		fp = frame->fp;
 		pc = ftrace_graph_ret_addr(current, NULL, frame->ra,
-					   (unsigned long *)(fp - 8));
+						   &frame->ra);
+			if (pc == (unsigned long)ret_from_exception) {
+				if (unlikely(!__kernel_text_address(pc) || fn(pc, sp, arg)))
+					break;
+
+				pc = ((struct pt_regs *)sp)->epc;
+				fp = ((struct pt_regs *)sp)->s0;
+			}
+		}
+
 	}
 }
 
 #else /* !CONFIG_FRAME_POINTER */
 
 void notrace walk_stackframe(struct task_struct *task,
-	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg)
+	struct pt_regs *regs, bool (*fn)(unsigned long, unsigned long, void *), void *arg)
 {
 	unsigned long sp, pc;
 	unsigned long *ksp;
@@ -88,7 +103,7 @@ void notrace walk_stackframe(struct task_struct *task,
 
 	ksp = (unsigned long *)sp;
 	while (!kstack_end(ksp)) {
-		if (__kernel_text_address(pc) && unlikely(fn(pc, arg)))
+		if (__kernel_text_address(pc) && unlikely(fn(pc, 0, arg)))
 			break;
 		pc = (*ksp++) - 0x4;
 	}
@@ -97,11 +112,15 @@ void notrace walk_stackframe(struct task_struct *task,
 #endif /* CONFIG_FRAME_POINTER */
 
 
-static bool print_trace_address(unsigned long pc, void *arg)
+static bool print_trace_address(unsigned long pc, unsigned long regs, void *arg)
 {
 	const char *loglvl = arg;
 
 	print_ip_sym(loglvl, pc);
+
+	if (regs)
+		show_regs((struct pt_regs *)regs);
+
 	return false;
 }
 
@@ -109,9 +128,10 @@ void show_stack(struct task_struct *task, unsigned long *sp, const char *loglvl)
 {
 	pr_cont("Call Trace:\n");
 	walk_stackframe(task, NULL, print_trace_address, (void *)loglvl);
+	pr_cont("End Trace.\n");
 }
 
-static bool save_wchan(unsigned long pc, void *arg)
+static bool save_wchan(unsigned long pc, unsigned long regs, void *arg)
 {
 	if (!in_sched_functions(pc)) {
 		unsigned long *p = arg;
@@ -148,7 +168,7 @@ static bool __save_trace(unsigned long pc, void *arg, bool nosched)
 	return (trace->nr_entries >= trace->max_entries);
 }
 
-static bool save_trace(unsigned long pc, void *arg)
+static bool save_trace(unsigned long pc, unsigned long regs, void *arg)
 {
 	return __save_trace(pc, arg, false);
 }
diff --git a/arch/riscv/kernel/syscall_table.c b/arch/riscv/kernel/syscall_table.c
index f1ead9df9..f5415280c 100644
--- a/arch/riscv/kernel/syscall_table.c
+++ b/arch/riscv/kernel/syscall_table.c
@@ -13,7 +13,7 @@
 #undef __SYSCALL
 #define __SYSCALL(nr, call)	[nr] = (call),
 
-void *sys_call_table[__NR_syscalls] = {
+const void *sys_call_table[__NR_syscalls] = {
 	[0 ... __NR_syscalls - 1] = sys_ni_syscall,
 #include <asm/unistd.h>
 };
diff --git a/arch/riscv/kernel/trace_irq.c b/arch/riscv/kernel/trace_irq.c
new file mode 100755
index 000000000..095ac976d
--- /dev/null
+++ b/arch/riscv/kernel/trace_irq.c
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2022 Changbin Du <changbin.du@gmail.com>
+ */
+
+#include <linux/irqflags.h>
+#include <linux/kprobes.h>
+#include "trace_irq.h"
+
+/*
+ * trace_hardirqs_on/off require the caller to setup frame pointer properly.
+ * Otherwise, CALLER_ADDR1 might trigger an pagging exception in kernel.
+ * Here we add one extra level so they can be safely called by low
+ * level entry code which $fp is used for other purpose.
+ */
+
+void __trace_hardirqs_on(void)
+{
+	trace_hardirqs_on();
+}
+NOKPROBE_SYMBOL(__trace_hardirqs_on);
+
+void __trace_hardirqs_off(void)
+{
+	trace_hardirqs_off();
+}
+NOKPROBE_SYMBOL(__trace_hardirqs_off);
diff --git a/arch/riscv/kernel/trace_irq.h b/arch/riscv/kernel/trace_irq.h
new file mode 100755
index 000000000..99fe67377
--- /dev/null
+++ b/arch/riscv/kernel/trace_irq.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Changbin Du <changbin.du@gmail.com>
+ */
+#ifndef __TRACE_IRQ_H
+#define __TRACE_IRQ_H
+
+void __trace_hardirqs_on(void);
+void __trace_hardirqs_off(void);
+
+#endif /* __TRACE_IRQ_H */
diff --git a/arch/riscv/kernel/traps.c b/arch/riscv/kernel/traps.c
index ad14f4466..b2cd335e1 100644
--- a/arch/riscv/kernel/traps.c
+++ b/arch/riscv/kernel/traps.c
@@ -12,9 +12,11 @@
 #include <linux/signal.h>
 #include <linux/kdebug.h>
 #include <linux/uaccess.h>
+#include <linux/kprobes.h>
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/irq.h>
+#include <linux/kexec.h>
 
 #include <asm/processor.h>
 #include <asm/ptrace.h>
@@ -43,6 +45,9 @@ void die(struct pt_regs *regs, const char *str)
 
 	ret = notify_die(DIE_OOPS, str, regs, 0, regs->cause, SIGSEGV);
 
+	if (regs && kexec_should_crash(current))
+		crash_kexec(regs);
+
 	bust_spinlocks(0);
 	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);
 	spin_unlock_irq(&die_lock);
@@ -56,10 +61,19 @@ void die(struct pt_regs *regs, const char *str)
 		do_exit(SIGSEGV);
 }
 
+#ifdef CONFIG_VECTOR_EMU
+extern bool decode_exec_insn(struct pt_regs *regs, uint64_t insn);
+#endif
 void do_trap(struct pt_regs *regs, int signo, int code, unsigned long addr)
 {
 	struct task_struct *tsk = current;
 
+#ifdef CONFIG_VECTOR_EMU
+	if (signo == SIGILL)
+		if (decode_exec_insn(regs, regs->badaddr))
+			return;
+#endif
+
 	if (show_unhandled_signals && unhandled_signal(tsk, signo)
 	    && printk_ratelimit()) {
 		pr_info("%s[%d]: unhandled signal %d code 0x%x at 0x" REG_FMT,
@@ -75,6 +89,8 @@ void do_trap(struct pt_regs *regs, int signo, int code, unsigned long addr)
 static void do_trap_error(struct pt_regs *regs, int signo, int code,
 	unsigned long addr, const char *str)
 {
+	current->thread.bad_cause = regs->cause;
+
 	if (user_mode(regs)) {
 		do_trap(regs, signo, code, addr);
 	} else {
@@ -145,6 +161,22 @@ static inline unsigned long get_break_insn_length(unsigned long pc)
 
 asmlinkage __visible void do_trap_break(struct pt_regs *regs)
 {
+#ifdef CONFIG_KPROBES
+	if (kprobe_single_step_handler(regs))
+		return;
+
+	if (kprobe_breakpoint_handler(regs))
+		return;
+#endif
+#ifdef CONFIG_UPROBES
+	if (uprobe_single_step_handler(regs))
+		return;
+
+	if (uprobe_breakpoint_handler(regs))
+		return;
+#endif
+	current->thread.bad_cause = regs->cause;
+
 	if (user_mode(regs))
 		force_sig_fault(SIGTRAP, TRAP_BRKPT, (void __user *)regs->epc);
 #ifdef CONFIG_KGDB
diff --git a/arch/riscv/kernel/vdso.c b/arch/riscv/kernel/vdso.c
index 73d45931a..5b52f39c1 100644
--- a/arch/riscv/kernel/vdso.c
+++ b/arch/riscv/kernel/vdso.c
@@ -32,7 +32,7 @@ static union {
 } vdso_data_store __page_aligned_data;
 struct vdso_data *vdso_data = &vdso_data_store.data;
 
-static int __init vdso_init(void)
+static int __init __vdso_init(void)
 {
 	unsigned int i;
 
@@ -54,6 +54,60 @@ static int __init vdso_init(void)
 
 	return 0;
 }
+
+#ifdef CONFIG_COMPAT
+extern char compat_vdso_start[], compat_vdso_end[];
+
+static unsigned int compat_vdso_pages;
+static struct page **compat_vdso_pagelist;
+
+/*
+ * The compat vDSO data page.
+ */
+static union {
+	struct vdso_data	data;
+	u8			page[PAGE_SIZE];
+} compat_vdso_data_store __page_aligned_data;
+struct vdso_data *compat_vdso_data = &compat_vdso_data_store.data;
+
+static int __init __compat_vdso_init(void)
+{
+	unsigned int i;
+
+	compat_vdso_pages = (compat_vdso_end - compat_vdso_start) >> PAGE_SHIFT;
+	compat_vdso_pagelist =
+		kcalloc(compat_vdso_pages + 1, sizeof(struct page *), GFP_KERNEL);
+	if (unlikely(compat_vdso_pagelist == NULL)) {
+		pr_err("compat vdso: pagelist allocation failed\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < compat_vdso_pages; i++) {
+		struct page *pg;
+
+		pg = virt_to_page(compat_vdso_start + (i << PAGE_SHIFT));
+		compat_vdso_pagelist[i] = pg;
+	}
+	compat_vdso_pagelist[i] = virt_to_page(compat_vdso_data);
+
+	return 0;
+}
+#endif
+
+static int __init vdso_init(void)
+{
+	int ret = 0;
+
+	ret = __vdso_init();
+	if (ret)
+		goto out;
+
+#ifdef CONFIG_COMPAT
+	ret = __compat_vdso_init();
+#endif
+out:
+	return ret;
+}
 arch_initcall(vdso_init);
 
 int arch_setup_additional_pages(struct linux_binprm *bprm,
@@ -102,6 +156,52 @@ int arch_setup_additional_pages(struct linux_binprm *bprm,
 	return ret;
 }
 
+#ifdef CONFIG_COMPAT
+int compat_arch_setup_additional_pages(struct linux_binprm *bprm,
+				       int uses_interp)
+{
+	struct mm_struct *mm = current->mm;
+	unsigned long vdso_base, vdso_len;
+	int ret;
+
+	vdso_len = (compat_vdso_pages + 1) << PAGE_SHIFT;
+
+	mmap_write_lock(mm);
+	vdso_base = get_unmapped_area(NULL, 0, vdso_len, 0, 0);
+	if (IS_ERR_VALUE(vdso_base)) {
+		ret = vdso_base;
+		goto end;
+	}
+
+	/*
+	 * Put vDSO base into mm struct. We need to do this before calling
+	 * install_special_mapping or the perf counter mmap tracking code
+	 * will fail to recognise it as a vDSO (since arch_vma_name fails).
+	 */
+	mm->context.vdso = (void *)vdso_base;
+
+	ret =
+	   install_special_mapping(mm, vdso_base, vdso_pages << PAGE_SHIFT,
+		(VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC),
+		compat_vdso_pagelist);
+
+	if (unlikely(ret)) {
+		mm->context.vdso = NULL;
+		goto end;
+	}
+
+	vdso_base += (compat_vdso_pages << PAGE_SHIFT);
+	ret = install_special_mapping(mm, vdso_base, PAGE_SIZE,
+		(VM_READ | VM_MAYREAD), &compat_vdso_pagelist[compat_vdso_pages]);
+
+	if (unlikely(ret))
+		mm->context.vdso = NULL;
+end:
+	mmap_write_unlock(mm);
+	return ret;
+}
+#endif
+
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
 	if (vma->vm_mm && (vma->vm_start == (long)vma->vm_mm->context.vdso))
diff --git a/arch/riscv/kernel/vdso/Makefile b/arch/riscv/kernel/vdso/Makefile
index 24d936c14..f8cb9144a 100644
--- a/arch/riscv/kernel/vdso/Makefile
+++ b/arch/riscv/kernel/vdso/Makefile
@@ -23,10 +23,10 @@ ifneq ($(c-gettimeofday-y),)
 endif
 
 # Build rules
-targets := $(obj-vdso) vdso.so vdso.so.dbg vdso.lds vdso-syms.S
+targets := $(obj-vdso) vdso.so vdso.so.dbg vdso.lds
 obj-vdso := $(addprefix $(obj)/, $(obj-vdso))
 
-obj-y += vdso.o vdso-syms.o
+obj-y += vdso.o
 CPPFLAGS_vdso.lds += -P -C -U$(ARCH)
 
 # Disable -pg to prevent insert call site
@@ -43,20 +43,22 @@ $(obj)/vdso.o: $(obj)/vdso.so
 # link rule for the .so file, .lds has to be first
 $(obj)/vdso.so.dbg: $(obj)/vdso.lds $(obj-vdso) FORCE
 	$(call if_changed,vdsold)
-LDFLAGS_vdso.so.dbg = -shared -s -soname=linux-vdso.so.1 \
+LDFLAGS_vdso.so.dbg = -shared -S -soname=linux-vdso.so.1 \
 	--build-id=sha1 --hash-style=both --eh-frame-hdr
 
-# We also create a special relocatable object that should mirror the symbol
-# table and layout of the linked DSO. With ld --just-symbols we can then
-# refer to these symbols in the kernel code rather than hand-coded addresses.
-$(obj)/vdso-syms.S: $(obj)/vdso.so FORCE
-	$(call if_changed,so2s)
-
 # strip rule for the .so file
 $(obj)/%.so: OBJCOPYFLAGS := -S
 $(obj)/%.so: $(obj)/%.so.dbg FORCE
 	$(call if_changed,objcopy)
 
+# Generate VDSO offsets using helper script
+gen-vdsosym := $(srctree)/$(src)/gen_vdso_offsets.sh
+quiet_cmd_vdsosym = VDSOSYM $@
+	cmd_vdsosym = $(NM) $< | $(gen-vdsosym) | LC_ALL=C sort > $@
+
+include/generated/vdso-offsets.h: $(obj)/vdso.so.dbg FORCE
+	$(call if_changed,vdsosym)
+
 # actual build commands
 # The DSO images are built using a special linker script
 # Make sure only to export the intended __vdso_xxx symbol offsets.
@@ -65,11 +67,6 @@ quiet_cmd_vdsold = VDSOLD  $@
                    $(OBJCOPY) $(patsubst %, -G __vdso_%, $(vdso-syms)) $@.tmp $@ && \
                    rm $@.tmp
 
-# Extracts symbol offsets from the VDSO, converting them into an assembly file
-# that contains the same symbols at the same offsets.
-quiet_cmd_so2s = SO2S    $@
-      cmd_so2s = $(NM) -D $< | $(srctree)/$(src)/so2s.sh > $@
-
 # install commands for the unstripped file
 quiet_cmd_vdso_install = INSTALL $@
       cmd_vdso_install = cp $(obj)/$@.dbg $(MODLIB)/vdso/$@
diff --git a/arch/riscv/kernel/vdso/gen_vdso_offsets.sh b/arch/riscv/kernel/vdso/gen_vdso_offsets.sh
new file mode 100755
index 000000000..c2e5613f3
--- /dev/null
+++ b/arch/riscv/kernel/vdso/gen_vdso_offsets.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0
+
+LC_ALL=C
+sed -n -e 's/^[0]\+\(0[0-9a-fA-F]*\) . \(__vdso_[a-zA-Z0-9_]*\)$/\#define \2_offset\t0x\1/p'
diff --git a/arch/riscv/kernel/vdso/vdso.S b/arch/riscv/kernel/vdso/vdso.S
index df222245b..83f1c899e 100644
--- a/arch/riscv/kernel/vdso/vdso.S
+++ b/arch/riscv/kernel/vdso/vdso.S
@@ -7,12 +7,16 @@
 #include <linux/linkage.h>
 #include <asm/page.h>
 
+#ifndef __VDSO_PATH
+#define __VDSO_PATH "arch/riscv/kernel/vdso/vdso.so"
+#endif
+
 	__PAGE_ALIGNED_DATA
 
 	.globl vdso_start, vdso_end
 	.balign PAGE_SIZE
 vdso_start:
-	.incbin "arch/riscv/kernel/vdso/vdso.so"
+	.incbin __VDSO_PATH
 	.balign PAGE_SIZE
 vdso_end:
 
diff --git a/arch/riscv/kernel/vector.S b/arch/riscv/kernel/vector.S
new file mode 100755
index 000000000..88221a1a4
--- /dev/null
+++ b/arch/riscv/kernel/vector.S
@@ -0,0 +1,234 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2012 Regents of the University of California
+ * Copyright (C) 2017 SiFive
+ * Copyright (C) 2019 T-HEAD
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+
+#include <asm/asm.h>
+#include <asm/csr.h>
+#include <asm/asm-offsets.h>
+
+#if (defined(CONFIG_VECTOR_1_0) && defined(__THEAD_VERSION__))
+#define V_ST	vse8.v
+#define V_LD	vle8.v
+#else
+#define V_ST	vsb.v
+#define V_LD	vlb.v
+#endif
+
+ENTRY(__vstate_save)
+	li	a2,  TASK_THREAD_V0
+	add	a0,  a0, a2
+
+	li	t1, (SR_VS | SR_FS)
+	csrs	sstatus, t1
+
+	csrr	t0,  CSR_VSTART
+	sd	t0,  TASK_THREAD_VSTART_V0(a0)
+	csrr	t0,  CSR_VXSAT
+	sd	t0,  TASK_THREAD_VXSAT_V0(a0)
+	csrr	t0,  CSR_VXRM
+	sd	t0,  TASK_THREAD_VXRM_V0(a0)
+	csrr	t0,  CSR_VL
+	sd	t0,  TASK_THREAD_VL_V0(a0)
+	csrr	t0,  CSR_VTYPE
+	sd	t0,  TASK_THREAD_VTYPE_V0(a0)
+
+#ifdef CONFIG_VLEN_256
+	vsetvli	t0, x0, e8,m1
+	V_ST	v0,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v1,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v2,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v3,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v4,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v5,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v6,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v7,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v8,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v9,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v10, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v11, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v12, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v13, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v14, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v15, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v16, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v17, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v18, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v19, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v20, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v21, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v22, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v23, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v24, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v25, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v26, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v27, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v28, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v29, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v30, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_ST	v31, (a0)
+#else
+	vsetvli	t0, x0, e8,m8
+	V_ST	v0,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	V_ST	v8,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	V_ST	v16, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	V_ST	v24, (a0)
+#endif
+
+	csrc	sstatus, t1
+	ret
+ENDPROC(__vstate_save)
+
+ENTRY(__vstate_restore)
+	li	a2,  TASK_THREAD_V0
+	add	a0,  a0, a2
+	mv	t2,  a0
+
+	li	t1, (SR_VS | SR_FS)
+	csrs	sstatus, t1
+
+#ifdef CONFIG_VLEN_256
+	vsetvli	t0, x0, e8,m1
+	V_LD	v0,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v1,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v2,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v3,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v4,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v5,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v6,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v7,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v8,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v9,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v10, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v11, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v12, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v13, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v14, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v15, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v16, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v17, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v18, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v19, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v20, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v21, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v22, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v23, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v24, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v25, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v26, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v27, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v28, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v29, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v30, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB
+	V_LD	v31, (a0)
+#else
+	vsetvli	t0, x0, e8,m8
+	V_LD	v0,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	V_LD	v8,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	V_LD	v16, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	V_LD	v24, (a0)
+#endif
+
+	mv	a0,  t2
+	ld	t0,  TASK_THREAD_VSTART_V0(a0)
+	csrw	CSR_VSTART, t0
+	ld	t0,  TASK_THREAD_VXSAT_V0(a0)
+	csrw	CSR_VXSAT, t0
+	ld	t0,  TASK_THREAD_VXRM_V0(a0)
+	csrw	CSR_VXRM, t0
+	ld	t0,  TASK_THREAD_VL_V0(a0)
+	ld	t2,  TASK_THREAD_VTYPE_V0(a0)
+#ifdef CONFIG_VECTOR_EMU
+	srli	t3, t2, 63
+	bne	t3,zero,1f
+#endif
+	vsetvl	t3, t0, t2
+#ifdef CONFIG_VECTOR_EMU
+	j	2f
+1:	vsetvli zero,zero,e64,m2,d1
+2:
+#endif
+	csrc	sstatus, t1
+	ret
+ENDPROC(__vstate_restore)
diff --git a/arch/riscv/kvm/Kconfig b/arch/riscv/kvm/Kconfig
new file mode 100755
index 000000000..cdf085bfd
--- /dev/null
+++ b/arch/riscv/kvm/Kconfig
@@ -0,0 +1,43 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# KVM configuration
+#
+
+source "virt/kvm/Kconfig"
+
+menuconfig VIRTUALIZATION
+	bool "Virtualization"
+	help
+	  Say Y here to get to see options for using your Linux host to run
+	  other operating systems inside virtual machines (guests).
+	  This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and
+	  disabled.
+
+if VIRTUALIZATION
+
+config KVM
+	tristate "Kernel-based Virtual Machine (KVM) support (EXPERIMENTAL)"
+	depends on RISCV_SBI && MMU
+	select MMU_NOTIFIER
+	select PREEMPT_NOTIFIERS
+	select ANON_INODES
+	select KVM_MMIO
+	select KVM_GENERIC_DIRTYLOG_READ_PROTECT
+	select HAVE_KVM_VCPU_ASYNC_IOCTL
+	select HAVE_KVM_EVENTFD
+	select SRCU
+	help
+	  Support hosting virtualized guest machines.
+
+	  If unsure, say N.
+
+config	SOC_INT_SRC7
+	bool "Kernel-based Heter Virtual Machine(KHV) Kick and Call supported by SOC_INT_SRC7"
+	default y
+	help
+	 Say Y here to use soc interrupt src7 to support kick and call between
+	 host and guest.
+
+endif # VIRTUALIZATION
diff --git a/arch/riscv/kvm/Makefile b/arch/riscv/kvm/Makefile
new file mode 100755
index 000000000..5a357490e
--- /dev/null
+++ b/arch/riscv/kvm/Makefile
@@ -0,0 +1,15 @@
+# SPDX-License-Identifier: GPL-2.0
+# Makefile for RISC-V KVM support
+#
+
+common-objs-y = $(addprefix ../../../virt/kvm/, kvm_main.o coalesced_mmio.o)
+common-objs-y += $(addprefix ../../../virt/kvm/, eventfd.o)
+
+ccflags-y := -Ivirt/kvm -Iarch/riscv/kvm
+
+kvm-objs := $(common-objs-y)
+
+kvm-objs += main.o vm.o mmu.o
+kvm-objs += vcpu.o vcpu_exit.o
+
+obj-$(CONFIG_KVM)	+= kvm.o
diff --git a/arch/riscv/kvm/main.c b/arch/riscv/kvm/main.c
new file mode 100755
index 000000000..a422781d9
--- /dev/null
+++ b/arch/riscv/kvm/main.c
@@ -0,0 +1,148 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Western Digital Corporation or its affiliates.
+ *
+ * Authors:
+ *     Anup Patel <anup.patel@wdc.com>
+ */
+
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/kvm_host.h>
+#include <asm/csr.h>
+#include <asm/hwcap.h>
+#include <asm/sbi.h>
+
+extern u64 khv_reserved_memory;
+extern u64 khv_reserved_memory_size;
+long kvm_arch_dev_ioctl(struct file *filp,
+			unsigned int ioctl, unsigned long arg)
+{
+	long r = -EINVAL;
+	void __user *argp = (void __user *)arg;
+
+	switch (ioctl) {
+	case KVM_RISCV_MEM_SIZE:
+		if (copy_to_user(argp, &khv_reserved_memory_size, sizeof(khv_reserved_memory)))
+			r = -EINVAL;
+		r = 0;
+		break;
+	case KVM_RISCV_MEM_ADDR_GET:
+		if (copy_to_user(argp, &khv_reserved_memory, sizeof(khv_reserved_memory)))
+			r = -EINVAL;
+		r = 0;
+		break;
+	case KVM_RISCV_MEM_ADDR_SET:
+		if (copy_from_user(&khv_reserved_memory, argp, sizeof(u64)))
+			r = -EINVAL;
+
+		r = 0;
+		break;
+	default:
+		break;
+	}
+
+	return r;
+}
+
+int kvm_arch_check_processor_compat(void *opaque)
+{
+	return 0;
+}
+
+int kvm_arch_hardware_setup(void *opaque)
+{
+	return 0;
+}
+
+int kvm_arch_hardware_enable(void)
+{
+#if 0
+	unsigned long hideleg, hedeleg;
+
+	hedeleg = 0;
+	hedeleg |= (1UL << EXC_INST_MISALIGNED);
+	hedeleg |= (1UL << EXC_BREAKPOINT);
+	hedeleg |= (1UL << EXC_SYSCALL);
+	hedeleg |= (1UL << EXC_INST_PAGE_FAULT);
+	hedeleg |= (1UL << EXC_LOAD_PAGE_FAULT);
+	hedeleg |= (1UL << EXC_STORE_PAGE_FAULT);
+	csr_write(CSR_HEDELEG, hedeleg);
+
+	hideleg = 0;
+	hideleg |= (1UL << IRQ_VS_SOFT);
+	hideleg |= (1UL << IRQ_VS_TIMER);
+	hideleg |= (1UL << IRQ_VS_EXT);
+	csr_write(CSR_HIDELEG, hideleg);
+
+	csr_write(CSR_HCOUNTEREN, -1UL);
+
+	csr_write(CSR_HVIP, 0);
+#endif
+	return 0;
+}
+
+void kvm_arch_hardware_disable(void)
+{
+#if 0
+	csr_write(CSR_HEDELEG, 0);
+	csr_write(CSR_HIDELEG, 0);
+#endif
+}
+
+int kvm_arch_init(void *opaque)
+{
+#if 0
+	const char *str;
+
+	if (!riscv_isa_extension_available(NULL, h)) {
+		kvm_info("hypervisor extension not available\n");
+		return -ENODEV;
+	}
+
+	if (sbi_spec_is_0_1()) {
+		kvm_info("require SBI v0.2 or higher\n");
+		return -ENODEV;
+	}
+
+	if (sbi_probe_extension(SBI_EXT_RFENCE) <= 0) {
+		kvm_info("require SBI RFENCE extension\n");
+		return -ENODEV;
+	}
+
+	kvm_riscv_stage2_mode_detect();
+
+	kvm_riscv_stage2_vmid_detect();
+
+	kvm_info("hypervisor extension available\n");
+
+	switch (kvm_riscv_stage2_mode()) {
+	case HGATP_MODE_SV32X4:
+		str = "Sv32x4";
+		break;
+	case HGATP_MODE_SV39X4:
+		str = "Sv39x4";
+		break;
+	case HGATP_MODE_SV48X4:
+		str = "Sv48x4";
+		break;
+	default:
+		return -ENODEV;
+	}
+	kvm_info("using %s G-stage page table format\n", str);
+
+	kvm_info("VMID %ld bits available\n", kvm_riscv_stage2_vmid_bits());
+#endif
+	return 0;
+}
+
+void kvm_arch_exit(void)
+{
+}
+
+static int riscv_kvm_init(void)
+{
+	return kvm_init(NULL, sizeof(struct kvm_vcpu), 0, THIS_MODULE);
+}
+module_init(riscv_kvm_init);
diff --git a/arch/riscv/kvm/mmu.c b/arch/riscv/kvm/mmu.c
new file mode 100755
index 000000000..27b977ebe
--- /dev/null
+++ b/arch/riscv/kvm/mmu.c
@@ -0,0 +1,88 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/hugetlb.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/kvm_host.h>
+#include <linux/sched/signal.h>
+
+void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm,
+					     struct kvm_memory_slot *slot,
+					     gfn_t gfn_offset,
+					     unsigned long mask)
+{
+}
+
+void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot)
+{
+}
+
+void kvm_arch_flush_remote_tlbs_memslot(struct kvm *kvm,
+					struct kvm_memory_slot *memslot)
+{
+	kvm_flush_remote_tlbs(kvm);
+}
+
+void kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free)
+{
+}
+
+int kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,
+			    unsigned long npages)
+{
+	return 0;
+}
+
+void kvm_arch_memslots_updated(struct kvm *kvm, u64 gen)
+{
+}
+
+void kvm_arch_flush_shadow_all(struct kvm *kvm)
+{
+}
+
+void kvm_arch_flush_shadow_memslot(struct kvm *kvm,
+				   struct kvm_memory_slot *slot)
+{
+}
+
+void kvm_arch_commit_memory_region(struct kvm *kvm,
+				const struct kvm_userspace_memory_region *mem,
+				struct kvm_memory_slot *old,
+				const struct kvm_memory_slot *new,
+				enum kvm_mr_change change)
+{
+}
+
+int kvm_arch_prepare_memory_region(struct kvm *kvm,
+				struct kvm_memory_slot *memslot,
+				const struct kvm_userspace_memory_region *mem,
+				enum kvm_mr_change change)
+{
+	return 0;
+}
+
+int kvm_unmap_hva_range(struct kvm *kvm, unsigned long start,
+			unsigned long end, unsigned int flags)
+{
+	return 0;
+}
+
+int kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte)
+{
+	return 0;
+}
+
+int kvm_age_hva(struct kvm *kvm, unsigned long start, unsigned long end)
+{
+	return 0;
+}
+
+int kvm_test_age_hva(struct kvm *kvm, unsigned long hva)
+{
+	return 0;
+}
diff --git a/arch/riscv/kvm/vcpu.c b/arch/riscv/kvm/vcpu.c
new file mode 100755
index 000000000..430f89f4f
--- /dev/null
+++ b/arch/riscv/kvm/vcpu.c
@@ -0,0 +1,354 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Western Digital Corporation or its affiliates.
+ *
+ * Authors:
+ *     Anup Patel <anup.patel@wdc.com>
+ */
+
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/kdebug.h>
+#include <linux/module.h>
+#include <linux/percpu.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/sched/signal.h>
+#include <linux/fs.h>
+#include <linux/kvm_host.h>
+#include <asm/csr.h>
+#include <asm/hwcap.h>
+#include <asm/sbi.h>
+
+struct kvm_stats_debugfs_item debugfs_entries[] = {
+	VCPU_STAT("halt_successful_poll", halt_successful_poll),
+	VCPU_STAT("halt_attempted_poll", halt_attempted_poll),
+	VCPU_STAT("halt_poll_success_ns", halt_poll_success_ns),
+	VCPU_STAT("halt_poll_fail_ns", halt_poll_fail_ns),
+	VCPU_STAT("halt_poll_invalid", halt_poll_invalid),
+	VCPU_STAT("halt_wakeup", halt_wakeup),
+	VCPU_STAT("ecall_exit_stat", ecall_exit_stat),
+	VCPU_STAT("wfi_exit_stat", wfi_exit_stat),
+	VCPU_STAT("mmio_exit_user", mmio_exit_user),
+	VCPU_STAT("mmio_exit_kernel", mmio_exit_kernel),
+	VCPU_STAT("exits", exits),
+	{ NULL }
+};
+
+static struct kvm_vcpu *kvm_vcpu = NULL;
+
+#define KVM_RISCV_ISA_ALLOWED	(riscv_isa_extension_mask(a) | \
+				 riscv_isa_extension_mask(c) | \
+				 riscv_isa_extension_mask(d) | \
+				 riscv_isa_extension_mask(f) | \
+				 riscv_isa_extension_mask(i) | \
+				 riscv_isa_extension_mask(m) | \
+				 riscv_isa_extension_mask(s) | \
+				 riscv_isa_extension_mask(u))
+
+int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id)
+{
+	return 0;
+}
+
+int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
+int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
+void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)
+{
+}
+
+void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
+{
+}
+
+int kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
+void kvm_arch_vcpu_blocking(struct kvm_vcpu *vcpu)
+{
+}
+
+void kvm_arch_vcpu_unblocking(struct kvm_vcpu *vcpu)
+{
+}
+
+int kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
+int kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
+bool kvm_arch_vcpu_in_kernel(struct kvm_vcpu *vcpu)
+{
+	return false;
+}
+
+bool kvm_arch_has_vcpu_debugfs(void)
+{
+	return false;
+}
+
+int kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
+vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)
+{
+	return VM_FAULT_SIGBUS;
+}
+
+extern u64 khv_reserved_memory;
+long kvm_arch_vcpu_async_ioctl(struct file *filp,
+			       unsigned int ioctl, unsigned long arg)
+{
+	return -ENOIOCTLCMD;
+}
+
+long kvm_arch_vcpu_ioctl(struct file *filp,
+			 unsigned int ioctl, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	long r = -EINVAL;
+
+	switch (ioctl) {
+	case KVM_SET_ONE_REG:
+	case KVM_GET_ONE_REG: {
+		struct kvm_one_reg reg;
+
+		r = -EFAULT;
+
+		if (copy_from_user(&reg, argp, sizeof(reg)))
+			break;
+
+		sbi_ecall(SBI_EXT_HSM, SBI_EXT_HSM_HART_START, reg.id, khv_reserved_memory + 0x200000, reg.addr, 0, 0, 0);
+
+		if (cpu_online(reg.id) || !cpu_possible(reg.id)) {
+			break;
+		} else
+			return 0;
+
+		break;
+	}
+	default:
+		break;
+	}
+
+	return r;
+}
+
+int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,
+				  struct kvm_sregs *sregs)
+{
+	return -EINVAL;
+}
+
+int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
+				  struct kvm_sregs *sregs)
+{
+	return -EINVAL;
+}
+
+int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
+{
+	return -EINVAL;
+}
+
+int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
+{
+	return -EINVAL;
+}
+
+int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,
+				  struct kvm_translation *tr)
+{
+	return -EINVAL;
+}
+
+int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
+{
+	return -EINVAL;
+}
+
+int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
+{
+	return -EINVAL;
+}
+
+void kvm_riscv_vcpu_flush_interrupts(struct kvm_vcpu *vcpu)
+{
+}
+
+void kvm_riscv_vcpu_sync_interrupts(struct kvm_vcpu *vcpu)
+{
+}
+
+int kvm_riscv_vcpu_set_interrupt(struct kvm_vcpu *vcpu, unsigned int irq)
+{
+	return 0;
+}
+
+int kvm_riscv_vcpu_unset_interrupt(struct kvm_vcpu *vcpu, unsigned int irq)
+{
+	return 0;
+}
+
+bool kvm_riscv_vcpu_has_interrupts(struct kvm_vcpu *vcpu, unsigned long mask)
+{
+	return false;
+}
+
+void kvm_riscv_vcpu_power_off(struct kvm_vcpu *vcpu)
+{
+}
+
+void kvm_riscv_vcpu_power_on(struct kvm_vcpu *vcpu)
+{
+}
+
+int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,
+				    struct kvm_mp_state *mp_state)
+{
+	return 0;
+}
+
+int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,
+				    struct kvm_mp_state *mp_state)
+{
+	return 0;
+}
+
+int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,
+					struct kvm_guest_debug *dbg)
+{
+	/* TODO; To be implemented later. */
+	return -EINVAL;
+}
+
+void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
+{
+}
+
+void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
+{
+}
+
+int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
+{
+	int ret;
+	struct kvm_cpu_trap trap;
+	struct kvm_run *run = vcpu->run;
+
+	kvm_vcpu = vcpu;
+
+	/* Mark this VCPU ran at least once */
+	vcpu->arch.ran_atleast_once = true;
+
+	vcpu->arch.srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);
+
+	/* Process MMIO value returned from user-space */
+	if (run->exit_reason == KVM_EXIT_MMIO) {
+		ret = kvm_riscv_vcpu_mmio_return(vcpu, vcpu->run);
+		if (ret) {
+			srcu_read_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu_idx);
+			return ret;
+		}
+	}
+
+	if (run->immediate_exit) {
+		printk("%s, immediate_exit.\n", __func__);
+		srcu_read_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu_idx);
+		return -EINTR;
+	}
+
+	vcpu_load(vcpu);
+
+	kvm_sigset_activate(vcpu);
+
+	ret = 1;
+	run->exit_reason = KVM_EXIT_UNKNOWN;
+
+	while (ret > 0) {
+		/* Check conditions before entering the guest */
+		cond_resched();
+
+		/*
+		 * Exit if we have a signal pending so that we can deliver
+		 * the signal to user space.
+		 */
+		if (signal_pending(current)) {
+			ret = -EINTR;
+			run->exit_reason = KVM_EXIT_INTR;
+		}
+
+		/*
+		 * Ensure we set mode to IN_GUEST_MODE after we disable
+		 * interrupts and before the final VCPU requests check.
+		 * See the comment in kvm_vcpu_exiting_guest_mode() and
+		 * Documentation/virtual/kvm/vcpu-requests.rst
+		 */
+		vcpu->mode = IN_GUEST_MODE;
+
+		srcu_read_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu_idx);
+		smp_mb__after_srcu_read_unlock();
+
+		ret = wait_event_interruptible(vcpu->kvm->arch.waitq,
+				(atomic64_read((atomic64_t *)&vcpu->kvm->arch.io_switch->status) & RVBM_STATUS_MASK) == RVBM_STATUS_START);
+		if (ret)
+			while(1);
+
+		vcpu->mode = OUTSIDE_GUEST_MODE;
+		vcpu->stat.exits++;
+
+		vcpu->arch.srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);
+
+		ret = kvm_riscv_vcpu_exit(vcpu, run, &trap);
+	}
+
+	kvm_sigset_deactivate(vcpu);
+
+	vcpu_put(vcpu);
+
+	srcu_read_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu_idx);
+
+	return ret;
+}
+
+bool kvm_riscv_vcpu_notify(void)
+{
+	struct kvm_vcpu *vcpu = kvm_vcpu;
+	struct khv_io *io_switch;
+	struct kvm_cpu_trap trap;
+	bool ret = false;
+
+	if (!vcpu)
+		return true;
+	io_switch = vcpu->kvm->arch.io_switch;
+
+	/* Skip guest shutdown command */
+	if (((io_switch->status >> 16) & 0xff) == 0x5a)
+		return true;
+
+	if ((io_switch->addr & 0xff) == 0x50)
+		kvm_riscv_vcpu_exit(vcpu, vcpu->run, &trap);
+	else
+		ret = true;
+
+	return ret;
+}
diff --git a/arch/riscv/kvm/vcpu_exit.c b/arch/riscv/kvm/vcpu_exit.c
new file mode 100755
index 000000000..53945b6e5
--- /dev/null
+++ b/arch/riscv/kvm/vcpu_exit.c
@@ -0,0 +1,135 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/kvm_host.h>
+#include <asm/csr.h>
+
+/**
+ * kvm_riscv_vcpu_mmio_return -- Handle MMIO loads after user space emulation
+ *			     or in-kernel IO emulation
+ *
+ * @vcpu: The VCPU pointer
+ * @run:  The VCPU run struct containing the mmio data
+ */
+int kvm_riscv_vcpu_mmio_return(struct kvm_vcpu *vcpu, struct kvm_run *run)
+{
+	struct kvm *kvm = vcpu->kvm;
+	struct khv_io *io_switch = kvm->arch.io_switch;
+	int len;
+
+	if (run->mmio.is_write)
+		goto out;
+
+	if (io_switch->status & BIT(7))
+		while(1)
+			printk_once(KERN_INFO "Can't be mmio write here\n");
+
+	len = 1 << ((io_switch->status >> 8) & 0xf);
+
+	switch (len) {
+	case 1:
+		*((u8  *)&io_switch->value) = *((u8  *)run->mmio.data);
+		break;
+	case 2:
+		*((u16 *)&io_switch->value) = *((u16 *)run->mmio.data);
+		break;
+	case 4:
+		*((u32 *)&io_switch->value) = *((u32 *)run->mmio.data);
+		break;
+	case 8:
+		*((u64 *)&io_switch->value) = *((u64 *)run->mmio.data);
+		break;
+	default:
+		return -EOPNOTSUPP;
+	};
+
+out:
+	if ((run->mmio.phys_addr & 0xff) != 0x50 ) { // skip VIRTIO_MMIO_QUEUE_NOTIFY
+		// READY
+		writeb(2, (void __iomem *)&io_switch->status);
+
+		while (readb((void __iomem *)&io_switch->status) != 3)
+			cpu_relax();
+	}
+
+	writel(0, (void __iomem *)&io_switch->status);
+
+	return 0;
+}
+
+/*
+ * Return > 0 to return to guest, < 0 on error, 0 (and set exit_reason) on
+ * proper exit to userspace.
+ */
+int kvm_riscv_vcpu_exit(struct kvm_vcpu *vcpu, struct kvm_run *run,
+			struct kvm_cpu_trap *trap)
+{
+	int ret;
+	struct kvm *kvm = vcpu->kvm;
+	struct khv_io *io_switch = kvm->arch.io_switch;
+	int len;
+
+	ret = -EFAULT;
+
+	if (((io_switch->status >> 16) & 0xff) == 0x5a) {
+		run->exit_reason = KVM_EXIT_SHUTDOWN;
+		io_switch->status = 0;
+		return 0;
+	}
+
+	run->exit_reason = KVM_EXIT_UNKNOWN;
+
+	len = 1 << ((io_switch->status >> 8) & 0xf);
+
+	/* Update MMIO details in kvm_run struct */
+	run->mmio.phys_addr = io_switch->addr;
+	run->mmio.len = len;
+
+	if (io_switch->status & BIT(7))
+		run->mmio.is_write = 1;
+	else {
+		run->mmio.is_write = 0;
+		goto out;
+	}
+
+	/* Copy data to kvm_run instance */
+	switch (len) {
+	case 1:
+		*((u8 *)run->mmio.data)  = *((u8  *)&io_switch->value);
+		break;
+	case 2:
+		*((u16 *)run->mmio.data) = *((u16 *)&io_switch->value);
+		break;
+	case 4:
+		*((u32 *)run->mmio.data) = *((u32 *)&io_switch->value);
+		break;
+	case 8:
+		*((u64 *)run->mmio.data) = *((u64 *)&io_switch->value);
+		break;
+	default:
+		pr_info("%s, %llx, len: %d.\n", __func__, io_switch->status, len);
+		return -EOPNOTSUPP;
+	};
+
+	pr_debug("mmio: 0x%llx 0x%x %d %d\n",
+		 run->mmio.phys_addr, *((u32 *)run->mmio.data),
+		 len, run->mmio.is_write);
+
+out:
+	/* Try to handle MMIO access in the kernel */
+	if (!kvm_io_bus_write(vcpu, KVM_MMIO_BUS,
+			      io_switch->addr, len, run->mmio.data)) {
+		/* Successfully handled MMIO access in the kernel so resume */
+		vcpu->stat.mmio_exit_kernel++;
+		kvm_riscv_vcpu_mmio_return(vcpu, run);
+		return 1;
+	}
+
+	/* Exit to userspace for MMIO emulation */
+	vcpu->stat.mmio_exit_user++;
+	run->exit_reason = KVM_EXIT_MMIO;
+
+	return 0;
+}
diff --git a/arch/riscv/kvm/vm.c b/arch/riscv/kvm/vm.c
new file mode 100755
index 000000000..d73e27b61
--- /dev/null
+++ b/arch/riscv/kvm/vm.c
@@ -0,0 +1,189 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Western Digital Corporation or its affiliates.
+ *
+ * Authors:
+ *     Anup Patel <anup.patel@wdc.com>
+ */
+
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/kvm_host.h>
+#include <linux/of_irq.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+
+static unsigned int kvm_arch_irq;
+
+static volatile unsigned char __iomem *kvm_arch_guest_intr_reg;
+
+extern bool kvm_riscv_vcpu_notify(void);
+
+void kvm_arch_notify_guest(void)
+{
+	writel(1, kvm_arch_guest_intr_reg);
+}
+
+static irqreturn_t kvm_arch_interrupt(int irq, void *opaque)
+{
+	struct kvm *kvm = (struct kvm *)opaque;
+
+#ifdef CONFIG_SOC_INT_SRC7
+	writel(0, kvm->arch.backend_intr_reg);
+#else
+	/* Clear mailbox interrupt */
+	writel(kvm->arch.clear_intr, kvm->arch.backend_intr_reg + 0x4);
+#endif
+
+	if (kvm_riscv_vcpu_notify())
+		wake_up(&kvm->arch.waitq);
+
+	return IRQ_HANDLED;
+}
+
+u64 khv_reserved_memory = (u64)-1;
+u64 khv_reserved_memory_size = (u64)-1;
+
+int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
+{
+	kvm->arch.khv_base_phys_addr = 0x1fd000;
+	kvm->arch.khv_base = (unsigned long)ioremap(kvm->arch.khv_base_phys_addr, 0x100);
+	memset((void *)kvm->arch.khv_base, 0, 0x100);
+
+	kvm->arch.io_switch = (struct khv_io *)kvm->arch.khv_base;
+
+#ifdef CONFIG_SOC_INT_SRC7
+	kvm->arch.backend_intr_reg  = ioremap(0xFFFF019094, 4);
+	kvm->arch.frontend_intr_reg = ioremap(0xFFEF018094, 4);
+	kvm_arch_guest_intr_reg = kvm->arch.frontend_intr_reg;
+#else
+	/* MPW use mailbox as interrupt */
+	kvm->arch.backend_intr_reg  = ioremap(0xffffc3b000, 0x100);
+	kvm->arch.frontend_intr_reg = ioremap(0xffefc50000, 0x100);
+	kvm->arch.enable_intr = 1;
+	kvm->arch.clear_intr = 1;
+	writel(kvm->arch.enable_intr, kvm->arch.frontend_intr_reg + 0xc);
+	writel(kvm->arch.clear_intr, kvm->arch.frontend_intr_reg + 0x4);
+	kvm_arch_guest_intr_reg = kvm->arch.frontend_intr_reg + 0x10;
+#endif
+
+	init_waitqueue_head(&kvm->arch.waitq);
+
+	if (request_irq(kvm_arch_irq, kvm_arch_interrupt, IRQF_SHARED,
+			"khv-interrupt", kvm) < 0) {
+		pr_err("kvm backend: register IRQ %d failed\n", kvm_arch_irq);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void kvm_arch_destroy_vm(struct kvm *kvm)
+{
+	int i;
+
+	for (i = 0; i < KVM_MAX_VCPUS; ++i) {
+		if (kvm->vcpus[i]) {
+			kvm_arch_vcpu_destroy(kvm->vcpus[i]);
+			kvm->vcpus[i] = NULL;
+		}
+	}
+}
+
+int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
+{
+	int r;
+
+	switch (ext) {
+	case KVM_CAP_IOEVENTFD:
+	case KVM_CAP_DEVICE_CTRL:
+	case KVM_CAP_USER_MEMORY:
+	case KVM_CAP_SYNC_MMU:
+	case KVM_CAP_DESTROY_MEMORY_REGION_WORKS:
+	case KVM_CAP_ONE_REG:
+	case KVM_CAP_READONLY_MEM:
+	case KVM_CAP_MP_STATE:
+	case KVM_CAP_IMMEDIATE_EXIT:
+		r = 1;
+		break;
+	case KVM_CAP_NR_VCPUS:
+		r = 0xffff;
+		break;
+	case KVM_CAP_MAX_VCPUS:
+		r = KVM_MAX_VCPUS;
+		break;
+	case KVM_CAP_NR_MEMSLOTS:
+		r = KVM_USER_MEM_SLOTS;
+		break;
+	default:
+		r = 0;
+		break;
+	}
+
+	return r;
+}
+
+long kvm_arch_vm_ioctl(struct file *filp,
+		       unsigned int ioctl, unsigned long arg)
+{
+	return 0;
+}
+
+static int khv_probe(struct platform_device *pdev)
+{
+	struct device_node *np;
+	struct resource r;
+	struct device *dev;
+	int rc;
+
+	dev = &pdev->dev;
+
+	kvm_arch_irq = platform_get_irq(pdev, 0);
+	if (kvm_arch_irq <= 0) {
+		pr_err("Cannot get IRQ resource for kvm backend\n");
+		return -EINVAL;
+	}
+
+	np = of_parse_phandle(dev->of_node, "memory-region", 0);
+	if (!np) {
+		goto out;
+	}
+
+	rc = of_address_to_resource(np, 0, &r);
+	if (rc) {
+		dev_err(dev, "No memory address assigned to the region\n");
+		return -ENOMEM;
+	}
+
+	khv_reserved_memory = r.start;
+	khv_reserved_memory_size = r.end - r.start + 1;
+out:
+	printk("%s, %d, irq: %d.\n", __func__, __LINE__, kvm_arch_irq);
+
+	return 0;
+}
+
+static int khv_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id khv_of_table[] = {
+	{ .compatible = "thead,khv-host" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, khv_of_table);
+
+static struct platform_driver khv_driver = {
+	.probe  = khv_probe,
+	.remove = khv_remove,
+	.driver = {
+		.name = "KVM-based Heterogeneous Virtualization",
+		.of_match_table = khv_of_table,
+	},
+};
+module_platform_driver(khv_driver);
diff --git a/arch/riscv/lib/Makefile b/arch/riscv/lib/Makefile
index 47e7a8204..699ed200c 100644
--- a/arch/riscv/lib/Makefile
+++ b/arch/riscv/lib/Makefile
@@ -4,3 +4,5 @@ lib-y			+= memcpy.o
 lib-y			+= memset.o
 lib-$(CONFIG_MMU)	+= uaccess.o
 lib-$(CONFIG_64BIT)	+= tishift.o
+
+obj-$(CONFIG_FUNCTION_ERROR_INJECTION) += error-inject.o
diff --git a/arch/riscv/lib/error-inject.c b/arch/riscv/lib/error-inject.c
new file mode 100755
index 000000000..d667ade2b
--- /dev/null
+++ b/arch/riscv/lib/error-inject.c
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/error-injection.h>
+#include <linux/kprobes.h>
+
+void override_function_with_return(struct pt_regs *regs)
+{
+	instruction_pointer_set(regs, regs->ra);
+}
+NOKPROBE_SYMBOL(override_function_with_return);
diff --git a/arch/riscv/lib/uaccess.S b/arch/riscv/lib/uaccess.S
index fceaeb18c..cc138c16e 100644
--- a/arch/riscv/lib/uaccess.S
+++ b/arch/riscv/lib/uaccess.S
@@ -14,6 +14,7 @@
 
 ENTRY(__asm_copy_to_user)
 ENTRY(__asm_copy_from_user)
+ENTRY(__asm_copy_in_user)
 
 	/* Enable access to user memory */
 	li t6, SR_SUM
@@ -65,8 +66,10 @@ ENTRY(__asm_copy_from_user)
 	j 3b
 ENDPROC(__asm_copy_to_user)
 ENDPROC(__asm_copy_from_user)
+ENDPROC(__asm_copy_in_user)
 EXPORT_SYMBOL(__asm_copy_to_user)
 EXPORT_SYMBOL(__asm_copy_from_user)
+EXPORT_SYMBOL(__asm_copy_in_user)
 
 
 ENTRY(__clear_user)
diff --git a/arch/riscv/mm/Makefile b/arch/riscv/mm/Makefile
index 7ebaef10e..756e5ad74 100644
--- a/arch/riscv/mm/Makefile
+++ b/arch/riscv/mm/Makefile
@@ -13,6 +13,10 @@ obj-y += extable.o
 obj-$(CONFIG_MMU) += fault.o pageattr.o
 obj-y += cacheflush.o
 obj-y += context.o
+obj-y += dma-mapping.o
+obj-y += ioremap.o
+obj-y += asid.o
+obj-y += context.o
 
 ifeq ($(CONFIG_MMU),y)
 obj-$(CONFIG_SMP) += tlbflush.o
@@ -24,6 +28,9 @@ obj-$(CONFIG_KASAN)   += kasan_init.o
 ifdef CONFIG_KASAN
 KASAN_SANITIZE_kasan_init.o := n
 KASAN_SANITIZE_init.o := n
+ifdef CONFIG_DEBUG_VIRTUAL
+KASAN_SANITIZE_physaddr.o := n
+endif
 endif
 
 obj-$(CONFIG_DEBUG_VIRTUAL) += physaddr.o
diff --git a/arch/riscv/mm/asid.c b/arch/riscv/mm/asid.c
new file mode 100755
index 000000000..b2e914745
--- /dev/null
+++ b/arch/riscv/mm/asid.c
@@ -0,0 +1,189 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Generic ASID allocator.
+ *
+ * Based on arch/arm/mm/context.c
+ *
+ * Copyright (C) 2002-2003 Deep Blue Solutions Ltd, all rights reserved.
+ * Copyright (C) 2012 ARM Ltd.
+ */
+
+#include <linux/slab.h>
+#include <linux/mm_types.h>
+
+#include <asm/asid.h>
+
+#define reserved_asid(info, cpu) *per_cpu_ptr((info)->reserved, cpu)
+
+#define ASID_MASK(info)			(~GENMASK((info)->bits - 1, 0))
+#define ASID_FIRST_VERSION(info)	(1UL << ((info)->bits))
+
+#define asid2idx(info, asid)		(((asid) & ~ASID_MASK(info)) >> (info)->ctxt_shift)
+#define idx2asid(info, idx)		(((idx) << (info)->ctxt_shift) & ~ASID_MASK(info))
+
+static void flush_context(struct asid_info *info)
+{
+	int i;
+	u64 asid;
+
+	/* Update the list of reserved ASIDs and the ASID bitmap. */
+	bitmap_clear(info->map, 0, NUM_CTXT_ASIDS(info));
+
+	for_each_possible_cpu(i) {
+		asid = atomic64_xchg_relaxed(&active_asid(info, i), 0);
+		/*
+		 * If this CPU has already been through a
+		 * rollover, but hasn't run another task in
+		 * the meantime, we must preserve its reserved
+		 * ASID, as this is the only trace we have of
+		 * the process it is still running.
+		 */
+		if (asid == 0)
+			asid = reserved_asid(info, i);
+		__set_bit(asid2idx(info, asid), info->map);
+		reserved_asid(info, i) = asid;
+	}
+
+	/*
+	 * Queue a TLB invalidation for each CPU to perform on next
+	 * context-switch
+	 */
+	cpumask_setall(&info->flush_pending);
+}
+
+static bool check_update_reserved_asid(struct asid_info *info, u64 asid,
+				       u64 newasid)
+{
+	int cpu;
+	bool hit = false;
+
+	/*
+	 * Iterate over the set of reserved ASIDs looking for a match.
+	 * If we find one, then we can update our mm to use newasid
+	 * (i.e. the same ASID in the current generation) but we can't
+	 * exit the loop early, since we need to ensure that all copies
+	 * of the old ASID are updated to reflect the mm. Failure to do
+	 * so could result in us missing the reserved ASID in a future
+	 * generation.
+	 */
+	for_each_possible_cpu(cpu) {
+		if (reserved_asid(info, cpu) == asid) {
+			hit = true;
+			reserved_asid(info, cpu) = newasid;
+		}
+	}
+
+	return hit;
+}
+
+static u64 new_context(struct asid_info *info, atomic64_t *pasid,
+		       struct mm_struct *mm)
+{
+	static u32 cur_idx = 1;
+	u64 asid = atomic64_read(pasid);
+	u64 generation = atomic64_read(&info->generation);
+
+	if (asid != 0) {
+		u64 newasid = generation | (asid & ~ASID_MASK(info));
+
+		/*
+		 * If our current ASID was active during a rollover, we
+		 * can continue to use it and this was just a false alarm.
+		 */
+		if (check_update_reserved_asid(info, asid, newasid))
+			return newasid;
+
+		/*
+		 * We had a valid ASID in a previous life, so try to re-use
+		 * it if possible.
+		 */
+		if (!__test_and_set_bit(asid2idx(info, asid), info->map))
+			return newasid;
+	}
+
+	/*
+	 * Allocate a free ASID. If we can't find one, take a note of the
+	 * currently active ASIDs and mark the TLBs as requiring flushes.  We
+	 * always count from ASID #2 (index 1), as we use ASID #0 when setting
+	 * a reserved TTBR0 for the init_mm and we allocate ASIDs in even/odd
+	 * pairs.
+	 */
+	asid = find_next_zero_bit(info->map, NUM_CTXT_ASIDS(info), cur_idx);
+	if (asid != NUM_CTXT_ASIDS(info))
+		goto set_asid;
+
+	/* We're out of ASIDs, so increment the global generation count */
+	generation = atomic64_add_return_relaxed(ASID_FIRST_VERSION(info),
+						 &info->generation);
+	flush_context(info);
+
+	/* We have more ASIDs than CPUs, so this will always succeed */
+	asid = find_next_zero_bit(info->map, NUM_CTXT_ASIDS(info), 1);
+
+set_asid:
+	__set_bit(asid, info->map);
+	cur_idx = asid;
+	cpumask_clear(mm_cpumask(mm));
+	return idx2asid(info, asid) | generation;
+}
+
+/*
+ * Generate a new ASID for the context.
+ *
+ * @pasid: Pointer to the current ASID batch allocated. It will be updated
+ * with the new ASID batch.
+ * @cpu: current CPU ID. Must have been acquired through get_cpu()
+ */
+void asid_new_context(struct asid_info *info, atomic64_t *pasid,
+		      unsigned int cpu, struct mm_struct *mm)
+{
+	unsigned long flags;
+	u64 asid;
+
+	raw_spin_lock_irqsave(&info->lock, flags);
+	/* Check that our ASID belongs to the current generation. */
+	asid = atomic64_read(pasid);
+	if ((asid ^ atomic64_read(&info->generation)) >> info->bits) {
+		asid = new_context(info, pasid, mm);
+		atomic64_set(pasid, asid);
+	}
+
+	if (cpumask_test_and_clear_cpu(cpu, &info->flush_pending))
+		info->flush_cpu_ctxt_cb();
+
+	atomic64_set(&active_asid(info, cpu), asid);
+	cpumask_set_cpu(cpu, mm_cpumask(mm));
+	raw_spin_unlock_irqrestore(&info->lock, flags);
+}
+
+/*
+ * Initialize the ASID allocator
+ *
+ * @info: Pointer to the asid allocator structure
+ * @bits: Number of ASIDs available
+ * @asid_per_ctxt: Number of ASIDs to allocate per-context. ASIDs are
+ * allocated contiguously for a given context. This value should be a power of
+ * 2.
+ */
+int asid_allocator_init(struct asid_info *info,
+			u32 bits, unsigned int asid_per_ctxt,
+			void (*flush_cpu_ctxt_cb)(void))
+{
+	info->bits = bits;
+	info->ctxt_shift = ilog2(asid_per_ctxt);
+	info->flush_cpu_ctxt_cb = flush_cpu_ctxt_cb;
+	/*
+	 * Expect allocation after rollover to fail if we don't have at least
+	 * one more ASID than CPUs. ASID #0 is always reserved.
+	 */
+	WARN_ON(NUM_CTXT_ASIDS(info) - 1 <= num_possible_cpus());
+	atomic64_set(&info->generation, ASID_FIRST_VERSION(info));
+	info->map = kcalloc(BITS_TO_LONGS(NUM_CTXT_ASIDS(info)),
+			    sizeof(*info->map), GFP_KERNEL);
+	if (!info->map)
+		return -ENOMEM;
+
+	raw_spin_lock_init(&info->lock);
+
+	return 0;
+}
diff --git a/arch/riscv/mm/cacheflush.c b/arch/riscv/mm/cacheflush.c
index 89f81067e..025f65cad 100644
--- a/arch/riscv/mm/cacheflush.c
+++ b/arch/riscv/mm/cacheflush.c
@@ -4,11 +4,10 @@
  */
 
 #include <asm/cacheflush.h>
+#include <asm/sbi.h>
 
 #ifdef CONFIG_SMP
 
-#include <asm/sbi.h>
-
 static void ipi_remote_fence_i(void *info)
 {
 	return local_flush_icache_all();
@@ -85,7 +84,49 @@ void flush_icache_pte(pte_t pte)
 {
 	struct page *page = pte_page(pte);
 
-	if (!test_and_set_bit(PG_dcache_clean, &page->flags))
+	if (!test_bit(PG_dcache_clean, &page->flags)) {
 		flush_icache_all();
+		set_bit(PG_dcache_clean, &page->flags);
+	}
 }
 #endif /* CONFIG_MMU */
+
+static bool thead_dma_init_flag = false;
+
+#define sync_is()	asm volatile (".long 0x01a0000b")
+void dma_wbinv_range(unsigned long start, unsigned long end)
+{
+	register unsigned long i asm("a0") = start & ~(L1_CACHE_BYTES - 1);
+
+	if (!thead_dma_init_flag)
+		return;
+
+	for (; i < end; i += L1_CACHE_BYTES)
+		asm volatile (".long 0x02b5000b"); /* dcache.cipa a0 */
+
+	sync_is();
+}
+
+void dma_wb_range(unsigned long start, unsigned long end)
+{
+	register unsigned long i asm("a0") = start & ~(L1_CACHE_BYTES - 1);
+
+	if (!thead_dma_init_flag)
+		return;
+
+	for (; i < end; i += L1_CACHE_BYTES)
+		asm volatile (".long 0x0295000b"); /* dcache.cpa a0 */
+
+	sync_is();
+}
+
+#define THEAD_VENDOR_ID       0x5b7
+
+static int __init thead_dma_init(void)
+{
+	if (sbi_get_mvendorid() == THEAD_VENDOR_ID)
+		thead_dma_init_flag = true;
+
+	return 0;
+}
+arch_initcall(thead_dma_init);
diff --git a/arch/riscv/mm/context.c b/arch/riscv/mm/context.c
index 613ec81a8..4e022e124 100644
--- a/arch/riscv/mm/context.c
+++ b/arch/riscv/mm/context.c
@@ -44,6 +44,7 @@ void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	struct task_struct *task)
 {
 	unsigned int cpu;
+	unsigned long asid;
 
 	if (unlikely(prev == next))
 		return;
@@ -55,13 +56,85 @@ void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	 */
 	cpu = smp_processor_id();
 
-	cpumask_clear_cpu(cpu, mm_cpumask(prev));
 	cpumask_set_cpu(cpu, mm_cpumask(next));
 
 #ifdef CONFIG_MMU
-	csr_write(CSR_SATP, virt_to_pfn(next->pgd) | SATP_MODE);
-	local_flush_tlb_all();
+	__asm__ __volatile__(
+			"jal t0,1f\n\t"
+			"1: \n\t"
+			"jal t0,2f\n\t"
+			"2: \n\t"
+			"jal t0,3f\n\t"
+			"3: \n\t"
+			"jal t0,4f\n\t"
+			"4: \n\t"
+			"jal t0,5f\n\t"
+			"5: \n\t"
+			"jal t0,6f\n\t"
+			"6: \n\t"
+			"jal t0,7f\n\t"
+			"7: \n\t"
+			"jal t0,8f\n\t"
+			"8: \n\t"
+			"jal t0,9f\n\t"
+			"9: \n\t"
+			"jal t0,10f\n\t"
+			"10: \n\t"
+			"jal t0,11f\n\t"
+			"11: \n\t"
+			"jal t0,12f\n\t"
+			"12: \n\t"
+			::: "memory", "t0");
+
+	check_and_switch_context(next, cpu);
+	asid = (next->context.asid.counter & SATP_ASID_MASK)
+		<< SATP_ASID_SHIFT;
+
+	local_flush_tlb_page(0);
+
+	/* flush utlb before setting satp */
+	__asm__ __volatile__(
+			"li t0, 0\n\t"
+			"sfence.vma t0, t0\n\t"
+			::: "memory", "t0");
+
+	csr_write(sptbr, virt_to_pfn(next->pgd) | SATP_MODE | asid);
 #endif
 
 	flush_icache_deferred(next);
 }
+
+static DEFINE_PER_CPU(atomic64_t, active_asids);
+static DEFINE_PER_CPU(u64, reserved_asids);
+
+struct asid_info asid_info;
+
+void check_and_switch_context(struct mm_struct *mm, unsigned int cpu)
+{
+	asid_check_context(&asid_info, &mm->context.asid, cpu, mm);
+}
+
+static void asid_flush_cpu_ctxt(void)
+{
+	local_flush_tlb_all();
+}
+
+static int asids_init(void)
+{
+	BUG_ON(((1 << SATP_ASID_BITS) - 1) <= num_possible_cpus());
+
+	if (asid_allocator_init(&asid_info, SATP_ASID_BITS, 1,
+				asid_flush_cpu_ctxt))
+		panic("Unable to initialize ASID allocator for %lu ASIDs\n",
+		      NUM_ASIDS(&asid_info));
+
+	asid_info.active = &active_asids;
+	asid_info.reserved = &reserved_asids;
+
+	pr_info("ASID allocator initialised with %lu entries\n",
+		NUM_CTXT_ASIDS(&asid_info));
+
+	local_flush_tlb_all();
+	return 0;
+}
+early_initcall(asids_init);
diff --git a/arch/riscv/mm/dma-mapping.c b/arch/riscv/mm/dma-mapping.c
new file mode 100755
index 000000000..e8acdce7d
--- /dev/null
+++ b/arch/riscv/mm/dma-mapping.c
@@ -0,0 +1,67 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/cache.h>
+#include <linux/dma-map-ops.h>
+#include <linux/genalloc.h>
+#include <linux/highmem.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/scatterlist.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <asm/cache.h>
+
+void arch_dma_prep_coherent(struct page *page, size_t size)
+{
+	void *ptr = page_address(page);
+
+	memset(ptr, 0, size);
+	dma_wbinv_range(page_to_phys(page), page_to_phys(page) + size);
+}
+
+static inline void cache_op(phys_addr_t paddr, size_t size,
+			    void (*fn)(unsigned long start, unsigned long end))
+{
+	unsigned long start = (unsigned long)paddr;
+
+	fn(start, start + size);
+}
+
+void arch_sync_dma_for_device(phys_addr_t paddr, size_t size,
+			      enum dma_data_direction dir)
+{
+	switch (dir) {
+	case DMA_TO_DEVICE:
+		cache_op(paddr, size, dma_wb_range);
+		break;
+	case DMA_FROM_DEVICE:
+	case DMA_BIDIRECTIONAL:
+		cache_op(paddr, size, dma_wbinv_range);
+		break;
+	default:
+		BUG();
+	}
+}
+
+void arch_sync_dma_for_cpu(phys_addr_t paddr, size_t size,
+			   enum dma_data_direction dir)
+{
+	switch (dir) {
+	case DMA_TO_DEVICE:
+		return;
+	case DMA_FROM_DEVICE:
+	case DMA_BIDIRECTIONAL:
+		cache_op(paddr, size, dma_wbinv_range);
+		break;
+	default:
+		BUG();
+	}
+}
+
+pgprot_t arch_dma_mmap_pgprot(struct device *dev, pgprot_t prot,
+		unsigned long attrs)
+{
+	if (attrs & DMA_ATTR_WRITE_COMBINE)
+		return pgprot_writecombine(prot);
+	return pgprot_noncached(prot);
+}
diff --git a/arch/riscv/mm/fault.c b/arch/riscv/mm/fault.c
index 3c8b9e433..d895064df 100644
--- a/arch/riscv/mm/fault.c
+++ b/arch/riscv/mm/fault.c
@@ -13,6 +13,7 @@
 #include <linux/perf_event.h>
 #include <linux/signal.h>
 #include <linux/uaccess.h>
+#include <linux/kprobes.h>
 
 #include <asm/ptrace.h>
 #include <asm/tlbflush.h>
@@ -202,6 +203,9 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	tsk = current;
 	mm = tsk->mm;
 
+	if (kprobe_page_fault(regs, cause))
+		return;
+
 	/*
 	 * Fault-in kernel-space virtual memory on-demand.
 	 * The 'reference' page table is init_mm.pgd.
@@ -217,7 +221,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	}
 
 	/* Enable interrupts if they were enabled in the parent context. */
-	if (likely(regs->status & SR_PIE))
+	if (likely(regs->status & SR_PIE) || user_mode(regs))
 		local_irq_enable();
 
 	/*
@@ -225,6 +229,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	 * in an atomic region, then we must not take the fault.
 	 */
 	if (unlikely(faulthandler_disabled() || !mm)) {
+		tsk->thread.bad_cause = cause;
 		no_context(regs, addr);
 		return;
 	}
@@ -242,16 +247,19 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	mmap_read_lock(mm);
 	vma = find_vma(mm, addr);
 	if (unlikely(!vma)) {
+		tsk->thread.bad_cause = cause;
 		bad_area(regs, mm, code, addr);
 		return;
 	}
 	if (likely(vma->vm_start <= addr))
 		goto good_area;
 	if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {
+		tsk->thread.bad_cause = cause;
 		bad_area(regs, mm, code, addr);
 		return;
 	}
 	if (unlikely(expand_stack(vma, addr))) {
+		tsk->thread.bad_cause = cause;
 		bad_area(regs, mm, code, addr);
 		return;
 	}
@@ -264,6 +272,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	code = SEGV_ACCERR;
 
 	if (unlikely(access_error(cause, vma))) {
+		tsk->thread.bad_cause = cause;
 		bad_area(regs, mm, code, addr);
 		return;
 	}
@@ -297,6 +306,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	mmap_read_unlock(mm);
 
 	if (unlikely(fault & VM_FAULT_ERROR)) {
+		tsk->thread.bad_cause = cause;
 		mm_fault_error(regs, addr, fault);
 		return;
 	}
diff --git a/arch/riscv/mm/init.c b/arch/riscv/mm/init.c
index e8921e78a..56b586d14 100644
--- a/arch/riscv/mm/init.c
+++ b/arch/riscv/mm/init.c
@@ -2,6 +2,8 @@
 /*
  * Copyright (C) 2012 Regents of the University of California
  * Copyright (C) 2019 Western Digital Corporation or its affiliates.
+ * Copyright (C) 2020 FORTH-ICS/CARV
+ *  Nick Kossifidis <mick@ics.forth.gr>
  */
 
 #include <linux/init.h>
@@ -11,8 +13,10 @@
 #include <linux/swap.h>
 #include <linux/sizes.h>
 #include <linux/of_fdt.h>
+#include <linux/of_reserved_mem.h>
 #include <linux/libfdt.h>
 #include <linux/set_memory.h>
+#include <linux/crash_dump.h>
 
 #include <asm/fixmap.h>
 #include <asm/tlbflush.h>
@@ -636,31 +640,102 @@ void mark_rodata_ro(void)
 }
 #endif
 
-static void __init resource_init(void)
+#ifdef CONFIG_KEXEC_CORE
+/*
+ * reserve_crashkernel() - reserves memory for crash kernel
+ *
+ * This function reserves memory area given in "crashkernel=" kernel command
+ * line parameter. The memory reserved is used by dump capture kernel when
+ * primary kernel is crashing.
+ */
+static void __init reserve_crashkernel(void)
 {
-	struct memblock_region *region;
+	unsigned long long crash_base = 0;
+	unsigned long long crash_size = 0;
+	unsigned long search_start = memblock_start_of_DRAM();
+	unsigned long search_end = memblock_end_of_DRAM();
+
+	int ret = 0;
+
+	/*
+	 * Don't reserve a region for a crash kernel on a crash kernel
+	 * since it doesn't make much sense and we have limited memory
+	 * resources.
+	 */
+#ifdef CONFIG_CRASH_DUMP
+	if (is_kdump_kernel()) {
+		pr_info("crashkernel: ignoring reservation request\n");
+		return;
+	}
+#endif
 
-	for_each_mem_region(region) {
-		struct resource *res;
+	ret = parse_crashkernel(boot_command_line, memblock_phys_mem_size(),
+				&crash_size, &crash_base);
+	if (ret || !crash_size)
+		return;
 
-		res = memblock_alloc(sizeof(struct resource), SMP_CACHE_BYTES);
-		if (!res)
-			panic("%s: Failed to allocate %zu bytes\n", __func__,
-			      sizeof(struct resource));
+	crash_size = PAGE_ALIGN(crash_size);
 
-		if (memblock_is_nomap(region)) {
-			res->name = "reserved";
-			res->flags = IORESOURCE_MEM;
+	if (crash_base == 0) {
+		/*
+		 * Current riscv boot protocol requires 2MB alignment for
+		 * RV64 and 4MB alignment for RV32 (hugepage size)
+		 */
+		crash_base = memblock_find_in_range(search_start, search_end,
+						    crash_size, PMD_SIZE);
+
+		if (crash_base == 0) {
+			pr_warn("crashkernel: couldn't allocate %lldKB\n",
+				crash_size >> 10);
+			return;
+		}
 		} else {
-			res->name = "System RAM";
-			res->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+		/* User specifies base address explicitly. */
+		if (!memblock_is_region_memory(crash_base, crash_size)) {
+			pr_warn("crashkernel: requested region is not memory\n");
+			return;
 		}
-		res->start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
-		res->end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;
 
-		request_resource(&iomem_resource, res);
+		if (memblock_is_region_reserved(crash_base, crash_size)) {
+			pr_warn("crashkernel: requested region is reserved\n");
+			return;
 	}
+
+
+		if (!IS_ALIGNED(crash_base, PMD_SIZE)) {
+			pr_warn("crashkernel: requested region is misaligned\n");
+			return;
+	}
+	}
+	memblock_reserve(crash_base, crash_size);
+
+	pr_info("crashkernel: reserved 0x%016llx - 0x%016llx (%lld MB)\n",
+		crash_base, crash_base + crash_size, crash_size >> 20);
+
+	crashk_res.start = crash_base;
+	crashk_res.end = crash_base + crash_size - 1;
 }
+#endif /* CONFIG_KEXEC_CORE */
+
+#ifdef CONFIG_CRASH_DUMP
+/*
+ * We keep track of the ELF core header of the crashed
+ * kernel with a reserved-memory region with compatible
+ * string "linux,elfcorehdr". Here we register a callback
+ * to populate elfcorehdr_addr/size when this region is
+ * present. Note that this region will be marked as
+ * reserved once we call early_init_fdt_scan_reserved_mem()
+ * later on.
+ */
+static int elfcore_hdr_setup(struct reserved_mem *rmem)
+{
+	elfcorehdr_addr = rmem->base;
+	elfcorehdr_size = rmem->size;
+	return 0;
+}
+
+RESERVEDMEM_OF_DECLARE(elfcorehdr, "linux,elfcorehdr", elfcore_hdr_setup);
+#endif
 
 void __init paging_init(void)
 {
@@ -668,7 +743,9 @@ void __init paging_init(void)
 	sparse_init();
 	setup_zero_page();
 	zone_sizes_init();
-	resource_init();
+#ifdef CONFIG_KEXEC_CORE
+	reserve_crashkernel();
+#endif
 }
 
 #ifdef CONFIG_SPARSEMEM_VMEMMAP
diff --git a/arch/riscv/mm/ioremap.c b/arch/riscv/mm/ioremap.c
new file mode 100755
index 000000000..c56f0ca33
--- /dev/null
+++ b/arch/riscv/mm/ioremap.c
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/export.h>
+#include <linux/mm.h>
+#include <linux/io.h>
+
+#include <asm/pgtable.h>
+
+pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
+			      unsigned long size, pgprot_t vma_prot)
+{
+	if (!pfn_valid(pfn)) {
+		return pgprot_noncached(vma_prot);
+	} else if (file->f_flags & O_SYNC) {
+		return pgprot_writecombine(vma_prot);
+	}
+
+	return vma_prot;
+}
+EXPORT_SYMBOL(phys_mem_access_prot);
diff --git a/arch/riscv/mm/kasan_init.c b/arch/riscv/mm/kasan_init.c
index 883c3be43..2db442701 100644
--- a/arch/riscv/mm/kasan_init.c
+++ b/arch/riscv/mm/kasan_init.c
@@ -21,8 +21,7 @@ asmlinkage void __init kasan_early_init(void)
 
 	for (i = 0; i < PTRS_PER_PTE; ++i)
 		set_pte(kasan_early_shadow_pte + i,
-			mk_pte(virt_to_page(kasan_early_shadow_page),
-			       PAGE_KERNEL));
+			pfn_pte(virt_to_pfn(kasan_early_shadow_page), PAGE_KERNEL));
 
 	for (i = 0; i < PTRS_PER_PMD; ++i)
 		set_pmd(kasan_early_shadow_pmd + i,
diff --git a/include/crypto/blake2s.h b/include/crypto/blake2s.h
index b471deac2..4e30e1799 100644
--- a/include/crypto/blake2s.h
+++ b/include/crypto/blake2s.h
@@ -3,15 +3,14 @@
  * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
-#ifndef BLAKE2S_H
-#define BLAKE2S_H
+#ifndef _CRYPTO_BLAKE2S_H
+#define _CRYPTO_BLAKE2S_H
 
+#include <linux/bug.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/string.h>
 
-#include <asm/bug.h>
-
 enum blake2s_lengths {
 	BLAKE2S_BLOCK_SIZE = 64,
 	BLAKE2S_HASH_SIZE = 32,
@@ -24,6 +23,7 @@ enum blake2s_lengths {
 };
 
 struct blake2s_state {
+	/* 'h', 't', and 'f' are used in assembly code, so keep them as-is. */
 	u32 h[8];
 	u32 t[2];
 	u32 f[2];
@@ -43,29 +43,34 @@ enum blake2s_iv {
 	BLAKE2S_IV7 = 0x5BE0CD19UL,
 };
 
-void blake2s_update(struct blake2s_state *state, const u8 *in, size_t inlen);
-void blake2s_final(struct blake2s_state *state, u8 *out);
-
-static inline void blake2s_init_param(struct blake2s_state *state,
-				      const u32 param)
+static inline void __blake2s_init(struct blake2s_state *state, size_t outlen,
+				  const void *key, size_t keylen)
 {
-	*state = (struct blake2s_state){{
-		BLAKE2S_IV0 ^ param,
-		BLAKE2S_IV1,
-		BLAKE2S_IV2,
-		BLAKE2S_IV3,
-		BLAKE2S_IV4,
-		BLAKE2S_IV5,
-		BLAKE2S_IV6,
-		BLAKE2S_IV7,
-	}};
+	state->h[0] = BLAKE2S_IV0 ^ (0x01010000 | keylen << 8 | outlen);
+	state->h[1] = BLAKE2S_IV1;
+	state->h[2] = BLAKE2S_IV2;
+	state->h[3] = BLAKE2S_IV3;
+	state->h[4] = BLAKE2S_IV4;
+	state->h[5] = BLAKE2S_IV5;
+	state->h[6] = BLAKE2S_IV6;
+	state->h[7] = BLAKE2S_IV7;
+	state->t[0] = 0;
+	state->t[1] = 0;
+	state->f[0] = 0;
+	state->f[1] = 0;
+	state->buflen = 0;
+	state->outlen = outlen;
+	if (keylen) {
+		memcpy(state->buf, key, keylen);
+		memset(&state->buf[keylen], 0, BLAKE2S_BLOCK_SIZE - keylen);
+		state->buflen = BLAKE2S_BLOCK_SIZE;
+	}
 }
 
 static inline void blake2s_init(struct blake2s_state *state,
 				const size_t outlen)
 {
-	blake2s_init_param(state, 0x01010000 | outlen);
-	state->outlen = outlen;
+	__blake2s_init(state, outlen, NULL, 0);
 }
 
 static inline void blake2s_init_key(struct blake2s_state *state,
@@ -75,12 +80,12 @@ static inline void blake2s_init_key(struct blake2s_state *state,
 	WARN_ON(IS_ENABLED(DEBUG) && (!outlen || outlen > BLAKE2S_HASH_SIZE ||
 		!key || !keylen || keylen > BLAKE2S_KEY_SIZE));
 
-	blake2s_init_param(state, 0x01010000 | keylen << 8 | outlen);
-	memcpy(state->buf, key, keylen);
-	state->buflen = BLAKE2S_BLOCK_SIZE;
-	state->outlen = outlen;
+	__blake2s_init(state, outlen, key, keylen);
 }
 
+void blake2s_update(struct blake2s_state *state, const u8 *in, size_t inlen);
+void blake2s_final(struct blake2s_state *state, u8 *out);
+
 static inline void blake2s(u8 *out, const u8 *in, const u8 *key,
 			   const size_t outlen, const size_t inlen,
 			   const size_t keylen)
@@ -91,16 +96,9 @@ static inline void blake2s(u8 *out, const u8 *in, const u8 *key,
 		outlen > BLAKE2S_HASH_SIZE || keylen > BLAKE2S_KEY_SIZE ||
 		(!key && keylen)));
 
-	if (keylen)
-		blake2s_init_key(&state, outlen, key, keylen);
-	else
-		blake2s_init(&state, outlen);
-
+	__blake2s_init(&state, outlen, key, keylen);
 	blake2s_update(&state, in, inlen);
 	blake2s_final(&state, out);
 }
 
-void blake2s256_hmac(u8 *out, const u8 *in, const u8 *key, const size_t inlen,
-		     const size_t keylen);
-
-#endif /* BLAKE2S_H */
+#endif /* _CRYPTO_BLAKE2S_H */
diff --git a/include/crypto/internal/blake2s.h b/include/crypto/internal/blake2s.h
index 74ff77032..52363eee2 100644
--- a/include/crypto/internal/blake2s.h
+++ b/include/crypto/internal/blake2s.h
@@ -1,24 +1,129 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
+/*
+ * Helper functions for BLAKE2s implementations.
+ * Keep this in sync with the corresponding BLAKE2b header.
+ */
 
-#ifndef BLAKE2S_INTERNAL_H
-#define BLAKE2S_INTERNAL_H
+#ifndef _CRYPTO_INTERNAL_BLAKE2S_H
+#define _CRYPTO_INTERNAL_BLAKE2S_H
 
 #include <crypto/blake2s.h>
+#include <crypto/internal/hash.h>
+#include <linux/string.h>
+
+void blake2s_compress_generic(struct blake2s_state *state, const u8 *block,
+			      size_t nblocks, const u32 inc);
+
+void blake2s_compress(struct blake2s_state *state, const u8 *block,
+		      size_t nblocks, const u32 inc);
+
+bool blake2s_selftest(void);
+
+static inline void blake2s_set_lastblock(struct blake2s_state *state)
+{
+	state->f[0] = -1;
+}
+
+/* Helper functions for BLAKE2s shared by the library and shash APIs */
+
+static __always_inline void
+__blake2s_update(struct blake2s_state *state, const u8 *in, size_t inlen,
+		 bool force_generic)
+{
+	const size_t fill = BLAKE2S_BLOCK_SIZE - state->buflen;
+
+	if (unlikely(!inlen))
+		return;
+	if (inlen > fill) {
+		memcpy(state->buf + state->buflen, in, fill);
+		if (force_generic)
+			blake2s_compress_generic(state, state->buf, 1,
+						 BLAKE2S_BLOCK_SIZE);
+		else
+			blake2s_compress(state, state->buf, 1,
+					 BLAKE2S_BLOCK_SIZE);
+		state->buflen = 0;
+		in += fill;
+		inlen -= fill;
+	}
+	if (inlen > BLAKE2S_BLOCK_SIZE) {
+		const size_t nblocks = DIV_ROUND_UP(inlen, BLAKE2S_BLOCK_SIZE);
+		/* Hash one less (full) block than strictly possible */
+		if (force_generic)
+			blake2s_compress_generic(state, in, nblocks - 1,
+						 BLAKE2S_BLOCK_SIZE);
+		else
+			blake2s_compress(state, in, nblocks - 1,
+					 BLAKE2S_BLOCK_SIZE);
+		in += BLAKE2S_BLOCK_SIZE * (nblocks - 1);
+		inlen -= BLAKE2S_BLOCK_SIZE * (nblocks - 1);
+	}
+	memcpy(state->buf + state->buflen, in, inlen);
+	state->buflen += inlen;
+}
+
+static __always_inline void
+__blake2s_final(struct blake2s_state *state, u8 *out, bool force_generic)
+{
+	blake2s_set_lastblock(state);
+	memset(state->buf + state->buflen, 0,
+	       BLAKE2S_BLOCK_SIZE - state->buflen); /* Padding */
+	if (force_generic)
+		blake2s_compress_generic(state, state->buf, 1, state->buflen);
+	else
+		blake2s_compress(state, state->buf, 1, state->buflen);
+	cpu_to_le32_array(state->h, ARRAY_SIZE(state->h));
+	memcpy(out, state->h, state->outlen);
+}
+
+/* Helper functions for shash implementations of BLAKE2s */
 
 struct blake2s_tfm_ctx {
 	u8 key[BLAKE2S_KEY_SIZE];
 	unsigned int keylen;
 };
 
-void blake2s_compress_generic(struct blake2s_state *state,const u8 *block,
-			      size_t nblocks, const u32 inc);
+static inline int crypto_blake2s_setkey(struct crypto_shash *tfm,
+					const u8 *key, unsigned int keylen)
+{
+	struct blake2s_tfm_ctx *tctx = crypto_shash_ctx(tfm);
 
-void blake2s_compress_arch(struct blake2s_state *state,const u8 *block,
-			   size_t nblocks, const u32 inc);
+	if (keylen == 0 || keylen > BLAKE2S_KEY_SIZE)
+		return -EINVAL;
 
-static inline void blake2s_set_lastblock(struct blake2s_state *state)
+	memcpy(tctx->key, key, keylen);
+	tctx->keylen = keylen;
+
+	return 0;
+}
+
+static inline int crypto_blake2s_init(struct shash_desc *desc)
 {
-	state->f[0] = -1;
+	const struct blake2s_tfm_ctx *tctx = crypto_shash_ctx(desc->tfm);
+	struct blake2s_state *state = shash_desc_ctx(desc);
+	unsigned int outlen = crypto_shash_digestsize(desc->tfm);
+
+	__blake2s_init(state, outlen, tctx->key, tctx->keylen);
+	return 0;
+}
+
+static inline int crypto_blake2s_update(struct shash_desc *desc,
+					const u8 *in, unsigned int inlen,
+					bool force_generic)
+{
+	struct blake2s_state *state = shash_desc_ctx(desc);
+
+	__blake2s_update(state, in, inlen, force_generic);
+	return 0;
+}
+
+static inline int crypto_blake2s_final(struct shash_desc *desc, u8 *out,
+				       bool force_generic)
+{
+	struct blake2s_state *state = shash_desc_ctx(desc);
+
+	__blake2s_final(state, out, force_generic);
+	return 0;
 }
 
-#endif /* BLAKE2S_INTERNAL_H */
+#endif /* _CRYPTO_INTERNAL_BLAKE2S_H */
diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index ea34ca146..c9d30bc10 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -165,6 +165,11 @@ struct dw_hdmi *dw_hdmi_bind(struct platform_device *pdev,
 
 void dw_hdmi_resume(struct dw_hdmi *hdmi);
 
+#ifdef CONFIG_PM
+int dw_hdmi_runtime_suspend(struct dw_hdmi *hdmi);
+int dw_hdmi_runtime_resume(struct dw_hdmi *hdmi);
+#endif
+
 void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense);
 
 int dw_hdmi_set_plugged_cb(struct dw_hdmi *hdmi, hdmi_codec_plugged_cb fn,
diff --git a/include/dt-bindings/clock/light-dspsys.h b/include/dt-bindings/clock/light-dspsys.h
new file mode 100755
index 000000000..6473e1262
--- /dev/null
+++ b/include/dt-bindings/clock/light-dspsys.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef _LIGHT_DSPSYS_H
+#define _LIGHT_DSPSYS_H
+
+#define CLKGEN_DSP0_PCLK			0
+#define CLKGEN_DSP0_CCLK                        1
+#define CLKGEN_DSP1_PCLK                        2
+#define CLKGEN_DSP1_CCLK                        3
+#define CLKGEN_X2X_X4_DSPSLV_DSP0_ACLK_M        4
+#define CLKGEN_X2X_X4_DSPSLV_DSP1_ACLK_M        5
+#define CLKGEN_AXI4_DSPSYS_SLV_ACLK             6
+#define CLKGEN_AXI4_DSPSYS_ACLK                 7
+#define CLKGEN_IOPMP_DSP0_PCLK                  8
+#define CLKGEN_IOPMP_DSP1_PCLK                  9
+#define CLKGEN_AXI4_DSPSYS_SLV_PCLK             10
+#define CLKGEN_AXI4_DSPSYS_PCLK                 11
+#define CLKGEN_X2X_DSP0_ACLK_S			12
+#define CLKGEN_X2X_DSP2_ACLK_S			13
+#define LIGHT_CLKGEN_DSPSYS_CLK_END		14
+
+#endif
diff --git a/include/dt-bindings/clock/light-fm-ap-clock.h b/include/dt-bindings/clock/light-fm-ap-clock.h
new file mode 100755
index 000000000..8bb23b690
--- /dev/null
+++ b/include/dt-bindings/clock/light-fm-ap-clock.h
@@ -0,0 +1,513 @@
+#ifndef _APSYS_CLKGEN_H
+#define _APSYS_CLKGEN_H
+
+#define C910_CCLK_I0                                       0
+#define AXI4_CPUSYS1_ACLK                                  1
+#define CLKGEN_GPIO2_DBCLK                                 2
+#define CLKGEN_MBOX0_PCLK                                  3
+#define CLKGEN_GMAC0_CCLK                                  4
+#define CLKGEN_SPI_PCLK                                    5
+#define CLKGEN_CLK_OUT_1_CLK                               6
+#define PAD_RTC_CLK                                        7
+#define CLKGEN_SPINLOCK_HCLK                               8
+#define CLKGEN_QSPI1_PCLK                                  9
+#define CLKGEN_HDMI_ISCAN_CK_REF_CLK                       10
+#define CLKGEN_IOPMP_AON_PCLK                              11
+#define CLKGEN_ISP_RY_ACLK                                 12
+#define CLKGEN_MIPIDSI0_SCANRXCLKESC                       13
+#define CLKGEN_EIP120SII_HCLK                              14
+#define CLKGEN_MIPI_CSI0_PIXCLK                            15
+#define CLKGEN_SRAM_AXI_ACLK_3                             16
+#define CLKGEN_PERISYS_AHB_HCLK                            17
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK0_CLK                  18
+#define CLKGEN_QSPI0_SSI_CLK                               19
+#define CLKGEN_DW200_ACLK                                  20
+#define CLKGEN_IOPMP_EIP120SIII_PCLK                       21
+#define VISYS_MIPI_CSI2_CFGCLK                             22
+#define CLKGEN_APB3_CPUSYS_HCLK                            23
+#define CLKGEN_PERISYS_APB1_HCLK                           24
+#define CLKGEN_GPU_CORE_CLK                                25
+#define CLKGEN_USB3_DRD_ACLK                               26
+#define CLKGEN_VISYS_ACLK                                  27
+#define CLKGEN_USB3_DRD_CTRL_REF_CLK                       28
+#define CLKGEN_TEE_DMAC_ACLK                               29
+#define CLKGEN_AUDIO_SUBSYS_ACLK_CP2AP                     30
+#define CLKGEN_SRAM_AXI_ACLK_2                             31
+#define CLKGEN_IOPMP_VOSYS_GPU_PCLK                        32
+#define CLKGEN_CFG2TEE_X2H_ACLK                            33
+#define CLKGEN_SRAM_AXI_ACLK_1                             34
+#define MISC_SDIO0_OSC_CLK                                 35
+#define CLKGEN_SDIO0_ACLK                                  36
+#define CLKGEN_MIPI_DSI1_CFGCLK                            37
+#define APB3_CPUSYS_PCLK                                   38
+#define CLKGEN_TEE_DMAC_HCLK                               39
+#define VOSYS_DPU0_PIXELCLK                                40
+#define CLKGEN_CPU2CFG_X2H_MHCLK                           41
+#define CLKGEN_VPSYS_ACLK                                  42
+#define CLKGEN_MIPIDSI1_SCANRXCLKESC                       43
+#define CLKGEN_MISC2VP_X2X_ACLK_S                          44
+#define CLKGEN_MIPI_CSI_SCANBYTECLK                        45
+#define CLKGEN_APB3_TEESYS_HCLK                            46
+#define VENC_CCLK                                          47
+#define VPSYS_VDEC_CCLK                                    48
+#define CLKGEN_MIPI_CSI0_CFG_CLK                           49
+#define CLKGEN_MISCSYS_BUS_CLK                             50
+#define CLKGEN_DPU_HCLK                                    51
+#define CLKGEN_UART1_SCLK                                  52
+#define GMAC_PLL_FOUTPOSTDIV                               53
+#define MISC_BUS_CLK                                       54
+#define CLKGEN_USB3_DRD_SPDCLK                             55
+#define CLKGEN_MIPI_CSI2_CFG_CLK                           56
+#define CLKGEN_TOP_AXI4S_ACLK                              57
+#define CLKGEN_IOPMP_EIP120SII_ACLK                        58
+#define CORE_CLK                                           59
+#define CLKGEN_VPSYS_FCE_ACLK                              60
+#define CLKGEN_I2C3_PCLK                                   61
+#define DPU1_PLL_DIV_CLK                                   62
+#define CLKGEN_USB3_DRD_PHY_REF_CLK                        63
+#define CLKGEN_AON2CPU_A2X_ACLK                            64
+#define CLKGEN_QSPI1_SSI_CLK                               65
+#define CLKGEN_DPU_CCLK                                    66
+#define VISYS_MASTER_BUS_ACLK                              67
+#define CLKGEN_PERI_I2S_SRC_CLK_0                          68
+#define VOSYS_ACLK_M                                       69
+#define TEESYS_I0_HCLK                                     70
+#define CLKGEN_MIPI_DSI1_REFCLK                            71
+#define CLKGEN_MIPI_DSI0_PCLK                              72
+#define CLKGEN_VOSYS_ACLK_S                                73
+#define CLKGEN_CPU2VP_X2P_PCLK                             74
+#define CLKGEN_X2X_CPUSYS_ACLK_S                           75
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK1_CLK                 76
+#define CLKGEN_IOPMP_VOSYS_DPU1_PCLK                       77
+#define CLKGEN_MISC2VP_X2X_ACLK_M                          78
+#define CLKGEN_WDT0_PCLK                                   79
+#define VOSYS_MIPIDSI0_SCANTXCLKESC                        80
+#define VISYS_MIPI_CSI1_CFGCLK                             81
+#define AHB2_CPUSYS_HCLK                                   82
+#define CLKGEN_SDIO1_HCLK                                  83
+#define CLKGEN_SDIO0_HCLK                                  84
+#define CLKGEN_CLK_OUT_3_CLK                               85
+#define CLKGEN_GMAC_AXI_ACLK                               86
+#define GMAC_CCLK                                          87
+#define CLKGEN_VIPRE_PCLK                                  88
+#define CLKGEN_HDMI_ISCAN_TX_CK_OUT2_CLK                   89
+#define CLKGEN_MIPIDSI1_SCANTXCLKESC                       90
+#define CLKGEN_VISYS_SLAVE_HCLK                            91
+#define VOSYS_HDMI_ISCAN_TX_CK_OUT1_CLK                    92
+#define CLKGEN_X2X_CPUSYS_ACLK_M                           93
+#define CLKGEN_CPU2CFG_X2X_ACLK_S                          94
+#define C910_OSC_CLK                                       95
+#define CLKGEN_X2H_DPU1_ACLK                               96
+#define CLKGEN_I2C4_PCLK                                   97
+#define CLKGEN_GMAC0_ACLK                                  98
+#define MISC_USB3_PHY_REF_CLK                              99
+#define VOSYS_MIPIDSI0_CFG_CLK                             100
+#define CLKGEN_VPSYS_VDEC_CCLK                             101
+#define VOSYS_MIPIDSI1_CFG_CLK                             102
+#define CLKGEN_I2S_PCLK                                    103
+#define CLKGEN_DMAC_CPUSYS_ACLK                            104
+#define VISYS_DW200_CLK_DWE                                105
+#define CLKGEN_OCRAM_HCLK                                  106
+#define CLKGEN_EFUSE_PCLK                                  107
+#define CLKGEN_X2H_DPU_ACLK                                108
+#define CLKGEN_IOPMP_SDIO0_ACLK                            109
+#define VOSYS_DPU1_PIXELCLK                                110
+#define CPU_PLL1_FOUT4                                     111
+#define CLKGEN_GPIO2_PCLK                                  112
+#define CLKGEN_GMAC1_CCLK                                  113
+#define CPU_PLL1_FOUTPOSTDIV                               114
+#define VOSYS_HDMI_ISCAN_40M_CLK                           115
+#define CLKGEN_VOSYS_X2X_ACLK_S                            116
+#define CLKGEN_PERISYS_APB2_HCLK                           117
+#define VOSYS_OSC_CLK_MUX_I2S_CLK_OCCBUF                   118
+#define CLKGEN_HDMI_CEC_CLK                                119
+#define CLKGEN_X2P_X4_VOSYS_PCLK                           120
+#define CLKGEN_VOSYS_ACLK_M                                121
+#define CLKGEN_EMMC_SDIO_REF_CLK                           122
+#define CLKGEN_IOPMP_EMMC_ACLK                             123
+#define VIDEO_PLL_FOUTVCO                                  124
+#define CLKGEN_HDMI_ISCAN_CKO_WORD_CLK                     125
+#define CLKGEN_IOPMP_VOSYS_DPU_PCLK                        126
+#define CLKGEN_AXI4_VISYS3_ACLK                            127
+#define CLKGEN_VISYS_SYSREG_PCLK                           128
+#define CLKGEN_MIPIDSI0_SCANTXCLKESC                       129
+#define CLKGEN_HDMI_ISCAN_TX_CK_OUT1_CLK                   130
+#define CLKGEN_IOPMP_EIP120SIII_ACLK                       131
+#define CLKGEN_EIP120SII_ACLK                              132
+#define CLKGEN_MBOX2_PCLK                                  133
+#define CLKGEN_AXI4_VISYS1_ACLK                            134
+#define CLKGEN_UART1_PCLK                                  135
+#define CLK_OUT_3                                          136
+#define CLKGEN_UART5_SCLK                                  137
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK2_CLK                 138
+#define CLKGEN_MBOX3_PCLK                                  139
+#define QSPI1_SSI_CLK                                      140
+#define CLKGEN_I2C1_PCLK                                   141
+#define CLKGEN_HDMI_I2S_CLK                                142
+#define CLKGEN_AXI4_CPUSYS2_PCLK                           143
+#define CLKGEN_CFG2TEE_X2H_MHCLK                           144
+#define CLKGEN_C910_CPU_CLK                                145
+#define VOSYS_HDMI_ISCAN_TX_CK_OUT2_CLK                    146
+#define CLKGEN_HDMI_PCLK                                   147
+#define CLKGEN_IOPMP_EIP120SII_PCLK                        148
+#define CLKGEN_MISCSYS_AXI_PCLK                            149
+#define CLKGEN_EIP120SI_ACLK                               150
+#define TEESYS_I1_HCLK                                     151
+#define PERISYS_APB_PCLK                                   152
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK0_DIV2_CLK             153
+#define CLKGEN_TIMER0_CCLK                                 154
+#define CLKGEN_IOPMP_USB3_ACLK                             155
+#define CLKGEN_UART2_PCLK                                  156
+#define CLK_OUT_4                                          157
+#define AXI4_CPUSYS2_ACLK                                  158
+#define CLKGEN_AUDIO_SUBSYS_ACLK_AP2CP                     159
+#define CLKGEN_I2C3_IC_CLK                                 160
+#define CLKGEN_IOPMP_GPU_ACLK                              161
+#define CLKGEN_TIMER1_CCLK                                 162
+#define VOSYS_I2S_CLK                                      163
+#define CLKGEN_I2C5_IC_CLK                                 164
+#define VOSYS_OSC_CLK_MUX_I2S_CLK                          165
+#define CLKGEN_DDR_SUBSYS_ACLK_0                           166
+#define CLKGEN_TIMER1_PCLK                                 167
+#define CLKGEN_I2C1_IC_CLK                                 168
+#define CLKGEN_I2S_SRC_CLK                                 169
+#define VISYS_DW200_CLK_VSE                                170
+#define CLKGEN_MIPIDSI1_PIXCLK                             171
+#define VOSYS_RTC_CLK                                      172
+#define CLK_OUT_1                                          173
+#define CLKGEN_PERISYS_APB4_HCLK                           174
+#define MISC_USB3_CTRL_REF_CLK                             175
+#define CLKGEN_TEE_SYSREG_PCLK                             176
+#define CLKGEN_MISCSYS_AXI_ACLK                            177
+#define CLKGEN_MIPIDSI1_SCANCLK                            178
+#define CLKGEN_GPIO3_DBCLK                                 179
+#define CLKGEN_HDMI_ISCAN_40M_CLK                          180
+#define CLKGEN_PERI2PERI1_APB_HCLK                         181
+#define CLKGEN_GMAC0_HCLK                                  182
+#define CLKGEN_DDR_SUBSYS_PCLK                             183
+#define VOSYS_PCLK                                         184
+#define CLKGEN_MIPIDSI1_SCANBYTECLK                        185
+#define CLKGEN_VPSYS_G2D_ACLK                              186
+#define CLKGEN_EIP150B_HCLK                                187
+#define CLKGEN_UART4_SCLK                                  188
+#define DPU1_PLL_TEST_CLK                                  189
+#define CLKGEN_VOSYS_X2X_ACLK_M                            190
+#define CLKGEN_IOPMP_EIP120SI_ACLK                         191
+#define CLKGEN_CLK_OUT_4_CLK                               192
+#define CLKGEN_GPIO0_FPCLK                                 193
+#define PAD_OSC_CLK                                        194
+#define CLKGEN_C910_BUS_CLK_NO_ICG                         195
+#define CLKGEN_TIMER0_PCLK                                 196
+#define CLKGEN_AHB2_CPUSYS_HCLK                            197
+#define EMMC_SDIO_REF_CLK                                  198
+#define CLKGEN_IOPMP_CHIP_DBG_PCLK                         199
+#define CLKGEN_BMU_C910_PCLK                               200
+#define CLKGEN_IOPMP_DPU1_ACLK                             201
+#define CLKGEN_PADCTRL0_APSYS_PCLK                         202
+#define MISC_SDIO1_OSC_CLK                                 203
+#define CLKGEN_C910_OSC_CLK                                204
+#define VISYS_ISP_RY_CCLK                                  205
+#define CLKGEN_VPSYS_PCLK                                  206
+#define VISYS_MIPI_CSI0_PIXELCLK                           207
+#define NPU_CCLK                                           208
+#define CLKGEN_AXI4_TEESYS_ACLK                            209
+#define PERI2SYS_APB_PCLK                                  210
+#define CLKGEN_IOPMP_GMAC0_PCLK                            211
+#define CLKGEN_VPSYS_G2D_PCLK                              212
+#define CLKGEN_EMMC_ACLK                                   213
+#define CLKGEN_UART3_SCLK                                  214
+#define AONSYS_BUS_CLK                                     215
+#define DPU0_PLL_FOUT4                                     216
+#define VOSYS_MIPIDSI1_SCANCLK                             217
+#define CLKGEN_UART4_PCLK                                  218
+#define CLKGEN_HDMI_ISCAN_SCL                              219
+#define CLKGEN_MIPI_CSI1_PIXCLK                            220
+#define CLKGEN_APSYS_CLKGEN_PCLK                           221
+#define CLKGEN_GPU_TIMER_REFCLK                            222
+#define GMAC_PLL_FOUT1PH0                                  223
+#define VOSYS_MIPIDSI1_SCANBYTECLK                         224
+#define CLKGEN_GPIO3_FPCLK                                 225
+#define CLKGEN_SDIO1_OSC_CLK                               226
+#define CLKGEN_GPIO3_PCLK                                  227
+#define CLKGEN_VPSYS_AXI_ACLK                              228
+#define CLKGEN_HDMI_ISCAN_TX_CK_20B_CLK                    229
+#define CLKGEN_VOSYSREG_PCLK                               230
+#define VIDEO_PLL_TEST_CLK                                 231
+#define CLKGEN_MBOX1_PCLK                                  232
+#define CLKGEN_I2C2_IC_CLK                                 233
+#define VOSYS_MIPIDSI0_PLL_SCANCLK                         234
+#define VOSYS_MIPIDSI1_SCANTXCLKESC                        235
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK1_DIV2_CLK             236
+#define CLKGEN_UART2_SCLK                                  237
+#define MISC_TEESYS_PCLK                                   238
+#define AUDIO_PLL_TEST_CLK                                 239
+#define CLKGEN_DPU_PIXELCLK1                               240
+#define CLKGEN_IOPMP_TEEDMAC_PCLK                          241
+#define CLKGEN_TOP_APB_SX_PCLK                             242
+#define CLKGEN_I2C4_IC_CLK                                 243
+#define GMAC_PLL_TEST_CLK                                  244
+#define CLKGEN_HDMI_JTAG_TCLK                              245
+#define VISYS_MIPI_CSI0_CFGCLK                             246
+#define CLKGEN_CPU2AON_X2H_ACLK                            247
+#define VOSYS_HDMI_ISCAN_TX_CK_OUT0_CLK                    248
+#define QSPI_SSI_CLK                                       249
+#define VOSYS_DPU_CCLK                                     250
+#define CLKGEN_CPU2VI_X2H_MHCLK                            251
+#define CLKGEN_MIPI_DSI0_REFCLK                            252
+#define CLKGEN_DSPSYS_HCLK                                 253
+#define CLKGEN_IOPMP_AUD_PCLK                              254
+#define CLKGEN_PERI2PERI1_APB_PCLK                         255
+#define CFG_AXI_ACLK                                       256
+#define VPSYS_FCE_CCLK                                     257
+#define CLKGEN_HDMI_ISCAN_CLK                              258
+#define CPU_PLL0_TEST_CLK                                  259
+#define CLKGEN_CPU2PERI_X2H_MHCLK                          260
+#define VISYS_ACLK_M                                       261
+#define VOSYS_HDMI_JTAG_TCLK                               262
+#define CLKGEN_IOPMP_AUD_ACLK                              263
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK1_DIV2_CLK            264
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK1_CLK                  265
+#define VOSYS_MIPIDSI0_REFCLK                              266
+#define CLKGEN_VISYS_ACLK_M                                267
+#define VOSYS_MIPIDSI0_SCANRXCLKESC                        268
+#define CLKGEN_SDIO1_ACLK                                  269
+#define CFG_APB_PCLK                                       270
+#define CLKGEN_PADCTRL1_APSYS_PCLK                         271
+#define VOSYS_MIPIDSI0_SCANCLK                             272
+#define CLKGEN_I2C0_IC_CLK                                 273
+#define CLKGEN_VPSYS_APB_PCLK                              274
+#define CLKGEN_VPSYS_VENC_CCLK                             275
+#define CLKGEN_AXI4_CFG_BUS_ACLK                           276
+#define CLKGEN_MIPIDSI0_SCANBYTECLK                        277
+#define GPIO3_DBCLK                                        278
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK0_CLK                 279
+#define CLKGEN_UART5_PCLK                                  280
+#define DPU0_PLL_FOUTPOSTDIV_ICG                           281
+#define CPU_PLL0_FOUT4                                     282
+#define CLKGEN_GPIO2_FPCLK                                 283
+#define CLKGEN_DPU_ACLK                                    284
+#define CLKGEN_AXI4_CPUSYS2_ACLK                           285
+#define CLKGEN_DSPSYS_PCLK                                 286
+#define TEE_PLL_FOUTPOSTDIV                                287
+#define TIMER_CCLK                                         288
+#define VOSYS_MIPIDSI1_PLL_SCANCLK                         289
+#define CLKGEN_GMAC_AXI_PCLK                               290
+#define CLKGEN_USB3_DRD_PCLK                               291
+#define CLKGEN_AXI4_CPUSYS1_PCLK                           292
+#define VOSYS_ACLK                                         293
+#define CLKGEN_IOPMP_EIP120SI_PCLK                         294
+#define VOSYS_HDMI_ISCAN_TMDSCLKIN_CLK                     295
+#define VOSYS_HDMI_ISCAN_CKO_WORD_CLK                      296
+#define CLKGEN_NPUSYS_AXI_ACLK                             297
+#define CLKGEN_IOPMP_SDIO0_PCLK                            298
+#define CLKGEN_DW200_HCLK                                  299
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK2_CLK                  300
+#define CLKGEN_UART0_PCLK                                  301
+#define CLKGEN_CLK_OUT_2_CLK                               302
+#define CLKGEN_GPIO0_PCLK                                  303
+#define CLKGEN_EMMC_OSC_CLK                                304
+#define VPSYS_APB_PCLK                                     305
+#define CLKGEN_HDMI_PIXCLK                                 306
+#define CLKGEN_IOPMP_TEEDMAC_ACLK                          307
+#define AUDIO_PLL_FOUT4                                    308
+#define CLKGEN_MIPI_CSI2_PCLK                              309
+#define CLKGEN_MIPI_DSI1_PCLK                              310
+#define CLKGEN_MIPI_DSI0_CFGCLK                            311
+#define VISYS_ISP0_CLK                                     312
+#define VISYS_ISP1_CLK                                     313
+#define MISC_EMMC_OSC_CLK                                  314
+#define DPU0_PLL_FOUTPOSTDIV                               315
+#define VISYS_AHB_HCLK                                     316
+#define CLKGEN_IOPMP_SDIO1_ACLK                            317
+#define CLKGEN_EMMC_HCLK                                   318
+#define I2S_CLK                                            319
+#define CLKGEN_CPU2PERI_X2H_ACLK                           320
+#define VPSYS_AXI_ACLK                                     321
+#define CLKGEN_IOPMP_SDIO1_PCLK                            322
+#define CLKGEN_EIP120SIII_HCLK                             323
+#define CLKGEN_BMU_C910_ACLK                               324
+#define CLKGEN_IOPMP_DMAC_CPUSYS_PCLK                      325
+#define GPIO2_DBCLK                                        326
+#define CHIP_DBG_CCLK                                      327
+#define CLKGEN_MISCSYS_TEE_CCLK                            328
+#define CLKGEN_I2C5_PCLK                                   329
+#define CLKGEN_X2H_CPUSYS_MHCLK                            330
+#define CLKGEN_PWM_CCLK                                    331
+#define DPU0_PLL_TEST_CLK                                  332
+#define CLKGEN_VISYS_PCLK                                  333
+#define MISC_TEESYS_HCLK                                   334
+#define SPI_SSI_CLK                                        335
+#define CLKGEN_PWM_PCLK                                    336
+#define VOSYS_MIPIDSI1_SCANRXCLKESC                        337
+#define QSPI0_SSI_CLK                                      338
+#define CLKGEN_HDMI_ISCAN_TMDSCLKIN_CLK                    339
+#define CLKGEN_SPI_SSI_CLK                                 340
+#define VIDEO_PLL_FOUT4                                    341
+#define CLKGEN_IOPMP_GMAC0_ACLK                            342
+#define CLKGEN_VIPRE_ACLK                                  343
+#define MISC_OSC_CLK_DIV24                                 344
+#define CLKGEN_ISP_VENC_SHAKE_PCLK                         345
+#define CLKGEN_HDMI_ISCAN_TX_CK_OUT0_CLK                   346
+#define CLKGEN_VPSYS_G2D_CCLK                              347
+#define CLKGEN_CPU2CFG_X2X_ACLK_M                          348
+#define CLKGEN_GMAC1_PCLK                                  349
+#define CLKGEN_MIPIDSI0_PLL_SCANCLK                        350
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK0_DIV2_CLK            351
+#define TEE_PLL_FOUT4                                      352
+#define PERISYS_AHB_HCLK                                   353
+#define VIDEO_PLL_FOUT1PH0                                 354
+#define CLKGEN_MIPIDSI0_PIXCLK                             355
+#define CLKGEN_PERI_I2S_SRC_CLK_1                          356
+#define CLKGEN_MIPI_CSI0_PCLK                              357
+#define CLKGEN_DDR_SUBSYS_ACLK_1                           358
+#define CLKGEN_GMAC0_PCLK                                  359
+#define CLK_OUT_2                                          360
+#define CLKGEN_EIP120SIII_ACLK                             361
+#define AONSYS_HCLK                                        362
+#define CLKGEN_ISP0_CLK                                    363
+#define CLKGEN_C910_BROM_HCLK                              364
+#define DPU1_PLL_FOUT4                                     365
+#define PERI_I2S_SRC_CLK                                   366
+#define CPU_PLL1_TEST_CLK                                  367
+#define CLKGEN_DDR_SUBSYS_ACLK_2                           368
+#define CLKGEN_MIPIDSI0_SCANCLK                            369
+#define I2C_IC_CLK                                         370
+#define CLKGEN_DPU_PIXELCLK0                               371
+#define CLKGEN_GPIO1_DBCLK                                 372
+#define CLKGEN_C910_TOP_DS_PCLK                            373
+#define CLKGEN_DSPSYS_ACLK_M                               374
+#define CLKGEN_AON2CPU_A2X_HCLK                            375
+#define VOSYS_HDMI_ISCAN_CK_REF_CLK                        376
+#define CLKGEN_IOPMP_EMMC_PCLK                             377
+#define NPU_CORE_CLK                                       378
+#define CLKGEN_IOPMP_USB3_PCLK                             379
+#define VPSYS_PCLK                                         380
+#define VIDEO_PLL_FOUTPOSTDIV                              381
+#define CLKGEN_CPU2VP_X2P_ACLK                             382
+#define CLKGEN_APB_CPU2CFG_HCLK                            383
+#define VOSYS_OSC_CLK_MUX_CEC_CLK_OCCBUF                   384
+#define CLKGEN_GPIO1_PCLK                                  385
+#define CLKGEN_APSYS_SYSREG_PCLK                           386
+#define CLKGEN_VISYS_HCLK                                  387
+#define CLKGEN_MIPI_CSI1_PCLK                              388
+#define CLKGEN_AHB2_TEESYS_HCLK                            389
+#define CLKGEN_DDR_SUBSYS_ACLK_4                           390
+#define SYS_PLL_TEST_CLK                                   391
+#define VISYS_MIPI_CSI_SCANCLK                             392
+#define CPU_PLL0_FOUTPOSTDIV                               393
+#define CLKGEN_UART3_PCLK                                  394
+#define CLKGEN_X2H_CPUSYS_ACLK                             395
+#define CLKGEN_MIPI_CSI1_CFG_CLK                           396
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK2_DIV2_CLK            397
+#define CLKGEN_MISCSYS_APB_HCLK                            398
+#define CLKGEN_CPU2CFG_X2H_ACLK                            399
+#define CLKGEN_MIPI_CSI2_FPCLK                             400
+#define CLKGEN_ISP_RY_CCLK                                 401
+#define CLKGEN_X2P_VOSYS_ACLK                              402
+#define CLKGEN_VIPRE_PIXELCLK                              403
+#define VOSYS_GPU_TIMER_REFCLK                             404
+#define VOSYS_OSC_CLK_MUX_CEC_CLK                          405
+#define CLKGEN_APSYS_RSTGEN_PCLK                           406
+#define VOSYS_HDMI_ISCAN_SCL                               407
+#define CLKGEN_ISP_RY_HCLK                                 408
+#define VOSYS_OSC_CLK                                      409
+#define VISYS_PCLK                                         410
+#define CLKGEN_AXI4_VO_ACLK                                411
+#define CLKGEN_MIPIDSI1_PLL_SCANCLK                        412
+#define GPIO1_DBCLK                                        413
+#define CLKGEN_AXI4_VISYS2_ACLK                            414
+#define CLKGEN_EIP120SI_HCLK                               415
+#define CLKGEN_IOPMP_CHIP_DBG_ACLK                         416
+#define VOSYS_HDMI_ISCAN_TX_CK_20B_CLK                     417
+#define VOSYS_MIPIDSI1_REFCLK                              418
+#define CLKGEN_CHIP_DBG_ACLK                               419
+#define VOSYS_CFG_ACLK                                     420
+#define CLKGEN_VOSYS_AXI_ACLK                              421
+#define CPU_BUS_DFTCLK                                     422
+#define VOSYS_HDMI_ISCAN_CLK                               423
+#define VISYS_SLAVE_BUS_HCLK                               424
+#define CLKGEN_VPSYS_VDEC_PCLK                             425
+#define GMAC_PLL_FOUT4                                     426
+#define CLKGEN_QSPI0_PCLK                                  427
+#define CLKGEN_ISP1_CLK                                    428
+#define CLKGEN_MIPI_CSI0_FPCLK                             429
+#define CLKGEN_ISP0_ACLK                                   430
+#define CLKGEN_CPU2VI_X2H_ACLK                             431
+#define C910_CCLK                                          432
+#define CLKGEN_DW200_CLK_VSE                               433
+#define CLKGEN_AXI4_CPUSYS1_ACLK                           434
+#define CLKGEN_GPU_CFG_ACLK                                435
+#define CLKGEN_GPIO1_FPCLK                                 436
+#define CLKGEN_SRAM_AXI_ACLK_0                             437
+#define CLKGEN_I2C2_PCLK                                   438
+#define CLKGEN_IOPMP_GMAC1_PCLK                            439
+#define CLKGEN_ISP0_S_HCLK                                 440
+#define GPIO0_DBCLK                                        441
+#define CLKGEN_AXI4_VO_CFG_ACLK                            442
+#define CLKGEN_NPU_CORE_CLK                                443
+#define DPU0_PLL_DIV_CLK                                   444
+#define VOSYS_MIPIDSI0_SCANBYTECLK                         445
+#define CLKGEN_CHIP_DBG_CCLK                               446
+#define CLKGEN_DMAC_CPUSYS_HCLK                            447
+#define CLKGEN_IOPMP_DPU_ACLK                              448
+#define CLKGEN_DDR_SUBSYS_ACLK_3                           449
+#define CLK_100M                                           450
+#define CLKGEN_DSMART_PCLK                                 451
+#define CLKGEN_DW200_CLK_DWE                               452
+#define VPSYS_G2D_CCLK                                     453
+#define CLKGEN_WDT1_PCLK                                   454
+#define DPU1_PLL_FOUTPOSTDIV                               455
+#define CLKGEN_IOPMP_GMAC1_ACLK                            456
+#define CLKGEN_VPSYS_FCE_PCLK                              457
+#define CLKGEN_MIPI_CSI_SCANCLK                            458
+#define CLKGEN_MIPI_CSI2_PIXCLK                            459
+#define CLKGEN_I2C0_PCLK                                   460
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK2_DIV2_CLK             461
+#define CLKGEN_HDMI_SFR_CLK                                462
+#define TEE_PLL_TEST_CLK                                   463
+#define CLKGEN_IOPMP_DMAC_CPUSYS_ACLK                      464
+#define CLKGEN_ISP_PIXELCLK                                465
+#define CLKGEN_MIPI_CSI1_FPCLK                             466
+#define SYS_PLL_FOUT4                                      467
+#define CLKGEN_AXI4_VO_PCLK                                468
+#define CLKGEN_UART0_SCLK                                  469
+#define CLKGEN_CPU2AON_X2H_MHCLK                           470
+#define VISYS_MIPI_CSI_SCANBYTECLK                         471
+#define UART_SCLK                                          472
+#define CLKGEN_IOPMP_AON_ACLK                              473
+#define CLKGEN_VPSYS_VDEC_ACLK                             474
+#define CLKGEN_GMAC1_HCLK                                  475
+#define CLKGEN_ISP_VENC_SHAKE_ACLK                         476
+#define TEESYS_HCLK                                        477
+#define PWM_CCLK                                           478
+#define CLKGEN_GPIO0_DBCLK                                 479
+#define CLKGEN_SDIO0_OSC_CLK                               480
+#define CLKGEN_GMAC1_ACLK                                  481
+#define VPSYS_ACLK                                         482
+
+#define AHB2_CPUSYS_HCLK_OUT_DIV			   483
+#define APB3_CPUSYS_PCLK_DIV				   484
+#define CFG_AXI_ACLK_OUT_DIV				   485
+#define PERISYS_AHB_HCLK_OUT_DIV			   486
+#define CLK_OUT_1_OUT_DIV				   487
+#define CLK_OUT_2_OUT_DIV                                  488
+#define CLK_OUT_3_OUT_DIV                                  489
+#define CLK_OUT_4_OUT_DIV                                  490
+#define NPU_CCLK_OUT_DIV				   491
+#define CFG_APB_PCLK_OUT_DIV				   492
+#define CPU_PLL0_BYPASS					   493
+#define CPU_PLL1_BYPASS					   494
+#define GMAC_PLL_BYPASS					   495
+#define VIDEO_PLL_BYPASS				   496
+#define TEE_PLL_BYPASS					   497
+#define DPU0_PLL_BYPASS					   498
+#define DPU1_PLL_BYPASS					   499
+
+#define CLK_DUMMY					   500
+#define OSC_32K						   501
+#define OSC_24M						   502
+#define RC_24M						   503
+
+#define CLK_END						   504
+
+#endif
diff --git a/include/dt-bindings/clock/light-mpw-clock.h b/include/dt-bindings/clock/light-mpw-clock.h
new file mode 100755
index 000000000..46c2a052a
--- /dev/null
+++ b/include/dt-bindings/clock/light-mpw-clock.h
@@ -0,0 +1,222 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+#ifndef __DT_BINDINGS_CLOCK_LIGHT_H
+#define __DT_BINDINGS_CLOCK_LIGHT_H
+
+#define LIGHT_CLK_DUMMY				0
+#define LIGHT_CLK_32K				1
+#define LIGHT_CLK_24M				2
+#define LIGHT_RC_24M				3
+
+#define LIGHT_VIDEO_PLL_FOUTVCO			4
+#define LIGHT_VIDEO_PLL_FOUTPOSTDIV		5
+#define LIGHT_VIDEO_PLL_FOUT4			6
+#define LIGHT_VIDEO_PLL_BYPASS			7
+
+#define LIGHT_GMAC_PLL_FOUTVCO			8
+#define LIGHT_GMAC_PLL_FOUTPOSTDIV		9
+#define LIGHT_GMAC_PLL_FOUT1PH0			10
+#define LIGHT_GMAC_PLL_FOUT4			11
+#define LIGHT_GMAC_PLL_BYPASS			12
+
+#define LIGHT_AUDIO_PLL_FOUTVCO			13
+#define LIGHT_AUDIO_PLL_FOUTPOSTDIV		14
+#define LIGHT_AUDIO_PLL_FOUT3			15
+#define LIGHT_AUDIO_PLL_BYPASS			16
+
+#define LIGHT_SYS_PLL_FOUTVCO			17
+#define LIGHT_SYS_PLL_FOUTPOSTDIV		18
+#define LIGHT_SYS_PLL_FOUT4			19
+#define LIGHT_SYS_PLL_BYPASS			20
+
+#define LIGHT_CPU_PLL0_FOUTVCO			21
+#define LIGHT_CPU_PLL0_FOUTPOSTDIV		22
+#define LIGHT_CPU_PLL0_FOUT4			23
+#define LIGHT_CPU_PLL0_BYPASS			24
+
+#define LIGHT_CPU_PLL1_FOUTVCO			25
+#define LIGHT_CPU_PLL1_FOUTPOSTDIV		26
+#define LIGHT_CPU_PLL1_FOUT4			27
+#define LIGHT_CPU_PLL1_BYPASS			28
+
+#define LIGHT_DDR_PLL_FOUTVCO			29
+#define LIGHT_DDR_PLL_FOUTPOSTDIV		30
+#define LIGHT_DDR_PLL_FOUT4			31
+#define LIGHT_DDR_PLL_BYPASS			32
+
+#define LIGHT_AONSYS_CLK_SWITCH_0		33
+#define LIGHT_AONSYS_CLK_SWITCH_1		34
+#define LIGHT_AONSYS_CLK			35
+#define LIGHT_SHARE_SRAM_CLK			36
+#define LIGHT_CLKGEN_RTC_PCLK			37
+#define LIGHT_CLKGEN_AOGPIO_PCLK		38
+#define LIGHT_CLKGEN_AOI2C_PCLK			39
+#define LIGHT_CLKGEN_PVTC_PCLK			40
+#define LIGHT_CLKGEN_AOAHB_HCLK			41
+#define LIGHT_CLKGEN_AOSRAM_HCLK		42
+#define LIGHT_CLKGEN_AOAPB_HCLK			43
+#define LIGHT_CLKGEN_AOPAD_PCLK			44
+#define LIGHT_CLKGEN_AOTIMER_PCLK		45
+#define LIGHT_CLKGEN_AOTIMER_CCLK		46
+#define LIGHT_CLKGEN_SRAM_AXI_ACLK		47
+#define LIGHT_CLKGEN_CPU2RAM_X2X_ACLK_S		48
+#define LIGHT_CLKGEN_AOGPIO_DBCLK		49
+
+#define LIGHT_GMAC_CORECLK			50
+#define LIGHT_OSC_CLK_DIV24			51
+#define LIGHT_GMAC_PLL_FOUTVCO_DIV5		52
+#define LIGHT_C910_CCLK_I0			53
+#define LIGHT_C910_CCLK				54
+#define LIGHT_CPUSYS_AHB_HCLK			55
+#define LIGHT_CPUSYS_CFG_AXI_ACLK		56
+#define LIGHT_PERISYS_AHB_HCLK			57
+#define LIGHT_CLK_OUT_1				58
+#define LIGHT_CLK_OUT_2				59
+#define LIGHT_CLK_OUT_3				60
+#define LIGHT_CLK_OUT_4				61
+#define LIGHT_CPUSYS_AHB_HCLK_DIV		62
+#define LIGHT_APB3_CPUSYS_PCLK			63
+#define LIGHT_CPUSYS_SUB_AXI_ACLK		64
+#define LIGHT_CPUSYS_CFG_AXI_ACLK_DIV		65
+#define LIGHT_TEESYS_HCLK			66
+#define LIGHT_DMAC_1_CLK			67
+#define LIGHT_DMAC_2_CLK			68
+#define LIGHT_DMAC_3_CLK			69
+#define LIGHT_AXI_PORT4_CLK			70
+#define LIGHT_PERISYS_AHB_HCLK_DIV		71
+#define LIGHT_PERISYS_APB_PCLK			72
+#define LIGHT_CLK_OUT_1_DIV			73
+#define LIGHT_CLK_OUT_2_DIV			74
+#define LIGHT_CLK_OUT_3_DIV			75
+#define LIGHT_CLK_OUT_4_DIV			76
+#define LIGHT_CLKGEN_PERISYS_AXI_ACLK		77
+#define LIGHT_CLKGEN_PERISYS_AHB_HCLK		78
+#define LIGHT_CLKGEN_PERISYS_APB1_HCLK		79
+#define LIGHT_CLKGEN_PERISYS_APB2_HCLK		80
+#define LIGHT_CLKGEN_USB3_DRD_PHY_REF_CLK	81
+#define LIGHT_CLKGEN_USB3_DRD_CTRL_REF_CLK	82
+#define LIGHT_CLKGEN_USB3_DRD_SPDCLK		83
+#define LIGHT_CLKGEN_USB3_DRD_ACLK		84
+#define LIGHT_CLKGEN_EMMC1_X2X_ACLK		85
+#define LIGHT_CLKGEN_EMMC0_X2X_ACLK		86
+#define LIGHT_CLKGEN_EMMC0_HCLK			87
+#define LIGHT_CLKGEN_EMMC1_HCLK			88
+#define LIGHT_CLKGEN_GMAC_ACLK			89
+#define LIGHT_CLKGEN_PWM_PCLK			90
+#define LIGHT_CLKGEN_QSPI0_PCLK			91
+#define LIGHT_CLKGEN_QSPI1_PCLK			92
+#define LIGHT_CLKGEN_SPI_PCLK			93
+#define LIGHT_CLKGEN_UART0_PCLK			94
+#define LIGHT_CLKGEN_UART1_PCLK			95
+#define LIGHT_CLKGEN_UART2_PCLK			96
+#define LIGHT_CLKGEN_UART3_PCLK			97
+#define LIGHT_CLKGEN_UART4_PCLK			98
+#define LIGHT_CLKGEN_UART5_PCLK			99
+#define LIGHT_CLKGEN_GPIO0_PCLK			100
+#define LIGHT_CLKGEN_GPIO1_PCLK			101
+#define LIGHT_CLKGEN_GPIO2_PCLK			102
+#define LIGHT_CLKGEN_I2C0_IC_CLK		103
+#define LIGHT_CLKGEN_I2C1_IC_CLK		104
+#define LIGHT_CLKGEN_I2C2_IC_CLK		105
+#define LIGHT_CLKGEN_I2C3_IC_CLK		106
+#define LIGHT_CLKGEN_I2C4_IC_CLK		107
+#define LIGHT_CLKGEN_I2C5_IC_CLK		108
+#define LIGHT_CLKGEN_PERI2DDR_X2X_ACLK_M	109
+#define LIGHT_CLKGEN_AXI_DUMMY_SLV_4_ACLK	110
+#define LIGHT_CLKGEN_AXI_DUMMY_SLV_3_ACLK	111
+#define LIGHT_CLKGEN_AXI_DUMMY_SLV_2_ACLK	112
+#define LIGHT_CLKGEN_AXI_DUMMY_SLV_1_ACLK	113
+#define LIGHT_CLKGEN_APB_CPU2FG_HCLK		114
+#define LIGHT_CLKGEN_AON2CPU_A2X_ACLK		115
+#define LIGHT_CLKGEN_CPU2CFG_X2X_ACLK_M		116
+#define LIGHT_CLKGEN_CPU2RAM_X2X_ACLK_M		117
+#define LIGHT_CLKGEN_AXI4_CPUSYS2_ACLK		118
+#define LIGHT_CLKGEN_X2X_CPUSYS_ACLK_M		119
+#define LIGHT_CLKGEN_CHIP_DBG_ACLK		120
+#define LIGHT_CLKGEN_AXI4_CFG_BUS_ACLK		121
+#define LIGHT_CLKGEN_X2H_CPUSYS_ACLK		122
+#define LIGHT_CLKGEN_CPU2TEE_X2H_ACLK		123
+#define LIGHT_CLKGEN_CPU2AON_X2H_ACLK		124
+#define LIGHT_CLKGEN_CPU2CFG_X2H_ACLK		125
+#define LIGHT_CLKGEN_CPU2PERI_X2H_MHCLK		126
+#define LIGHT_CLKGEN_AHB2_CPUSYS_HCLK		127
+#define LIGHT_CLKGEN_APB3_CPUSYS_HCLK		128
+#define LIGHT_CLKGEN_C910_BROM_HCLK		129
+#define LIGHT_CLKGEN_DMAC_ACLK			130
+#define LIGHT_CLKGEN_MBOX0_PCLK			131
+#define LIGHT_CLKGEN_MBOX1_PCLK			132
+#define LIGHT_CLKGEN_MBOX2_PCLK			133
+#define LIGHT_CLKGEN_MBOX3_PCLK			134
+#define LIGHT_CLKGEN_WDT0_PCLK			135
+#define LIGHT_CLKGEN_WDT1_PCLK			136
+#define LIGHT_CLKGEN_TIMER0_CCLK		137
+#define LIGHT_CLKGEN_TIMER1_CCLK		138
+#define LIGHT_CLKGEN_TRNG_RB_HCLK		139
+#define LIGHT_CLKGEN_ADC_PCLK			140
+#define LIGHT_CLKGEN_AXI_ACLK_4			141
+#define LIGHT_CLKGEN_AXI_ACLK_3			142
+#define LIGHT_CLKGEN_AXI_ACLK_2			143
+#define LIGHT_CLKGEN_AXI_ACLK_1			145
+#define LIGHT_CLKGEN_AXI_ACLK_0			146
+#define LIGHT_CLKGEN_DMAC_1_ACLK		147
+#define LIGHT_CLKGEN_DMAC_2_ACLK		148
+#define LIGHT_CLKGEN_DMAC_3_ACLK		149
+#define LIGHT_CLKGEN_SRAM_AXI_PCLK		150
+#define LIGHT_CLKGEN_AHB2_TEESYS_HCLK		151
+#define LIGHT_CLKGEN_EFUSE_MPW_PCLK		152
+#define LIGHT_CLKGEN_CLK_OUT_4_CLK		153
+#define LIGHT_CLKGEN_CLK_OUT_3_CLK		154
+#define LIGHT_CLKGEN_CLK_OUT_2_CLK		155
+#define LIGHT_CLKGEN_CLK_OUT_1_CLK		156
+#define LIGHT_CLKGEN_DDR_APB_PCLK		157
+#define LIGHT_CLKGEN_PADCTRL_APSYS_PCLK		158
+#define LIGHT_CLKGEN_CHIP_DBG_CCLK		159
+#define LIGHT_CHIP_DBG_CCLK			160
+#define LIGHT_AXI_ACLK				161
+
+#define LIGHT_CLKGEN_CPU2CFG_X2X_ACLK_S		162
+#define LIGHT_CLKGEN_CPU2CFG_X2H_ACLK_S		163
+#define LIGHT_CLKGEN_AON2CPU_A2X_HCLK		164
+#define LIGHT_CLKGEN_DMAC_HCLK			165
+#define LIGHT_CLKGEN_X2H_CPUSYS_MHCLK		166
+#define LIGHT_CLKGEN_CPU2TEE_X2H_MHCLK		167
+#define LIGHT_CLKGEN_CPU2AON_X2H_MHCLK		168
+#define LIGHT_AXI_HCLK				169
+#define LIGHT_CLKGEN_CPU2CFG_X2H_MHCLK		170
+#define LIGHT_CLKGEN_TIMER0_PCLK		171
+#define LIGHT_CLKGEN_TIMER1_PCLK		172
+#define LIGHT_CLKGEN_PERI2DDR_X2X_ACLK_S	173
+#define LIGHT_CLKGEN_USB3_DRD_PCLK		174
+#define LIGHT_CLKGEN_GMAC_HCLK			175
+#define LIGHT_CLKGEN_GMAC_PCLK			176
+#define LIGHT_CLKGEN_GMAC_CCLK			177
+#define LIGHT_CLKGEN_EMMC0_ACLK			178
+#define LIGHT_CLKGEN_EMMC0_REF_CLK		179
+#define LIGHT_CLKGEN_EMMC0_OSC_CLK		180
+#define LIGHT_CLKGEN_EMMC1_ACLK			181
+#define LIGHT_CLKGEN_EMMC1_REF_CLK		182
+#define LIGHT_CLKGEN_EMMC1_OSC_CLK		183
+#define LIGHT_CLKGEN_PWM_CCLK			184
+#define LIGHT_CLKGEN_QSPI0_SSI_CLK		185
+#define LIGHT_CLKGEN_QSPI1_SSI_CLK		186
+#define LIGHT_CLKGEN_SPI_SSI_CLK		187
+#define LIGHT_CLKGEN_GPIO0_DBCLK		188
+#define LIGHT_CLKGEN_GPIO1_DBCLK		189
+#define LIGHT_CLKGEN_GPIO2_DBCLK		190
+#define LIGHT_CLKGEN_DMAC_1_HCLK		191
+#define LIGHT_CLKGEN_DMAC_2_HCLK		192
+#define LIGHT_CLKGEN_DMAC_3_HCLK		193
+#define LIGHT_EMMC_CLK_DIV			194
+#define LIGHT_EMMC0_OSC_CLK			195
+#define LIGHT_EMMC1_OSC_CLK			196
+#define LIGHT_PWM_CCLK				197
+#define LIGHT_USB3_PHY_REF_CLK			198
+#define LIGHT_SPI_CLK				199
+#define LIGHT_GPIO_DBCLK			200
+#define LIGHT_X2H_HCLK				201
+
+#define LIGHT_CLK_END				202
+#endif
diff --git a/include/dt-bindings/clock/light-visys.h b/include/dt-bindings/clock/light-visys.h
new file mode 100755
index 000000000..53fed0bfb
--- /dev/null
+++ b/include/dt-bindings/clock/light-visys.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef _LIGHT_VISYS_H
+#define _LIGHT_VISYS_H
+
+#define LIGHT_CLKGEN_VISYS_ACLK			      0
+#define LIGHT_CLKGEN_DW200_ACLK			      1
+#define LIGHT_CLKGEN_AXI4_VISYS1_ACLK		      2
+#define LIGHT_CLKGEN_AXI4_VISYS2_ACLK                 3
+#define LIGHT_CLKGEN_AXI4_VISYS3_ACLK                 4
+#define LIGHT_CLKGEN_ISP0_ACLK                        5
+#define LIGHT_CLKGEN_ISP_RY_ACLK                      6
+#define LIGHT_CLKGEN_ISP_VENC_SHAKE_ACLK              7
+#define LIGHT_CLKGEN_VIPRE_ACLK                       8
+#define LIGHT_CLKGEN_VISYS_SLAVE_HCLK                 9
+#define LIGHT_CLKGEN_ISP0_S_HCLK                      10
+#define LIGHT_CLKGEN_DW200_HCLK                       11
+#define LIGHT_CLKGEN_ISP_RY_HCLK                      12
+#define LIGHT_CLKGEN_MIPI_CSI0_PCLK                   13
+#define LIGHT_CLKGEN_MIPI_CSI0_FPCLK                  14
+#define LIGHT_CLKGEN_MIPI_CSI1_PCLK                   15
+#define LIGHT_CLKGEN_MIPI_CSI1_FPCLK                  16
+#define LIGHT_CLKGEN_MIPI_CSI2_PCLK                   17
+#define LIGHT_CLKGEN_MIPI_CSI2_FPCLK                  18
+#define LIGHT_CLKGEN_VIPRE_PCLK                       19
+#define LIGHT_CLKGEN_VISYS_PCLK                       20
+#define LIGHT_CLKGEN_VISYS_SYSREG_PCLK                21
+#define LIGHT_CLKGEN_ISP_VENC_SHAKE_PCLK              22
+#define LIGHT_CLKGEN_MIPI_CSI0_PIXCLK                 23
+#define LIGHT_CLKGEN_MIPI_CSI1_PIXCLK                 24
+#define LIGHT_CLKGEN_MIPI_CSI2_PIXCLK                 25
+#define LIGHT_CLKGEN_VIPRE_PIXELCLK                   26
+#define LIGHT_CLKGEN_ISP_PIXELCLK                     27
+#define LIGHT_CLKGEN_MIPI_CSI0_CFG_CLK                28
+#define LIGHT_CLKGEN_MIPI_CSI1_CFG_CLK                29
+#define LIGHT_CLKGEN_MIPI_CSI2_CFG_CLK                30
+#define LIGHT_CLKGEN_DW200_CLK_VSE                    31
+#define LIGHT_CLKGEN_DW200_CLK_DWE                    32
+#define LIGHT_CLKGEN_ISP0_CLK                         33
+#define LIGHT_CLKGEN_ISP1_CLK                         34
+#define LIGHT_CLKGEN_ISP_RY_CCLK                      35
+#define LIGHT_CLKGEN_MIPI_CSI_SCANBYTECLK             36
+#define LIGHT_CLKGEN_MIPI_CSI_SCANCLK                 37
+#define LIGHT_CLKGEN_ISP1_PIXELCLK		      38
+#define LIGHT_CLKGEN_ISP0_PIXELCLK		      39
+#define LIGHT_CLKGEN_ISP1_HCLK			      40
+#define LIGHT_CLKGEN_ISP0_HCLK			      41
+#define LIGHT_CLKGEN_ISP1_ACLK			      42
+#define LIGHT_CLKGEN_VISYS_CLK_END		      43
+
+#endif
diff --git a/include/dt-bindings/clock/light-vosys.h b/include/dt-bindings/clock/light-vosys.h
new file mode 100755
index 000000000..dbdd7fa70
--- /dev/null
+++ b/include/dt-bindings/clock/light-vosys.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef LIGHT_VOSYS_H
+#define LIGHT_VOSYS_H
+
+#define LIGHT_CLKGEN_AXI4_VO_PCLK			0
+#define LIGHT_CLKGEN_IOPMP_VOSYS_DPU_PCLK		1
+#define LIGHT_CLKGEN_IOPMP_VOSYS_DPU1_PCLK		2
+#define LIGHT_CLKGEN_IOPMP_VOSYS_GPU_PCLK		3
+#define LIGHT_CLKGEN_HDMI_PCLK				4
+#define LIGHT_CLKGEN_MIPIDSI0_PCLK			5
+#define LIGHT_CLKGEN_MIPIDSI1_PCLK			6
+#define LIGHT_CLKGEN_AXI4_VO_ACLK			7
+#define LIGHT_CLKGEN_IOPMP_GPU_ACLK			8
+#define LIGHT_CLKGEN_IOPMP_DPU_ACLK			9
+#define LIGHT_CLKGEN_IOPMP_DPU1_ACLK			10
+#define LIGHT_CLKGEN_X2H_DPU_ACLK			11
+#define LIGHT_CLKGEN_X2H_DPU1_ACLK			12
+#define LIGHT_CLKGEN_MIPIDSI0_PIXCLK			13
+#define LIGHT_CLKGEN_HDMI_PIXCLK			14
+#define LIGHT_CLKGEN_MIPIDSI1_PIXCLK			15
+#define LIGHT_CLKGEN_HDMI_SFR_CLK			16
+#define LIGHT_CLKGEN_HDMI_CEC_CLK			17
+#define LIGHT_CLKGEN_HDMI_I2S_CLK			18
+#define LIGHT_CLKGEN_MIPIDSI0_CFG_CLK			19
+#define LIGHT_CLKGEN_MIPIDSI1_CFG_CLK			20
+#define LIGHT_CLKGEN_MIPIDSI0_REFCLK			21
+#define LIGHT_CLKGEN_MIPIDSI1_REFCLK			22
+#define LIGHT_CLKGEN_GPU_CORE_CLK			23
+#define LIGHT_CLKGEN_GPU_CFG_ACLK			24
+#define LIGHT_CLKGEN_DPU_HCLK				25
+#define LIGHT_CLKGEN_DPU_ACLK				26
+#define LIGHT_CLKGEN_DPU_CCLK				27
+#define LIGHT_CLKGEN_DPU_PIXCLK0			28
+#define LIGHT_CLKGEN_DPU_PIXCLK1                        29
+#define LIGHT_CLKGEN_VOSYS_CLK_END			30
+
+#endif
diff --git a/include/dt-bindings/clock/light-vpsys.h b/include/dt-bindings/clock/light-vpsys.h
new file mode 100755
index 000000000..188aaa6cc
--- /dev/null
+++ b/include/dt-bindings/clock/light-vpsys.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef _LIGHT_VPSYS_H
+#define _LIGHT_VPSYS_H
+
+#define LIGHT_VPSYS_G2D_PCLK		0
+#define LIGHT_VPSYS_G2D_ACLK		1
+#define LIGHT_VPSYS_G2D_CCLK		2
+#define LIGHT_VPSYS_FCE_PCLK		3
+#define LIGHT_VPSYS_FCE_ACLK		4
+#define LIGHT_VPSYS_VDEC_PCLK		5
+#define LIGHT_VPSYS_VDEC_ACLK		6
+#define LIGHT_VPSYS_VDEC_CCLK		7
+#define LIGHT_VPSYS_AXI_ACLK		8
+#define LIGHT_VPSYS_VENC_CCLK		9
+#define LIGHT_VPSYS_VENC_PCLK		10
+#define LIGHT_VPSYS_VENC_ACLK		11
+#define LIGHT_VPSYS_CLK_END		12
+
+#endif
+
diff --git a/include/dt-bindings/firmware/thead/rsrc.h b/include/dt-bindings/firmware/thead/rsrc.h
new file mode 100755
index 000000000..8cee0fcae
--- /dev/null
+++ b/include/dt-bindings/firmware/thead/rsrc.h
@@ -0,0 +1,17 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef __DT_BINDINGS_RSCRC_LIGHT_H
+#define __DT_BINDINGS_RSCRC_LIGHT_H
+
+#define LIGHT_AON_AUDIO_PD	0
+#define LIGHT_AON_VDEC_PD	1
+#define LIGHT_AON_NPU_PD        2
+#define LIGHT_AON_VENC_PD       3
+#define LIGHT_AON_GPU_PD        4
+#define LIGHT_AON_DSP0_PD       5
+#define LIGHT_AON_DSP1_PD       6
+
+#endif
diff --git a/include/dt-bindings/pinctrl/light-fm-aon-pinctrl.h b/include/dt-bindings/pinctrl/light-fm-aon-pinctrl.h
new file mode 100755
index 000000000..3d2676d8b
--- /dev/null
+++ b/include/dt-bindings/pinctrl/light-fm-aon-pinctrl.h
@@ -0,0 +1,78 @@
+#ifndef _LIGHT_FM_AUDIO_PINCTRL_H
+#define _LIGHT_FM_AUDIO_PINCTRL_H
+
+#define FM_OSC_CLK_IN			0
+#define FM_RTC_CLK_IN			3
+#define FM_DEBUG_MODE			7
+#define FM_I2C_AON_SCL			9
+#define FM_I2C_AON_SDA			10
+#define FM_CPU_JTG_TCLK			11
+#define FM_CPU_JTG_TMS			12
+#define FM_CPU_JTG_TDI			13
+#define FM_CPU_JTG_TDO			14
+#define FM_CPU_JTG_TRST			15
+#define FM_AOGPIO_7			16
+#define FM_AOGPIO_8			17
+#define FM_AOGPIO_9			18
+#define FM_AOGPIO_10			19
+#define FM_AOGPIO_11			20
+#define FM_AOGPIO_12			21
+#define FM_AOGPIO_13			22
+#define FM_AOGPIO_14			23
+#define FM_AOGPIO_15			24
+#define FM_AUDIO_PA0			25
+#define FM_AUDIO_PA1			26
+#define FM_AUDIO_PA2			27
+#define FM_AUDIO_PA3			28
+#define FM_AUDIO_PA4			29
+#define FM_AUDIO_PA5			30
+#define FM_AUDIO_PA6			31
+#define FM_AUDIO_PA7			32
+#define FM_AUDIO_PA8			33
+#define FM_AUDIO_PA9			34
+#define FM_AUDIO_PA10			35
+#define FM_AUDIO_PA11			36
+#define FM_AUDIO_PA12			37
+#define FM_AUDIO_PA13			38
+#define FM_AUDIO_PA14			39
+#define FM_AUDIO_PA15			40
+#define FM_AUDIO_PA16			41
+#define FM_AUDIO_PA17			42
+#define FM_AUDIO_PA27			43
+#define FM_AUDIO_PA28			44
+#define FM_AUDIO_PA29			45
+#define FM_AUDIO_PA30			46
+
+#define FM_AUDIO_CFG_PA0			25
+#define FM_AUDIO_CFG_PA1			26
+#define FM_AUDIO_CFG_PA2			27
+#define FM_AUDIO_CFG_PA3			28
+#define FM_AUDIO_CFG_PA4			29
+#define FM_AUDIO_CFG_PA5			30
+#define FM_AUDIO_CFG_PA6			31
+#define FM_AUDIO_CFG_PA7			32
+#define FM_AUDIO_CFG_PA8			33
+#define FM_AUDIO_CFG_PA9			34
+#define FM_AUDIO_CFG_PA10			35
+#define FM_AUDIO_CFG_PA11			36
+#define FM_AUDIO_CFG_PA12			37
+#define FM_AUDIO_CFG_PA13			38
+#define FM_AUDIO_CFG_PA14			39
+#define FM_AUDIO_CFG_PA15			40
+#define FM_AUDIO_CFG_PA16			41
+#define FM_AUDIO_CFG_PA17			42
+#define FM_AUDIO_CFG_PA18			43
+#define FM_AUDIO_CFG_PA19			44
+#define FM_AUDIO_CFG_PA20			45
+#define FM_AUDIO_CFG_PA21			46
+#define FM_AUDIO_CFG_PA22			47
+#define FM_AUDIO_CFG_PA23			48
+#define FM_AUDIO_CFG_PA24			49
+#define FM_AUDIO_CFG_PA25			50
+#define FM_AUDIO_CFG_PA26			51
+#define FM_AUDIO_CFG_PA27			52
+#define FM_AUDIO_CFG_PA28			53
+#define FM_AUDIO_CFG_PA29			54
+#define FM_AUDIO_CFG_PA30			55
+
+#endif	/* _LIGHT_FM_AUDIO_PINCTRL_H */
diff --git a/include/dt-bindings/pinctrl/light-fm-left-pinctrl.h b/include/dt-bindings/pinctrl/light-fm-left-pinctrl.h
new file mode 100755
index 000000000..1ebc511a0
--- /dev/null
+++ b/include/dt-bindings/pinctrl/light-fm-left-pinctrl.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _DT_BINDINGS_LIGHT_FM_LEFT_PINCTRL_H_
+#define _DT_BINDINGS_LIGHT_FM_LEFT_PINCTRL_H_
+
+#define FM_QSPI1_SCLK		0
+#define FM_QSPI1_CSN0		1
+#define FM_QSPI1_D0_MOSI	2
+#define FM_QSPI1_D1_MISO	3
+#define FM_QSPI1_D2_WP		4
+#define FM_QSPI1_D3_HOLD	5
+#define FM_I2C0_SCL		6
+#define FM_I2C0_SDA		7
+#define FM_I2C1_SCL		8
+#define FM_I2C1_SDA		9
+#define FM_UART1_TXD		10
+#define FM_UART1_RXD		11
+#define FM_UART4_TXD		12
+#define FM_UART4_RXD		13
+#define FM_UART4_CTSN		14
+#define FM_UART4_RTSN		15
+#define FM_UART3_TXD		16
+#define FM_UART3_RXD		17
+#define FM_GPIO0_18		18
+#define FM_GPIO0_19		19
+#define FM_GPIO0_20		20
+#define FM_GPIO0_21		21
+#define FM_GPIO0_22		22
+#define FM_GPIO0_23		23
+#define FM_GPIO0_24		24
+#define FM_GPIO0_25		25
+#define FM_GPIO0_26		26
+#define FM_GPIO0_27		27
+#define FM_GPIO0_28		28
+#define FM_GPIO0_29		29
+#define FM_GPIO0_30		30
+#define FM_GPIO0_31		31
+#define FM_GPIO1_0		32
+#define FM_GPIO1_1		33
+#define FM_GPIO1_2		34
+#define FM_GPIO1_3		35
+#define FM_GPIO1_4		36
+#define FM_GPIO1_5		37
+#define FM_GPIO1_6		38
+#define FM_GPIO1_7		39
+#define FM_GPIO1_8		40
+#define FM_GPIO1_9		41
+#define FM_GPIO1_10		42
+#define FM_GPIO1_11		43
+#define FM_GPIO1_12		44
+#define FM_GPIO1_13		45
+#define FM_GPIO1_14		46
+#define FM_GPIO1_15		47
+#define FM_GPIO1_16		48
+#define FM_CLK_OUT_0		49
+#define FM_CLK_OUT_1		50
+#define FM_CLK_OUT_2		51
+#define FM_CLK_OUT_3		52
+#define FM_GPIO1_21		53
+#define FM_GPIO1_22		54
+#define FM_GPIO1_23		55
+#define FM_GPIO1_24		56
+#define FM_GPIO1_25		57
+#define FM_GPIO1_26		58
+#define FM_GPIO1_27		59
+#define FM_GPIO1_28		60
+#define FM_GPIO1_29		61
+#define FM_GPIO1_30		62
+
+
+#endif /* _DT_BINDINGS_LIGHT_FM_LEFT_PINCTRL_H_ */
diff --git a/include/dt-bindings/pinctrl/light-fm-right-pinctrl.h b/include/dt-bindings/pinctrl/light-fm-right-pinctrl.h
new file mode 100755
index 000000000..6522efc72
--- /dev/null
+++ b/include/dt-bindings/pinctrl/light-fm-right-pinctrl.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _DT_BINDINGS_LIGHT_FM_RIGHT_PINCTRL_H_
+#define _DT_BINDINGS_LIGHT_FM_RIGHT_PINCTRL_H_
+
+#define FM_UART0_TXD		0
+#define FM_UART0_RXD		1
+#define FM_QSPI0_SCLK		2
+#define FM_QSPI0_CSN0		3
+#define FM_QSPI0_CSN1		4
+#define FM_QSPI0_D0_MOSI	5
+#define FM_QSPI0_D1_MISO	6
+#define FM_QSPI0_D2_WP		7
+#define FM_QSPI0_D3_HOLD	8
+#define FM_I2C2_SCL		9
+#define FM_I2C2_SDA		10
+#define FM_I2C3_SCL		11
+#define FM_I2C3_SDA		12
+#define FM_GPIO2_13		13
+#define FM_SPI_SCLK		14
+#define FM_SPI_CSN		15
+#define FM_SPI_MOSI		16
+#define FM_SPI_MISO		17
+#define FM_GPIO2_18		18
+#define FM_GPIO2_19		19
+#define FM_GPIO2_20		20
+#define FM_GPIO2_21		21
+#define FM_GPIO2_22		22
+#define FM_GPIO2_23		23
+#define FM_GPIO2_24		24
+#define FM_GPIO2_25		25
+#define FM_SDIO0_WPRTN		26
+#define FM_SDIO0_DETN		27
+#define FM_SDIO1_WPRTN		28
+#define FM_SDIO1_DETN		29
+#define FM_GPIO2_30		30
+#define FM_GPIO2_31		31
+#define FM_GPIO3_0		32
+#define FM_GPIO3_1		33
+#define FM_GPIO3_2		34
+#define FM_GPIO3_3		35
+#define FM_HDMI_SCL		36
+#define FM_HDMI_SDA		37
+#define FM_HDMI_CEC		38
+#define FM_GMAC0_TX_CLK		39
+#define FM_GMAC0_RX_CLK		40
+#define FM_GMAC0_TXEN		41
+#define FM_GMAC0_TXD0		42
+#define FM_GMAC0_TXD1		43
+#define FM_GMAC0_TXD2		44
+#define FM_GMAC0_TXD3		45
+#define FM_GMAC0_RXDV		46
+#define FM_GMAC0_RXD0		47
+#define FM_GMAC0_RXD1		48
+#define FM_GMAC0_RXD2		49
+#define FM_GMAC0_RXD3		50
+#define FM_GMAC0_MDC		51
+#define FM_GMAC0_MDIO		52
+#define FM_GMAC0_COL		53
+#define FM_GMAC0_CRS		54
+
+#endif /* _DT_BINDINGS_LIGHT_FM_RIGHT_PINCTRL_H_ */
diff --git a/include/dt-bindings/pinctrl/light-mpw-pinctrl.h b/include/dt-bindings/pinctrl/light-mpw-pinctrl.h
new file mode 100755
index 000000000..7ce627b9f
--- /dev/null
+++ b/include/dt-bindings/pinctrl/light-mpw-pinctrl.h
@@ -0,0 +1,104 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef __DT_BINDINGS_LIGHT_C910_PINCTRL_H__
+#define __DT_BINDINGS_LIGHT_C910_PINCTRL_H__
+
+#define	BOOT_SEL0	0
+#define	BOOT_SEL1	1
+#define	BOOT_SEL2	2
+#define	OSC_BOOT	3
+#define	QSPI0_SCK	4
+#define	QSPI0_SSN0	5
+#define	QSPI0_M0_MOSI	6
+#define	QSPI0_M1_MISO	7
+#define	QSPI0_M2_WP	8
+#define	QSPI0_M3_HOLD	9
+#define	QSPI1_SCK	10
+#define	QSPI1_SSN0	11
+#define	QSPI1_M0_MOSI	12
+#define	QSPI1_M1_MISO	13
+#define	QSPI1_M2_WP	14
+#define	QSPI1_M3_HOLD	15
+#define	SPI_SCK		16
+#define	SPI_SSN0	17
+#define	SPI_SSN1	18
+#define	SPI_MOSI	19
+#define	SPI_MISO	20
+#define	I2C0_SCL	21
+#define	I2C0_SDA	22
+#define	I2C1_SCL	23
+#define	I2C1_SDA	24
+#define	I2C2_SCL	25
+#define	I2C2_SDA	26
+#define	I2C3_SCL	27
+#define	I2C3_SDA	28
+#define	UART0_RXD	29
+#define	UART0_TXD	30
+#define	UART1_RXD	31
+#define	UART1_TXD	32
+#define	UART3_RXD	33
+#define	UART3_TXD	34
+#define	UART4_RXD	35
+#define	UART4_TXD	36
+#define	UART4_CTSN	37
+#define	UART4_RTSN	38
+#define	GPIO1_DATA7	39
+#define	GPIO1_DATA8	40
+#define	GPIO1_DATA9	41
+#define	GPIO1_DATA10	42
+#define	GPIO1_DATA11	43
+#define	GPIO1_DATA12	44
+#define	GPIO1_DATA13	45
+#define	GPIO1_DATA14	46
+#define	GPIO1_DATA15	47
+#define	GPIO1_DATA16	48
+#define	GPIO1_DATA17	49
+#define	GPIO1_DATA18	50
+#define	GPIO1_DATA19	51
+#define	GPIO1_DATA20	52
+#define	GPIO1_DATA21	53
+#define	GPIO1_DATA22	54
+#define	GPIO1_DATA23	55
+#define	GPIO1_DATA24	56
+#define	GPIO1_DATA25	57
+#define	GPIO1_DATA26	58
+#define	EMMC0_DETN	59
+#define	EMMC0_PWRON	60
+#define	EMMC0_WPRTN	61
+#define	EMMC0_VOL_STB	62
+#define	EMMC1_DETN	63
+#define	EMMC1_PWRON	64
+#define	EMMC1_WPRTN	65
+#define	EMMC1_VOL_STB	66
+#define	C910_JTG_TCLK	67
+#define	C910_JTG_TRST	68
+#define	C910_JTG_TDI	69
+#define	C910_JTG_TMS	70
+#define	C910_JTG_TDO	71
+#define	GPIO2_DATA8	72
+#define	GPIO2_DATA9	73
+#define	GPIO2_DATA10	74
+#define	GPIO2_DATA11	75
+#define	GPIO2_DATA12	76
+#define	GPIO2_DATA13	77
+#define	GPIO2_DATA14	78
+#define	RGM_PAD_MS_RTE	120
+#define	GMAC_EPHY_CLK	121
+#define	GMAC_TX_CLK	122
+#define	GMAC_RX_CLK	123
+#define	GMAC_TXEN	124
+#define	GMAC_TXD0	125
+#define	GMAC_TXD1	126
+#define	GMAC_TXD2	127
+#define	GMAC_TXD3	128
+#define	GMAC_RXDV	129
+#define	GMAC_RXD0	130
+#define	GMAC_RXD1	131
+#define	GMAC_RXD2	132
+#define	GMAC_RXD3	133
+#define	GMAC_MDC	134
+#define	GMAC_MDIO	135
+#define	GMAC_COL	136
+#define	GMAC_CRS	137
+
+#endif /* __DT_BINDINGS_LIGHT_C910_PINCTRL_H__ */
diff --git a/include/dt-bindings/reset/light-reset.h b/include/dt-bindings/reset/light-reset.h
new file mode 100755
index 000000000..44d5a722f
--- /dev/null
+++ b/include/dt-bindings/reset/light-reset.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2021 Alibaba, Inc.
+ *
+ * Author: zenglinghui  <zenglinghui.zlh@linux.alibaba.com>
+ */
+
+#ifndef DT_BINDING_RESET_LIGHT_H
+#define DT_BINDING_RESET_LIGHT_H
+
+#define LIGHT_RESET_WDT0    0
+#define LIGHT_RESET_WDT1    1
+#define LIGHT_RESET_NPU    	2
+
+// vpsys reset
+#define LIGHT_RESET_FCE    	100
+
+#endif
+
diff --git a/include/dt-bindings/soc/thead,light-iopmp.h b/include/dt-bindings/soc/thead,light-iopmp.h
new file mode 100755
index 000000000..53739acb9
--- /dev/null
+++ b/include/dt-bindings/soc/thead,light-iopmp.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+
+#ifndef __DT_THEAD_LIGHT_IOPMP_H__
+#define __DT_THEAD_LIGHT_IOPMP_H__
+
+#define IOPMP_EMMC	0
+#define IOPMP_SDIO0	1
+#define IOPMP_SDIO1	2
+#define IOPMP_USB0	3
+#define IOPMP_AO	4
+#define IOPMP_AUD	5
+#define IOPMP_CHIP_DBG	6
+#define IOPMP_EIP120I	7
+#define IOPMP_EIP120II	8
+#define IOPMP_EIP120III	9
+#define IOPMP_ISP0	10
+#define IOPMP_ISP1	11
+#define IOPMP_DW200	12
+#define IOPMP_VIPRE	13
+#define IOPMP_VENC	14
+#define IOPMP_VDEC	15
+#define IOPMP_G2D	16
+#define IOPMP_FCE	17
+#define IOPMP_NPU	18
+#define IOPMP0_DPU	19
+#define IOPMP1_DPU	20
+#define IOPMP_GPU	21
+#define IOPMP_GMAC1	22
+#define IOPMP_GMAC2	23
+#define IOPMP_DMAC	24
+#define IOPMP_TEE_DMAC	25
+#define IOPMP_DSP0	26
+#define IOPMP_DSP1	27
+
+#endif /* __DT_THEAD_LIGHT_IOPMP_H__ */
diff --git a/include/linux/device-mapper.h b/include/linux/device-mapper.h
index 50cc070cb..878324cfd 100644
--- a/include/linux/device-mapper.h
+++ b/include/linux/device-mapper.h
@@ -261,6 +261,12 @@ struct target_type {
 #define DM_TARGET_NOWAIT		0x00000080
 #define dm_target_supports_nowait(type) ((type)->features & DM_TARGET_NOWAIT)
 
+/*
+ * A target supports passing through inline crypto support.
+ */
+#define DM_TARGET_PASSES_CRYPTO		0x00000100
+#define dm_target_passes_crypto(type) ((type)->features & DM_TARGET_PASSES_CRYPTO)
+
 #ifdef CONFIG_BLK_DEV_ZONED
 #define DM_TARGET_MIXED_ZONED_MODEL	0x00000200
 #define dm_target_supports_mixed_zoned_model(type) \
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index dd357a747..2e8e4d6cb 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -443,6 +443,8 @@ struct dma_slave_config {
 	u32 dst_port_window_size;
 	bool device_fc;
 	unsigned int slave_id;
+	void *peripheral_config;
+	size_t peripheral_size;
 };
 
 /**
diff --git a/include/linux/dsmart_card_interface.h b/include/linux/dsmart_card_interface.h
new file mode 100755
index 000000000..392c7ac86
--- /dev/null
+++ b/include/linux/dsmart_card_interface.h
@@ -0,0 +1,74 @@
+#ifndef _DSMART_CARD_INTERFACE_H
+#define _DSMART_CARD_INTERFACE_H
+
+#define DSMART_CARD_OK			0
+#define DSMART_CARD_E_ACCESS		1
+#define DSMART_CARD_E_DATA_TIMEOUT	2
+#define DSMART_CARD_E_NOCARD		3
+#define DSMART_CARD_E_NOACT		4
+#define DSMART_CARD_E_REMOVED		5
+#define DSMART_CARD_E_NO_RX_EV		6
+#define DSMART_CARD_E_NO_TX_EV		7
+#define DSMART_CARD_E_NO_CRD_EV		8
+#define DSMART_CARD_E_ACT_TIMEOUT	9
+#define DSMART_CARD_E_DATA_RCV_FAILED	10
+#define DSMART_CARD_E_ACTIVATE_FAILED	11
+#define DSMART_CARD_E_TX_FULL		12
+#define DSMART_CARD_E_PAR_ERR		13
+#define DSMART_CARD_E_CRC_ERR		14
+#define DSMART_CARD_E_REP_ERR		15
+#define DSMART_CARD_E_CWT_TIM		16
+#define DSMART_CARD_E_RX_OVER		17
+#define DSMART_CARD_STATE_ERR_EVENT	18
+
+#define CARD_PROTOCOL_T0	1
+#define	CARD_PROTOCOL_T1	2
+
+struct dsmart_card_atr {
+	unsigned char atr_buffer[64];
+	unsigned int len;	/* length of ATR received */
+	int errval;
+};
+
+struct dsmart_card_rcv {
+	unsigned char rcv_buffer[256];
+	int rcv_length;
+	int time_out;
+	int errval;
+};
+
+struct dsmart_card_xmt {
+	unsigned char xmt_buffer[256];
+	int xmt_length;
+	int time_out;
+	int errval;
+};
+
+struct dsmart_card_timing {
+	unsigned int wwt;
+	unsigned int cwt;
+	unsigned int bwt;
+	unsigned int bgt;
+	unsigned int egt;
+};
+
+struct dsmart_card_baud {
+	unsigned char di;
+	unsigned char fi;
+};
+
+/* ioctl encodings */
+#define DSMART_CARD_BASE			0xc0
+#define DSMART_CARD_IOCTL_SET_PROTOCOL		_IOR(DSMART_CARD_BASE, 1, int)
+#define DSMART_CARD_IOCTL_DEACTIVATE		_IOR(DSMART_CARD_BASE, 2, int)
+#define DSMART_CARD_IOCTL_COLD_RESET		_IOR(DSMART_CARD_BASE, 3, int)
+#define DSMART_CARD_IOCTL_WARM_RESET		_IOR(DSMART_CARD_BASE, 4, int)
+#define DSMART_CARD_IOCTL_SET_TIMING		_IOR(DSMART_CARD_BASE, 5, int)
+#define DSMART_CARD_IOCTL_SET_BAUD		_IOR(DSMART_CARD_BASE, 6, int)
+#define DSMART_CARD_IOCTL_SET_RX_THRESHOLD	_IOR(DSMART_CARD_BASE, 7, int)
+#define DSMART_CARD_IOCTL_SET_TX_THRESHOLD	_IOR(DSMART_CARD_BASE, 8, int)
+#define DSMART_CARD_IOCTL_XMT			_IOR(DSMART_CARD_BASE, 9, int)
+#define DSMART_CARD_IOCTL_RCV			_IOR(DSMART_CARD_BASE, 10, int)
+#define DSMART_CARD_IOCTL_ATR_RCV		_IOR(DSMART_CARD_BASE, 11, int)
+
+#endif
diff --git a/include/linux/firmware/thead/ipc.h b/include/linux/firmware/thead/ipc.h
new file mode 100755
index 000000000..dd23f3201
--- /dev/null
+++ b/include/linux/firmware/thead/ipc.h
@@ -0,0 +1,70 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+#ifndef _SC_IPC_H
+#define _SC_IPC_H
+
+#include <linux/device.h>
+#include <linux/types.h>
+
+#define AON_RPC_MSG_MAGIC       (0xef)
+#define LIGHT_AON_RPC_VERSION	1
+#define LIGHT_AON_RPC_MSG_NUM	7
+
+struct light_aon_ipc;
+
+enum light_aon_rpc_svc {
+	LIGHT_AON_RPC_SVC_UNKNOWN = 0,
+	LIGHT_AON_RPC_SVC_RETURN = 1,
+	LIGHT_AON_RPC_SVC_PM = 2,
+	LIGHT_AON_RPC_SVC_MISC = 3,
+	LIGHT_AON_RPC_SVC_AVFS = 4,
+};
+
+enum light_aon_misc_func {
+	LIGHT_AON_MISC_FUNC_UNKNOWN = 0,
+	LIGHT_AON_MISC_FUNC_SET_CONTROL = 1,
+	LIGHT_AON_MISC_FUNC_GET_CONTROL = 2,
+	LIGHT_AON_MISC_FUNC_WDG_START = 3,
+	LIGHT_AON_MISC_FUNC_WDG_STOP = 4,
+	LIGHT_AON_MISC_FUNC_WDG_PING = 5,
+	LIGHT_AON_MISC_FUNC_WDG_TIMEOUTSET = 6,
+	LIGHT_AON_MISC_FUNC_WDG_RESTART = 7,
+	LIGHT_AON_MISC_FUNC_WDG_GET_STATE = 8,
+	LIGHT_AON_MISC_FUNC_WDG_POWER_OFF = 9,
+	LIGHT_AON_MISC_FUNC_AON_WDT_ON  = 10,
+	LIGHT_AON_MISC_FUNC_AON_WDT_OFF = 11,
+	LIGHT_AON_MISC_FUNC_AON_RESERVE_MEM = 12,
+};
+
+enum light_aon_pm_func {
+	LIGHT_AON_PM_FUNC_UNKNOWN = 0,
+	LIGHT_AON_PM_FUNC_SET_RESOURCE_REGULATOR = 1,
+	LIGHT_AON_PM_FUNC_GET_RESOURCE_REGULATOR = 2,
+	LIGHT_AON_PM_FUNC_SET_RESOURCE_POWER_MODE = 3,
+	LIGHT_AON_PM_FUNC_PWR_SET  = 4,
+	LIGHT_AON_PM_FUNC_PWR_GET  = 5,
+};
+
+struct light_aon_rpc_msg_hdr {
+	uint8_t ver;                   ///< version of msg hdr
+	uint8_t size;                  ///< msg size ,uinit in bytes,the size includes rpc msg header self.
+	uint8_t svc;                   ///< rpc main service id
+	uint8_t func;                  ///< rpc sub func id of specific service, sent by caller
+} __packed __aligned(4);
+
+/*
+ * Defines for SC PM Power Mode
+ */
+#define LIGHT_AON_PM_PW_MODE_OFF	0	/* Power off */
+#define LIGHT_AON_PM_PW_MODE_STBY	1	/* Power in standby */
+#define LIGHT_AON_PM_PW_MODE_LP		2	/* Power in low-power */
+#define LIGHT_AON_PM_PW_MODE_ON		3	/* Power on */
+
+int light_aon_call_rpc(struct light_aon_ipc *ipc, void *msg, bool have_resp);
+int light_aon_get_handle(struct light_aon_ipc **ipc);
+int light_aon_misc_set_control(struct light_aon_ipc *ipc, u16 resource, u32 ctrl, u32 val);
+int light_aon_misc_get_control(struct light_aon_ipc *ipc, u16 resource, u32 ctrl, u32 *val);
+#endif /* _SC_IPC_H */
diff --git a/include/linux/firmware/thead/light_event.h b/include/linux/firmware/thead/light_event.h
new file mode 100755
index 000000000..a4f99d41c
--- /dev/null
+++ b/include/linux/firmware/thead/light_event.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _LIGHT_EVENT_H
+#define _LIGHT_EVENT_H
+
+enum light_rebootmode_index {
+	/* C902 event rebootmode */
+        LIGHT_EVENT_PMIC_RESET = 0x0,
+        LIGHT_EVENT_PMIC_ONKEY,
+        LIGHT_EVENT_PMIC_POWERUP,
+
+	/* C910 event rebootmode */
+        LIGHT_EVENT_SW_REBOOT = 0x20,
+        LIGHT_EVENT_SW_WATCHDOG,
+        LIGHT_EVENT_SW_PANIC,
+        LIGHT_EVENT_SW_HANG,
+        LIGHT_EVENT_MAX,
+};
+
+#if IS_ENABLED(CONFIG_LIGHT_REBOOTMODE)
+extern int light_event_set_rebootmode(enum light_rebootmode_index mode);
+extern int light_event_get_rebootmode(enum light_rebootmode_index *mode);
+#else
+static int light_event_set_rebootmode(enum light_rebootmode_index mode)
+{
+	return 0;
+}
+static int light_event_get_rebootmode(enum light_rebootmode_index *mode)
+{
+	*mode = LIGHT_EVENT_MAX;
+
+	return 0;
+}
+#endif
+
+#endif
diff --git a/include/uapi/drm/drm_fourcc.h b/include/uapi/drm/drm_fourcc.h
index 5498d7a65..8b4ebbbf4 100644
--- a/include/uapi/drm/drm_fourcc.h
+++ b/include/uapi/drm/drm_fourcc.h
@@ -271,6 +271,13 @@ extern "C" {
  */
 #define DRM_FORMAT_P016		fourcc_code('P', '0', '1', '6') /* 2x2 subsampled Cr:Cb plane 16 bits per channel */
 
+/* 2 plane YCbCr420.
+ * 3 10 bit components and 2 padding bits packed into 4 bytes.
+ * index 0 = Y plane, [31:0] x:Y2:Y1:Y0 2:10:10:10 little endian
+ * index 1 = Cr:Cb plane, [63:0] x:Cr2:Cb2:Cr1:x:Cb1:Cr0:Cb0 [2:10:10:10:2:10:10:10] little endian
+ */
+#define DRM_FORMAT_P030		fourcc_code('P', '0', '3', '0') /* 2x2 subsampled Cr:Cb plane 10 bits per channel packed */
+
 /* 3 plane non-subsampled (444) YCbCr
  * 16 bits per component, but only 10 bits are used and 6 bits are padded
  * index 0: Y plane, [15:0] Y:x [10:6] little endian
@@ -332,6 +339,7 @@ extern "C" {
 #define DRM_FORMAT_MOD_VENDOR_ARM     0x08
 #define DRM_FORMAT_MOD_VENDOR_ALLWINNER 0x09
 #define DRM_FORMAT_MOD_VENDOR_AMLOGIC 0x0a
+#define DRM_FORMAT_MOD_VENDOR_VS      0x0b
 
 /* add more to the end as needed */
 
@@ -777,6 +785,10 @@ drm_fourcc_canonicalize_nvidia_format_mod(__u64 modifier)
  * and UV.  Some SAND-using hardware stores UV in a separate tiled
  * image from Y to reduce the column height, which is not supported
  * with these modifiers.
+ *
+ * The DRM_FORMAT_MOD_BROADCOM_SAND128_COL_HEIGHT modifier is also
+ * supported for DRM_FORMAT_P030 where the columns remain as 128 bytes
+ * wide, but as this is a 10 bpp format that translates to 96 pixels.
  */
 
 #define DRM_FORMAT_MOD_BROADCOM_SAND32_COL_HEIGHT(v) \
@@ -1056,6 +1068,95 @@ drm_fourcc_canonicalize_nvidia_format_mod(__u64 modifier)
  */
 #define AMLOGIC_FBC_OPTION_MEM_SAVING		(1ULL << 0)
 
+/*
+ * VeriSilicon Compressed Format
+ *
+ * DEC(Decompressor-Compressor) format consists of category (2 bits),
+ * tile mode (6 bits) and align mode (2 bits).
+ */
+
+#define DRM_FORMAT_MOD_VS_TYPE_NORMAL        0x00
+#define DRM_FORMAT_MOD_VS_TYPE_COMPRESSED    0x01
+#define DRM_FORMAT_MOD_VS_TYPE_CUSTOM_10BIT  0x02
+#define DRM_FORMAT_MOD_VS_TYPE_MASK     ((__u64)0x3 << 54)
+
+#define fourcc_mod_vs_code(type, val) \
+    fourcc_mod_code(VS, ((((__u64)type) << 54) | (val)))
+
+#define DRM_FORMAT_MOD_VS_DEC_TILE_MODE_MASK    0x3F
+#define DRM_FORMAT_MOD_VS_DEC_TILE_8X8_XMAJOR   0x00
+#define DRM_FORMAT_MOD_VS_DEC_TILE_8X8_YMAJOR   0x01
+#define DRM_FORMAT_MOD_VS_DEC_TILE_16X4     0x02
+#define DRM_FORMAT_MOD_VS_DEC_TILE_8X4      0x03
+#define DRM_FORMAT_MOD_VS_DEC_TILE_4X8      0x04
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_16X4   0x06
+#define DRM_FORMAT_MOD_VS_DEC_TILE_64X4     0x07
+#define DRM_FORMAT_MOD_VS_DEC_TILE_32X4     0x08
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_256X1  0x09
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_128X1  0x0A
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_64X4   0x0B
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_256X2  0x0C
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_128X2  0x0D
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_128X4  0x0E
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_64X1   0x0F
+#define DRM_FORMAT_MOD_VS_DEC_TILE_16X8     0x10
+#define DRM_FORMAT_MOD_VS_DEC_TILE_8X16     0x11
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_512X1  0x12
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_32X4   0x13
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_64X2   0x14
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_32X2   0x15
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_32X1   0x16
+#define DRM_FORMAT_MOD_VS_DEC_RASTER_16X1   0x17
+#define DRM_FORMAT_MOD_VS_DEC_TILE_128X4    0x18
+#define DRM_FORMAT_MOD_VS_DEC_TILE_256X4    0x19
+#define DRM_FORMAT_MOD_VS_DEC_TILE_512X4    0x1A
+#define DRM_FORMAT_MOD_VS_DEC_TILE_16X16    0x1B
+#define DRM_FORMAT_MOD_VS_DEC_TILE_32X16    0x1C
+#define DRM_FORMAT_MOD_VS_DEC_TILE_64X16    0x1D
+#define DRM_FORMAT_MOD_VS_DEC_TILE_128X8    0x1E
+#define DRM_FORMAT_MOD_VS_DEC_TILE_8X4_S    0x1F
+#define DRM_FORMAT_MOD_VS_DEC_TILE_16X4_S   0x20
+#define DRM_FORMAT_MOD_VS_DEC_TILE_32X4_S   0x21
+#define DRM_FORMAT_MOD_VS_DEC_TILE_16X4_LSB 0x22
+#define DRM_FORMAT_MOD_VS_DEC_TILE_32X4_LSB 0x23
+#define DRM_FORMAT_MOD_VS_DEC_TILE_32X8     0x24
+
+#define DRM_FORMAT_MOD_VS_DEC_ALIGN_32      (0x01 << 6)
+#define DRM_FORMAT_MOD_VS_DEC_ALIGN_64      (0x01 << 7)
+
+#define fourcc_mod_vs_dec_code(tile, align) \
+    fourcc_mod_vs_code(DRM_FORMAT_MOD_VS_TYPE_COMPRESSED, \
+                ((tile) | (align)))
+
+#define DRM_FORMAT_MOD_VS_NORM_MODE_MASK        0x1F
+#define DRM_FORMAT_MOD_VS_LINEAR                0x00
+#define DRM_FORMAT_MOD_VS_TILED4x4              0x01
+#define DRM_FORMAT_MOD_VS_SUPER_TILED_XMAJOR    0x02
+#define DRM_FORMAT_MOD_VS_SUPER_TILED_YMAJOR    0x03
+#define DRM_FORMAT_MOD_VS_TILE_8X8              0x04
+#define DRM_FORMAT_MOD_VS_TILE_MODE1            0x05
+#define DRM_FORMAT_MOD_VS_TILE_MODE2            0x06
+#define DRM_FORMAT_MOD_VS_TILE_8X4              0x07
+#define DRM_FORMAT_MOD_VS_TILE_MODE4            0x08
+#define DRM_FORMAT_MOD_VS_TILE_MODE5            0x09
+#define DRM_FORMAT_MOD_VS_TILE_MODE6            0x0A
+#define DRM_FORMAT_MOD_VS_SUPER_TILED_XMAJOR_8X4    0x0B
+#define DRM_FORMAT_MOD_VS_SUPER_TILED_YMAJOR_4X8    0x0C
+#define DRM_FORMAT_MOD_VS_TILE_Y                0x0D
+#define DRM_FORMAT_MOD_VS_TILE_128X1            0x0F
+#define DRM_FORMAT_MOD_VS_TILE_256X1            0x10
+#define DRM_FORMAT_MOD_VS_TILE_32X1             0x11
+#define DRM_FORMAT_MOD_VS_TILE_64X1             0x12
+#define DRM_FORMAT_MOD_VS_TILE_MODE4X4          0x15
+
+#define fourcc_mod_vs_norm_code(tile) \
+    fourcc_mod_vs_code(DRM_FORMAT_MOD_VS_TYPE_NORMAL, \
+                (tile))
+
+#define fourcc_mod_vs_custom_code(tile) \
+    fourcc_mod_vs_code(DRM_FORMAT_MOD_VS_TYPE_CUSTOM_10BIT, \
+                (tile))
+
 #if defined(__cplusplus)
 }
 #endif
diff --git a/include/uapi/drm/vs_drm.h b/include/uapi/drm/vs_drm.h
new file mode 100755
index 000000000..72bb9e757
--- /dev/null
+++ b/include/uapi/drm/vs_drm.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2020 VeriSilicon Holdings Co., Ltd.
+ */
+
+#ifndef __VS_DRM_H__
+#define __VS_DRM_H__
+
+#include "drm.h"
+
+enum drm_vs_degamma_mode {
+    VS_DEGAMMA_DISABLE = 0,
+    VS_DEGAMMA_BT709 = 1,
+    VS_DEGAMMA_BT2020 = 2,
+};
+
+enum drm_vs_sync_dc_mode {
+    VS_SINGLE_DC = 0,
+    VS_MULTI_DC_PRIMARY = 1,
+    VS_MULTI_DC_SECONDARY = 2,
+};
+
+enum drm_vs_mmu_prefetch_mode {
+    VS_MMU_PREFETCH_DISABLE = 0,
+    VS_MMU_PREFETCH_ENABLE = 1,
+};
+
+struct drm_vs_watermark {
+    __u32 watermark;
+    __u8 qos_low;
+    __u8 qos_high;
+};
+
+struct drm_vs_color_mgmt {
+    __u32 colorkey;
+    __u32 colorkey_high;
+    __u32 clear_value;
+    bool  clear_enable;
+    bool  transparency;
+};
+
+struct drm_vs_roi {
+    bool enable;
+    __u16 roi_x;
+    __u16 roi_y;
+    __u16 roi_w;
+    __u16 roi_h;
+};
+
+#endif /* __VS_DRM_H__ */
diff --git a/include/uapi/linux/dm-user.h b/include/uapi/linux/dm-user.h
new file mode 100755
index 000000000..6d8f535b3
--- /dev/null
+++ b/include/uapi/linux/dm-user.h
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: LGPL-2.0+ WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2020 Google, Inc
+ * Copyright (C) 2020 Palmer Dabbelt <palmerdabbelt@google.com>
+ */
+
+#ifndef _LINUX_DM_USER_H
+#define _LINUX_DM_USER_H
+
+#include <linux/types.h>
+
+/*
+ * dm-user proxies device mapper ops between the kernel and userspace.  It's
+ * essentially just an RPC mechanism: all kernel calls create a request,
+ * userspace handles that with a response.  Userspace obtains requests via
+ * read() and provides responses via write().
+ *
+ * See Documentation/block/dm-user.rst for more information.
+ */
+
+#define DM_USER_REQ_MAP_READ 0
+#define DM_USER_REQ_MAP_WRITE 1
+#define DM_USER_REQ_MAP_FLUSH 2
+#define DM_USER_REQ_MAP_DISCARD 3
+#define DM_USER_REQ_MAP_SECURE_ERASE 4
+#define DM_USER_REQ_MAP_WRITE_SAME 5
+#define DM_USER_REQ_MAP_WRITE_ZEROES 6
+#define DM_USER_REQ_MAP_ZONE_OPEN 7
+#define DM_USER_REQ_MAP_ZONE_CLOSE 8
+#define DM_USER_REQ_MAP_ZONE_FINISH 9
+#define DM_USER_REQ_MAP_ZONE_APPEND 10
+#define DM_USER_REQ_MAP_ZONE_RESET 11
+#define DM_USER_REQ_MAP_ZONE_RESET_ALL 12
+
+#define DM_USER_REQ_MAP_FLAG_FAILFAST_DEV 0x00001
+#define DM_USER_REQ_MAP_FLAG_FAILFAST_TRANSPORT 0x00002
+#define DM_USER_REQ_MAP_FLAG_FAILFAST_DRIVER 0x00004
+#define DM_USER_REQ_MAP_FLAG_SYNC 0x00008
+#define DM_USER_REQ_MAP_FLAG_META 0x00010
+#define DM_USER_REQ_MAP_FLAG_PRIO 0x00020
+#define DM_USER_REQ_MAP_FLAG_NOMERGE 0x00040
+#define DM_USER_REQ_MAP_FLAG_IDLE 0x00080
+#define DM_USER_REQ_MAP_FLAG_INTEGRITY 0x00100
+#define DM_USER_REQ_MAP_FLAG_FUA 0x00200
+#define DM_USER_REQ_MAP_FLAG_PREFLUSH 0x00400
+#define DM_USER_REQ_MAP_FLAG_RAHEAD 0x00800
+#define DM_USER_REQ_MAP_FLAG_BACKGROUND 0x01000
+#define DM_USER_REQ_MAP_FLAG_NOWAIT 0x02000
+#define DM_USER_REQ_MAP_FLAG_CGROUP_PUNT 0x04000
+#define DM_USER_REQ_MAP_FLAG_NOUNMAP 0x08000
+#define DM_USER_REQ_MAP_FLAG_HIPRI 0x10000
+#define DM_USER_REQ_MAP_FLAG_DRV 0x20000
+#define DM_USER_REQ_MAP_FLAG_SWAP 0x40000
+
+#define DM_USER_RESP_SUCCESS 0
+#define DM_USER_RESP_ERROR 1
+#define DM_USER_RESP_UNSUPPORTED 2
+
+struct dm_user_message {
+	__u64 seq;
+	__u64 type;
+	__u64 flags;
+	__u64 sector;
+	__u64 len;
+	__u8 buf[];
+};
+
+#endif
diff --git a/include/uapi/linux/dma-heap.h b/include/uapi/linux/dma-heap.h
index 6f84fa08e..1bee4b113 100644
--- a/include/uapi/linux/dma-heap.h
+++ b/include/uapi/linux/dma-heap.h
@@ -40,7 +40,30 @@ struct dma_heap_allocation_data {
 };
 
 #define DMA_HEAP_IOC_MAGIC		'H'
+#ifndef CONFIG_RISCV
+enum dma_heap_flag_owner_id {
+	OWNER_DEFAULT = 0,
+	OWNER_GPU,
+	OWNER_MEDIA,
+	COUNT_DMA_HEAP_FLAG_OWNER,
+};
+
+#define OFFSET_BIT 56 /* 7 bytes */
+
+/* Use the first byte (56-63 bits) of heap flags as owner_id flag */
+void set_owner_id_for_heap_flags(__u64 *heap_flags, __u64 owner_id)
+{
+	if (heap_flags == NULL)
+		return;
+	*heap_flags |= owner_id << OFFSET_BIT;
+}
 
+/* To get the binary number of owner_id */
+__u64 get_owner_id_from_heap_flags(__u64 heap_flags)
+{
+	return heap_flags >> OFFSET_BIT;
+}
+#endif
 /**
  * DOC: DMA_HEAP_IOCTL_ALLOC - allocate memory from pool
  *
diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index 2f06a1195..05854f075 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -39,6 +39,7 @@ typedef __s64	Elf64_Sxword;
 #define PT_GNU_PROPERTY		0x6474e553
 
 #define PT_OHOS_RANDOMDATA  0x6788fc60	/* ohos-specific segment */
+#define PT_OHOS_RANDOMDATA_SIZE_LIMIT  1024 * 128
 
 #define PT_GNU_STACK	(PT_LOOS + 0x474e551)
 
@@ -433,6 +434,7 @@ typedef struct elf64_shdr {
 #define NT_MIPS_DSP	0x800		/* MIPS DSP ASE registers */
 #define NT_MIPS_FP_MODE	0x801		/* MIPS floating-point mode */
 #define NT_MIPS_MSA	0x802		/* MIPS SIMD registers */
+#define NT_RISCV_VECTOR	0x900		/* RISC-V vector registers */
 
 /* Note types with note name "GNU" */
 #define NT_GNU_PROPERTY_TYPE_0	5
diff --git a/include/uapi/linux/kexec.h b/include/uapi/linux/kexec.h
index 05669c87a..778dc191c 100644
--- a/include/uapi/linux/kexec.h
+++ b/include/uapi/linux/kexec.h
@@ -42,6 +42,7 @@
 #define KEXEC_ARCH_MIPS_LE (10 << 16)
 #define KEXEC_ARCH_MIPS    ( 8 << 16)
 #define KEXEC_ARCH_AARCH64 (183 << 16)
+#define KEXEC_ARCH_RISCV   (243 << 16)
 
 /* The artificial cap on the number of segments passed to kexec_load. */
 #define KEXEC_SEGMENT_MAX 16
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index ca41220b4..9e1d1922b 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -827,6 +827,11 @@ struct kvm_ppc_resize_hpt {
 #define KVM_GET_MSR_INDEX_LIST    _IOWR(KVMIO, 0x02, struct kvm_msr_list)
 
 #define KVM_S390_ENABLE_SIE       _IO(KVMIO,   0x06)
+
+#define KVM_RISCV_MEM_ADDR_SET	_IO(KVMIO,   0xf0)
+#define KVM_RISCV_MEM_ADDR_GET	_IO(KVMIO,   0xf1)
+#define KVM_RISCV_MEM_SIZE	_IO(KVMIO,   0xf2)
+
 /*
  * Check if a kvm extension is available.  Argument is extension number,
  * return is 1 (yes) or 0 (no, sorry).
diff --git a/include/uapi/linux/vhost.h b/include/uapi/linux/vhost.h
index c998860d7..2648764d6 100644
--- a/include/uapi/linux/vhost.h
+++ b/include/uapi/linux/vhost.h
@@ -105,6 +105,9 @@
  * device.  This can be used to stop the ring (e.g. for migration). */
 #define VHOST_NET_SET_BACKEND _IOW(VHOST_VIRTIO, 0x30, struct vhost_vring_file)
 
+/* VHOST_BLK specific defines */
+#define VHOST_BLK_SET_BACKEND _IOW(VHOST_VIRTIO, 0x35, struct vhost_vring_file)
+
 /* VHOST_SCSI specific defines */
 
 #define VHOST_SCSI_SET_ENDPOINT _IOW(VHOST_VIRTIO, 0x40, struct vhost_scsi_target)
diff --git a/include/uapi/linux/virtio_ids.h b/include/uapi/linux/virtio_ids.h
index b052355ac..6319423ae 100644
--- a/include/uapi/linux/virtio_ids.h
+++ b/include/uapi/linux/virtio_ids.h
@@ -45,8 +45,11 @@
 #define VIRTIO_ID_CRYPTO       20 /* virtio crypto */
 #define VIRTIO_ID_IOMMU        23 /* virtio IOMMU */
 #define VIRTIO_ID_MEM          24 /* virtio mem */
+#define VIRTIO_ID_SOUND        25 /* virtio sound */
 #define VIRTIO_ID_FS           26 /* virtio filesystem */
 #define VIRTIO_ID_PMEM         27 /* virtio pmem */
 #define VIRTIO_ID_MAC80211_HWSIM 29 /* virtio mac80211-hwsim */
+#define VIRTIO_ID_MAILBOX	30 /* virtio mailbox */
+#define VIRTIO_ID_VDMABUF	37 /* virtio vdmabuf */
 
 #endif /* _LINUX_VIRTIO_IDS_H */
diff --git a/include/uapi/linux/virtio_light.h b/include/uapi/linux/virtio_light.h
new file mode 100755
index 000000000..7c737a185
--- /dev/null
+++ b/include/uapi/linux/virtio_light.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _LINUX_VIRTIO_LIGHT_H
+#define _LINUX_VIRTIO_LIGHT_H
+
+/*
+ * Virtio device common config offset
+ */
+
+/* Magic value ("virt" string) - Read Only */
+#define VIRTIO_LIGHT_MAGIC_VALUE	0x000
+
+/* Virtio device version - Read Only */
+#define VIRTIO_LIGHT_VERSION		0x004
+
+/* Virtio device ID - Read Only */
+#define VIRTIO_LIGHT_DEVICE_ID		0x008
+
+/* Virtio vendor ID - Read Only */
+#define VIRTIO_LIGHT_VENDOR_ID		0x00C
+
+/* Device status register - Read Write */
+#define VIRTIO_LIGHT_STATUS		0x010
+
+/* Bitmask of the features supported by the device (host)
+ * (32 bits per set) - Read Only
+ */
+
+/* Low 32 bits */
+#define VIRTIO_LIGHT_DEVICE_FEATURES_LOW	0x014
+
+/* High 32bits */
+#define VIRTIO_LIGHT_DEVICE_FEATURES_HIGH	0x018
+
+/* Maximum size of the currently selected queue - Read Only */
+#define VIRTIO_LIGHT_QUEUE_SIZE_MAX	0x01C
+
+/* Queue size for the currently selected queue - Write Only */
+#define VIRTIO_LIGHT_QUEUE_SIZE		0x020
+
+/* Used Ring alignment for the currently selected queue - Write Only */
+#define VIRTIO_LIGHT_QUEUE_ALIGN	0x024
+
+/* Numbers of virt queue */
+#define VIRTIO_LIGHT_QUEUE_NUM		0x028
+
+/* Guest's PFN for the queue with number index - Read Write
+ * Please notes, if some virtual device support multiple vqs,
+ * it will occupy more config space size(vq_num*4). So we
+ * should reserve more space starting from this offset.
+ * eg, Offset between 0x2C~0x100 is for QUEUE_PFN config space.
+ */
+#define VIRTIO_LIGHT_QUEUE_PFN		0x2C
+
+
+/* The config space is defined by each driver as
+ * the per-driver configuration space - Read Write */
+#define VIRTIO_LIGHT_CONFIG		0x100
+
+#define VIRTIO_LIGHT_CONFIG_LEN		0x1000
+
+#endif
diff --git a/include/uapi/linux/virtio_mailbox.h b/include/uapi/linux/virtio_mailbox.h
new file mode 100755
index 000000000..20e3c7075
--- /dev/null
+++ b/include/uapi/linux/virtio_mailbox.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _LIGHT_MAILBOX_H
+#define _LIGHT_MAILBOX_H
+
+#include <linux/virtio_types.h>
+
+/* Feature bits */
+#define VIRTIO_MAILBOX_F_CHAN_NUM	1	/* Indicates maximum mailbox channels */
+#define VIRTIO_MAILBOX_F_MSG_SIZE	2	/* Indicates msg size for one transport */
+
+/* Default values when feature not set */
+#define VIRTIO_MAILBOX_MSG_SIZE_DEFAULT	128
+#define VIRTIO_MAILBOX_CHAN_NUM_DEFAULT	8
+
+#define VIRTIO_MAILBOX_CHAN_MAX		32
+
+struct virtio_mailbox_config {
+	__virtio32 chan_num;
+	__virtio32 msg_size;
+	__virtio32 msg_g[VIRTIO_MAILBOX_CHAN_MAX];
+	__virtio32 msg_h[VIRTIO_MAILBOX_CHAN_MAX];
+	__virtio32 ack_g[VIRTIO_MAILBOX_CHAN_MAX];
+	__virtio32 ack_h[VIRTIO_MAILBOX_CHAN_MAX];
+} __attribute__((packed));
+
+static const unsigned int offsets[] = {
+	offsetof(struct virtio_mailbox_config, chan_num),
+	offsetof(struct virtio_mailbox_config, msg_size),
+	offsetof(struct virtio_mailbox_config, msg_g),
+	offsetof(struct virtio_mailbox_config, msg_h),
+	offsetof(struct virtio_mailbox_config, ack_g),
+	offsetof(struct virtio_mailbox_config, ack_h),
+};
+
+enum offsets_index {
+	CHAN_NUM,
+	MSG_SIZE,
+	MSG_G,
+	MSG_H,
+	ACK_G,
+	ACK_H,
+};
+
+#endif
diff --git a/include/uapi/linux/virtio_vdmabuf.h b/include/uapi/linux/virtio_vdmabuf.h
new file mode 100755
index 000000000..fa4fd1e60
--- /dev/null
+++ b/include/uapi/linux/virtio_vdmabuf.h
@@ -0,0 +1,84 @@
+/* SPDX-License-Identifier: (GPL-2.0 WITH Linux-syscall-note) OR MIT */
+#ifndef _UAPI_LINUX_VIRTIO_VDMABUF_H
+#define _UAPI_LINUX_VIRTIO_VDMABUF_H
+
+/*
+ * user can use this ioctl to alloc dmabuf, and get its
+ * fd, buf_id
+ */
+#define VIRTIO_VDMABUF_IOCTL_ALLOC_FD \
+_IOC(_IOC_NONE, 'G', 2, sizeof(struct virtio_vdmabuf_alloc))
+
+/*
+ * user can use this ioctl to get dmabuf fd via buf_id,
+ * which is passed to us from remote peer
+ */
+#define VIRTIO_VDMABUF_IOCTL_IMPORT_FD \
+_IOC(_IOC_NONE, 'G', 3, sizeof(struct virtio_vdmabuf_import))
+
+/* dmabuf flag */
+#define VIRTIO_VDAMBUF_NONCACHED			0x1
+#define VIRTIO_VDAMBUF_DMA32				0x4
+
+/*
+ * Max single alloc size is (768 * PAGE_SIZE) only for
+ * VIRTIO_VDMABUF_TYPE_SYSTEM heap
+ * eg, it is 3M when PAGE_SIZE is 4K
+ */
+#define VIRTIO_VDAMBUF_MAX_ALLOC_SIZE	(768 * PAGE_SIZE)
+
+/*
+ * size          : user fill dmabuf size only when use heap VIRTIO_VDMABUF_TYPE_SYSTEM or
+ *                 VIRTIO_VDMABUF_HEAP_TYPE_SYSTEM_CONTIG or VIRTIO_VDMABUF_HEAP_USER
+ * align         : user fill dmabuf align, kernel use PAGE_SIZE as the align by default
+ * uaddr         : user fill user buf addr only when use VIRTIO_VDMABUF_HEAP_USER heap
+ * fd            : kernel fill dmabuf fd
+ * buf_id        : kernel fill id of dmabuf
+ * heap_type     : user fill heap type
+ * carveout_type : user fill carveout type when heap type is VIRTIO_VDMABUF_HEAP_TYPE_CARVEOUT
+ * flags         : user fill buf flags, eg, noncache(VIRTIO_VDAMBUF_NONCACHED),
+ *                 kernel use cache mode by default
+ */
+struct virtio_vdmabuf_alloc {
+	size_t size;
+	int align;
+	void *uaddr;
+	int fd;
+	unsigned int buf_id;
+	int heap_type;
+	int carveout_type;
+	int flags;
+};
+
+/*
+ * buf_id : user fill the dmabuf id
+ * fd     : kernel fill the dmabuf fd
+ * size   : kernel fill the dmabuf size
+ */
+struct virtio_vdmabuf_import {
+	unsigned int buf_id;
+	int fd;
+	size_t size;
+};
+
+/* virtio-vdmabuf supported heap type */
+enum virtio_vdmabuf_heap_type {
+	VIRTIO_VDMABUF_HEAP_TYPE_USER,
+	VIRTIO_VDMABUF_HEAP_TYPE_SYSTEM,
+	VIRTIO_VDMABUF_HEAP_TYPE_SYSTEM_CONTIG,
+	VIRTIO_VDMABUF_HEAP_TYPE_CARVEOUT, /* reserved mem */
+	VIRTIO_VDMABUF_HEAP_NUM_HEAPS,
+};
+
+/* carveout type */
+enum virtio_vdmabuf_carveout_id {
+	VIRTIO_VDMABUF_CARVEOUT_TYPE_VI,
+	VIRTIO_VDMABUF_CARVEOUT_TYPE_VO,
+	VIRTIO_VDMABUF_CARVEOUT_TYPE_ENC,
+	VIRTIO_VDMABUF_CARVEOUT_TYPE_DEC,
+	VIRTIO_VDMABUF_CARVEOUT_TYPE_GPU,
+	VIRTIO_VDMABUF_CARVEOUT_TYPE_DPU,
+	VIRTIO_VDMABUF_CARVEOUTS_NUM,
+};
+
+#endif
