From 2b383580b6eb5843b3d4eb8002263442c2c8964a Mon Sep 17 00:00:00 2001
From: jiewangdp <jiewangdp@isoftstone.com>
Date: Sat, 25 Jun 2022 11:20:43 +0800
Subject: [PATCH] net

Change-Id: Ie4e61b14556ec020baa1fec637c89b2628f94904
---
 net/bluetooth/l2cap_sock.c | 10 +--------
 net/bluetooth/sco.c        | 42 +++++++++++++++-----------------------
 net/rfkill/Kconfig         |  9 ++++++++
 net/rfkill/Makefile        |  2 ++
 4 files changed, 29 insertions(+), 34 deletions(-)

diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index 160c016a5dfb..c99d65ef13b1 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -1508,9 +1508,6 @@ static void l2cap_sock_close_cb(struct l2cap_chan *chan)
 {
 	struct sock *sk = chan->data;
 
-	if (!sk)
-		return;
-
 	l2cap_sock_kill(sk);
 }
 
@@ -1519,9 +1516,6 @@ static void l2cap_sock_teardown_cb(struct l2cap_chan *chan, int err)
 	struct sock *sk = chan->data;
 	struct sock *parent;
 
-	if (!sk)
-		return;
-
 	BT_DBG("chan %p state %s", chan, state_to_string(chan->state));
 
 	/* This callback can be called both for server (BT_LISTEN)
@@ -1713,10 +1707,8 @@ static void l2cap_sock_destruct(struct sock *sk)
 {
 	BT_DBG("sk %p", sk);
 
-	if (l2cap_pi(sk)->chan) {
-		l2cap_pi(sk)->chan->data = NULL;
+	if (l2cap_pi(sk)->chan)
 		l2cap_chan_put(l2cap_pi(sk)->chan);
-	}
 
 	if (l2cap_pi(sk)->rx_busy_skb) {
 		kfree_skb(l2cap_pi(sk)->rx_busy_skb);
diff --git a/net/bluetooth/sco.c b/net/bluetooth/sco.c
index 918df8d0e8b6..7c24a9acbc45 100644
--- a/net/bluetooth/sco.c
+++ b/net/bluetooth/sco.c
@@ -93,10 +93,10 @@ static void sco_sock_timeout(struct work_struct *work)
 
 	BT_DBG("sock %p state %d", sk, sk->sk_state);
 
-	lock_sock(sk);
+	bh_lock_sock(sk);
 	sk->sk_err = ETIMEDOUT;
 	sk->sk_state_change(sk);
-	release_sock(sk);
+	bh_unlock_sock(sk);
 
 	sock_put(sk);
 }
@@ -192,10 +192,10 @@ static void sco_conn_del(struct hci_conn *hcon, int err)
 
 	if (sk) {
 		sock_hold(sk);
-		lock_sock(sk);
+		bh_lock_sock(sk);
 		sco_sock_clear_timer(sk);
 		sco_chan_del(sk, err);
-		release_sock(sk);
+		bh_unlock_sock(sk);
 		sock_put(sk);
 
 		/* Ensure no more work items will run before freeing conn. */
@@ -281,8 +281,7 @@ static int sco_connect(struct hci_dev *hdev, struct sock *sk)
 	return err;
 }
 
-static int sco_send_frame(struct sock *sk, void *buf, int len,
-			  unsigned int msg_flags)
+static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)
 {
 	struct sco_conn *conn = sco_pi(sk)->conn;
 	struct sk_buff *skb;
@@ -294,11 +293,15 @@ static int sco_send_frame(struct sock *sk, void *buf, int len,
 
 	BT_DBG("sk %p len %d", sk, len);
 
-	skb = bt_skb_send_alloc(sk, len, msg_flags & MSG_DONTWAIT, &err);
+	skb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);
 	if (!skb)
 		return err;
 
-	memcpy(skb_put(skb, len), buf, len);
+	if (memcpy_from_msg(skb_put(skb, len), msg, len)) {
+		kfree_skb(skb);
+		return -EFAULT;
+	}
+
 	hci_send_sco(conn->hcon, skb);
 
 	return len;
@@ -723,7 +726,6 @@ static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,
 			    size_t len)
 {
 	struct sock *sk = sock->sk;
-	void *buf;
 	int err;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
@@ -735,24 +737,14 @@ static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,
 	if (msg->msg_flags & MSG_OOB)
 		return -EOPNOTSUPP;
 
-	buf = kmalloc(len, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	if (memcpy_from_msg(buf, msg, len)) {
-		kfree(buf);
-		return -EFAULT;
-	}
-
 	lock_sock(sk);
 
 	if (sk->sk_state == BT_CONNECTED)
-		err = sco_send_frame(sk, buf, len, msg->msg_flags);
+		err = sco_send_frame(sk, msg, len);
 	else
 		err = -ENOTCONN;
 
 	release_sock(sk);
-	kfree(buf);
 	return err;
 }
 
@@ -1109,10 +1101,10 @@ static void sco_conn_ready(struct sco_conn *conn)
 
 	if (sk) {
 		sco_sock_clear_timer(sk);
-		lock_sock(sk);
+		bh_lock_sock(sk);
 		sk->sk_state = BT_CONNECTED;
 		sk->sk_state_change(sk);
-		release_sock(sk);
+		bh_unlock_sock(sk);
 	} else {
 		sco_conn_lock(conn);
 
@@ -1127,12 +1119,12 @@ static void sco_conn_ready(struct sco_conn *conn)
 			return;
 		}
 
-		lock_sock(parent);
+		bh_lock_sock(parent);
 
 		sk = sco_sock_alloc(sock_net(parent), NULL,
 				    BTPROTO_SCO, GFP_ATOMIC, 0);
 		if (!sk) {
-			release_sock(parent);
+			bh_unlock_sock(parent);
 			sco_conn_unlock(conn);
 			return;
 		}
@@ -1153,7 +1145,7 @@ static void sco_conn_ready(struct sco_conn *conn)
 		/* Wake up parent */
 		parent->sk_data_ready(parent);
 
-		release_sock(parent);
+		bh_unlock_sock(parent);
 
 		sco_conn_unlock(conn);
 	}
diff --git a/net/rfkill/Kconfig b/net/rfkill/Kconfig
index 83a7af8982bb..33ab1f7a3cc0 100644
--- a/net/rfkill/Kconfig
+++ b/net/rfkill/Kconfig
@@ -32,3 +32,12 @@ config RFKILL_GPIO
 	help
 	  If you say yes here you get support of a generic gpio RFKILL
 	  driver.
+
+config RFKILL_RK
+	tristate "Rockchip RFKILL driver"
+	depends on RFKILL
+	depends on MMC
+	depends on ARCH_ROCKCHIP
+	default y
+	help
+	  Rockchip rfkill driver for rk29/rk3X
diff --git a/net/rfkill/Makefile b/net/rfkill/Makefile
index dc47b6174ec5..beed5b506307 100644
--- a/net/rfkill/Makefile
+++ b/net/rfkill/Makefile
@@ -7,3 +7,5 @@ rfkill-y			+= core.o
 rfkill-$(CONFIG_RFKILL_INPUT)	+= input.o
 obj-$(CONFIG_RFKILL)		+= rfkill.o
 obj-$(CONFIG_RFKILL_GPIO)	+= rfkill-gpio.o
+rfkill-rk-y			+= rfkill-wlan.o rfkill-bt.o
+obj-$(CONFIG_RFKILL_RK)		+= rfkill-rk.o
-- 
2.25.1

